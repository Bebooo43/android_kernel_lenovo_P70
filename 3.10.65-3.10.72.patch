diff --git a/Documentation/device-mapper/verity.txt b/Documentation/device-mapper/verity.txt
index 9884681..2929f6b 100644
--- a/Documentation/device-mapper/verity.txt
+++ b/Documentation/device-mapper/verity.txt
@@ -10,7 +10,7 @@ Construction Parameters
     <version> <dev> <hash_dev>
     <data_block_size> <hash_block_size>
     <num_data_blocks> <hash_start_block>
-    <algorithm> <digest> <salt>
+    <algorithm> <digest> <salt> <mode>
 
 <version>
     This is the type of the on-disk hash format.
@@ -62,6 +62,16 @@ Construction Parameters
 <salt>
     The hexadecimal encoding of the salt value.
 
+<mode>
+    Optional. The mode of operation.
+
+    0 is the normal mode of operation where a corrupted block will result in an
+      I/O error.
+
+    1 is logging mode where corrupted blocks are logged and a uevent is sent to
+      notify user space.
+
+
 Theory of operation
 ===================
 
diff --git a/Documentation/filesystems/porting b/Documentation/filesystems/porting
index 4db22f6..85a4a03 100644
--- a/Documentation/filesystems/porting
+++ b/Documentation/filesystems/porting
@@ -445,3 +445,6 @@ object doesn't exist.  It's remote/distributed ones that might care...
 [mandatory]
 	FS_REVAL_DOT is gone; if you used to have it, add ->d_weak_revalidate()
 in your dentry operations instead.
+--
+[mandatory]
+	vfs_readdir() is gone; switch to iterate_dir() instead
diff --git a/Documentation/filesystems/proc.txt b/Documentation/filesystems/proc.txt
index 7ce8ef7..be35913 100644
--- a/Documentation/filesystems/proc.txt
+++ b/Documentation/filesystems/proc.txt
@@ -490,6 +490,10 @@ To clear the bits for the file mapped pages associated with the process
     > echo 3 > /proc/PID/clear_refs
 Any other value written to /proc/PID/clear_refs will have no effect.
 
+To reset the peak resident set size ("high water mark") to the process's
+current value:
+    > echo 5 > /proc/PID/clear_refs
+
 The /proc/pid/pagemap gives the PFN, which can be used to find the pageflags
 using /proc/kpageflags and number of times a page is mapped using
 /proc/kpagecount. For detailed explanation, see Documentation/vm/pagemap.txt.
diff --git a/Documentation/filesystems/squashfs.txt b/Documentation/filesystems/squashfs.txt
index 403c090..e5274f8 100644
--- a/Documentation/filesystems/squashfs.txt
+++ b/Documentation/filesystems/squashfs.txt
@@ -2,10 +2,10 @@ SQUASHFS 4.0 FILESYSTEM
 =======================
 
 Squashfs is a compressed read-only filesystem for Linux.
-It uses zlib/lzo/xz compression to compress files, inodes and directories.
-Inodes in the system are very small and all blocks are packed to minimise
-data overhead. Block sizes greater than 4K are supported up to a maximum
-of 1Mbytes (default block size 128K).
+It uses zlib, lz4, lzo, or xz compression to compress files, inodes and
+directories.  Inodes in the system are very small and all blocks are packed to
+minimise data overhead. Block sizes greater than 4K are supported up to a
+maximum of 1Mbytes (default block size 128K).
 
 Squashfs is intended for general read-only filesystem use, for archival
 use (i.e. in cases where a .tar.gz file may be used), and in constrained
diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index 2082e5b..b041a0f 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -1061,6 +1061,7 @@ bytes respectively. Such letter suffixes can also be entirely omitted.
 	i8042.notimeout	[HW] Ignore timeout condition signalled by controller
 	i8042.reset	[HW] Reset the controller during init and cleanup
 	i8042.unlock	[HW] Unlock (ignore) the keylock
+	i8042.kbdreset  [HW] Reset device connected to KBD port
 
 	i810=		[HW,DRM]
 
diff --git a/Makefile b/Makefile
index 88ac543..917f5c5 100644
--- a/Makefile
+++ b/Makefile
@@ -1,6 +1,6 @@
 VERSION = 3
 PATCHLEVEL = 10
-SUBLEVEL = 65
+SUBLEVEL = 72
 EXTRAVERSION =
 NAME = TOSSUG Baby Fish
 
diff --git a/README.md b/README.md
index dbfccb6..15b1b64 100644
--- a/README.md
+++ b/README.md
@@ -1 +1 @@
-# kernel-3.10.65
+# kernel-3.10.72
diff --git a/android/configs/android-base.cfg b/android/configs/android-base.cfg
index d8503e4..6c08830 100644
--- a/android/configs/android-base.cfg
+++ b/android/configs/android-base.cfg
@@ -1,4 +1,6 @@
 #  KEEP ALPHABETICALLY SORTED
+# CONFIG_DEVKMEM is not set
+# CONFIG_DEVMEM is not set
 # CONFIG_INET_LRO is not set
 # CONFIG_MODULES is not set
 # CONFIG_OABI_COMPAT is not set
diff --git a/arch/alpha/kernel/osf_sys.c b/arch/alpha/kernel/osf_sys.c
index b9e37ad..1402fcc 100644
--- a/arch/alpha/kernel/osf_sys.c
+++ b/arch/alpha/kernel/osf_sys.c
@@ -96,6 +96,7 @@ struct osf_dirent {
 };
 
 struct osf_dirent_callback {
+	struct dir_context ctx;
 	struct osf_dirent __user *dirent;
 	long __user *basep;
 	unsigned int count;
@@ -146,17 +147,17 @@ SYSCALL_DEFINE4(osf_getdirentries, unsigned int, fd,
 {
 	int error;
 	struct fd arg = fdget(fd);
-	struct osf_dirent_callback buf;
+	struct osf_dirent_callback buf = {
+		.ctx.actor = osf_filldir,
+		.dirent = dirent,
+		.basep = basep,
+		.count = count
+	};
 
 	if (!arg.file)
 		return -EBADF;
 
-	buf.dirent = dirent;
-	buf.basep = basep;
-	buf.count = count;
-	buf.error = 0;
-
-	error = vfs_readdir(arg.file, osf_filldir, &buf);
+	error = iterate_dir(arg.file, &buf.ctx);
 	if (error >= 0)
 		error = buf.error;
 	if (count != buf.count)
diff --git a/arch/arc/boot/dts/nsimosci.dts b/arch/arc/boot/dts/nsimosci.dts
index 398064c..4c169d8 100644
--- a/arch/arc/boot/dts/nsimosci.dts
+++ b/arch/arc/boot/dts/nsimosci.dts
@@ -20,7 +20,7 @@
 		/* this is for console on PGU */
 		/* bootargs = "console=tty0 consoleblank=0"; */
 		/* this is for console on serial */
-		bootargs = "earlycon=uart8250,mmio32,0xc0000000,115200n8 console=tty0 console=ttyS0,115200n8 consoleblank=0 debug";
+		bootargs = "earlycon=uart8250,mmio32,0xf0000000,115200n8 console=tty0 console=ttyS0,115200n8 consoleblank=0 debug";
 	};
 
 	aliases {
@@ -46,9 +46,9 @@
 			#interrupt-cells = <1>;
 		};
 
-		uart0: serial@c0000000 {
+		uart0: serial@f0000000 {
 			compatible = "ns8250";
-			reg = <0xc0000000 0x2000>;
+			reg = <0xf0000000 0x2000>;
 			interrupts = <11>;
 			clock-frequency = <3686400>;
 			baud = <115200>;
@@ -57,21 +57,21 @@
 			no-loopback-test = <1>;
 		};
 
-		pgu0: pgu@c9000000 {
+		pgu0: pgu@f9000000 {
 			compatible = "snps,arcpgufb";
-			reg = <0xc9000000 0x400>;
+			reg = <0xf9000000 0x400>;
 		};
 
-		ps2: ps2@c9001000 {
+		ps2: ps2@f9001000 {
 			compatible = "snps,arc_ps2";
-			reg = <0xc9000400 0x14>;
+			reg = <0xf9000400 0x14>;
 			interrupts = <13>;
 			interrupt-names = "arc_ps2_irq";
 		};
 
-		eth0: ethernet@c0003000 {
+		eth0: ethernet@f0003000 {
 			compatible = "snps,oscilan";
-			reg = <0xc0003000 0x44>;
+			reg = <0xf0003000 0x44>;
 			interrupts = <7>, <8>;
 			interrupt-names = "rx", "tx";
 		};
diff --git a/arch/arc/include/asm/pgtable.h b/arch/arc/include/asm/pgtable.h
index 95b1522..ecf23ea 100644
--- a/arch/arc/include/asm/pgtable.h
+++ b/arch/arc/include/asm/pgtable.h
@@ -270,7 +270,8 @@ static inline void pmd_set(pmd_t *pmdp, pte_t *ptep)
 #define pmd_clear(xp)			do { pmd_val(*(xp)) = 0; } while (0)
 
 #define pte_page(x) (mem_map + \
-		(unsigned long)(((pte_val(x) - PAGE_OFFSET) >> PAGE_SHIFT)))
+		(unsigned long)(((pte_val(x) - CONFIG_LINUX_LINK_BASE) >> \
+				PAGE_SHIFT)))
 
 #define mk_pte(page, pgprot)						\
 ({									\
diff --git a/arch/arm/boot/dts/imx25.dtsi b/arch/arm/boot/dts/imx25.dtsi
index 7011539..97d1a55 100644
--- a/arch/arm/boot/dts/imx25.dtsi
+++ b/arch/arm/boot/dts/imx25.dtsi
@@ -141,7 +141,7 @@
 				#size-cells = <0>;
 				compatible = "fsl,imx25-cspi", "fsl,imx35-cspi";
 				reg = <0x43fa4000 0x4000>;
-				clocks = <&clks 62>, <&clks 62>;
+				clocks = <&clks 78>, <&clks 78>;
 				clock-names = "ipg", "per";
 				interrupts = <14>;
 				status = "disabled";
@@ -335,7 +335,7 @@
 				compatible = "fsl,imx25-pwm", "fsl,imx27-pwm";
 				#pwm-cells = <2>;
 				reg = <0x53fa0000 0x4000>;
-				clocks = <&clks 106>, <&clks 36>;
+				clocks = <&clks 106>, <&clks 52>;
 				clock-names = "ipg", "per";
 				interrupts = <36>;
 			};
@@ -354,7 +354,7 @@
 				compatible = "fsl,imx25-pwm", "fsl,imx27-pwm";
 				#pwm-cells = <2>;
 				reg = <0x53fa8000 0x4000>;
-				clocks = <&clks 107>, <&clks 36>;
+				clocks = <&clks 107>, <&clks 52>;
 				clock-names = "ipg", "per";
 				interrupts = <41>;
 			};
@@ -394,7 +394,7 @@
 			pwm4: pwm@53fc8000 {
 				compatible = "fsl,imx25-pwm", "fsl,imx27-pwm";
 				reg = <0x53fc8000 0x4000>;
-				clocks = <&clks 108>, <&clks 36>;
+				clocks = <&clks 108>, <&clks 52>;
 				clock-names = "ipg", "per";
 				interrupts = <42>;
 			};
@@ -439,7 +439,7 @@
 				compatible = "fsl,imx25-pwm", "fsl,imx27-pwm";
 				#pwm-cells = <2>;
 				reg = <0x53fe0000 0x4000>;
-				clocks = <&clks 105>, <&clks 36>;
+				clocks = <&clks 105>, <&clks 52>;
 				clock-names = "ipg", "per";
 				interrupts = <26>;
 			};
diff --git a/arch/arm/boot/dts/vanzo6752_35gu_l.dts b/arch/arm/boot/dts/vanzo6752_35gu_l.dts
index d530477..f848310 100755
--- a/arch/arm/boot/dts/vanzo6752_35gu_l.dts
+++ b/arch/arm/boot/dts/vanzo6752_35gu_l.dts
@@ -16,11 +16,6 @@
 		ranges = <0 0 0 0xffffffff>;
 
 		I2C0@0x11007000 {
-			gt9xx@5d {
-				compatible = "gt9xx";
-				reg = <0x5d>;
-			};
-
 			bq24261@6b {
 				compatible = "bq24261";
 				reg = <0x6b>;
@@ -31,92 +26,11 @@
 				reg = <0x64>;
 			};
 		};
-
-		I2C1@0x11008000 {
-			yas533@2e {
-				compatible = "yas533";
-				reg = <0x2e>;
-			};
-
-			mpu-6515@68 {
-				compatible = "mpu-6515";
-				reg = <0x68>;
-			};
-
-			bmp180@77 {
-				compatible = "bmp180";
-				reg = <0x77>;
-			};
-
-			cm36652@60 {
-				compatble = "cm36652";
-				reg = <0x60>;
-			};
-
-			mt6605@28 {
-				compatible = "mediatek,mt6605";
-				reg = <0x28>;
-			};
-		};
-
 	};
     TOUCH@0 {
     	compatible = "mediatek,TPD";
 		eint-gpio = <139 1>;
-		rst-gpio = <144 1>;
+		rst-gpio = <147 1>;
 		interrupts = <139 2>;
-    };
-  /*  start sensor */
-		cust_accel@0 {
-		compatible 				= "mediatek,MC3410";
-		i2c_num 				= <2>;
-		i2c_addr				= <0x4c 0 0 0>;
-		direction 				= <0>;
-		power_id 				= <0xffff>;
-		power_vol				= <0>;
-		firlen 					= <0>;
-		is_batch_supported  			= <0>;
-  		};
-  
-		cust_alsps@0 {
-		compatible 				= "mediatek,CM36652";
-		i2c_num 				= <1>;
-		i2c_addr 				= <0x60 0 0 0>;
-		polling_mode_ps			= <0>;
-		polling_mode_als		= <1>;
-		power_id   				= <0xffff>;
-		power_vol  				= <0>; 
-/* Total has 15 level*/
-		als_level  				= <0 471 1058 1703 3883 10171 10443 15445 28499 35153 41421 59194 65535 65535 65535>;
-/*  Total has 16 range*/
-		als_value  				= <0 133 303 501 1002 2001 3355 5001 8008 10010 12000 16010 20010 20010 20010 20010>;
-		ps_threshold_high		=  <32>;
-		ps_threshold_low		=  <22>;
-		is_batch_supported_ps	= <1>;
-		is_batch_supported_als	= <1>;
-		};
-		
-  		cust_mag@0 {
-		compatible				= "mediatek,AKM09911";
-		i2c_num 				= <2>;
-		i2c_addr				= <0x0D 0 0 0>;
-		direction 				= <1>;
-		power_id 				= <0xffff>;
-		power_vol				= <0>;
-		is_batch_supported  	= <0>;
-  		};
-		
-  		cust_gyro@0 {
-		compatible 				= "mediatek,ITG1010";
-		i2c_num 				= <2>;
-		i2c_addr				= <0x68 0 0 0>;
-		direction 				= <3>;
-		power_id 				= <0xffff>;
-		power_vol				= <0>;
-		firlen 					= <0>;
-		is_batch_supported  	= <0>;
-  		};
-
-
-  /* end sensor */
+    };	
 };
diff --git a/arch/arm/configs/vanzo6752_35gu_l_defconfig b/arch/arm/configs/vanzo6752_35gu_l_defconfig
index 22a88bf..8a59b2c 100644
--- a/arch/arm/configs/vanzo6752_35gu_l_defconfig
+++ b/arch/arm/configs/vanzo6752_35gu_l_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated file; DO NOT EDIT.
-# Linux/arm 3.10.61 Kernel Configuration
+# Linux/arm 3.10.72 Kernel Configuration
 #
 CONFIG_ARM=y
 CONFIG_ARM_HAS_SG_CHAIN=y
@@ -98,7 +98,7 @@ CONFIG_RCU_FANOUT_LEAF=16
 # CONFIG_RCU_BOOST is not set
 # CONFIG_RCU_NOCB_CPU is not set
 # CONFIG_IKCONFIG is not set
-CONFIG_LOG_BUF_SHIFT=17
+CONFIG_LOG_BUF_SHIFT=21
 CONFIG_GENERIC_SCHED_CLOCK=y
 CONFIG_CGROUPS=y
 # CONFIG_CGROUP_DEBUG is not set
@@ -220,10 +220,13 @@ CONFIG_EFI_PARTITION=y
 CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_IOSCHED_BFQ=y
+CONFIG_CGROUP_BFQIO=y
 # CONFIG_DEFAULT_DEADLINE is not set
-CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_CFQ is not set
 # CONFIG_DEFAULT_NOOP is not set
-CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_DEFAULT_BFQ=y
+CONFIG_DEFAULT_IOSCHED="bfq"
 CONFIG_UNINLINE_SPIN_UNLOCK=y
 CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
 CONFIG_MUTEX_SPIN_ON_OWNER=y
@@ -470,7 +473,7 @@ CONFIG_CPU_FREQ_GOV_ONDEMAND=y
 # CONFIG_CPU_FREQ_GOV_INTERACTIVEPLUS is not set
 CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
 # CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
-# CONFIG_CPU_FREQ_GOV_HOTPLUG is not set
+CONFIG_CPU_FREQ_GOV_HOTPLUG=y
 
 #
 # ARM CPU frequency scaling drivers
@@ -1147,8 +1150,8 @@ CONFIG_ARCH_MTK_PROJECT="vanzo6752_35gu_l"
 CONFIG_MTK_CIRQ=y
 CONFIG_MTK_SYSTRACKER=y
 CONFIG_MTK_L2C_SHARE=y
-CONFIG_HAVE_AEE_FEATURE=y
-CONFIG_HAVE_XLOG_FEATURE=y
+# CONFIG_HAVE_AEE_FEATURE is not set
+# CONFIG_HAVE_XLOG_FEATURE is not set
 # CONFIG_FPGA_EARLY_PORTING is not set
 CONFIG_MTK_EMMC_SUPPORT=y
 CONFIG_MTK_NEW_COMBO_EMMC_SUPPORT=y
@@ -1171,27 +1174,27 @@ CONFIG_MTK_SENSOR_SUPPORT=y
 # CONFIG_MTK_AUTO_DETECT_MAGNETOMETER is not set
 # CONFIG_MTK_AUTO_DETECT_ALSPS is not set
 CONFIG_CUSTOM_KERNEL_ACCELEROMETER=y
-CONFIG_CUSTOM_KERNEL_GYROSCOPE=y
+# CONFIG_CUSTOM_KERNEL_GYROSCOPE is not set
 CONFIG_CUSTOM_KERNEL_ALSPS=y
 # CONFIG_CUSTOM_SEC_AUTH_SUPPORT is not set
-CONFIG_CUSTOM_KERNEL_MAGNETOMETER=y
-CONFIG_CUSTOM_KERNEL_BAROMETER=y
-CONFIG_MTK_SENSOR_HUB_SUPPORT=y
-CONFIG_CUSTOM_KERNEL_SENSORHUB="SCP_shf SCP_sensorHub"
-CONFIG_CUSTOM_KERNEL_STEP_COUNTER="SCP_sensorHub"
-CONFIG_CUSTOM_KERNEL_SIGNIFICANT_MOTION_SENSOR="SCP_sensorHub"
-CONFIG_CUSTOM_KERNEL_ACTIVITY_SENSOR="SCP_sensorHub"
-CONFIG_CUSTOM_KERNEL_PICK_UP_SENSOR="SCP_sensorHub"
-CONFIG_CUSTOM_KERNEL_SHAKE_SENSOR="SCP_sensorHub"
-CONFIG_CUSTOM_KERNEL_FACE_DOWN_SENSOR="SCP_sensorHub"
-CONFIG_CUSTOM_KERNEL_IN_POCKET_SENSOR="SCP_sensorHub"
-CONFIG_CUSTOM_KERNEL_PEDOMETER="SCP_sensorHub"
-CONFIG_CUSTOM_KERNEL_HEART_RATE_SENSOR="SCP_sensorHub"
-CONFIG_CUSTOM_KERNEL_TILT_DETECTOR_SENSOR="SCP_sensorHub"
-CONFIG_CUSTOM_KERNEL_WAKE_GESTURE_SENSOR="SCP_sensorHub"
-CONFIG_CUSTOM_KERNEL_GLANCE_GESTURE_SENSOR="SCP_sensorHub"
-CONFIG_CUSTOM_KERNEL_IMGSENSOR="imx135_mipi_raw ov5648_mipi_raw s5k2p8_mipi_raw"
-CONFIG_CUSTOM_KERNEL_LCM="nt35595_fhd_dsi_cmd_truly_nt50358_720p"
+# CONFIG_CUSTOM_KERNEL_MAGNETOMETER is not set
+# CONFIG_CUSTOM_KERNEL_BAROMETER is not set
+# CONFIG_MTK_SENSOR_HUB_SUPPORT is not set
+CONFIG_CUSTOM_KERNEL_SENSORHUB=""
+CONFIG_CUSTOM_KERNEL_STEP_COUNTER=""
+CONFIG_CUSTOM_KERNEL_SIGNIFICANT_MOTION_SENSOR=""
+CONFIG_CUSTOM_KERNEL_ACTIVITY_SENSOR=""
+CONFIG_CUSTOM_KERNEL_PICK_UP_SENSOR=""
+CONFIG_CUSTOM_KERNEL_SHAKE_SENSOR=""
+CONFIG_CUSTOM_KERNEL_FACE_DOWN_SENSOR=""
+CONFIG_CUSTOM_KERNEL_IN_POCKET_SENSOR=""
+CONFIG_CUSTOM_KERNEL_PEDOMETER=""
+CONFIG_CUSTOM_KERNEL_HEART_RATE_SENSOR=""
+CONFIG_CUSTOM_KERNEL_TILT_DETECTOR_SENSOR=""
+CONFIG_CUSTOM_KERNEL_WAKE_GESTURE_SENSOR=""
+CONFIG_CUSTOM_KERNEL_GLANCE_GESTURE_SENSOR=""
+CONFIG_CUSTOM_KERNEL_IMGSENSOR="ov13850_mipi_raw ov5670_mipi_raw"
+CONFIG_CUSTOM_KERNEL_LCM="otm1284a_hd720_dsi_vdo hx8394a_hd720_dsi_vdo_tianma"
 CONFIG_CUSTOM_KERNEL_FLASHLIGHT="constant_flashlight"
 CONFIG_CUSTOM_KERNEL_EXTMD=""
 CONFIG_CUSTOM_KERNEL_SSW="ssw_generic_v2"
@@ -1216,7 +1219,6 @@ CONFIG_MTK_SCHED_CMP_TGS_WAKEUP=y
 #
 # Tracer Related
 #
-# CONFIG_MTK_SCHED_TRACERS is not set
 # CONFIG_MTK_KERNEL_MARKER is not set
 # CONFIG_FUNCTION_DURATION_TRACER is not set
 # CONFIG_MT65XX_TRACER is not set
@@ -1325,8 +1327,8 @@ CONFIG_CUSTOM_LCM_Y="0"
 # CONFIG_LCM_SEND_CMD_IN_VIDEO is not set
 CONFIG_GPS=y
 CONFIG_MTK_GPS=y
-CONFIG_MTK_NFC=y
-CONFIG_NFC_MT6605=y
+# CONFIG_MTK_NFC is not set
+# CONFIG_NFC_MT6605 is not set
 # CONFIG_NFC_MSR3110 is not set
 CONFIG_MTK_BTIF=y
 CONFIG_MTK_COMBO=y
@@ -1360,7 +1362,7 @@ CONFIG_MTK_FM_CHIP="MT6625_FM"
 # CONFIG_MTK_FM_50KHZ_SUPPORT is not set
 # CONFIG_MTK_MERGE_INTERFACE_SUPPORT is not set
 # CONFIG_SDIOAUTOK_SUPPORT is not set
-CONFIG_MTK_MT6306_SUPPORT=y
+# CONFIG_MTK_MT6306_SUPPORT is not set
 # CONFIG_MTK_IDLE_TIME_FIX is not set
 CONFIG_MTK_G2D=y
 # CONFIG_MTK_MPEG4_DEC_DRIVER is not set
@@ -1401,7 +1403,7 @@ CONFIG_MTK_BQ24261_SUPPORT=y
 # CONFIG_MTK_FAN5405_SUPPORT is not set
 # CONFIG_MTK_FAN5402_SUPPORT is not set
 # CONFIG_MTK_BQ24158_SUPPORT is not set
-# CONFIG_MTK_BQ24296_SUPPORT is not set
+CONFIG_MTK_BQ24296_SUPPORT=y
 # CONFIG_MTK_BQ27541_SUPPORT is not set
 # CONFIG_MTK_NCP1851_SUPPORT is not set
 # CONFIG_MTK_NCP1854_SUPPORT is not set
@@ -1425,7 +1427,7 @@ CONFIG_MTK_SIM2=y
 # CONFIG_MTK_EPL2182_NEW is not set
 # CONFIG_MTK_STK3X1X is not set
 # CONFIG_MTK_STK3X1X_NEW is not set
-CONFIG_MTK_CM36652_NEW=y
+# CONFIG_MTK_CM36652_NEW is not set
 # CONFIG_MTK_APDS9930 is not set
 # CONFIG_MTK_CM3232_NEW is not set
 # CONFIG_MTK_APDS9930_NEW is not set
@@ -1437,8 +1439,12 @@ CONFIG_MTK_CM36652_NEW=y
 # CONFIG_MTK_MC3410_NEW is not set
 # CONFIG_MTK_MPU6050G_NEW is not set
 # CONFIG_MTK_BMA250 is not set
-CONFIG_MTK_MPU6515A=y
+# CONFIG_MTK_MPU6515A is not set
 # CONFIG_MTK_MPU60X0 is not set
+# zormax
+CONFIG_MTK_STK3310=y
+CONFIG_MTK_BMA222E_NEW=y
+CONFIG_MTK_KXTJ2_1009_NEW=y
 # CONFIG_MTK_KXTJ2_1009_NEW is not set
 # CONFIG_MTK_MC3XXX_AUTO is not set
 # CONFIG_MTK_BMA250E is not set
@@ -1447,7 +1453,7 @@ CONFIG_MTK_MPU6515A=y
 # CONFIG_MTK_MPU3000_NEW is not set
 # CONFIG_MTK_MPU6050GY_NEW is not set
 # CONFIG_MTK_ITG1010_NEW is not set
-CONFIG_MTK_MPU6515G=y
+# CONFIG_MTK_MPU6515G is not set
 # CONFIG_MTK_MPU3050C_NEW is not set
 # CONFIG_MTK_MPU6050C is not set
 # CONFIG_MTK_AKM8963 is not set
@@ -1461,8 +1467,8 @@ CONFIG_MTK_MPU6515G=y
 # CONFIG_MTK_BMA050 is not set
 # CONFIG_MTK_BMA050_NEW is not set
 # CONFIG_MTK_S2200 is not set
-CONFIG_MTK_YAS532=y
-CONFIG_MTK_BMP180_NEW=y
+# CONFIG_MTK_YAS532 is not set
+# CONFIG_MTK_BMP180_NEW is not set
 CONFIG_MTK_TOUCHPANEL=y
 # CONFIG_MTK_S7020 is not set
 CONFIG_MTK_USB_GADGET=y
@@ -1508,10 +1514,10 @@ CONFIG_MTK_GPU_SUPPORT=y
 CONFIG_MTK_KERNEL_POWER_OFF_CHARGING=y
 # CONFIG_MTK_BQ24160_SUPPORT is not set
 # CONFIG_MTK_MT8193_SUPPORT is not set
-CONFIG_MTK_HDMI_SUPPORT=y
+# CONFIG_MTK_HDMI_SUPPORT is not set
 # CONFIG_MTK_INTERNAL_HDMI_SUPPORT is not set
 # CONFIG_MTK_MT8193_HDCP_SUPPORT is not set
-CONFIG_CUSTOM_KERNEL_HDMI="Sii8348"
+# CONFIG_CUSTOM_KERNEL_HDMI is not set
 # CONFIG_SINGLE_PANEL_OUTPUT is not set
 # CONFIG_MTK_INTERNAL_MHL_SUPPORT is not set
 CONFIG_MTK_THERMAL_PA_VIA_ATCMD=y
@@ -1527,7 +1533,7 @@ CONFIG_MTK_BICR_SUPPORT=y
 # CONFIG_NAND_OTP_SUPPORT is not set
 # CONFIG_MTK_OD_SUPPORT is not set
 CONFIG_MTK_LENS_DUMMYLENS_SUPPORT=y
-CONFIG_MTK_LENS_AD5820AF_SUPPORT=y
+# CONFIG_MTK_LENS_AD5820AF_SUPPORT is not set
 # CONFIG_MTK_LENS_AD5823_SUPPORT is not set
 # CONFIG_MTK_LENS_AD5823AF_SUPPORT is not set
 # CONFIG_MTK_LENS_AK7345AF_SUPPORT is not set
@@ -1537,8 +1543,8 @@ CONFIG_MTK_LENS_AD5820AF_SUPPORT=y
 # CONFIG_MTK_LENS_DW9718AF_SUPPORT is not set
 CONFIG_MTK_LENS_DW9714AF_SUPPORT=y
 # CONFIG_MTK_LENS_DW9714A_SUPPORT is not set
-CONFIG_MTK_LENS_LC898122AF_SUPPORT=y
-CONFIG_MTK_LENS_LC898212AF_SUPPORT=y
+# CONFIG_MTK_LENS_LC898122AF_SUPPORT is not set
+# CONFIG_MTK_LENS_LC898212AF_SUPPORT is not set
 # CONFIG_MTK_LENS_FM50AF_SUPPORT is not set
 # CONFIG_MTK_LENS_MT9P017AF_SUPPORT is not set
 # CONFIG_MTK_LENS_OV8825AF_SUPPORT is not set
@@ -1550,7 +1556,7 @@ CONFIG_MTK_LENS_LC898212AF_SUPPORT=y
 # CONFIG_MTK_CAM_CAL_BRCC064GWZ_3_SUPPORT is not set
 # CONFIG_MTK_CAM_CAL_BRCB032GWZ_3_SUPPORT is not set
 # CONFIG_MTK_EXTMEM is not set
-CONFIG_MTK_CPU_STRESS=y
+# CONFIG_MTK_CPU_STRESS is not set
 CONFIG_MTK_LASTPC=y
 CONFIG_MTK_FMRADIO=y
 CONFIG_MTK_HWMON=y
@@ -1717,8 +1723,8 @@ CONFIG_INPUT=y
 #
 CONFIG_INPUT_MOUSEDEV=y
 CONFIG_INPUT_MOUSEDEV_PSAUX=y
-CONFIG_INPUT_MOUSEDEV_SCREEN_X=1920
-CONFIG_INPUT_MOUSEDEV_SCREEN_Y=1080
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1280
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=720
 # CONFIG_INPUT_JOYDEV is not set
 CONFIG_INPUT_EVDEV=y
 # CONFIG_INPUT_EVBUG is not set
@@ -1791,7 +1797,7 @@ CONFIG_TOUCHSCREEN_MTK=y
 # CONFIG_TOUCHSCREEN_MTK_FHD is not set
 # CONFIG_TOUCHSCREEN_MTK_HD is not set
 # CONFIG_TOUCHSCREEN_MTK_GT9XX_AIO is not set
-CONFIG_TOUCHSCREEN_MTK_GT9XX_HOTKNOT_SCP=y
+# CONFIG_TOUCHSCREEN_MTK_GT9XX_HOTKNOT_SCP is not set
 # CONFIG_TOUCHSCREEN_MTK_GT9XX_HOTKNOT is not set
 # CONFIG_TOUCHSCREEN_MTK_GT1151 is not set
 # CONFIG_TOUCHSCREEN_MTK_MAX1187X is not set
@@ -1804,6 +1810,7 @@ CONFIG_TOUCHSCREEN_MTK_GT9XX_HOTKNOT_SCP=y
 # CONFIG_MTK_MMS244 is not set
 # CONFIG_GT9XX_HOTKNOT_FLASHLESS is not set
 # CONFIG_MTK_FT5406 is not set
+CONFIG_MTK_FT5436I=y
 # CONFIG_MTK_FT5406_82 is not set
 # CONFIG_MTK_FT5206 is not set
 # CONFIG_MTK_MMS134 is not set
@@ -2204,7 +2211,11 @@ CONFIG_FB_TILEBLITTING=y
 # Console display driver support
 #
 CONFIG_FONT_8x16=y
-# CONFIG_LOGO is not set
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_FB_SSD1307 is not set
 CONFIG_SOUND=y
 CONFIG_SOUND_OSS_CORE=y
 CONFIG_SOUND_OSS_CORE_PRECLAIM=y
@@ -2700,7 +2711,6 @@ CONFIG_ANDROID=y
 CONFIG_ANDROID_BINDER_IPC=y
 CONFIG_ANDROID_BINDER_IPC_32BIT=y
 CONFIG_ASHMEM=y
-CONFIG_ANDROID_LOGGER=y
 CONFIG_ANDROID_TIMED_OUTPUT=y
 # CONFIG_ANDROID_TIMED_GPIO is not set
 CONFIG_ANDROID_LOW_MEMORY_KILLER=y
@@ -2709,7 +2719,7 @@ CONFIG_ANDROID_INTF_ALARM_DEV=y
 CONFIG_SYNC=y
 CONFIG_SW_SYNC=y
 CONFIG_SW_SYNC_USER=y
-CONFIG_MTK_GMO_RAM_OPTIMIZE=y
+# CONFIG_MTK_GMO_RAM_OPTIMIZE is not set
 CONFIG_ION=y
 # CONFIG_ION_TEST is not set
 # CONFIG_FIQ_DEBUGGER is not set
@@ -2807,7 +2817,16 @@ CONFIG_MSDOS_FS=y
 CONFIG_VFAT_FS=y
 CONFIG_FAT_DEFAULT_CODEPAGE=437
 CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
-# CONFIG_NTFS_FS is not set
+CONFIG_NTFS_FS=y
+# CONFIG_NTFS_DEBUG is not set
+CONFIG_NTFS_RW=y
+CONFIG_EXFAT_FS=y
+CONFIG_EXFAT_DISCARD=y
+# CONFIG_EXFAT_DELAYED_SYNC is not set
+# CONFIG_EXFAT_KERNEL_DEBUG is not set
+# CONFIG_EXFAT_DEBUG_MSG is not set
+CONFIG_EXFAT_DEFAULT_CODEPAGE=437
+CONFIG_EXFAT_DEFAULT_IOCHARSET="utf8"
 
 #
 # Pseudo filesystems
@@ -2848,7 +2867,12 @@ CONFIG_NETWORK_FILESYSTEMS=y
 # CONFIG_NFS_FS is not set
 # CONFIG_NFSD is not set
 # CONFIG_CEPH_FS is not set
-# CONFIG_CIFS is not set
+CONFIG_CIFS=y
+# CONFIG_CIFS_STATS is not set
+# CONFIG_CIFS_WEAK_PW_HASH is not set
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CIFS_DEBUG2 is not set
+# CONFIG_CIFS_EXPERIMENTAL is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
@@ -3224,3 +3248,21 @@ CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
 # CONFIG_VIRTUALIZATION is not set
 CONFIG_ENABLE_DEFAULT_TRACERS=y
 # CONFIG_MTK_OTG_OC_DETECTOR is not set
+CONFIG_ANDROID_LOGGER=y
+CONFIG_MTK_SCHED_TRACERS=y
+# CONFIG_MTK_FTRACE_DEFAULT_ENABLE is not set
+# CONFIG_MTK_DUM_CHAR is not set
+# CONFIG_MTK_SOUND_DRV is not set
+CONFIG_MTK_LEGACY=y
+CONFIG_MTK_CONN_LTE_IDC_SUPPORT=y
+CONFIG_LIGHTNESS_MAPPING_VALUE=255
+CONFIG_KPD_PMIC_LPRST_TD=1
+# CONFIG_MTK_TC1_FM_AT_SUSPEND is not set
+# CONFIG_KICK_SPM_WDT is not set
+# CONFIG_MTK_INHOUSE_GPU is not set
+# CONFIG_SW_SYNC64 is not set
+# CONFIG_MT_SND_SOC_6580 is not set
+# CONFIG_MT_SND_SOC_8163 is not set
+# CONFIG_MMC_FFU is not set
+# CONFIG_RAWFS_FS is not set
+# CONFIG_CRYPTO_LZ4K is not set
diff --git a/arch/arm/crypto/aes_glue.c b/arch/arm/crypto/aes_glue.c
index ef73898..aafe908 100644
--- a/arch/arm/crypto/aes_glue.c
+++ b/arch/arm/crypto/aes_glue.c
@@ -95,6 +95,6 @@ module_exit(aes_fini);
 
 MODULE_DESCRIPTION("Rijndael (AES) Cipher Algorithm (ASM)");
 MODULE_LICENSE("GPL");
-MODULE_ALIAS("aes");
-MODULE_ALIAS("aes-asm");
+MODULE_ALIAS_CRYPTO("aes");
+MODULE_ALIAS_CRYPTO("aes-asm");
 MODULE_AUTHOR("David McCullough <ucdevel@gmail.com>");
diff --git a/arch/arm/crypto/sha1_glue.c b/arch/arm/crypto/sha1_glue.c
index 84f2a75..e31b044 100644
--- a/arch/arm/crypto/sha1_glue.c
+++ b/arch/arm/crypto/sha1_glue.c
@@ -171,5 +171,5 @@ module_exit(sha1_mod_fini);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("SHA1 Secure Hash Algorithm (ARM)");
-MODULE_ALIAS("sha1");
+MODULE_ALIAS_CRYPTO("sha1");
 MODULE_AUTHOR("David McCullough <ucdevel@gmail.com>");
diff --git a/arch/arm/include/asm/atomic.h b/arch/arm/include/asm/atomic.h
index da1c77d..9ee7e01 100644
--- a/arch/arm/include/asm/atomic.h
+++ b/arch/arm/include/asm/atomic.h
@@ -114,7 +114,8 @@ static inline int atomic_sub_return(int i, atomic_t *v)
 
 static inline int atomic_cmpxchg(atomic_t *ptr, int old, int new)
 {
-	unsigned long oldval, res;
+	int oldval;
+	unsigned long res;
 
 	smp_mb();
 
@@ -238,15 +239,15 @@ static inline int __atomic_add_unless(atomic_t *v, int a, int u)
 
 #ifndef CONFIG_GENERIC_ATOMIC64
 typedef struct {
-	u64 __aligned(8) counter;
+	long long counter;
 } atomic64_t;
 
 #define ATOMIC64_INIT(i) { (i) }
 
 #ifdef CONFIG_ARM_LPAE
-static inline u64 atomic64_read(const atomic64_t *v)
+static inline long long atomic64_read(const atomic64_t *v)
 {
-	u64 result;
+	long long result;
 
 	__asm__ __volatile__("@ atomic64_read\n"
 "	ldrd	%0, %H0, [%1]"
@@ -257,7 +258,7 @@ static inline u64 atomic64_read(const atomic64_t *v)
 	return result;
 }
 
-static inline void atomic64_set(atomic64_t *v, u64 i)
+static inline void atomic64_set(atomic64_t *v, long long i)
 {
 	__asm__ __volatile__("@ atomic64_set\n"
 "	strd	%2, %H2, [%1]"
@@ -266,9 +267,9 @@ static inline void atomic64_set(atomic64_t *v, u64 i)
 	);
 }
 #else
-static inline u64 atomic64_read(const atomic64_t *v)
+static inline long long atomic64_read(const atomic64_t *v)
 {
-	u64 result;
+	long long result;
 
 	__asm__ __volatile__("@ atomic64_read\n"
 "	ldrexd	%0, %H0, [%1]"
@@ -279,9 +280,9 @@ static inline u64 atomic64_read(const atomic64_t *v)
 	return result;
 }
 
-static inline void atomic64_set(atomic64_t *v, u64 i)
+static inline void atomic64_set(atomic64_t *v, long long i)
 {
-	u64 tmp;
+	long long tmp;
 
 	__asm__ __volatile__("@ atomic64_set\n"
 "1:	ldrexd	%0, %H0, [%2]\n"
@@ -294,9 +295,9 @@ static inline void atomic64_set(atomic64_t *v, u64 i)
 }
 #endif
 
-static inline void atomic64_add(u64 i, atomic64_t *v)
+static inline void atomic64_add(long long i, atomic64_t *v)
 {
-	u64 result;
+	long long result;
 	unsigned long tmp;
 
 	__asm__ __volatile__("@ atomic64_add\n"
@@ -311,9 +312,9 @@ static inline void atomic64_add(u64 i, atomic64_t *v)
 	: "cc");
 }
 
-static inline u64 atomic64_add_return(u64 i, atomic64_t *v)
+static inline long long atomic64_add_return(long long i, atomic64_t *v)
 {
-	u64 result;
+	long long result;
 	unsigned long tmp;
 
 	smp_mb();
@@ -334,9 +335,9 @@ static inline u64 atomic64_add_return(u64 i, atomic64_t *v)
 	return result;
 }
 
-static inline void atomic64_sub(u64 i, atomic64_t *v)
+static inline void atomic64_sub(long long i, atomic64_t *v)
 {
-	u64 result;
+	long long result;
 	unsigned long tmp;
 
 	__asm__ __volatile__("@ atomic64_sub\n"
@@ -351,9 +352,9 @@ static inline void atomic64_sub(u64 i, atomic64_t *v)
 	: "cc");
 }
 
-static inline u64 atomic64_sub_return(u64 i, atomic64_t *v)
+static inline long long atomic64_sub_return(long long i, atomic64_t *v)
 {
-	u64 result;
+	long long result;
 	unsigned long tmp;
 
 	smp_mb();
@@ -374,9 +375,10 @@ static inline u64 atomic64_sub_return(u64 i, atomic64_t *v)
 	return result;
 }
 
-static inline u64 atomic64_cmpxchg(atomic64_t *ptr, u64 old, u64 new)
+static inline long long atomic64_cmpxchg(atomic64_t *ptr, long long old,
+					long long new)
 {
-	u64 oldval;
+	long long oldval;
 	unsigned long res;
 
 	smp_mb();
@@ -398,9 +400,9 @@ static inline u64 atomic64_cmpxchg(atomic64_t *ptr, u64 old, u64 new)
 	return oldval;
 }
 
-static inline u64 atomic64_xchg(atomic64_t *ptr, u64 new)
+static inline long long atomic64_xchg(atomic64_t *ptr, long long new)
 {
-	u64 result;
+	long long result;
 	unsigned long tmp;
 
 	smp_mb();
@@ -419,9 +421,9 @@ static inline u64 atomic64_xchg(atomic64_t *ptr, u64 new)
 	return result;
 }
 
-static inline u64 atomic64_dec_if_positive(atomic64_t *v)
+static inline long long atomic64_dec_if_positive(atomic64_t *v)
 {
-	u64 result;
+	long long result;
 	unsigned long tmp;
 
 	smp_mb();
@@ -445,9 +447,9 @@ static inline u64 atomic64_dec_if_positive(atomic64_t *v)
 	return result;
 }
 
-static inline int atomic64_add_unless(atomic64_t *v, u64 a, u64 u)
+static inline int atomic64_add_unless(atomic64_t *v, long long a, long long u)
 {
-	u64 val;
+	long long val;
 	unsigned long tmp;
 	int ret = 1;
 
diff --git a/arch/arm/include/asm/memory.h b/arch/arm/include/asm/memory.h
index 57870ab..beab975 100644
--- a/arch/arm/include/asm/memory.h
+++ b/arch/arm/include/asm/memory.h
@@ -275,7 +275,8 @@ static inline __deprecated void *bus_to_virt(unsigned long x)
 #define ARCH_PFN_OFFSET		PHYS_PFN_OFFSET
 
 #define virt_to_page(kaddr)	pfn_to_page(__pa(kaddr) >> PAGE_SHIFT)
-#define virt_addr_valid(kaddr)	((unsigned long)(kaddr) >= PAGE_OFFSET && (unsigned long)(kaddr) < (unsigned long)high_memory)
+#define virt_addr_valid(kaddr)	(((unsigned long)(kaddr) >= PAGE_OFFSET && (unsigned long)(kaddr) < (unsigned long)high_memory) \
+					&& pfn_valid(__pa(kaddr) >> PAGE_SHIFT) )
 
 #endif
 
diff --git a/arch/arm/include/asm/module.h b/arch/arm/include/asm/module.h
index 0d3a28d..ed690c4 100644
--- a/arch/arm/include/asm/module.h
+++ b/arch/arm/include/asm/module.h
@@ -12,6 +12,8 @@ enum {
 	ARM_SEC_CORE,
 	ARM_SEC_EXIT,
 	ARM_SEC_DEVEXIT,
+	ARM_SEC_HOT,
+	ARM_SEC_UNLIKELY,
 	ARM_SEC_MAX,
 };
 
diff --git a/arch/arm/include/asm/page.h b/arch/arm/include/asm/page.h
index cbdc7a2..4355f0e 100644
--- a/arch/arm/include/asm/page.h
+++ b/arch/arm/include/asm/page.h
@@ -13,7 +13,7 @@
 /* PAGE_SHIFT determines the page size */
 #define PAGE_SHIFT		12
 #define PAGE_SIZE		(_AC(1,UL) << PAGE_SHIFT)
-#define PAGE_MASK		(~(PAGE_SIZE-1))
+#define PAGE_MASK		(~((1 << PAGE_SHIFT) - 1))
 
 #ifndef __ASSEMBLY__
 
diff --git a/arch/arm/include/asm/pgtable-3level-hwdef.h b/arch/arm/include/asm/pgtable-3level-hwdef.h
index 18f5cef..add785b 100644
--- a/arch/arm/include/asm/pgtable-3level-hwdef.h
+++ b/arch/arm/include/asm/pgtable-3level-hwdef.h
@@ -68,6 +68,7 @@
 #define PTE_TYPE_PAGE		(_AT(pteval_t, 3) << 0)
 #define PTE_BUFFERABLE		(_AT(pteval_t, 1) << 2)		/* AttrIndx[0] */
 #define PTE_CACHEABLE		(_AT(pteval_t, 1) << 3)		/* AttrIndx[1] */
+#define PTE_AP2			(_AT(pteval_t, 1) << 7)		/* AP[2] */
 #define PTE_EXT_SHARED		(_AT(pteval_t, 3) << 8)		/* SH[1:0], inner shareable */
 #define PTE_EXT_AF		(_AT(pteval_t, 1) << 10)	/* Access Flag */
 #define PTE_EXT_NG		(_AT(pteval_t, 1) << 11)	/* nG */
diff --git a/arch/arm/include/asm/pgtable-3level.h b/arch/arm/include/asm/pgtable-3level.h
index 86b8fe3..bb01732 100644
--- a/arch/arm/include/asm/pgtable-3level.h
+++ b/arch/arm/include/asm/pgtable-3level.h
@@ -33,7 +33,7 @@
 #define PTRS_PER_PMD		512
 #define PTRS_PER_PGD		4
 
-#define PTE_HWTABLE_PTRS	(PTRS_PER_PTE)
+#define PTE_HWTABLE_PTRS	(0)
 #define PTE_HWTABLE_OFF		(0)
 #define PTE_HWTABLE_SIZE	(PTRS_PER_PTE * sizeof(u64))
 
@@ -48,16 +48,16 @@
 #define PMD_SHIFT		21
 
 #define PMD_SIZE		(1UL << PMD_SHIFT)
-#define PMD_MASK		(~(PMD_SIZE-1))
+#define PMD_MASK		(~((1 << PMD_SHIFT) - 1))
 #define PGDIR_SIZE		(1UL << PGDIR_SHIFT)
-#define PGDIR_MASK		(~(PGDIR_SIZE-1))
+#define PGDIR_MASK		(~((1 << PGDIR_SHIFT) - 1))
 
 /*
  * section address mask and size definitions.
  */
 #define SECTION_SHIFT		21
 #define SECTION_SIZE		(1UL << SECTION_SHIFT)
-#define SECTION_MASK		(~(SECTION_SIZE-1))
+#define SECTION_MASK		(~((1 << SECTION_SHIFT) - 1))
 
 #define USER_PTRS_PER_PGD	(PAGE_OFFSET / PGDIR_SIZE)
 
@@ -71,13 +71,13 @@
 #define L_PTE_PRESENT		(_AT(pteval_t, 3) << 0)		/* Present */
 #define L_PTE_FILE		(_AT(pteval_t, 1) << 2)		/* only when !PRESENT */
 #define L_PTE_USER		(_AT(pteval_t, 1) << 6)		/* AP[1] */
-#define L_PTE_RDONLY		(_AT(pteval_t, 1) << 7)		/* AP[2] */
 #define L_PTE_SHARED		(_AT(pteval_t, 3) << 8)		/* SH[1:0], inner shareable */
 #define L_PTE_YOUNG		(_AT(pteval_t, 1) << 10)	/* AF */
 #define L_PTE_XN		(_AT(pteval_t, 1) << 54)	/* XN */
-#define L_PTE_DIRTY		(_AT(pteval_t, 1) << 55)	/* unused */
-#define L_PTE_SPECIAL		(_AT(pteval_t, 1) << 56)	/* unused */
+#define L_PTE_DIRTY		(_AT(pteval_t, 1) << 55)
+#define L_PTE_SPECIAL		(_AT(pteval_t, 1) << 56)
 #define L_PTE_NONE		(_AT(pteval_t, 1) << 57)	/* PROT_NONE */
+#define L_PTE_RDONLY		(_AT(pteval_t, 1) << 58)	/* READ ONLY */
 
 /*
  * To be used in assembly code with the upper page attributes.
@@ -166,6 +166,23 @@ static inline pmd_t *pmd_offset(pud_t *pud, unsigned long addr)
 		clean_pmd_entry(pmdp);	\
 	} while (0)
 
+/*
+ * For 3 levels of paging the PTE_EXT_NG bit will be set for user address ptes
+ * that are written to a page table but not for ptes created with mk_pte.
+ *
+ * In hugetlb_no_page, a new huge pte (new_pte) is generated and passed to
+ * hugetlb_cow, where it is compared with an entry in a page table.
+ * This comparison test fails erroneously leading ultimately to a memory leak.
+ *
+ * To correct this behaviour, we mask off PTE_EXT_NG for any pte that is
+ * present before running the comparison.
+ */
+#define __HAVE_ARCH_PTE_SAME
+#define pte_same(pte_a,pte_b)	((pte_present(pte_a) ? pte_val(pte_a) & ~PTE_EXT_NG	\
+					: pte_val(pte_a))				\
+				== (pte_present(pte_b) ? pte_val(pte_b) & ~PTE_EXT_NG	\
+					: pte_val(pte_b)))
+
 #define set_pte_ext(ptep,pte,ext) cpu_set_pte_ext(ptep,__pte(pte_val(pte)|(ext)))
 
 #endif /* __ASSEMBLY__ */
diff --git a/arch/arm/include/asm/pgtable.h b/arch/arm/include/asm/pgtable.h
index 5aac06f..4043d7f 100644
--- a/arch/arm/include/asm/pgtable.h
+++ b/arch/arm/include/asm/pgtable.h
@@ -211,12 +211,16 @@ static inline pte_t *pmd_page_vaddr(pmd_t pmd)
 
 #define pte_clear(mm,addr,ptep)	set_pte_ext(ptep, __pte(0), 0)
 
+#define pte_isset(pte, val)	((u32)(val) == (val) ? pte_val(pte) & (val) \
+						: !!(pte_val(pte) & (val)))
+#define pte_isclear(pte, val)	(!(pte_val(pte) & (val)))
+
 #define pte_none(pte)		(!pte_val(pte))
-#define pte_present(pte)	(pte_val(pte) & L_PTE_PRESENT)
-#define pte_write(pte)		(!(pte_val(pte) & L_PTE_RDONLY))
-#define pte_dirty(pte)		(pte_val(pte) & L_PTE_DIRTY)
-#define pte_young(pte)		(pte_val(pte) & L_PTE_YOUNG)
-#define pte_exec(pte)		(!(pte_val(pte) & L_PTE_XN))
+#define pte_present(pte)	(pte_isset((pte), L_PTE_PRESENT))
+#define pte_write(pte)		(pte_isclear((pte), L_PTE_RDONLY))
+#define pte_dirty(pte)		(pte_isset((pte), L_PTE_DIRTY))
+#define pte_young(pte)		(pte_isset((pte), L_PTE_YOUNG))
+#define pte_exec(pte)		(pte_isclear((pte), L_PTE_XN))
 #define pte_special(pte)	(0)
 
 #define pte_present_user(pte)  (pte_present(pte) && (pte_val(pte) & L_PTE_USER))
diff --git a/arch/arm/kernel/head.S b/arch/arm/kernel/head.S
index b42251a..3a63c46 100644
--- a/arch/arm/kernel/head.S
+++ b/arch/arm/kernel/head.S
@@ -110,7 +110,7 @@ ENTRY(stext)
 	sub	r4, r3, r4			@ (PHYS_OFFSET - PAGE_OFFSET)
 	add	r8, r8, r4			@ PHYS_OFFSET
 #else
-	ldr	r8, =PHYS_OFFSET		@ always constant in this case
+	ldr	r8, =PLAT_PHYS_OFFSET		@ always constant in this case
 #endif
 
 	/*
diff --git a/arch/arm/kernel/module.c b/arch/arm/kernel/module.c
index b69ed0c..70bec79 100644
--- a/arch/arm/kernel/module.c
+++ b/arch/arm/kernel/module.c
@@ -296,6 +296,10 @@ int module_finalize(const Elf32_Ehdr *hdr, const Elf_Shdr *sechdrs,
 			maps[ARM_SEC_EXIT].unw_sec = s;
 		else if (strcmp(".ARM.exidx.devexit.text", secname) == 0)
 			maps[ARM_SEC_DEVEXIT].unw_sec = s;
+		else if (strcmp(".ARM.exidx.text.unlikely", secname) == 0)
+			maps[ARM_SEC_UNLIKELY].unw_sec = s;
+		else if (strcmp(".ARM.exidx.text.hot", secname) == 0)
+			maps[ARM_SEC_HOT].unw_sec = s;
 		else if (strcmp(".init.text", secname) == 0)
 			maps[ARM_SEC_INIT].txt_sec = s;
 		else if (strcmp(".devinit.text", secname) == 0)
@@ -306,6 +310,10 @@ int module_finalize(const Elf32_Ehdr *hdr, const Elf_Shdr *sechdrs,
 			maps[ARM_SEC_EXIT].txt_sec = s;
 		else if (strcmp(".devexit.text", secname) == 0)
 			maps[ARM_SEC_DEVEXIT].txt_sec = s;
+		else if (strcmp(".text.unlikely", secname) == 0)
+			maps[ARM_SEC_UNLIKELY].txt_sec = s;
+		else if (strcmp(".text.hot", secname) == 0)
+			maps[ARM_SEC_HOT].txt_sec = s;
 	}
 
 	for (i = 0; i < ARM_SEC_MAX; i++)
diff --git a/arch/arm/mach-imx/clk-imx6q.c b/arch/arm/mach-imx/clk-imx6q.c
index 0b9e437..2acaded 100644
--- a/arch/arm/mach-imx/clk-imx6q.c
+++ b/arch/arm/mach-imx/clk-imx6q.c
@@ -301,8 +301,8 @@ int __init mx6q_clocks_init(void)
 		post_div_table[1].div = 1;
 		post_div_table[2].div = 1;
 		video_div_table[1].div = 1;
-		video_div_table[2].div = 1;
-	};
+		video_div_table[3].div = 1;
+	}
 
 	/*                   type                               name         parent_name  base     div_mask */
 	clk[pll1_sys]      = imx_clk_pllv3(IMX_PLLV3_SYS,	"pll1_sys",	"osc", base,        0x7f);
diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index f8b23b8..3f3259e 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -503,11 +503,11 @@ static void __init realtime_counter_init(void)
 	rate = clk_get_rate(sys_clk);
 	/* Numerator/denumerator values refer TRM Realtime Counter section */
 	switch (rate) {
-	case 1200000:
+	case 12000000:
 		num = 64;
 		den = 125;
 		break;
-	case 1300000:
+	case 13000000:
 		num = 768;
 		den = 1625;
 		break;
@@ -515,11 +515,11 @@ static void __init realtime_counter_init(void)
 		num = 8;
 		den = 25;
 		break;
-	case 2600000:
+	case 26000000:
 		num = 384;
 		den = 1625;
 		break;
-	case 2700000:
+	case 27000000:
 		num = 256;
 		den = 1125;
 		break;
diff --git a/arch/arm/mach-pxa/corgi.c b/arch/arm/mach-pxa/corgi.c
index a5b8fea..9cb7ea7 100644
--- a/arch/arm/mach-pxa/corgi.c
+++ b/arch/arm/mach-pxa/corgi.c
@@ -26,6 +26,7 @@
 #include <linux/i2c.h>
 #include <linux/i2c/pxa-i2c.h>
 #include <linux/io.h>
+#include <linux/regulator/machine.h>
 #include <linux/spi/spi.h>
 #include <linux/spi/ads7846.h>
 #include <linux/spi/corgi_lcd.h>
@@ -711,6 +712,8 @@ static void __init corgi_init(void)
 		sharpsl_nand_partitions[1].size = 53 * 1024 * 1024;
 
 	platform_add_devices(devices, ARRAY_SIZE(devices));
+
+	regulator_has_full_constraints();
 }
 
 static void __init fixup_corgi(struct tag *tags, char **cmdline,
diff --git a/arch/arm/mach-pxa/hx4700.c b/arch/arm/mach-pxa/hx4700.c
index 133109e..a07accf 100644
--- a/arch/arm/mach-pxa/hx4700.c
+++ b/arch/arm/mach-pxa/hx4700.c
@@ -891,6 +891,8 @@ static void __init hx4700_init(void)
 	mdelay(10);
 	gpio_set_value(GPIO71_HX4700_ASIC3_nRESET, 1);
 	mdelay(10);
+
+	regulator_has_full_constraints();
 }
 
 MACHINE_START(H4700, "HP iPAQ HX4700")
diff --git a/arch/arm/mach-pxa/poodle.c b/arch/arm/mach-pxa/poodle.c
index 50ccd5f..362c05f 100644
--- a/arch/arm/mach-pxa/poodle.c
+++ b/arch/arm/mach-pxa/poodle.c
@@ -25,6 +25,7 @@
 #include <linux/gpio.h>
 #include <linux/i2c.h>
 #include <linux/i2c/pxa-i2c.h>
+#include <linux/regulator/machine.h>
 #include <linux/spi/spi.h>
 #include <linux/spi/ads7846.h>
 #include <linux/spi/pxa2xx_spi.h>
@@ -452,6 +453,7 @@ static void __init poodle_init(void)
 	pxa_set_i2c_info(NULL);
 	i2c_register_board_info(0, ARRAY_AND_SIZE(poodle_i2c_devices));
 	poodle_init_spi();
+	regulator_has_full_constraints();
 }
 
 static void __init fixup_poodle(struct tag *tags, char **cmdline,
diff --git a/arch/arm/mach-sa1100/pm.c b/arch/arm/mach-sa1100/pm.c
index 6645d1e..34853d5 100644
--- a/arch/arm/mach-sa1100/pm.c
+++ b/arch/arm/mach-sa1100/pm.c
@@ -81,6 +81,7 @@ static int sa11x0_pm_enter(suspend_state_t state)
 	/*
 	 * Ensure not to come back here if it wasn't intended
 	 */
+	RCSR = RCSR_SMR;
 	PSPR = 0;
 
 	/*
diff --git a/arch/arm/mach-shmobile/setup-sh73a0.c b/arch/arm/mach-shmobile/setup-sh73a0.c
index 9696f36..ea788c8 100644
--- a/arch/arm/mach-shmobile/setup-sh73a0.c
+++ b/arch/arm/mach-shmobile/setup-sh73a0.c
@@ -814,6 +814,7 @@ static struct platform_device ipmmu_device = {
 
 static struct renesas_intc_irqpin_config irqpin0_platform_data = {
 	.irq_base = irq_pin(0), /* IRQ0 -> IRQ7 */
+	.control_parent = true,
 };
 
 static struct resource irqpin0_resources[] = {
@@ -875,6 +876,7 @@ static struct platform_device irqpin1_device = {
 
 static struct renesas_intc_irqpin_config irqpin2_platform_data = {
 	.irq_base = irq_pin(16), /* IRQ16 -> IRQ23 */
+	.control_parent = true,
 };
 
 static struct resource irqpin2_resources[] = {
@@ -905,6 +907,7 @@ static struct platform_device irqpin2_device = {
 
 static struct renesas_intc_irqpin_config irqpin3_platform_data = {
 	.irq_base = irq_pin(24), /* IRQ24 -> IRQ31 */
+	.control_parent = true,
 };
 
 static struct resource irqpin3_resources[] = {
diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c
index 6c9d705..8ca636c 100644
--- a/arch/arm/mm/dma-mapping.c
+++ b/arch/arm/mm/dma-mapping.c
@@ -429,12 +429,21 @@ void __init dma_contiguous_remap(void)
 		map.type = MT_MEMORY_DMA_READY;
 
 		/*
-		 * Clear previous low-memory mapping
+		 * Clear previous low-memory mapping to ensure that the
+		 * TLB does not see any conflicting entries, then flush
+		 * the TLB of the old entries before creating new mappings.
+		 *
+		 * This ensures that any speculatively loaded TLB entries
+		 * (even though they may be rare) can not cause any problems,
+		 * and ensures that this code is architecturally compliant.
 		 */
 		for (addr = __phys_to_virt(start); addr < __phys_to_virt(end);
 		     addr += PMD_SIZE)
 			pmd_clear(pmd_off_k(addr));
 
+		flush_tlb_kernel_range(__phys_to_virt(start),
+				       __phys_to_virt(end));
+
 		iotable_init(&map, 1);
 	}
 }
diff --git a/arch/arm/mm/init.c b/arch/arm/mm/init.c
index 0b9bbfe..4117a6e 100644
--- a/arch/arm/mm/init.c
+++ b/arch/arm/mm/init.c
@@ -21,7 +21,6 @@
 #include <linux/gfp.h>
 #include <linux/memblock.h>
 #include <linux/dma-contiguous.h>
-#include <linux/mrdump.h>
 #include <linux/sizes.h>
 
 #include <asm/mach-types.h>
@@ -387,14 +386,6 @@ void __init arm_memblock_init(struct meminfo *mi, struct machine_desc *mdesc)
 	if (mdesc->reserve)
 		mdesc->reserve();
 
-#if defined(CONFIG_MTK_RAM_CONSOLE_USING_DRAM)
-    memblock_reserve(CONFIG_MTK_RAM_CONSOLE_DRAM_ADDR, CONFIG_MTK_RAM_CONSOLE_DRAM_SIZE);
-#endif
-
-    mrdump_reserve_memory();
-
-    mrdump_mini_reserve_memory();
-	
 	early_init_fdt_scan_reserved_mem();
 
     //reserve for ion_carveout_heap
diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c
index 54fc6e5..232bc22 100644
--- a/arch/arm/mm/mmu.c
+++ b/arch/arm/mm/mmu.c
@@ -708,7 +708,7 @@ static void __init alloc_init_pmd(pud_t *pud, unsigned long addr,
 }
 
 static void __init alloc_init_pud(pgd_t *pgd, unsigned long addr,
-	unsigned long end, unsigned long phys, const struct mem_type *type,
+	unsigned long end, phys_addr_t phys, const struct mem_type *type,
 	bool force_pages)
 {
 	pud_t *pud = pud_offset(pgd, addr);
diff --git a/arch/arm/mm/proc-v7-3level.S b/arch/arm/mm/proc-v7-3level.S
index b45d73f..29944d7 100644
--- a/arch/arm/mm/proc-v7-3level.S
+++ b/arch/arm/mm/proc-v7-3level.S
@@ -78,8 +78,13 @@ ENTRY(cpu_v7_set_pte_ext)
 	tst	rh, #1 << (57 - 32)		@ L_PTE_NONE
 	bicne	rl, #L_PTE_VALID
 	bne	1f
-	tst	rh, #1 << (55 - 32)		@ L_PTE_DIRTY
-	orreq	rl, #L_PTE_RDONLY
+
+	eor	ip, rh, #1 << (55 - 32)	@ toggle L_PTE_DIRTY in temp reg to
+					@ test for !L_PTE_DIRTY || L_PTE_RDONLY
+	tst	ip, #1 << (55 - 32) | 1 << (58 - 32)
+	orrne	rl, #PTE_AP2
+	biceq	rl, #PTE_AP2
+
 1:	strd	r2, r3, [r0]
 	ALT_SMP(W(nop))
 #ifdef CONFIG_ARM_ERRATA_824069
diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index 93c6fd5..21f090b 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -133,6 +133,25 @@ config ARM_ERRATA_824069
 	  incorrectly marked as dirty. This workaround replaces all cache clean opeartion
 	  to clean & invalidate.
 
+config ARM64_ERRATUM_845719
+	bool "Cortex-A53: 845719: a load might read incorrect data"
+	depends on COMPAT
+	default y
+	help
+	  This option enables the workaround for erratum 845719.
+	  When running a compat (AArch32) userspace on an affected Cortex-A53
+	  part, a load at EL0 from a virtual address that matches the bottom 32
+	  bits of the virtual address used by a recent load at (AArch64) EL1
+	  might return incorrect data.
+
+	  The workaround is to write the contextidr_el1 register on exception
+	  return to a 32-bit task.
+	  Please note that this does not necessarily enable the workaround,
+	  as it depends on the alternative framework, which will only patch
+	  the kernel if an affected CPU is detected.
+
+	  If unsure, say Y.
+
 config KERNEL_MODE_NEON
 	def_bool y
 
@@ -232,6 +251,7 @@ config ARCH_MT6752
 	select ARMV7_COMPAT
         select ARMV7_COMPAT_CPUINFO
 	select ARM_ERRATA_824069
+	select ARM64_ERRATUM_845719
 	help
 	  This enable support for MediaTek MT6752
 
@@ -282,6 +302,7 @@ config ARCH_MT6795
         select ARMV7_COMPAT_CPUINFO
         select MD32_SUPPORT
 	select ARM_ERRATA_824069
+	select ARM64_ERRATUM_845719
 	help
 	  This enable support for MediaTek MT6795
 endmenu
diff --git a/arch/arm64/configs/P70_defconfig b/arch/arm64/configs/P70_defconfig
index 2c36737..cd4603c 100644
--- a/arch/arm64/configs/P70_defconfig
+++ b/arch/arm64/configs/P70_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated file; DO NOT EDIT.
-# Linux/arm64 3.10.61 Kernel Configuration
+# Linux/arm64 3.10.72 Kernel Configuration
 #
 CONFIG_ARM64=y
 CONFIG_ARM_HAS_SG_CHAIN=y
@@ -90,7 +90,7 @@ CONFIG_RCU_FANOUT_LEAF=16
 # CONFIG_RCU_BOOST is not set
 # CONFIG_RCU_NOCB_CPU is not set
 # CONFIG_IKCONFIG is not set
-CONFIG_LOG_BUF_SHIFT=20
+CONFIG_LOG_BUF_SHIFT=21
 CONFIG_GENERIC_SCHED_CLOCK=y
 CONFIG_CGROUPS=y
 # CONFIG_CGROUP_DEBUG is not set
@@ -204,10 +204,13 @@ CONFIG_BLOCK_COMPAT=y
 CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_IOSCHED_BFQ=y
+CONFIG_CGROUP_BFQIO=y
 # CONFIG_DEFAULT_DEADLINE is not set
-CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_CFQ is not set
 # CONFIG_DEFAULT_NOOP is not set
-CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_DEFAULT_BFQ=y
+CONFIG_DEFAULT_IOSCHED="bfq"
 CONFIG_UNINLINE_SPIN_UNLOCK=y
 CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
 CONFIG_MUTEX_SPIN_ON_OWNER=y
@@ -832,6 +835,8 @@ CONFIG_DMA_SHARED_BUFFER=y
 # Bus devices
 #
 # CONFIG_CONNECTOR is not set
+# CONFIG_CPU_IDLE is not set
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
 CONFIG_MTD=y
 # CONFIG_MTD_REDBOOT_PARTS is not set
 # CONFIG_MTD_CMDLINE_PARTS is not set
@@ -988,8 +993,8 @@ CONFIG_ARCH_MTK_PROJECT="P70"
 CONFIG_MTK_CIRQ=y
 CONFIG_MTK_SYSTRACKER=y
 CONFIG_MTK_L2C_SHARE=y
-CONFIG_HAVE_AEE_FEATURE=y
-CONFIG_HAVE_XLOG_FEATURE=y
+# CONFIG_HAVE_AEE_FEATURE is not set
+# CONFIG_HAVE_XLOG_FEATURE is not set
 # CONFIG_FPGA_EARLY_PORTING is not set
 CONFIG_MTK_EMMC_SUPPORT=y
 CONFIG_MTK_NEW_COMBO_EMMC_SUPPORT=y
@@ -1042,23 +1047,17 @@ CONFIG_MTK_HIBERNATION=y
 # CONFIG_CUSTOM_KERNEL_CHARGEPUMP is not set
 # CONFIG_MTK_TC1_FEATURE is not set
 # CONFIG_MTK_TC7_FEATURE is not set
+# CONFIG_MTK_TC1_FM_AT_SUSPEND is not set
 
 #
 # Kernel Configurations
 #
 
 #
-# MTK Cluster MultiProcessor Scheduler
-#
-CONFIG_MTK_SCHED_CMP=y
-CONFIG_MTK_SCHED_CMP_TGS=y
-CONFIG_MTK_SCHED_CMP_TGS_WAKEUP=y
-# CONFIG_MTK_SCHED_CMP_PACK_SMALL_TASK is not set
-
-#
 # Tracer Related
 #
-# CONFIG_MTK_SCHED_TRACERS is not set
+CONFIG_MTK_SCHED_TRACERS=y
+# CONFIG_MTK_FTRACE_DEFAULT_ENABLE is not set
 # CONFIG_MTK_KERNEL_MARKER is not set
 # CONFIG_MT65XX_TRACER is not set
 
@@ -1073,15 +1072,12 @@ CONFIG_MTK_MET_PLF=y
 #
 CONFIG_MTK_MUTATION=y
 CONFIG_MTPROF_CPUTIME=y
-# CONFIG_MTPROF_IRQ_DURATION is not set
 CONFIG_MTK_AEE_FEATURE=y
 CONFIG_MTK_AEE_AED=y
 CONFIG_MTK_AEE_IPANIC=y
 CONFIG_MTK_AEE_POWERKEY_HANG_DETECT=y
 # CONFIG_MTK_AEE_MRDUMP is not set
 # CONFIG_ANDROID_VMEM is not set
-# CONFIG_CPUTIME_SUPPORT is not set
-# CONFIG_CPUTIME_STATS is not set
 CONFIG_MTK_RAM_CONSOLE=y
 # CONFIG_MTK_RAM_CONSOLE_USING_SRAM is not set
 CONFIG_MTK_RAM_CONSOLE_USING_DRAM=y
@@ -1108,13 +1104,23 @@ CONFIG_MTK_ETM=y
 CONFIG_MT_SCHED=y
 CONFIG_MT_LOAD_BALANCE_ENHANCEMENT=y
 # CONFIG_MT_LOAD_BALANCE_PROFILER is not set
-# CONFIG_MT_SCHED_NOTICE is not set
 CONFIG_MTK_COMPAT=y
-CONFIG_MTK_CPU_TOPOLOGY=y
-# CONFIG_MT_PRIO_TRACER is not set
-# CONFIG_MTK_WQ_DEBUG is not set
+# CONFIG_MT_SCHED_INTEROP is not set
 CONFIG_MTK_SCHED_RQAVG_US=y
 CONFIG_MTK_SCHED_RQAVG_KS=y
+# CONFIG_MT_PRIO_TRACER is not set
+# CONFIG_MT_SCHED_TRACE is not set
+# CONFIG_MT_DEBUG_PREEMPT is not set
+
+#
+# MTK Cluster MultiProcessor Scheduler
+#
+CONFIG_MTK_SCHED_CMP=y
+CONFIG_MTK_SCHED_CMP_TGS=y
+CONFIG_MTK_SCHED_CMP_TGS_WAKEUP=y
+# CONFIG_MTK_SCHED_CMP_PACK_SMALL_TASK is not set
+CONFIG_MTK_CPU_TOPOLOGY=y
+# CONFIG_MTK_WQ_DEBUG is not set
 CONFIG_MTK_STORAGE_PID_LOGGER=y
 
 #
@@ -1126,6 +1132,7 @@ CONFIG_GATOR_DRIVER=y
 # CONFIG_MTK_IPV6_TETHER_NDP_MODE is not set
 # CONFIG_MTK_EMMC_SUPPORT_OTP is not set
 CONFIG_MTK_TETHERINGIPV6_SUPPORT=y
+CONFIG_MTK_LEGACY=y
 
 #
 # Drivers Configurations
@@ -1153,7 +1160,7 @@ CONFIG_MTK_MD2_SBP_CUSTOM_VALUE=""
 # CONFIG_MTK_EMCI_DEVICES is not set
 CONFIG_MTK_EXTERNAL_MODEM_SLOT=""
 # CONFIG_MTK_SWITCH_TX_POWER is not set
-#
+CONFIG_MTK_CONN_LTE_IDC_SUPPORT=y
 CONFIG_MTK_FB=y
 CONFIG_MTK_FB_SUPPORT_ASSERTION_LAYER=y
 CONFIG_MTK_DITHERING_SUPPORT=y
@@ -1172,27 +1179,10 @@ CONFIG_MTK_GPS=y
 # CONFIG_NFC_MT6605 is not set
 # CONFIG_NFC_MSR3110 is not set
 CONFIG_MTK_BTIF=y
-CONFIG_MTK_COMBO=y
-# CONFIG_MTK_COMBO_CHIP_MT6620 is not set
-# CONFIG_MTK_COMBO_CHIP_MT6628 is not set
-# CONFIG_MTK_COMBO_CHIP_MT6630 is not set
-# CONFIG_MTK_COMBO_CHIP_CONSYS_6572 is not set
-# CONFIG_MTK_COMBO_CHIP_CONSYS_6582 is not set
-# CONFIG_MTK_COMBO_CHIP_CONSYS_8127 is not set
-CONFIG_MTK_COMBO_CHIP_CONSYS_6752=y
-# CONFIG_MTK_COMBO_CHIP_CONSYS_6592 is not set
-# CONFIG_MTK_COMBO_CHIP_CONSYS_6735 is not set
-CONFIG_MTK_COMBO_CHIP="CONSYS_6752"
 CONFIG_MTK_WAPI_SUPPORT=y
 CONFIG_MTK_PASSPOINT_R1_SUPPORT=y
 # CONFIG_MTK_PASSPOINT_R2_SUPPORT is not set
 CONFIG_MTK_WIFI_MCC_SUPPORT=y
-CONFIG_MTK_COMBO_PLAT_PATH=""
-# CONFIG_MTK_COMBO_COMM is not set
-CONFIG_MTK_COMBO_BT=y
-# CONFIG_MTK_COMBO_ANT is not set
-CONFIG_MTK_COMBO_GPS=y
-CONFIG_MTK_GPS_SUPPORT=y
 CONFIG_MTK_COMBO_WIFI=y
 CONFIG_MTK_BT_SUPPORT=y
 CONFIG_MTK_WFD_SUPPORT=y
@@ -1219,6 +1209,7 @@ CONFIG_MTK_JPEG=y
 CONFIG_MTK_KEYPAD=y
 # CONFIG_KEYBOARD_HID is not set
 CONFIG_MTK_LEDS=y
+CONFIG_LIGHTNESS_MAPPING_VALUE=255
 CONFIG_MTK_MMC=y
 # CONFIG_MTK_SDIOAUTOK_SUPPORT is not set
 
@@ -1240,11 +1231,11 @@ CONFIG_MTK_PMIC_WRAP=y
 # CONFIG_X2_BQ27531_SUPPORT is not set
 # CONFIG_MTK_BQ24250_SUPPORT is not set
 CONFIG_MTK_BQ24261_SUPPORT=y
-CONFIG_MTK_BQ24296_SUPPORT=y
 # CONFIG_MTK_BQ24196_SUPPORT is not set
 # CONFIG_MTK_FAN5405_SUPPORT is not set
 # CONFIG_MTK_FAN5402_SUPPORT is not set
 # CONFIG_MTK_BQ24158_SUPPORT is not set
+CONFIG_MTK_BQ24296_SUPPORT=y
 # CONFIG_MTK_BQ27541_SUPPORT is not set
 # CONFIG_MTK_NCP1851_SUPPORT is not set
 # CONFIG_MTK_NCP1854_SUPPORT is not set
@@ -1266,10 +1257,12 @@ CONFIG_MTK_SIM2=y
 # CONFIG_MTK_APM_16D is not set
 # CONFIG_MTK_EPL2182 is not set
 # CONFIG_MTK_EPL2182_NEW is not set
+# CONFIG_MTK_STK3X1X is not set
 # CONFIG_MTK_STK3X1X_NEW is not set
 # CONFIG_MTK_CM36652_NEW is not set
 # CONFIG_MTK_APDS9930 is not set
 # CONFIG_MTK_CM3232_NEW is not set
+# CONFIG_MTK_RPR410 is not set
 # CONFIG_MTK_APDS9930_NEW is not set
 # CONFIG_MTK_KXTJ2_1009 is not set
 # CONFIG_MTK_KXTIK1004 is not set
@@ -1277,12 +1270,12 @@ CONFIG_MTK_SIM2=y
 # CONFIG_MTK_BMA222E is not set
 # CONFIG_MTK_MC3410_NEW is not set
 # CONFIG_MTK_MPU6050G_NEW is not set
+# CONFIG_MTK_MPU6050G is not set
 # CONFIG_MTK_BMA250 is not set
 # CONFIG_MTK_MPU6515A is not set
 # CONFIG_MTK_MPU60X0 is not set
 # zormax
 CONFIG_MTK_STK3310=y
-# CONFIG_MTK_STK3X1X is not set
 CONFIG_MTK_BMA222E_NEW=y
 CONFIG_MTK_KXTJ2_1009_NEW=y
 
@@ -1292,6 +1285,7 @@ CONFIG_MTK_KXTJ2_1009_NEW=y
 # CONFIG_MTK_MPU3000 is not set
 # CONFIG_MTK_MPU3000_NEW is not set
 # CONFIG_MTK_MPU6050GY_NEW is not set
+# CONFIG_MTK_MPU6050GY is not set
 # CONFIG_MTK_ITG1010_NEW is not set
 # CONFIG_MTK_MPU6515G is not set
 # CONFIG_MTK_MPU3050C_NEW is not set
@@ -1303,11 +1297,16 @@ CONFIG_MTK_KXTJ2_1009_NEW=y
 # CONFIG_MTK_HSCDTD006 is not set
 # CONFIG_MTK_BMM050 is not set
 # CONFIG_MTK_BMM050_NEW is not set
+# CONFIG_MTK_BMM056_NEW is not set
 # CONFIG_MTK_MMC3416X is not set
 # CONFIG_MTK_BMA050 is not set
 # CONFIG_MTK_BMA050_NEW is not set
+# CONFIG_MTK_BMA056 is not set
+# CONFIG_MTK_BMA255_SDO0 is not set
+# CONFIG_MTK_BMA255_SDO1 is not set
 # CONFIG_MTK_S2200 is not set
 # CONFIG_MTK_YAS532 is not set
+# CONFIG_MTK_YAS532_NEW is not set
 # CONFIG_MTK_BMP180_NEW is not set
 CONFIG_MTK_TOUCHPANEL=y
 # CONFIG_MTK_S7020 is not set
@@ -1318,15 +1317,23 @@ CONFIG_MTK_USB_GADGET=y
 # CONFIG_MU3_PHY is not set
 # CONFIG_MTK_XHCI is not set
 # CONFIG_MTK_OTG_PMIC_BOOST_5V is not set
+# CONFIG_MTK_OTG_OC_DETECTOR is not set
 # CONFIG_MTK_TEST_XHCI is not set
 # CONFIG_USBIF_COMPLIANCE is not set
 # CONFIG_MTK_S3320 is not set
 # CONFIG_MTK_S3320_47 is not set
+# CONFIG_MTK_S3320_50 is not set
 # CONFIG_LEDS_LM3632 is not set
 # CONFIG_LEDS_LM3639 is not set
 # CONFIG_LEDS_RT8542 is not set
 CONFIG_MTK_VIBRATOR=y
 CONFIG_MTK_WD_KICKER=y
+# CONFIG_KICK_SPM_WDT is not set
+# CONFIG_ONEKEY_REBOOT_NORMAL_MODE is not set
+# CONFIG_TWOKEY_REBOOT_NORMAL_MODE is not set
+# CONFIG_ONEKEY_REBOOT_OTHER_MODE is not set
+# CONFIG_TWOKEY_REBOOT_OTHER_MODE is not set
+CONFIG_KPD_PMIC_LPRST_TD=1
 # CONFIG_MT592X_SDIO_CLNT is not set
 CONFIG_USB_MTK_ACM_TEMP=y
 CONFIG_USB_MTK_HDRC=y
@@ -1345,6 +1352,7 @@ CONFIG_ION_MTK=y
 # CONFIG_ION_MTK_FB_HEAP_SUPPORT is not set
 CONFIG_MMPROFILE=y
 # CONFIG_MTK_STAGING is not set
+# CONFIG_MTKPASR is not set
 # CONFIG_PWR_LOSS_MTK_TEST is not set
 CONFIG_MTK_EMMC_CACHE=y
 CONFIG_MTK_GPU_SUPPORT=y
@@ -1382,8 +1390,8 @@ CONFIG_MTK_LENS_DUMMYLENS_SUPPORT=y
 # CONFIG_MTK_LENS_BU6429AF_SUPPORT is not set
 # CONFIG_MTK_LENS_BU64745GWZAF_SUPPORT is not set
 # CONFIG_MTK_LENS_DW9718AF_SUPPORT is not set
-CONFIG_MTK_LENS_DW9714AF_SUPPORT=y
 # CONFIG_MTK_LENS_DW9714A_SUPPORT is not set
+CONFIG_MTK_LENS_DW9714AF_SUPPORT=y
 # CONFIG_MTK_LENS_LC898122AF_SUPPORT is not set
 # CONFIG_MTK_LENS_LC898212AF_SUPPORT is not set
 # CONFIG_MTK_LENS_FM50AF_SUPPORT is not set
@@ -1394,6 +1402,8 @@ CONFIG_MTK_LENS_DW9714AF_SUPPORT=y
 # CONFIG_MTK_LENS_GAF002AF_SUPPORT is not set
 # CONFIG_MTK_LENS_GAF008AF_SUPPORT is not set
 # CONFIG_MTK_EXTMEM is not set
+# CONFIG_MTK_INHOUSE_GPU is not set
+# CONFIG_SW_SYNC64 is not set
 CONFIG_MTK_CPU_STRESS=y
 CONFIG_MTK_LASTPC=y
 CONFIG_MTK_FMRADIO=y
@@ -1406,11 +1416,11 @@ CONFIG_MTK_LENS=y
 CONFIG_MTK_IMGSENSOR=y
 # CONFIG_MTK_CAM_CAL is not set
 CONFIG_MTK_FLASHLIGHT=y
-CONFIG_MTK_DUM_CHAR=y
+# CONFIG_MTK_DUM_CHAR is not set
 CONFIG_MTK_SYSENV=y
 CONFIG_MTK_SMI=y
 CONFIG_MTK_BTCVSD=y
-CONFIG_MTK_SOUND_DRV=y
+# CONFIG_MTK_SOUND_DRV is not set
 CONFIG_MTK_POWER_GS=y
 # CONFIG_MTK_VIDEO is not set
 # CONFIG_MTK_MRDUMP is not set
@@ -1419,6 +1429,25 @@ CONFIG_MTK_POWER_GS=y
 CONFIG_MTK_EMI_MPU=y
 CONFIG_MTK_EMI_BWL=y
 # CONFIG_MTK_DBG_DUMP is not set
+CONFIG_MTK_COMBO=y
+# CONFIG_MTK_COMBO_CHIP_MT6620 is not set
+# CONFIG_MTK_COMBO_CHIP_MT6628 is not set
+# CONFIG_MTK_COMBO_CHIP_MT6630 is not set
+# CONFIG_MTK_COMBO_CHIP_CONSYS_6572 is not set
+# CONFIG_MTK_COMBO_CHIP_CONSYS_6582 is not set
+# CONFIG_MTK_COMBO_CHIP_CONSYS_8127 is not set
+CONFIG_MTK_COMBO_CHIP_CONSYS_6752=y
+# CONFIG_MTK_COMBO_CHIP_CONSYS_6592 is not set
+# CONFIG_MTK_COMBO_CHIP_CONSYS_8163 is not set
+# CONFIG_MTK_COMBO_CHIP_CONSYS_6735 is not set
+# CONFIG_MTK_COMBO_CHIP_CONSYS_6580 is not set
+CONFIG_MTK_COMBO_CHIP="CONSYS_6752"
+CONFIG_MTK_COMBO_PLAT_PATH=""
+# CONFIG_MTK_COMBO_COMM is not set
+CONFIG_MTK_COMBO_BT=y
+# CONFIG_MTK_COMBO_ANT is not set
+CONFIG_MTK_COMBO_GPS=y
+CONFIG_MTK_GPS_SUPPORT=y
 
 #
 # SCSI device support
@@ -1562,10 +1591,7 @@ CONFIG_INPUT=y
 #
 # Userland interfaces
 #
-CONFIG_INPUT_MOUSEDEV=y
-CONFIG_INPUT_MOUSEDEV_PSAUX=y
-CONFIG_INPUT_MOUSEDEV_SCREEN_X=1920
-CONFIG_INPUT_MOUSEDEV_SCREEN_Y=1080
+# CONFIG_INPUT_MOUSEDEV is not set
 # CONFIG_INPUT_JOYDEV is not set
 CONFIG_INPUT_EVDEV=y
 # CONFIG_INPUT_EVBUG is not set
@@ -1575,37 +1601,8 @@ CONFIG_INPUT_EVDEV=y
 #
 # Input Device Drivers
 #
-CONFIG_INPUT_KEYBOARD=y
-# CONFIG_KEYBOARD_ADP5588 is not set
-# CONFIG_KEYBOARD_ADP5589 is not set
-# CONFIG_KEYBOARD_ATKBD is not set
-# CONFIG_KEYBOARD_QT1070 is not set
-# CONFIG_KEYBOARD_QT2160 is not set
-# CONFIG_KEYBOARD_LKKBD is not set
-# CONFIG_KEYBOARD_GPIO is not set
-# CONFIG_KEYBOARD_TCA6416 is not set
-# CONFIG_KEYBOARD_TCA8418 is not set
-# CONFIG_KEYBOARD_MATRIX is not set
-# CONFIG_KEYBOARD_LM8323 is not set
-# CONFIG_KEYBOARD_LM8333 is not set
-# CONFIG_KEYBOARD_MAX7359 is not set
-# CONFIG_KEYBOARD_MCS is not set
-# CONFIG_KEYBOARD_MPR121 is not set
-# CONFIG_KEYBOARD_NEWTON is not set
-# CONFIG_KEYBOARD_OPENCORES is not set
-# CONFIG_KEYBOARD_STOWAWAY is not set
-# CONFIG_KEYBOARD_SUNKBD is not set
-# CONFIG_KEYBOARD_XTKBD is not set
-CONFIG_INPUT_MOUSE=y
-# CONFIG_MOUSE_PS2 is not set
-# CONFIG_MOUSE_SERIAL is not set
-# CONFIG_MOUSE_APPLETOUCH is not set
-# CONFIG_MOUSE_BCM5974 is not set
-# CONFIG_MOUSE_CYAPA is not set
-# CONFIG_MOUSE_VSXXXAA is not set
-# CONFIG_MOUSE_GPIO is not set
-# CONFIG_MOUSE_SYNAPTICS_I2C is not set
-# CONFIG_MOUSE_SYNAPTICS_USB is not set
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
 # CONFIG_INPUT_JOYSTICK is not set
 # CONFIG_INPUT_TABLET is not set
 CONFIG_INPUT_TOUCHSCREEN=y
@@ -1640,8 +1637,11 @@ CONFIG_TOUCHSCREEN_MTK=y
 # CONFIG_TOUCHSCREEN_MTK_GT9XX_AIO is not set
 # CONFIG_TOUCHSCREEN_MTK_GT9XX_HOTKNOT_SCP is not set
 # CONFIG_TOUCHSCREEN_MTK_GT9XX_HOTKNOT is not set
+# CONFIG_TOUCHSCREEN_MTK_GT9XX_HOTKNOT_WEAR is not set
 # CONFIG_TOUCHSCREEN_MTK_GT1151 is not set
+# CONFIG_TOUCHSCREEN_MTK_GT910 is not set
 # CONFIG_TOUCHSCREEN_MTK_MAX1187X is not set
+# CONFIG_TOUCHSCREEN_MTK_GT9XX_HOTKNOT_FPGA is not set
 # CONFIG_TOUCHSCREEN_MTK_GT9XXTB_HOTKNOT is not set
 # CONFIG_TOUCHSCREEN_MTK_GT818B_FPGA is not set
 # CONFIG_TOUCHSCREEN_S7020 is not set
@@ -1655,6 +1655,7 @@ CONFIG_TOUCHSCREEN_MTK=y
 CONFIG_MTK_FT5436I=y
 # CONFIG_MTK_FT5406_82 is not set
 # CONFIG_MTK_FT5206 is not set
+# CONFIG_MTK_FT5X0X is not set
 # CONFIG_MTK_MMS134 is not set
 # CONFIG_MTK_MMS128 is not set
 # CONFIG_MTK_MIT200 is not set
@@ -1682,7 +1683,7 @@ CONFIG_INPUT_MISC=y
 # CONFIG_INPUT_GP2A is not set
 # CONFIG_INPUT_GPIO_TILT_POLLED is not set
 # CONFIG_INPUT_ATI_REMOTE2 is not set
-CONFIG_INPUT_KEYCHORD=y
+# CONFIG_INPUT_KEYCHORD is not set
 # CONFIG_INPUT_KEYSPAN_REMOTE is not set
 # CONFIG_INPUT_KXTJ9 is not set
 # CONFIG_INPUT_POWERMATE is not set
@@ -2044,7 +2045,11 @@ CONFIG_FB_TILEBLITTING=y
 # Console display driver support
 #
 CONFIG_FONT_8x16=y
-# CONFIG_LOGO is not set
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_FB_SSD1307 is not set
 CONFIG_SOUND=y
 CONFIG_SOUND_OSS_CORE=y
 CONFIG_SOUND_OSS_CORE_PRECLAIM=y
@@ -2095,6 +2100,8 @@ CONFIG_SND_SOC=y
 # CONFIG_MT_SND_SOC_V1 is not set
 CONFIG_MT_SND_SOC_V2=y
 # CONFIG_MT_SND_SOC_V3 is not set
+# CONFIG_MT_SND_SOC_6580 is not set
+# CONFIG_MT_SND_SOC_8163 is not set
 CONFIG_MTK_SPEAKER=y
 # CONFIG_MTK_NXP_TFA9890 is not set
 CONFIG_SND_SOC_I2C_AND_SPI=y
@@ -2227,8 +2234,8 @@ CONFIG_USB_DEFAULT_PERSIST=y
 #
 # USB Device Class drivers
 #
-CONFIG_USB_ACM=y
-CONFIG_USB_PRINTER=y
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
 # CONFIG_USB_WDM is not set
 # CONFIG_USB_TMC is not set
 
@@ -2357,6 +2364,7 @@ CONFIG_MMC_BLOCK_BOUNCE=y
 # CONFIG_MMC_BLOCK_DEFERRED_RESUME is not set
 # CONFIG_SDIO_UART is not set
 # CONFIG_MMC_TEST is not set
+# CONFIG_MMC_FFU is not set
 
 #
 # MMC/SD/SDIO Host Controller Drivers
@@ -2536,7 +2544,6 @@ CONFIG_ZRAM_DEBUG=y
 # Android
 #
 CONFIG_ANDROID=y
-CONFIG_ANDROID_BINDER_IPC=y
 CONFIG_ASHMEM=y
 CONFIG_ANDROID_LOGGER=y
 CONFIG_ANDROID_TIMED_OUTPUT=y
@@ -2597,6 +2604,11 @@ CONFIG_MTK_EIC=y
 # CONFIG_RESET_CONTROLLER is not set
 
 #
+# Android
+#
+CONFIG_ANDROID_BINDER_IPC=y
+
+#
 # File systems
 #
 # CONFIG_EXT2_FS is not set
@@ -2661,7 +2673,16 @@ CONFIG_MSDOS_FS=y
 CONFIG_VFAT_FS=y
 CONFIG_FAT_DEFAULT_CODEPAGE=437
 CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
-# CONFIG_NTFS_FS is not set
+CONFIG_NTFS_FS=y
+# CONFIG_NTFS_DEBUG is not set
+CONFIG_NTFS_RW=y
+CONFIG_EXFAT_FS=y
+CONFIG_EXFAT_DISCARD=y
+# CONFIG_EXFAT_DELAYED_SYNC is not set
+# CONFIG_EXFAT_KERNEL_DEBUG is not set
+# CONFIG_EXFAT_DEBUG_MSG is not set
+CONFIG_EXFAT_DEFAULT_CODEPAGE=437
+CONFIG_EXFAT_DEFAULT_IOCHARSET="utf8"
 
 #
 # Pseudo filesystems
@@ -2687,7 +2708,11 @@ CONFIG_MISC_FILESYSTEMS=y
 # CONFIG_JFFS2_FS is not set
 # CONFIG_LOGFS is not set
 # CONFIG_CRAMFS is not set
-# CONFIG_SQUASHFS is not set
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_LZ4=y
+CONFIG_SQUASHFS_FILE_DIRECT=y
+CONFIG_SQUASHFS_DECOMP_MULTI_PERCPU=y
+CONFIG_SQUASHFS_XATTR=y
 # CONFIG_VXFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_OMFS_FS is not set
@@ -2703,7 +2728,12 @@ CONFIG_NETWORK_FILESYSTEMS=y
 # CONFIG_NFS_FS is not set
 # CONFIG_NFSD is not set
 # CONFIG_CEPH_FS is not set
-# CONFIG_CIFS is not set
+CONFIG_CIFS=y
+# CONFIG_CIFS_STATS is not set
+# CONFIG_CIFS_WEAK_PW_HASH is not set
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CIFS_DEBUG2 is not set
+# CONFIG_CIFS_EXPERIMENTAL is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
@@ -2759,6 +2789,7 @@ CONFIG_NLS_ISO8859_1=y
 # CONFIG_NLS_MAC_TURKISH is not set
 CONFIG_NLS_UTF8=y
 # CONFIG_DLM is not set
+# CONFIG_RAWFS_FS is not set
 
 #
 # Kernel hacking
@@ -3006,6 +3037,7 @@ CONFIG_CRYPTO_TWOFISH_COMMON=y
 CONFIG_CRYPTO_DEFLATE=y
 # CONFIG_CRYPTO_ZLIB is not set
 CONFIG_CRYPTO_LZO=y
+# CONFIG_CRYPTO_LZ4K is not set
 
 #
 # Random Number Generation
@@ -3067,4 +3099,3 @@ CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
 # CONFIG_AVERAGE is not set
 # CONFIG_CORDIC is not set
 # CONFIG_DDR is not set
-# CONFIG_MTK_OTG_OC_DETECTOR is not set
diff --git a/arch/arm64/include/asm/cputype.h b/arch/arm64/include/asm/cputype.h
index 3c1f295..65531f1 100644
--- a/arch/arm64/include/asm/cputype.h
+++ b/arch/arm64/include/asm/cputype.h
@@ -85,6 +85,8 @@ static inline u32 __attribute_const__ read_cpuid_cachetype(void)
 	return read_cpuid(CTR_EL0);
 }
 
+void cpuinfo_store_cpu(void);
+
 #endif /* __ASSEMBLY__ */
 
 #endif
diff --git a/arch/arm64/kernel/entry.S b/arch/arm64/kernel/entry.S
index bbb6564..e9fa682 100644
--- a/arch/arm64/kernel/entry.S
+++ b/arch/arm64/kernel/entry.S
@@ -140,6 +140,16 @@
 	msr	spsr_el1, x22
 	.if	\el == 0
 	msr	sp_el0, x23
+#ifdef CONFIG_ARM64_ERRATUM_845719
+	tbz 	x22, #4, 1f
+#ifdef CONFIG_PID_IN_CONTEXTIDR
+	mrs	x29, contextidr_el1
+	msr	contextidr_el1, x29
+#else
+	msr	contextidr_el1, xzr
+#endif
+1:
+#endif
 	.endif
 	pop	x10, x11
 	pop	x12, x13
@@ -188,7 +198,16 @@
 	eret					// return to kernel
 	// could not run here
 
-1:	add	sp, sp, #S_X29-S_X15
+1:
+#ifdef CONFIG_ARM64_ERRATUM_845719
+#ifdef CONFIG_PID_IN_CONTEXTIDR
+	mrs     x29, contextidr_el1
+	msr     contextidr_el1, x29
+#else
+	msr     contextidr_el1, xzr
+#endif
+#endif
+	add	sp, sp, #S_X29-S_X15
 	ldr	lr, [sp], #S_FRAME_SIZE - S_LR	// load LR and restore SP
 	eret					// return to kernel
 	.endm
diff --git a/arch/arm64/kernel/setup.c b/arch/arm64/kernel/setup.c
index 268f504..a9507c5 100644
--- a/arch/arm64/kernel/setup.c
+++ b/arch/arm64/kernel/setup.c
@@ -41,6 +41,7 @@
 #include <linux/memblock.h>
 #include <linux/of_fdt.h>
 #include <linux/of_platform.h>
+#include <linux/personality.h>
 
 #include <asm/cputype.h>
 #include <asm/elf.h>
@@ -109,6 +110,19 @@ void __init early_print(const char *str, ...)
 	printk("%s", buf);
 }
 
+struct cpuinfo_arm64 {
+	struct cpu	cpu;
+	u32		reg_midr;
+};
+
+static DEFINE_PER_CPU(struct cpuinfo_arm64, cpu_data);
+
+void cpuinfo_store_cpu(void)
+{
+	struct cpuinfo_arm64 *info = this_cpu_ptr(&cpu_data);
+	info->reg_midr = read_cpuid_id();
+}
+
 void __init smp_setup_processor_id(void)
 {
 	/*
@@ -198,6 +212,11 @@ static void __init setup_processor(void)
 	struct cpu_info *cpu_info;
 	u64 features, block;
 
+	/*
+	 * locate processor in the list of supported processor
+	 * types.  The linker builds this table for us from the
+	 * entries in arch/arm/mm/proc.S
+	 */
 	cpu_info = lookup_processor_type(read_cpuid_id());
 	if (!cpu_info) {
 		printk("CPU configuration botched (ID %08x), unable to continue.\n",
@@ -250,6 +269,8 @@ static void __init setup_machine_fdt(phys_addr_t dt_phys)
 	struct boot_param_header *devtree;
 	unsigned long dt_root;
 
+	cpuinfo_store_cpu();
+
 	/* Check we have a non-NULL DT pointer */
 	if (!dt_phys) {
 		early_print("\n"
@@ -405,7 +426,6 @@ void __init setup_arch(char **cmdline_p)
 	conswitchp = &dummy_con;
 #endif
 #endif
-
 }
 
 static int __init arm64_device_init(void)
@@ -416,14 +436,12 @@ static int __init arm64_device_init(void)
 }
 arch_initcall_sync(arm64_device_init);
 
-static DEFINE_PER_CPU(struct cpu, cpu_data);
-
 static int __init topology_init(void)
 {
 	int i;
 
 	for_each_possible_cpu(i) {
-		struct cpu *cpu = &per_cpu(cpu_data, i);
+		struct cpu *cpu = &per_cpu(cpu_data.cpu, i);
 		cpu->hotpluggable = 1;
 		register_cpu(cpu, i);
 	}
@@ -444,14 +462,44 @@ static const char *hwcap_str[] = {
 	NULL
 };
 
+#ifdef CONFIG_COMPAT
+static const char *compat_hwcap_str[] = {
+	"swp",
+	"half",
+	"thumb",
+	"26bit",
+	"fastmult",
+	"fpa",
+	"vfp",
+	"edsp",
+	"java",
+	"iwmmxt",
+	"crunch",
+	"thumbee",
+	"neon",
+	"vfpv3",
+	"vfpv3d16",
+	"tls",
+	"vfpv4",
+	"idiva",
+	"idivt",
+	"vfpd32",
+	"lpae",
+	"evtstrm"
+};
+#endif /* CONFIG_COMPAT */
+
 static int c_show(struct seq_file *m, void *v)
 {
-	int i;
+	int i, j;
 
 	seq_printf(m, "Processor\t: %s rev %d (%s)\n",
 		   cpu_name, read_cpuid_id() & 15, ELF_PLATFORM);
 
 	for_each_online_cpu(i) {
+		struct cpuinfo_arm64 *cpuinfo = &per_cpu(cpu_data, i);
+		u32 midr = cpuinfo->reg_midr;
+
 		/*
 		 * glibc reads /proc/cpuinfo to determine the number of
 		 * online processors, looking for lines beginning with
@@ -460,26 +508,39 @@ static int c_show(struct seq_file *m, void *v)
 #ifdef CONFIG_SMP
 		seq_printf(m, "processor\t: %d\n", i);
 #endif
-		seq_printf(m, "BogoMIPS\t: %lu.%02lu\n\n",
+		seq_printf(m, "BogoMIPS\t: %lu.%02lu\n",
 			   loops_per_jiffy / (500000UL/HZ),
 			   loops_per_jiffy / (5000UL/HZ) % 100);
-	}
-
-	/* dump out the processor features */
-	seq_puts(m, "Features\t: ");
 
-	for (i = 0; hwcap_str[i]; i++)
-		if (elf_hwcap & (1 << i))
-			seq_printf(m, "%s ", hwcap_str[i]);
+		/*
+		 * Dump out the common processor features in a single line.
+		 * Userspace should read the hwcaps with getauxval(AT_HWCAP)
+		 * rather than attempting to parse this, but there's a body of
+		 * software which does already (at least for 32-bit).
+		 */
+		seq_puts(m, "Features\t:");
+		if (personality(current->personality) == PER_LINUX32) {
+#ifdef CONFIG_COMPAT
+			for (j = 0; compat_hwcap_str[j]; j++)
+				if (COMPAT_ELF_HWCAP & (1 << j))
+					seq_printf(m, " %s", compat_hwcap_str[j]);
+#endif /* CONFIG_COMPAT */
+		} else {
+			for (j = 0; hwcap_str[j]; j++)
+				if (elf_hwcap & (1 << j))
+					seq_printf(m, " %s", hwcap_str[j]);
+		}
+		
 #ifdef CONFIG_ARMV7_COMPAT_CPUINFO
 	if (is_compat_task()) {
 		/* Print out the non-optional ARMv8 HW capabilities */
-		seq_printf(m, "wp half thumb fastmult vfp edsp neon vfpv3 tlsi ");
+		seq_printf(m, " wp half thumb fastmult vfp edsp neon vfpv3 tlsi ");
 		seq_printf(m, "vfpv4 idiva idivt ");
 	}
 #endif
+	seq_puts(m, "\n");
 
-	seq_printf(m, "\nCPU implementer\t: 0x%02x\n", read_cpuid_id() >> 24);
+	seq_printf(m, "CPU implementer\t: 0x%02x\n", read_cpuid_id() >> 24);
 	seq_printf(m, "CPU architecture: %s\n",
 #if IS_ENABLED(CONFIG_ARMV7_COMPAT_CPUINFO)
 			is_compat_task() ? "8" :
@@ -488,7 +549,7 @@ static int c_show(struct seq_file *m, void *v)
 	seq_printf(m, "CPU variant\t: 0x%x\n", (read_cpuid_id() >> 20) & 15);
 	seq_printf(m, "CPU part\t: 0x%03x\n", (read_cpuid_id() >> 4) & 0xfff);
 	seq_printf(m, "CPU revision\t: %d\n", read_cpuid_id() & 15);
-
+    }
 	seq_puts(m, "\n");
 
 	seq_printf(m, "Hardware\t: %s\n", machine_name);
diff --git a/arch/arm64/kernel/signal32.c b/arch/arm64/kernel/signal32.c
index e1b8b9f..36db987 100644
--- a/arch/arm64/kernel/signal32.c
+++ b/arch/arm64/kernel/signal32.c
@@ -179,8 +179,7 @@ int copy_siginfo_to_user32(compat_siginfo_t __user *to, siginfo_t *from)
 	case __SI_TIMER:
 		 err |= __put_user(from->si_tid, &to->si_tid);
 		 err |= __put_user(from->si_overrun, &to->si_overrun);
-		 err |= __put_user((compat_uptr_t)(unsigned long)from->si_ptr,
-				   &to->si_ptr);
+		 err |= __put_user(from->si_int, &to->si_int);
 		break;
 	case __SI_POLL:
 		err |= __put_user(from->si_band, &to->si_band);
@@ -209,7 +208,7 @@ int copy_siginfo_to_user32(compat_siginfo_t __user *to, siginfo_t *from)
 	case __SI_MESGQ: /* But this is */
 		err |= __put_user(from->si_pid, &to->si_pid);
 		err |= __put_user(from->si_uid, &to->si_uid);
-		err |= __put_user((compat_uptr_t)(unsigned long)from->si_ptr, &to->si_ptr);
+		err |= __put_user(from->si_int, &to->si_int);
 		break;
 #ifdef __ARCH_SIGSYS
 	case __SI_SYS:
diff --git a/arch/arm64/kernel/smp.c b/arch/arm64/kernel/smp.c
index f6d41cc..ad2cf06 100644
--- a/arch/arm64/kernel/smp.c
+++ b/arch/arm64/kernel/smp.c
@@ -111,17 +111,17 @@ int __cpuinit __cpu_up(unsigned int cpu, struct task_struct *idle)
 					    msecs_to_jiffies(1000));
 
 		if (!cpu_online(cpu)) {
-			pr_crit("CPU%u: failed to come online\n", cpu);
-            #if 1
+                   pr_crit("CPU%u: failed to come online\n", cpu);
+                #if 1
 	        pr_crit("Trigger WDT RESET\n");
-            res = get_wd_api(&wd_api);
-            if(res) 
-            {
-              pr_crit("get wd api error !!\n");
-            }else {
-              wd_api -> wd_sw_reset(3);  //=> this action will ask system to reboot
-            }
-            #endif
+                res = get_wd_api(&wd_api);
+                if(res) 
+                {
+                  pr_crit("get wd api error !!\n");
+                }else {
+                  wd_api -> wd_sw_reset(3);  //=> this action will ask system to reboot
+                }
+                #endif
                         
             ret = -EIO;
 	        }
@@ -182,6 +182,11 @@ asmlinkage void __cpuinit secondary_start_kernel(void)
     aee_rr_rec_hoplug(cpu, 8, 0);
 
 	/*
+	 * Log the CPU info before it is marked online and might get read.
+	 */
+	cpuinfo_store_cpu();
+
+	/*
 	 * OK, now it's safe to let the boot CPU continue.  Wait for
 	 * the CPU migration code to notice that the CPU is online
 	 * before we continue.
diff --git a/arch/metag/include/asm/processor.h b/arch/metag/include/asm/processor.h
index 579e3d9..b88e9cb 100644
--- a/arch/metag/include/asm/processor.h
+++ b/arch/metag/include/asm/processor.h
@@ -149,8 +149,8 @@ extern void exit_thread(void);
 
 unsigned long get_wchan(struct task_struct *p);
 
-#define	KSTK_EIP(tsk)	((tsk)->thread.kernel_context->CurrPC)
-#define	KSTK_ESP(tsk)	((tsk)->thread.kernel_context->AX[0].U0)
+#define	KSTK_EIP(tsk)	(task_pt_regs(tsk)->ctx.CurrPC)
+#define	KSTK_ESP(tsk)	(task_pt_regs(tsk)->ctx.AX[0].U0)
 
 #define user_stack_pointer(regs)        ((regs)->ctx.AX[0].U0)
 
diff --git a/arch/mips/kernel/irq_cpu.c b/arch/mips/kernel/irq_cpu.c
index 72ef2d2..ab941a3 100644
--- a/arch/mips/kernel/irq_cpu.c
+++ b/arch/mips/kernel/irq_cpu.c
@@ -56,6 +56,8 @@ static struct irq_chip mips_cpu_irq_controller = {
 	.irq_mask_ack	= mask_mips_irq,
 	.irq_unmask	= unmask_mips_irq,
 	.irq_eoi	= unmask_mips_irq,
+	.irq_disable	= mask_mips_irq,
+	.irq_enable	= unmask_mips_irq,
 };
 
 /*
@@ -92,6 +94,8 @@ static struct irq_chip mips_mt_cpu_irq_controller = {
 	.irq_mask_ack	= mips_mt_cpu_irq_ack,
 	.irq_unmask	= unmask_mips_irq,
 	.irq_eoi	= unmask_mips_irq,
+	.irq_disable	= mask_mips_irq,
+	.irq_enable	= unmask_mips_irq,
 };
 
 void __init mips_cpu_irq_init(void)
diff --git a/arch/mips/kernel/mips_ksyms.c b/arch/mips/kernel/mips_ksyms.c
index 6e58e97..cedeb56 100644
--- a/arch/mips/kernel/mips_ksyms.c
+++ b/arch/mips/kernel/mips_ksyms.c
@@ -14,6 +14,7 @@
 #include <linux/mm.h>
 #include <asm/uaccess.h>
 #include <asm/ftrace.h>
+#include <asm/fpu.h>
 
 extern void *__bzero(void *__s, size_t __count);
 extern long __strncpy_from_user_nocheck_asm(char *__to,
@@ -26,6 +27,13 @@ extern long __strnlen_user_nocheck_asm(const char *s);
 extern long __strnlen_user_asm(const char *s);
 
 /*
+ * Core architecture code
+ */
+#ifdef CONFIG_CPU_R4K_FPU
+EXPORT_SYMBOL_GPL(_save_fp);
+#endif
+
+/*
  * String functions
  */
 EXPORT_SYMBOL(memset);
diff --git a/arch/mips/kernel/smp.c b/arch/mips/kernel/smp.c
index 6e7862a..caeec21 100644
--- a/arch/mips/kernel/smp.c
+++ b/arch/mips/kernel/smp.c
@@ -109,10 +109,10 @@ asmlinkage __cpuinit void start_secondary(void)
 	else
 #endif /* CONFIG_MIPS_MT_SMTC */
 	cpu_probe();
-	cpu_report();
 	per_cpu_trap_init(false);
 	mips_clockevent_init();
 	mp_ops->init_secondary();
+	cpu_report();
 
 	/*
 	 * XXX parity protection should be folded in here when it's converted
diff --git a/arch/mips/kvm/kvm_locore.S b/arch/mips/kvm/kvm_locore.S
index dca2aa6..920b632 100644
--- a/arch/mips/kvm/kvm_locore.S
+++ b/arch/mips/kvm/kvm_locore.S
@@ -431,7 +431,7 @@ __kvm_mips_return_to_guest:
     /* Setup status register for running guest in UM */
     .set at
     or     v1, v1, (ST0_EXL | KSU_USER | ST0_IE)
-    and     v1, v1, ~ST0_CU0
+    and     v1, v1, ~(ST0_CU0 | ST0_MX)
     .set noat
     mtc0    v1, CP0_STATUS
     ehb
diff --git a/arch/mips/kvm/kvm_mips.c b/arch/mips/kvm/kvm_mips.c
index 2c7b3ad..843ec38 100644
--- a/arch/mips/kvm/kvm_mips.c
+++ b/arch/mips/kvm/kvm_mips.c
@@ -15,6 +15,7 @@
 #include <linux/vmalloc.h>
 #include <linux/fs.h>
 #include <linux/bootmem.h>
+#include <asm/fpu.h>
 #include <asm/page.h>
 #include <asm/cacheflush.h>
 #include <asm/mmu_context.h>
@@ -413,11 +414,13 @@ int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *run)
 		vcpu->mmio_needed = 0;
 	}
 
+	lose_fpu(1);
+
+	local_irq_disable();
 	/* Check if we have any exceptions/interrupts pending */
 	kvm_mips_deliver_interrupts(vcpu,
 				    kvm_read_c0_guest_cause(vcpu->arch.cop0));
 
-	local_irq_disable();
 	kvm_guest_enter();
 
 	r = __kvm_mips_vcpu_run(run, vcpu);
@@ -1017,9 +1020,6 @@ void kvm_mips_set_c0_status(void)
 {
 	uint32_t status = read_c0_status();
 
-	if (cpu_has_fpu)
-		status |= (ST0_CU1);
-
 	if (cpu_has_dsp)
 		status |= (ST0_MX);
 
diff --git a/arch/mips/kvm/trace.h b/arch/mips/kvm/trace.h
index bc9e0f4..e51621e 100644
--- a/arch/mips/kvm/trace.h
+++ b/arch/mips/kvm/trace.h
@@ -26,18 +26,18 @@ TRACE_EVENT(kvm_exit,
 	    TP_PROTO(struct kvm_vcpu *vcpu, unsigned int reason),
 	    TP_ARGS(vcpu, reason),
 	    TP_STRUCT__entry(
-			__field(struct kvm_vcpu *, vcpu)
+			__field(unsigned long, pc)
 			__field(unsigned int, reason)
 	    ),
 
 	    TP_fast_assign(
-			__entry->vcpu = vcpu;
+			__entry->pc = vcpu->arch.pc;
 			__entry->reason = reason;
 	    ),
 
 	    TP_printk("[%s]PC: 0x%08lx",
 		      kvm_mips_exit_types_str[__entry->reason],
-		      __entry->vcpu->arch.pc)
+		      __entry->pc)
 );
 
 #endif /* _TRACE_KVM_H */
diff --git a/arch/parisc/hpux/fs.c b/arch/parisc/hpux/fs.c
index 838b479..88d0962 100644
--- a/arch/parisc/hpux/fs.c
+++ b/arch/parisc/hpux/fs.c
@@ -60,6 +60,7 @@ struct hpux_dirent {
 };
 
 struct getdents_callback {
+	struct dir_context ctx;
 	struct hpux_dirent __user *current_dir;
 	struct hpux_dirent __user *previous;
 	int count;
@@ -110,24 +111,23 @@ int hpux_getdents(unsigned int fd, struct hpux_dirent __user *dirent, unsigned i
 {
 	struct fd arg;
 	struct hpux_dirent __user * lastdirent;
-	struct getdents_callback buf;
+	struct getdents_callback buf = {
+		.ctx.actor = filldir,
+		.current_dir = dirent,
+		.count = count
+	};
 	int error;
 
 	arg = fdget(fd);
 	if (!arg.file)
 		return -EBADF;
 
-	buf.current_dir = dirent;
-	buf.previous = NULL;
-	buf.count = count;
-	buf.error = 0;
-
-	error = vfs_readdir(arg.file, filldir, &buf);
+	error = iterate_dir(arg.file, &buf.ctx);
 	if (error >= 0)
 		error = buf.error;
 	lastdirent = buf.previous;
 	if (lastdirent) {
-		if (put_user(arg.file->f_pos, &lastdirent->d_off))
+		if (put_user(buf.ctx.pos, &lastdirent->d_off))
 			error = -EFAULT;
 		else
 			error = count - buf.count;
diff --git a/arch/powerpc/crypto/sha1.c b/arch/powerpc/crypto/sha1.c
index f9e8b94..b51da91 100644
--- a/arch/powerpc/crypto/sha1.c
+++ b/arch/powerpc/crypto/sha1.c
@@ -154,4 +154,5 @@ module_exit(sha1_powerpc_mod_fini);
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("SHA1 Secure Hash Algorithm");
 
-MODULE_ALIAS("sha1-powerpc");
+MODULE_ALIAS_CRYPTO("sha1");
+MODULE_ALIAS_CRYPTO("sha1-powerpc");
diff --git a/arch/powerpc/sysdev/axonram.c b/arch/powerpc/sysdev/axonram.c
index 1c16141..1fea249 100644
--- a/arch/powerpc/sysdev/axonram.c
+++ b/arch/powerpc/sysdev/axonram.c
@@ -155,7 +155,7 @@ axon_ram_direct_access(struct block_device *device, sector_t sector,
 	}
 
 	*kaddr = (void *)(bank->ph_addr + offset);
-	*pfn = virt_to_phys(kaddr) >> PAGE_SHIFT;
+	*pfn = virt_to_phys(*kaddr) >> PAGE_SHIFT;
 
 	return 0;
 }
diff --git a/arch/powerpc/xmon/xmon.c b/arch/powerpc/xmon/xmon.c
index 94599a6..89e5728 100644
--- a/arch/powerpc/xmon/xmon.c
+++ b/arch/powerpc/xmon/xmon.c
@@ -288,6 +288,7 @@ static inline void disable_surveillance(void)
 	args.token = rtas_token("set-indicator");
 	if (args.token == RTAS_UNKNOWN_SERVICE)
 		return;
+	args.token = cpu_to_be32(args.token);
 	args.nargs = cpu_to_be32(3);
 	args.nret = cpu_to_be32(1);
 	args.rets = &args.args[3];
diff --git a/arch/s390/crypto/aes_s390.c b/arch/s390/crypto/aes_s390.c
index fd104db..92eb4d6 100644
--- a/arch/s390/crypto/aes_s390.c
+++ b/arch/s390/crypto/aes_s390.c
@@ -970,7 +970,7 @@ static void __exit aes_s390_fini(void)
 module_init(aes_s390_init);
 module_exit(aes_s390_fini);
 
-MODULE_ALIAS("aes-all");
+MODULE_ALIAS_CRYPTO("aes-all");
 
 MODULE_DESCRIPTION("Rijndael (AES) Cipher Algorithm");
 MODULE_LICENSE("GPL");
diff --git a/arch/s390/crypto/des_s390.c b/arch/s390/crypto/des_s390.c
index f2d6ccc..a89feff 100644
--- a/arch/s390/crypto/des_s390.c
+++ b/arch/s390/crypto/des_s390.c
@@ -619,8 +619,8 @@ static void __exit des_s390_exit(void)
 module_init(des_s390_init);
 module_exit(des_s390_exit);
 
-MODULE_ALIAS("des");
-MODULE_ALIAS("des3_ede");
+MODULE_ALIAS_CRYPTO("des");
+MODULE_ALIAS_CRYPTO("des3_ede");
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("DES & Triple DES EDE Cipher Algorithms");
diff --git a/arch/s390/crypto/ghash_s390.c b/arch/s390/crypto/ghash_s390.c
index d43485d..7940dc9 100644
--- a/arch/s390/crypto/ghash_s390.c
+++ b/arch/s390/crypto/ghash_s390.c
@@ -160,7 +160,7 @@ static void __exit ghash_mod_exit(void)
 module_init(ghash_mod_init);
 module_exit(ghash_mod_exit);
 
-MODULE_ALIAS("ghash");
+MODULE_ALIAS_CRYPTO("ghash");
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("GHASH Message Digest Algorithm, s390 implementation");
diff --git a/arch/s390/crypto/sha1_s390.c b/arch/s390/crypto/sha1_s390.c
index a1b3a9d..5b2bee3 100644
--- a/arch/s390/crypto/sha1_s390.c
+++ b/arch/s390/crypto/sha1_s390.c
@@ -103,6 +103,6 @@ static void __exit sha1_s390_fini(void)
 module_init(sha1_s390_init);
 module_exit(sha1_s390_fini);
 
-MODULE_ALIAS("sha1");
+MODULE_ALIAS_CRYPTO("sha1");
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("SHA1 Secure Hash Algorithm");
diff --git a/arch/s390/crypto/sha256_s390.c b/arch/s390/crypto/sha256_s390.c
index 9b85380..b74ff15 100644
--- a/arch/s390/crypto/sha256_s390.c
+++ b/arch/s390/crypto/sha256_s390.c
@@ -143,7 +143,7 @@ static void __exit sha256_s390_fini(void)
 module_init(sha256_s390_init);
 module_exit(sha256_s390_fini);
 
-MODULE_ALIAS("sha256");
-MODULE_ALIAS("sha224");
+MODULE_ALIAS_CRYPTO("sha256");
+MODULE_ALIAS_CRYPTO("sha224");
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("SHA256 and SHA224 Secure Hash Algorithm");
diff --git a/arch/s390/crypto/sha512_s390.c b/arch/s390/crypto/sha512_s390.c
index 32a8138..0c36989 100644
--- a/arch/s390/crypto/sha512_s390.c
+++ b/arch/s390/crypto/sha512_s390.c
@@ -86,7 +86,7 @@ static struct shash_alg sha512_alg = {
 	}
 };
 
-MODULE_ALIAS("sha512");
+MODULE_ALIAS_CRYPTO("sha512");
 
 static int sha384_init(struct shash_desc *desc)
 {
@@ -126,7 +126,7 @@ static struct shash_alg sha384_alg = {
 	}
 };
 
-MODULE_ALIAS("sha384");
+MODULE_ALIAS_CRYPTO("sha384");
 
 static int __init init(void)
 {
diff --git a/arch/sparc/crypto/aes_glue.c b/arch/sparc/crypto/aes_glue.c
index 503e6d9..ded4cee 100644
--- a/arch/sparc/crypto/aes_glue.c
+++ b/arch/sparc/crypto/aes_glue.c
@@ -499,6 +499,6 @@ module_exit(aes_sparc64_mod_fini);
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("AES Secure Hash Algorithm, sparc64 aes opcode accelerated");
 
-MODULE_ALIAS("aes");
+MODULE_ALIAS_CRYPTO("aes");
 
 #include "crop_devid.c"
diff --git a/arch/sparc/crypto/camellia_glue.c b/arch/sparc/crypto/camellia_glue.c
index 888f626..641f55c 100644
--- a/arch/sparc/crypto/camellia_glue.c
+++ b/arch/sparc/crypto/camellia_glue.c
@@ -322,6 +322,6 @@ module_exit(camellia_sparc64_mod_fini);
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Camellia Cipher Algorithm, sparc64 camellia opcode accelerated");
 
-MODULE_ALIAS("aes");
+MODULE_ALIAS_CRYPTO("aes");
 
 #include "crop_devid.c"
diff --git a/arch/sparc/crypto/crc32c_glue.c b/arch/sparc/crypto/crc32c_glue.c
index 5162fad..d1064e4 100644
--- a/arch/sparc/crypto/crc32c_glue.c
+++ b/arch/sparc/crypto/crc32c_glue.c
@@ -176,6 +176,6 @@ module_exit(crc32c_sparc64_mod_fini);
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("CRC32c (Castagnoli), sparc64 crc32c opcode accelerated");
 
-MODULE_ALIAS("crc32c");
+MODULE_ALIAS_CRYPTO("crc32c");
 
 #include "crop_devid.c"
diff --git a/arch/sparc/crypto/des_glue.c b/arch/sparc/crypto/des_glue.c
index 3065bc6..d115009 100644
--- a/arch/sparc/crypto/des_glue.c
+++ b/arch/sparc/crypto/des_glue.c
@@ -532,6 +532,6 @@ module_exit(des_sparc64_mod_fini);
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("DES & Triple DES EDE Cipher Algorithms, sparc64 des opcode accelerated");
 
-MODULE_ALIAS("des");
+MODULE_ALIAS_CRYPTO("des");
 
 #include "crop_devid.c"
diff --git a/arch/sparc/crypto/md5_glue.c b/arch/sparc/crypto/md5_glue.c
index 09a9ea1..64c7ff5 100644
--- a/arch/sparc/crypto/md5_glue.c
+++ b/arch/sparc/crypto/md5_glue.c
@@ -185,6 +185,6 @@ module_exit(md5_sparc64_mod_fini);
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("MD5 Secure Hash Algorithm, sparc64 md5 opcode accelerated");
 
-MODULE_ALIAS("md5");
+MODULE_ALIAS_CRYPTO("md5");
 
 #include "crop_devid.c"
diff --git a/arch/sparc/crypto/sha1_glue.c b/arch/sparc/crypto/sha1_glue.c
index 6cd5f29..1b3e47a 100644
--- a/arch/sparc/crypto/sha1_glue.c
+++ b/arch/sparc/crypto/sha1_glue.c
@@ -180,6 +180,6 @@ module_exit(sha1_sparc64_mod_fini);
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("SHA1 Secure Hash Algorithm, sparc64 sha1 opcode accelerated");
 
-MODULE_ALIAS("sha1");
+MODULE_ALIAS_CRYPTO("sha1");
 
 #include "crop_devid.c"
diff --git a/arch/sparc/crypto/sha256_glue.c b/arch/sparc/crypto/sha256_glue.c
index 04f555a..41f27cc 100644
--- a/arch/sparc/crypto/sha256_glue.c
+++ b/arch/sparc/crypto/sha256_glue.c
@@ -237,7 +237,7 @@ module_exit(sha256_sparc64_mod_fini);
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("SHA-224 and SHA-256 Secure Hash Algorithm, sparc64 sha256 opcode accelerated");
 
-MODULE_ALIAS("sha224");
-MODULE_ALIAS("sha256");
+MODULE_ALIAS_CRYPTO("sha224");
+MODULE_ALIAS_CRYPTO("sha256");
 
 #include "crop_devid.c"
diff --git a/arch/sparc/crypto/sha512_glue.c b/arch/sparc/crypto/sha512_glue.c
index f04d199..9fff885 100644
--- a/arch/sparc/crypto/sha512_glue.c
+++ b/arch/sparc/crypto/sha512_glue.c
@@ -222,7 +222,7 @@ module_exit(sha512_sparc64_mod_fini);
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("SHA-384 and SHA-512 Secure Hash Algorithm, sparc64 sha512 opcode accelerated");
 
-MODULE_ALIAS("sha384");
-MODULE_ALIAS("sha512");
+MODULE_ALIAS_CRYPTO("sha384");
+MODULE_ALIAS_CRYPTO("sha512");
 
 #include "crop_devid.c"
diff --git a/arch/um/Kconfig.common b/arch/um/Kconfig.common
index bceee66..d1ff46c 100644
--- a/arch/um/Kconfig.common
+++ b/arch/um/Kconfig.common
@@ -8,6 +8,7 @@ config UML
 	default y
 	select HAVE_GENERIC_HARDIRQS
 	select HAVE_UID16
+	select HAVE_FUTEX_CMPXCHG if FUTEX
 	select GENERIC_IRQ_SHOW
 	select GENERIC_CPU_DEVICES
 	select GENERIC_IO
diff --git a/arch/um/include/shared/frame_kern.h b/arch/um/include/shared/frame_kern.h
index e584e40..f2ca570 100644
--- a/arch/um/include/shared/frame_kern.h
+++ b/arch/um/include/shared/frame_kern.h
@@ -6,13 +6,13 @@
 #ifndef __FRAME_KERN_H_
 #define __FRAME_KERN_H_
 
-extern int setup_signal_stack_sc(unsigned long stack_top, int sig, 
+extern int setup_signal_stack_sc(unsigned long stack_top, int sig,
 				 struct k_sigaction *ka,
-				 struct pt_regs *regs, 
+				 struct pt_regs *regs,
 				 sigset_t *mask);
-extern int setup_signal_stack_si(unsigned long stack_top, int sig, 
+extern int setup_signal_stack_si(unsigned long stack_top, int sig,
 				 struct k_sigaction *ka,
-				 struct pt_regs *regs, siginfo_t *info, 
+				 struct pt_regs *regs, struct siginfo *info,
 				 sigset_t *mask);
 
 #endif
diff --git a/arch/um/kernel/signal.c b/arch/um/kernel/signal.c
index 3e831b3..f57e02e 100644
--- a/arch/um/kernel/signal.c
+++ b/arch/um/kernel/signal.c
@@ -19,7 +19,7 @@ EXPORT_SYMBOL(unblock_signals);
  * OK, we're invoking a handler
  */
 static void handle_signal(struct pt_regs *regs, unsigned long signr,
-			 struct k_sigaction *ka, siginfo_t *info)
+			 struct k_sigaction *ka, struct siginfo *info)
 {
 	sigset_t *oldset = sigmask_to_save();
 	int singlestep = 0;
@@ -71,7 +71,7 @@ static void handle_signal(struct pt_regs *regs, unsigned long signr,
 static int kern_do_signal(struct pt_regs *regs)
 {
 	struct k_sigaction ka_copy;
-	siginfo_t info;
+	struct siginfo info;
 	int sig, handled_sig = 0;
 
 	while ((sig = get_signal_to_deliver(&info, &ka_copy, regs, NULL)) > 0) {
diff --git a/arch/um/os-Linux/signal.c b/arch/um/os-Linux/signal.c
index 9d9f1b4..905924b 100644
--- a/arch/um/os-Linux/signal.c
+++ b/arch/um/os-Linux/signal.c
@@ -25,7 +25,7 @@ void (*sig_info[NSIG])(int, struct siginfo *, struct uml_pt_regs *) = {
 	[SIGIO]		= sigio_handler,
 	[SIGVTALRM]	= timer_handler };
 
-static void sig_handler_common(int sig, siginfo_t *si, mcontext_t *mc)
+static void sig_handler_common(int sig, struct siginfo *si, mcontext_t *mc)
 {
 	struct uml_pt_regs r;
 	int save_errno = errno;
@@ -61,7 +61,7 @@ static void sig_handler_common(int sig, siginfo_t *si, mcontext_t *mc)
 static int signals_enabled;
 static unsigned int signals_pending;
 
-void sig_handler(int sig, siginfo_t *si, mcontext_t *mc)
+void sig_handler(int sig, struct siginfo *si, mcontext_t *mc)
 {
 	int enabled;
 
@@ -120,7 +120,7 @@ void set_sigstack(void *sig_stack, int size)
 		panic("enabling signal stack failed, errno = %d\n", errno);
 }
 
-static void (*handlers[_NSIG])(int sig, siginfo_t *si, mcontext_t *mc) = {
+static void (*handlers[_NSIG])(int sig, struct siginfo *si, mcontext_t *mc) = {
 	[SIGSEGV] = sig_handler,
 	[SIGBUS] = sig_handler,
 	[SIGILL] = sig_handler,
@@ -162,7 +162,7 @@ static void hard_handler(int sig, siginfo_t *si, void *p)
 		while ((sig = ffs(pending)) != 0){
 			sig--;
 			pending &= ~(1 << sig);
-			(*handlers[sig])(sig, si, mc);
+			(*handlers[sig])(sig, (struct siginfo *)si, mc);
 		}
 
 		/*
diff --git a/arch/um/os-Linux/skas/process.c b/arch/um/os-Linux/skas/process.c
index 4625949..908579f 100644
--- a/arch/um/os-Linux/skas/process.c
+++ b/arch/um/os-Linux/skas/process.c
@@ -409,7 +409,7 @@ void userspace(struct uml_pt_regs *regs)
 		if (WIFSTOPPED(status)) {
 			int sig = WSTOPSIG(status);
 
-			ptrace(PTRACE_GETSIGINFO, pid, 0, &si);
+			ptrace(PTRACE_GETSIGINFO, pid, 0, (struct siginfo *)&si);
 
 			switch (sig) {
 			case SIGSEGV:
@@ -417,7 +417,7 @@ void userspace(struct uml_pt_regs *regs)
 				    !ptrace_faultinfo) {
 					get_skas_faultinfo(pid,
 							   &regs->faultinfo);
-					(*sig_info[SIGSEGV])(SIGSEGV, &si,
+					(*sig_info[SIGSEGV])(SIGSEGV, (struct siginfo *)&si,
 							     regs);
 				}
 				else handle_segv(pid, regs);
@@ -426,14 +426,14 @@ void userspace(struct uml_pt_regs *regs)
 			        handle_trap(pid, regs, local_using_sysemu);
 				break;
 			case SIGTRAP:
-				relay_signal(SIGTRAP, &si, regs);
+				relay_signal(SIGTRAP, (struct siginfo *)&si, regs);
 				break;
 			case SIGVTALRM:
 				now = os_nsecs();
 				if (now < nsecs)
 					break;
 				block_signals();
-				(*sig_info[sig])(sig, &si, regs);
+				(*sig_info[sig])(sig, (struct siginfo *)&si, regs);
 				unblock_signals();
 				nsecs = timer.it_value.tv_sec *
 					UM_NSEC_PER_SEC +
@@ -447,7 +447,7 @@ void userspace(struct uml_pt_regs *regs)
 			case SIGFPE:
 			case SIGWINCH:
 				block_signals();
-				(*sig_info[sig])(sig, &si, regs);
+				(*sig_info[sig])(sig, (struct siginfo *)&si, regs);
 				unblock_signals();
 				break;
 			default:
diff --git a/arch/x86/crypto/aes_glue.c b/arch/x86/crypto/aes_glue.c
index aafe8ce..e26984f 100644
--- a/arch/x86/crypto/aes_glue.c
+++ b/arch/x86/crypto/aes_glue.c
@@ -66,5 +66,5 @@ module_exit(aes_fini);
 
 MODULE_DESCRIPTION("Rijndael (AES) Cipher Algorithm, asm optimized");
 MODULE_LICENSE("GPL");
-MODULE_ALIAS("aes");
-MODULE_ALIAS("aes-asm");
+MODULE_ALIAS_CRYPTO("aes");
+MODULE_ALIAS_CRYPTO("aes-asm");
diff --git a/arch/x86/crypto/aesni-intel_glue.c b/arch/x86/crypto/aesni-intel_glue.c
index f80e668..f89e749 100644
--- a/arch/x86/crypto/aesni-intel_glue.c
+++ b/arch/x86/crypto/aesni-intel_glue.c
@@ -1373,4 +1373,4 @@ module_exit(aesni_exit);
 
 MODULE_DESCRIPTION("Rijndael (AES) Cipher Algorithm, Intel AES-NI instructions optimized");
 MODULE_LICENSE("GPL");
-MODULE_ALIAS("aes");
+MODULE_ALIAS_CRYPTO("aes");
diff --git a/arch/x86/crypto/blowfish_avx2_glue.c b/arch/x86/crypto/blowfish_avx2_glue.c
index 4417e9a..183395b 100644
--- a/arch/x86/crypto/blowfish_avx2_glue.c
+++ b/arch/x86/crypto/blowfish_avx2_glue.c
@@ -581,5 +581,5 @@ module_exit(fini);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Blowfish Cipher Algorithm, AVX2 optimized");
-MODULE_ALIAS("blowfish");
-MODULE_ALIAS("blowfish-asm");
+MODULE_ALIAS_CRYPTO("blowfish");
+MODULE_ALIAS_CRYPTO("blowfish-asm");
diff --git a/arch/x86/crypto/blowfish_glue.c b/arch/x86/crypto/blowfish_glue.c
index 3548d76..9f7cc6b 100644
--- a/arch/x86/crypto/blowfish_glue.c
+++ b/arch/x86/crypto/blowfish_glue.c
@@ -465,5 +465,5 @@ module_exit(fini);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Blowfish Cipher Algorithm, asm optimized");
-MODULE_ALIAS("blowfish");
-MODULE_ALIAS("blowfish-asm");
+MODULE_ALIAS_CRYPTO("blowfish");
+MODULE_ALIAS_CRYPTO("blowfish-asm");
diff --git a/arch/x86/crypto/camellia_aesni_avx2_glue.c b/arch/x86/crypto/camellia_aesni_avx2_glue.c
index 414fe5d..da710fc 100644
--- a/arch/x86/crypto/camellia_aesni_avx2_glue.c
+++ b/arch/x86/crypto/camellia_aesni_avx2_glue.c
@@ -582,5 +582,5 @@ module_exit(camellia_aesni_fini);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Camellia Cipher Algorithm, AES-NI/AVX2 optimized");
-MODULE_ALIAS("camellia");
-MODULE_ALIAS("camellia-asm");
+MODULE_ALIAS_CRYPTO("camellia");
+MODULE_ALIAS_CRYPTO("camellia-asm");
diff --git a/arch/x86/crypto/camellia_aesni_avx_glue.c b/arch/x86/crypto/camellia_aesni_avx_glue.c
index 37fd0c0..883e1af 100644
--- a/arch/x86/crypto/camellia_aesni_avx_glue.c
+++ b/arch/x86/crypto/camellia_aesni_avx_glue.c
@@ -574,5 +574,5 @@ module_exit(camellia_aesni_fini);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Camellia Cipher Algorithm, AES-NI/AVX optimized");
-MODULE_ALIAS("camellia");
-MODULE_ALIAS("camellia-asm");
+MODULE_ALIAS_CRYPTO("camellia");
+MODULE_ALIAS_CRYPTO("camellia-asm");
diff --git a/arch/x86/crypto/camellia_glue.c b/arch/x86/crypto/camellia_glue.c
index 5cb86cc..16d65b0 100644
--- a/arch/x86/crypto/camellia_glue.c
+++ b/arch/x86/crypto/camellia_glue.c
@@ -1725,5 +1725,5 @@ module_exit(fini);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Camellia Cipher Algorithm, asm optimized");
-MODULE_ALIAS("camellia");
-MODULE_ALIAS("camellia-asm");
+MODULE_ALIAS_CRYPTO("camellia");
+MODULE_ALIAS_CRYPTO("camellia-asm");
diff --git a/arch/x86/crypto/cast5_avx_glue.c b/arch/x86/crypto/cast5_avx_glue.c
index c663181..d416069 100644
--- a/arch/x86/crypto/cast5_avx_glue.c
+++ b/arch/x86/crypto/cast5_avx_glue.c
@@ -494,4 +494,4 @@ module_exit(cast5_exit);
 
 MODULE_DESCRIPTION("Cast5 Cipher Algorithm, AVX optimized");
 MODULE_LICENSE("GPL");
-MODULE_ALIAS("cast5");
+MODULE_ALIAS_CRYPTO("cast5");
diff --git a/arch/x86/crypto/cast6_avx_glue.c b/arch/x86/crypto/cast6_avx_glue.c
index 8d0dfb8..c197562 100644
--- a/arch/x86/crypto/cast6_avx_glue.c
+++ b/arch/x86/crypto/cast6_avx_glue.c
@@ -611,4 +611,4 @@ module_exit(cast6_exit);
 
 MODULE_DESCRIPTION("Cast6 Cipher Algorithm, AVX optimized");
 MODULE_LICENSE("GPL");
-MODULE_ALIAS("cast6");
+MODULE_ALIAS_CRYPTO("cast6");
diff --git a/arch/x86/crypto/crc32-pclmul_glue.c b/arch/x86/crypto/crc32-pclmul_glue.c
index 9d014a7..1937fc1 100644
--- a/arch/x86/crypto/crc32-pclmul_glue.c
+++ b/arch/x86/crypto/crc32-pclmul_glue.c
@@ -197,5 +197,5 @@ module_exit(crc32_pclmul_mod_fini);
 MODULE_AUTHOR("Alexander Boyko <alexander_boyko@xyratex.com>");
 MODULE_LICENSE("GPL");
 
-MODULE_ALIAS("crc32");
-MODULE_ALIAS("crc32-pclmul");
+MODULE_ALIAS_CRYPTO("crc32");
+MODULE_ALIAS_CRYPTO("crc32-pclmul");
diff --git a/arch/x86/crypto/crc32c-intel_glue.c b/arch/x86/crypto/crc32c-intel_glue.c
index 6812ad9..28640c3 100644
--- a/arch/x86/crypto/crc32c-intel_glue.c
+++ b/arch/x86/crypto/crc32c-intel_glue.c
@@ -280,5 +280,5 @@ MODULE_AUTHOR("Austin Zhang <austin.zhang@intel.com>, Kent Liu <kent.liu@intel.c
 MODULE_DESCRIPTION("CRC32c (Castagnoli) optimization using Intel Hardware.");
 MODULE_LICENSE("GPL");
 
-MODULE_ALIAS("crc32c");
-MODULE_ALIAS("crc32c-intel");
+MODULE_ALIAS_CRYPTO("crc32c");
+MODULE_ALIAS_CRYPTO("crc32c-intel");
diff --git a/arch/x86/crypto/fpu.c b/arch/x86/crypto/fpu.c
index 98d7a18..f368ba2 100644
--- a/arch/x86/crypto/fpu.c
+++ b/arch/x86/crypto/fpu.c
@@ -17,6 +17,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
+#include <linux/crypto.h>
 #include <asm/i387.h>
 
 struct crypto_fpu_ctx {
@@ -159,3 +160,5 @@ void __exit crypto_fpu_exit(void)
 {
 	crypto_unregister_template(&crypto_fpu_tmpl);
 }
+
+MODULE_ALIAS_CRYPTO("fpu");
diff --git a/arch/x86/crypto/ghash-clmulni-intel_glue.c b/arch/x86/crypto/ghash-clmulni-intel_glue.c
index d785cf2..a8d6f69 100644
--- a/arch/x86/crypto/ghash-clmulni-intel_glue.c
+++ b/arch/x86/crypto/ghash-clmulni-intel_glue.c
@@ -341,4 +341,4 @@ module_exit(ghash_pclmulqdqni_mod_exit);
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("GHASH Message Digest Algorithm, "
 		   "acclerated by PCLMULQDQ-NI");
-MODULE_ALIAS("ghash");
+MODULE_ALIAS_CRYPTO("ghash");
diff --git a/arch/x86/crypto/salsa20_glue.c b/arch/x86/crypto/salsa20_glue.c
index 5e8e677..399a29d 100644
--- a/arch/x86/crypto/salsa20_glue.c
+++ b/arch/x86/crypto/salsa20_glue.c
@@ -119,5 +119,5 @@ module_exit(fini);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION ("Salsa20 stream cipher algorithm (optimized assembly version)");
-MODULE_ALIAS("salsa20");
-MODULE_ALIAS("salsa20-asm");
+MODULE_ALIAS_CRYPTO("salsa20");
+MODULE_ALIAS_CRYPTO("salsa20-asm");
diff --git a/arch/x86/crypto/serpent_avx2_glue.c b/arch/x86/crypto/serpent_avx2_glue.c
index 23aabc6..cb57caf 100644
--- a/arch/x86/crypto/serpent_avx2_glue.c
+++ b/arch/x86/crypto/serpent_avx2_glue.c
@@ -558,5 +558,5 @@ module_exit(fini);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Serpent Cipher Algorithm, AVX2 optimized");
-MODULE_ALIAS("serpent");
-MODULE_ALIAS("serpent-asm");
+MODULE_ALIAS_CRYPTO("serpent");
+MODULE_ALIAS_CRYPTO("serpent-asm");
diff --git a/arch/x86/crypto/serpent_avx_glue.c b/arch/x86/crypto/serpent_avx_glue.c
index 9ae83cf..0a86e8b 100644
--- a/arch/x86/crypto/serpent_avx_glue.c
+++ b/arch/x86/crypto/serpent_avx_glue.c
@@ -617,4 +617,4 @@ module_exit(serpent_exit);
 
 MODULE_DESCRIPTION("Serpent Cipher Algorithm, AVX optimized");
 MODULE_LICENSE("GPL");
-MODULE_ALIAS("serpent");
+MODULE_ALIAS_CRYPTO("serpent");
diff --git a/arch/x86/crypto/serpent_sse2_glue.c b/arch/x86/crypto/serpent_sse2_glue.c
index 97a356e..279f389 100644
--- a/arch/x86/crypto/serpent_sse2_glue.c
+++ b/arch/x86/crypto/serpent_sse2_glue.c
@@ -618,4 +618,4 @@ module_exit(serpent_sse2_exit);
 
 MODULE_DESCRIPTION("Serpent Cipher Algorithm, SSE2 optimized");
 MODULE_LICENSE("GPL");
-MODULE_ALIAS("serpent");
+MODULE_ALIAS_CRYPTO("serpent");
diff --git a/arch/x86/crypto/sha1_ssse3_glue.c b/arch/x86/crypto/sha1_ssse3_glue.c
index 4a11a9d..29e1060 100644
--- a/arch/x86/crypto/sha1_ssse3_glue.c
+++ b/arch/x86/crypto/sha1_ssse3_glue.c
@@ -237,4 +237,4 @@ module_exit(sha1_ssse3_mod_fini);
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("SHA1 Secure Hash Algorithm, Supplemental SSE3 accelerated");
 
-MODULE_ALIAS("sha1");
+MODULE_ALIAS_CRYPTO("sha1");
diff --git a/arch/x86/crypto/sha256_ssse3_glue.c b/arch/x86/crypto/sha256_ssse3_glue.c
index 597d4da..ceafb01 100644
--- a/arch/x86/crypto/sha256_ssse3_glue.c
+++ b/arch/x86/crypto/sha256_ssse3_glue.c
@@ -272,4 +272,4 @@ module_exit(sha256_ssse3_mod_fini);
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("SHA256 Secure Hash Algorithm, Supplemental SSE3 accelerated");
 
-MODULE_ALIAS("sha256");
+MODULE_ALIAS_CRYPTO("sha256");
diff --git a/arch/x86/crypto/sha512_ssse3_glue.c b/arch/x86/crypto/sha512_ssse3_glue.c
index 9f5e71f..d1ee9f6 100644
--- a/arch/x86/crypto/sha512_ssse3_glue.c
+++ b/arch/x86/crypto/sha512_ssse3_glue.c
@@ -279,4 +279,4 @@ module_exit(sha512_ssse3_mod_fini);
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("SHA512 Secure Hash Algorithm, Supplemental SSE3 accelerated");
 
-MODULE_ALIAS("sha512");
+MODULE_ALIAS_CRYPTO("sha512");
diff --git a/arch/x86/crypto/twofish_avx2_glue.c b/arch/x86/crypto/twofish_avx2_glue.c
index ce33b5b..bb1f0a1 100644
--- a/arch/x86/crypto/twofish_avx2_glue.c
+++ b/arch/x86/crypto/twofish_avx2_glue.c
@@ -580,5 +580,5 @@ module_exit(fini);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Twofish Cipher Algorithm, AVX2 optimized");
-MODULE_ALIAS("twofish");
-MODULE_ALIAS("twofish-asm");
+MODULE_ALIAS_CRYPTO("twofish");
+MODULE_ALIAS_CRYPTO("twofish-asm");
diff --git a/arch/x86/crypto/twofish_avx_glue.c b/arch/x86/crypto/twofish_avx_glue.c
index 2047a56..4a1f944 100644
--- a/arch/x86/crypto/twofish_avx_glue.c
+++ b/arch/x86/crypto/twofish_avx_glue.c
@@ -589,4 +589,4 @@ module_exit(twofish_exit);
 
 MODULE_DESCRIPTION("Twofish Cipher Algorithm, AVX optimized");
 MODULE_LICENSE("GPL");
-MODULE_ALIAS("twofish");
+MODULE_ALIAS_CRYPTO("twofish");
diff --git a/arch/x86/crypto/twofish_glue.c b/arch/x86/crypto/twofish_glue.c
index 0a52023..77e06c2 100644
--- a/arch/x86/crypto/twofish_glue.c
+++ b/arch/x86/crypto/twofish_glue.c
@@ -96,5 +96,5 @@ module_exit(fini);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION ("Twofish Cipher Algorithm, asm optimized");
-MODULE_ALIAS("twofish");
-MODULE_ALIAS("twofish-asm");
+MODULE_ALIAS_CRYPTO("twofish");
+MODULE_ALIAS_CRYPTO("twofish-asm");
diff --git a/arch/x86/crypto/twofish_glue_3way.c b/arch/x86/crypto/twofish_glue_3way.c
index 13e63b3..56d8a08 100644
--- a/arch/x86/crypto/twofish_glue_3way.c
+++ b/arch/x86/crypto/twofish_glue_3way.c
@@ -495,5 +495,5 @@ module_exit(fini);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Twofish Cipher Algorithm, 3-way parallel asm optimized");
-MODULE_ALIAS("twofish");
-MODULE_ALIAS("twofish-asm");
+MODULE_ALIAS_CRYPTO("twofish");
+MODULE_ALIAS_CRYPTO("twofish-asm");
diff --git a/arch/x86/include/asm/desc.h b/arch/x86/include/asm/desc.h
index 8bf1c06..23fb67e 100644
--- a/arch/x86/include/asm/desc.h
+++ b/arch/x86/include/asm/desc.h
@@ -251,7 +251,8 @@ static inline void native_load_tls(struct thread_struct *t, unsigned int cpu)
 		gdt[GDT_ENTRY_TLS_MIN + i] = t->tls_array[i];
 }
 
-#define _LDT_empty(info)				\
+/* This intentionally ignores lm, since 32-bit apps don't have that field. */
+#define LDT_empty(info)					\
 	((info)->base_addr		== 0	&&	\
 	 (info)->limit			== 0	&&	\
 	 (info)->contents		== 0	&&	\
@@ -261,11 +262,18 @@ static inline void native_load_tls(struct thread_struct *t, unsigned int cpu)
 	 (info)->seg_not_present	== 1	&&	\
 	 (info)->useable		== 0)
 
-#ifdef CONFIG_X86_64
-#define LDT_empty(info) (_LDT_empty(info) && ((info)->lm == 0))
-#else
-#define LDT_empty(info) (_LDT_empty(info))
-#endif
+/* Lots of programs expect an all-zero user_desc to mean "no segment at all". */
+static inline bool LDT_zero(const struct user_desc *info)
+{
+	return (info->base_addr		== 0 &&
+		info->limit		== 0 &&
+		info->contents		== 0 &&
+		info->read_exec_only	== 0 &&
+		info->seg_32bit		== 0 &&
+		info->limit_in_pages	== 0 &&
+		info->seg_not_present	== 0 &&
+		info->useable		== 0);
+}
 
 static inline void clear_LDT(void)
 {
diff --git a/arch/x86/include/uapi/asm/vmx.h b/arch/x86/include/uapi/asm/vmx.h
index 7a34e8f..dccea7f 100644
--- a/arch/x86/include/uapi/asm/vmx.h
+++ b/arch/x86/include/uapi/asm/vmx.h
@@ -67,6 +67,7 @@
 #define EXIT_REASON_EPT_MISCONFIG       49
 #define EXIT_REASON_INVEPT              50
 #define EXIT_REASON_PREEMPTION_TIMER    52
+#define EXIT_REASON_INVVPID             53
 #define EXIT_REASON_WBINVD              54
 #define EXIT_REASON_XSETBV              55
 #define EXIT_REASON_APIC_WRITE          56
@@ -112,6 +113,7 @@
 	{ EXIT_REASON_EOI_INDUCED,           "EOI_INDUCED" }, \
 	{ EXIT_REASON_INVALID_STATE,         "INVALID_STATE" }, \
 	{ EXIT_REASON_INVD,                  "INVD" }, \
+	{ EXIT_REASON_INVVPID,               "INVVPID" }, \
 	{ EXIT_REASON_INVPCID,               "INVPCID" }, \
 	{ EXIT_REASON_PREEMPTION_TIMER,      "PREEMPTION_TIMER" }
 
diff --git a/arch/x86/kernel/cpu/mshyperv.c b/arch/x86/kernel/cpu/mshyperv.c
index 8f4be53..1853659 100644
--- a/arch/x86/kernel/cpu/mshyperv.c
+++ b/arch/x86/kernel/cpu/mshyperv.c
@@ -60,6 +60,7 @@ static struct clocksource hyperv_cs = {
 	.rating		= 400, /* use this when running on Hyperv*/
 	.read		= read_hv_clock,
 	.mask		= CLOCKSOURCE_MASK(64),
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
 };
 
 static void __init ms_hyperv_init_platform(void)
diff --git a/arch/x86/kernel/entry_64.S b/arch/x86/kernel/entry_64.S
index 948b2e1..6ed8f16 100644
--- a/arch/x86/kernel/entry_64.S
+++ b/arch/x86/kernel/entry_64.S
@@ -557,11 +557,14 @@ ENTRY(ret_from_fork)
 	testl $3, CS-ARGOFFSET(%rsp)		# from kernel_thread?
 	jz   1f
 
-	testl $_TIF_IA32, TI_flags(%rcx)	# 32-bit compat task needs IRET
-	jnz  int_ret_from_sys_call
-
-	RESTORE_TOP_OF_STACK %rdi, -ARGOFFSET
-	jmp ret_from_sys_call			# go to the SYSRET fastpath
+	/*
+	 * By the time we get here, we have no idea whether our pt_regs,
+	 * ti flags, and ti status came from the 64-bit SYSCALL fast path,
+	 * the slow path, or one of the ia32entry paths.
+	 * Use int_ret_from_sys_call to return, since it can safely handle
+	 * all of the above.
+	 */
+	jmp  int_ret_from_sys_call
 
 1:
 	subq $REST_SKIP, %rsp	# leave space for volatiles
diff --git a/arch/x86/kernel/kprobes/core.c b/arch/x86/kernel/kprobes/core.c
index 211bce4..0c6c07c 100644
--- a/arch/x86/kernel/kprobes/core.c
+++ b/arch/x86/kernel/kprobes/core.c
@@ -1017,6 +1017,15 @@ int __kprobes setjmp_pre_handler(struct kprobe *p, struct pt_regs *regs)
 	regs->flags &= ~X86_EFLAGS_IF;
 	trace_hardirqs_off();
 	regs->ip = (unsigned long)(jp->entry);
+
+	/*
+	 * jprobes use jprobe_return() which skips the normal return
+	 * path of the function, and this messes up the accounting of the
+	 * function graph tracer to get messed up.
+	 *
+	 * Pause function graph tracing while performing the jprobe function.
+	 */
+	pause_graph_tracing();
 	return 1;
 }
 
@@ -1042,24 +1051,25 @@ int __kprobes longjmp_break_handler(struct kprobe *p, struct pt_regs *regs)
 	struct kprobe_ctlblk *kcb = get_kprobe_ctlblk();
 	u8 *addr = (u8 *) (regs->ip - 1);
 	struct jprobe *jp = container_of(p, struct jprobe, kp);
+	void *saved_sp = kcb->jprobe_saved_sp;
 
 	if ((addr > (u8 *) jprobe_return) &&
 	    (addr < (u8 *) jprobe_return_end)) {
-		if (stack_addr(regs) != kcb->jprobe_saved_sp) {
+		if (stack_addr(regs) != saved_sp) {
 			struct pt_regs *saved_regs = &kcb->jprobe_saved_regs;
 			printk(KERN_ERR
 			       "current sp %p does not match saved sp %p\n",
-			       stack_addr(regs), kcb->jprobe_saved_sp);
+			       stack_addr(regs), saved_sp);
 			printk(KERN_ERR "Saved registers for jprobe %p\n", jp);
 			show_regs(saved_regs);
 			printk(KERN_ERR "Current registers\n");
 			show_regs(regs);
 			BUG();
 		}
+		/* It's OK to start function graph tracing again */
+		unpause_graph_tracing();
 		*regs = kcb->jprobe_saved_regs;
-		memcpy((kprobe_opcode_t *)(kcb->jprobe_saved_sp),
-		       kcb->jprobes_stack,
-		       MIN_STACK_SIZE(kcb->jprobe_saved_sp));
+		memcpy(saved_sp, kcb->jprobes_stack, MIN_STACK_SIZE(saved_sp));
 		preempt_enable_no_resched();
 		return 1;
 	}
diff --git a/arch/x86/kernel/tls.c b/arch/x86/kernel/tls.c
index 4e942f3..7fc5e84 100644
--- a/arch/x86/kernel/tls.c
+++ b/arch/x86/kernel/tls.c
@@ -29,7 +29,28 @@ static int get_free_idx(void)
 
 static bool tls_desc_okay(const struct user_desc *info)
 {
-	if (LDT_empty(info))
+	/*
+	 * For historical reasons (i.e. no one ever documented how any
+	 * of the segmentation APIs work), user programs can and do
+	 * assume that a struct user_desc that's all zeros except for
+	 * entry_number means "no segment at all".  This never actually
+	 * worked.  In fact, up to Linux 3.19, a struct user_desc like
+	 * this would create a 16-bit read-write segment with base and
+	 * limit both equal to zero.
+	 *
+	 * That was close enough to "no segment at all" until we
+	 * hardened this function to disallow 16-bit TLS segments.  Fix
+	 * it up by interpreting these zeroed segments the way that they
+	 * were almost certainly intended to be interpreted.
+	 *
+	 * The correct way to ask for "no segment at all" is to specify
+	 * a user_desc that satisfies LDT_empty.  To keep everything
+	 * working, we accept both.
+	 *
+	 * Note that there's a similar kludge in modify_ldt -- look at
+	 * the distinction between modes 1 and 0x11.
+	 */
+	if (LDT_empty(info) || LDT_zero(info))
 		return true;
 
 	/*
@@ -71,7 +92,7 @@ static void set_tls_desc(struct task_struct *p, int idx,
 	cpu = get_cpu();
 
 	while (n-- > 0) {
-		if (LDT_empty(info))
+		if (LDT_empty(info) || LDT_zero(info))
 			desc->a = desc->b = 0;
 		else
 			fill_ldt(desc, info);
diff --git a/arch/x86/kernel/traps.c b/arch/x86/kernel/traps.c
index 332cafe..0010ed7 100644
--- a/arch/x86/kernel/traps.c
+++ b/arch/x86/kernel/traps.c
@@ -362,7 +362,7 @@ exit:
  * for scheduling or signal handling. The actual stack switch is done in
  * entry.S
  */
-asmlinkage __kprobes struct pt_regs *sync_regs(struct pt_regs *eregs)
+asmlinkage notrace __kprobes struct pt_regs *sync_regs(struct pt_regs *eregs)
 {
 	struct pt_regs *regs = eregs;
 	/* Did already sync */
@@ -387,7 +387,7 @@ struct bad_iret_stack {
 	struct pt_regs regs;
 };
 
-asmlinkage __visible
+asmlinkage __visible notrace __kprobes
 struct bad_iret_stack *fixup_bad_iret(struct bad_iret_stack *s)
 {
 	/*
diff --git a/arch/x86/kernel/tsc.c b/arch/x86/kernel/tsc.c
index 4e27ba5..27e3a14 100644
--- a/arch/x86/kernel/tsc.c
+++ b/arch/x86/kernel/tsc.c
@@ -380,7 +380,7 @@ static unsigned long quick_pit_calibrate(void)
 			goto success;
 		}
 	}
-	pr_err("Fast TSC calibration failed\n");
+	pr_info("Fast TSC calibration failed\n");
 	return 0;
 
 success:
diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c
index 4c01f02..af88fa2 100644
--- a/arch/x86/kvm/emulate.c
+++ b/arch/x86/kvm/emulate.c
@@ -4732,7 +4732,8 @@ int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)
 		if (rc != X86EMUL_CONTINUE)
 			goto done;
 	}
-	ctxt->dst.orig_val = ctxt->dst.val;
+	/* Copy full 64-bit value for CMPXCHG8B.  */
+	ctxt->dst.orig_val64 = ctxt->dst.val64;
 
 special_insn:
 
diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c
index 7112be5..04cc2fa 100644
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@ -438,6 +438,7 @@ struct vcpu_vmx {
 #endif
 		int           gs_ldt_reload_needed;
 		int           fs_reload_needed;
+		unsigned long vmcs_host_cr4;    /* May not match real cr4 */
 	} host_state;
 	struct {
 		int vm86_active;
@@ -4076,11 +4077,16 @@ static void vmx_set_constant_host_state(struct vcpu_vmx *vmx)
 	u32 low32, high32;
 	unsigned long tmpl;
 	struct desc_ptr dt;
+	unsigned long cr4;
 
 	vmcs_writel(HOST_CR0, read_cr0() & ~X86_CR0_TS);  /* 22.2.3 */
-	vmcs_writel(HOST_CR4, read_cr4());  /* 22.2.3, 22.2.5 */
 	vmcs_writel(HOST_CR3, read_cr3());  /* 22.2.3  FIXME: shadow tables */
 
+	/* Save the most likely value for this task's CR4 in the VMCS. */
+	cr4 = read_cr4();
+	vmcs_writel(HOST_CR4, cr4);			/* 22.2.3, 22.2.5 */
+	vmx->host_state.vmcs_host_cr4 = cr4;
+
 	vmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  /* 22.2.4 */
 #ifdef CONFIG_X86_64
 	/*
@@ -6248,6 +6254,12 @@ static int handle_invept(struct kvm_vcpu *vcpu)
 	return 1;
 }
 
+static int handle_invvpid(struct kvm_vcpu *vcpu)
+{
+	kvm_queue_exception(vcpu, UD_VECTOR);
+	return 1;
+}
+
 /*
  * The exit handlers return 1 if the exit was handled fully and guest execution
  * may resume.  Otherwise they set the kvm_run parameter to indicate what needs
@@ -6293,6 +6305,7 @@ static int (*const kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = {
 	[EXIT_REASON_MWAIT_INSTRUCTION]	      = handle_invalid_op,
 	[EXIT_REASON_MONITOR_INSTRUCTION]     = handle_invalid_op,
 	[EXIT_REASON_INVEPT]                  = handle_invept,
+	[EXIT_REASON_INVVPID]                 = handle_invvpid,
 };
 
 static const int kvm_vmx_max_exit_handlers =
@@ -6519,7 +6532,7 @@ static bool nested_vmx_exit_handled(struct kvm_vcpu *vcpu)
 	case EXIT_REASON_VMPTRST: case EXIT_REASON_VMREAD:
 	case EXIT_REASON_VMRESUME: case EXIT_REASON_VMWRITE:
 	case EXIT_REASON_VMOFF: case EXIT_REASON_VMON:
-	case EXIT_REASON_INVEPT:
+	case EXIT_REASON_INVEPT: case EXIT_REASON_INVVPID:
 		/*
 		 * VMX instructions trap unconditionally. This allows L1 to
 		 * emulate them for its L2 guest, i.e., allows 3-level nesting!
@@ -6964,7 +6977,7 @@ static void atomic_switch_perf_msrs(struct vcpu_vmx *vmx)
 static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)
 {
 	struct vcpu_vmx *vmx = to_vmx(vcpu);
-	unsigned long debugctlmsr;
+	unsigned long debugctlmsr, cr4;
 
 	/* Record the guest's net vcpu time for enforced NMI injections. */
 	if (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked))
@@ -6985,6 +6998,12 @@ static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)
 	if (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty))
 		vmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);
 
+	cr4 = read_cr4();
+	if (unlikely(cr4 != vmx->host_state.vmcs_host_cr4)) {
+		vmcs_writel(HOST_CR4, cr4);
+		vmx->host_state.vmcs_host_cr4 = cr4;
+	}
+
 	/* When single-stepping over STI and MOV SS, we must clear the
 	 * corresponding interruptibility bits in the guest state. Otherwise
 	 * vmentry fails as it then expects bit 14 (BS) in pending debug
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index adfc30d..41ba726 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -1182,21 +1182,22 @@ void kvm_track_tsc_matching(struct kvm_vcpu *vcpu)
 {
 #ifdef CONFIG_X86_64
 	bool vcpus_matched;
-	bool do_request = false;
 	struct kvm_arch *ka = &vcpu->kvm->arch;
 	struct pvclock_gtod_data *gtod = &pvclock_gtod_data;
 
 	vcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==
 			 atomic_read(&vcpu->kvm->online_vcpus));
 
-	if (vcpus_matched && gtod->clock.vclock_mode == VCLOCK_TSC)
-		if (!ka->use_master_clock)
-			do_request = 1;
-
-	if (!vcpus_matched && ka->use_master_clock)
-			do_request = 1;
-
-	if (do_request)
+	/*
+	 * Once the masterclock is enabled, always perform request in
+	 * order to update it.
+	 *
+	 * In order to enable masterclock, the host clocksource must be TSC
+	 * and the vcpus need to have matched TSCs.  When that happens,
+	 * perform request to enable masterclock.
+	 */
+	if (ka->use_master_clock ||
+	    (gtod->clock.vclock_mode == VCLOCK_TSC && vcpus_matched))
 		kvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);
 
 	trace_kvm_track_tsc(vcpu->vcpu_id, ka->nr_vcpus_matched_tsc,
diff --git a/arch/x86/mm/mmap.c b/arch/x86/mm/mmap.c
index 5c1ae28..75f9e5d 100644
--- a/arch/x86/mm/mmap.c
+++ b/arch/x86/mm/mmap.c
@@ -35,12 +35,12 @@ struct __read_mostly va_alignment va_align = {
 	.flags = -1,
 };
 
-static unsigned int stack_maxrandom_size(void)
+static unsigned long stack_maxrandom_size(void)
 {
-	unsigned int max = 0;
+	unsigned long max = 0;
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
-		max = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;
+		max = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;
 	}
 
 	return max;
diff --git a/arch/x86/pci/common.c b/arch/x86/pci/common.c
index 981c2db..88f143d 100644
--- a/arch/x86/pci/common.c
+++ b/arch/x86/pci/common.c
@@ -448,6 +448,22 @@ static const struct dmi_system_id pciprobe_dmi_table[] = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "ftServer"),
 		},
 	},
+        {
+                .callback = set_scan_all,
+                .ident = "Stratus/NEC ftServer",
+                .matches = {
+                        DMI_MATCH(DMI_SYS_VENDOR, "NEC"),
+                        DMI_MATCH(DMI_PRODUCT_NAME, "Express5800/R32"),
+                },
+        },
+        {
+                .callback = set_scan_all,
+                .ident = "Stratus/NEC ftServer",
+                .matches = {
+                        DMI_MATCH(DMI_SYS_VENDOR, "NEC"),
+                        DMI_MATCH(DMI_PRODUCT_NAME, "Express5800/R31"),
+                },
+        },
 	{}
 };
 
diff --git a/arch/x86/um/signal.c b/arch/x86/um/signal.c
index ae7319d..5e04a1c 100644
--- a/arch/x86/um/signal.c
+++ b/arch/x86/um/signal.c
@@ -508,7 +508,6 @@ int setup_signal_stack_si(unsigned long stack_top, int sig,
 {
 	struct rt_sigframe __user *frame;
 	int err = 0;
-	struct task_struct *me = current;
 
 	frame = (struct rt_sigframe __user *)
 		round_down(stack_top - sizeof(struct rt_sigframe), 16);
diff --git a/arch/x86/um/sys_call_table_32.c b/arch/x86/um/sys_call_table_32.c
index 531d426..bd16d6c 100644
--- a/arch/x86/um/sys_call_table_32.c
+++ b/arch/x86/um/sys_call_table_32.c
@@ -34,7 +34,7 @@ typedef asmlinkage void (*sys_call_ptr_t)(void);
 
 extern asmlinkage void sys_ni_syscall(void);
 
-const sys_call_ptr_t sys_call_table[] __cacheline_aligned = {
+const sys_call_ptr_t sys_call_table[] ____cacheline_aligned = {
 	/*
 	 * Smells like a compiler bug -- it doesn't work
 	 * when the & below is removed.
diff --git a/arch/x86/um/sys_call_table_64.c b/arch/x86/um/sys_call_table_64.c
index f2f0723..9578308 100644
--- a/arch/x86/um/sys_call_table_64.c
+++ b/arch/x86/um/sys_call_table_64.c
@@ -46,7 +46,7 @@ typedef void (*sys_call_ptr_t)(void);
 
 extern void sys_ni_syscall(void);
 
-const sys_call_ptr_t sys_call_table[] __cacheline_aligned = {
+const sys_call_ptr_t sys_call_table[] ____cacheline_aligned = {
 	/*
 	 * Smells like a compiler bug -- it doesn't work
 	 * when the & below is removed.
diff --git a/block/Kconfig.iosched b/block/Kconfig.iosched
index 421bef9..84068c7 100644
--- a/block/Kconfig.iosched
+++ b/block/Kconfig.iosched
@@ -39,6 +39,27 @@ config CFQ_GROUP_IOSCHED
 	---help---
 	  Enable group IO scheduling in CFQ.
 
+config IOSCHED_BFQ
+	tristate "BFQ I/O scheduler"
+	default n
+	---help---
+	  The BFQ I/O scheduler tries to distribute bandwidth among
+	  all processes according to their weights.
+	  It aims at distributing the bandwidth as desired, independently of
+	  the disk parameters and with any workload. It also tries to
+	  guarantee low latency to interactive and soft real-time
+	  applications. If compiled built-in (saying Y here), BFQ can
+	  be configured to support hierarchical scheduling.
+
+config CGROUP_BFQIO
+	bool "BFQ hierarchical scheduling support"
+	depends on CGROUPS && IOSCHED_BFQ=y
+	default n
+	---help---
+	  Enable hierarchical scheduling in BFQ, using the cgroups
+	  filesystem interface.  The name of the subsystem will be
+	  bfqio.	  
+	  
 choice
 	prompt "Default I/O scheduler"
 	default DEFAULT_CFQ
@@ -52,6 +73,9 @@ choice
 	config DEFAULT_CFQ
 		bool "CFQ" if IOSCHED_CFQ=y
 
+	config DEFAULT_BFQ
+		bool "BFQ" if IOSCHED_BFQ=y	
+
 	config DEFAULT_NOOP
 		bool "No-op"
 
@@ -61,6 +85,7 @@ config DEFAULT_IOSCHED
 	string
 	default "deadline" if DEFAULT_DEADLINE
 	default "cfq" if DEFAULT_CFQ
+	default "bfq" if DEFAULT_BFQ
 	default "noop" if DEFAULT_NOOP
 
 endmenu
diff --git a/block/Makefile b/block/Makefile
index 0a0125a..6370e71 100644
--- a/block/Makefile
+++ b/block/Makefile
@@ -15,6 +15,7 @@ obj-$(CONFIG_BLK_DEV_THROTTLING)	+= blk-throttle.o
 obj-$(CONFIG_IOSCHED_NOOP)	+= noop-iosched.o
 obj-$(CONFIG_IOSCHED_DEADLINE)	+= deadline-iosched.o
 obj-$(CONFIG_IOSCHED_CFQ)	+= cfq-iosched.o
+obj-$(CONFIG_IOSCHED_BFQ)	+= bfq-iosched.o
 
 obj-$(CONFIG_BLOCK_COMPAT)	+= compat_ioctl.o
 obj-$(CONFIG_BLK_DEV_INTEGRITY)	+= blk-integrity.o
diff --git a/block/blk-throttle.c b/block/blk-throttle.c
index 3114622..7cddfe6 100644
--- a/block/blk-throttle.c
+++ b/block/blk-throttle.c
@@ -942,6 +942,9 @@ static u64 tg_prfill_cpu_rwstat(struct seq_file *sf,
 	struct blkg_rwstat rwstat = { }, tmp;
 	int i, cpu;
 
+	if (tg->stats_cpu == NULL)
+		return 0;
+
 	for_each_possible_cpu(cpu) {
 		struct tg_stats_cpu *sc = per_cpu_ptr(tg->stats_cpu, cpu);
 
diff --git a/block/cfq-iosched.c b/block/cfq-iosched.c
index c981097..69111c5 100644
--- a/block/cfq-iosched.c
+++ b/block/cfq-iosched.c
@@ -3575,6 +3575,11 @@ retry:
 
 	blkcg = bio_blkcg(bio);
 	cfqg = cfq_lookup_create_cfqg(cfqd, blkcg);
+	if (!cfqg) {
+		cfqq = &cfqd->oom_cfqq;
+		goto out;
+	}
+
 	cfqq = cic_to_cfqq(cic, is_sync);
 
 	/*
@@ -3611,7 +3616,7 @@ retry:
 		} else
 			cfqq = &cfqd->oom_cfqq;
 	}
-
+out:
 	if (new_cfqq)
 		kmem_cache_free(cfq_pool, new_cfqq);
 
@@ -3641,12 +3646,17 @@ static struct cfq_queue *
 cfq_get_queue(struct cfq_data *cfqd, bool is_sync, struct cfq_io_cq *cic,
 	      struct bio *bio, gfp_t gfp_mask)
 {
-	const int ioprio_class = IOPRIO_PRIO_CLASS(cic->ioprio);
-	const int ioprio = IOPRIO_PRIO_DATA(cic->ioprio);
+	int ioprio_class = IOPRIO_PRIO_CLASS(cic->ioprio);
+	int ioprio = IOPRIO_PRIO_DATA(cic->ioprio);
 	struct cfq_queue **async_cfqq = NULL;
 	struct cfq_queue *cfqq = NULL;
 
 	if (!is_sync) {
+		if (!ioprio_valid(cic->ioprio)) {
+			struct task_struct *tsk = current;
+			ioprio = task_nice_ioprio(tsk);
+			ioprio_class = task_nice_ioclass(tsk);
+		}
 		async_cfqq = cfq_async_queue_prio(cfqd, ioprio_class, ioprio);
 		cfqq = *async_cfqq;
 	}
diff --git a/crypto/842.c b/crypto/842.c
index 65c7a89..b48f4f1 100644
--- a/crypto/842.c
+++ b/crypto/842.c
@@ -180,3 +180,4 @@ module_exit(nx842_mod_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("842 Compression Algorithm");
+MODULE_ALIAS_CRYPTO("842");
diff --git a/crypto/aes_generic.c b/crypto/aes_generic.c
index 47f2e5c..e138ad8 100644
--- a/crypto/aes_generic.c
+++ b/crypto/aes_generic.c
@@ -1474,4 +1474,5 @@ module_exit(aes_fini);
 
 MODULE_DESCRIPTION("Rijndael (AES) Cipher Algorithm");
 MODULE_LICENSE("Dual BSD/GPL");
-MODULE_ALIAS("aes");
+MODULE_ALIAS_CRYPTO("aes");
+MODULE_ALIAS_CRYPTO("aes-generic");
diff --git a/crypto/algapi.c b/crypto/algapi.c
index 7a1ae87..00d8d93 100644
--- a/crypto/algapi.c
+++ b/crypto/algapi.c
@@ -495,8 +495,8 @@ static struct crypto_template *__crypto_lookup_template(const char *name)
 
 struct crypto_template *crypto_lookup_template(const char *name)
 {
-	return try_then_request_module(__crypto_lookup_template(name), "%s",
-				       name);
+	return try_then_request_module(__crypto_lookup_template(name),
+				       "crypto-%s", name);
 }
 EXPORT_SYMBOL_GPL(crypto_lookup_template);
 
diff --git a/crypto/ansi_cprng.c b/crypto/ansi_cprng.c
index 666f196..6f5bebc 100644
--- a/crypto/ansi_cprng.c
+++ b/crypto/ansi_cprng.c
@@ -476,4 +476,5 @@ module_param(dbg, int, 0);
 MODULE_PARM_DESC(dbg, "Boolean to enable debugging (0/1 == off/on)");
 module_init(prng_mod_init);
 module_exit(prng_mod_fini);
-MODULE_ALIAS("stdrng");
+MODULE_ALIAS_CRYPTO("stdrng");
+MODULE_ALIAS_CRYPTO("ansi_cprng");
diff --git a/crypto/anubis.c b/crypto/anubis.c
index 008c8a4..4bb187c 100644
--- a/crypto/anubis.c
+++ b/crypto/anubis.c
@@ -704,3 +704,4 @@ module_exit(anubis_mod_fini);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Anubis Cryptographic Algorithm");
+MODULE_ALIAS_CRYPTO("anubis");
diff --git a/crypto/api.c b/crypto/api.c
index 37c4c72..335abea 100644
--- a/crypto/api.c
+++ b/crypto/api.c
@@ -216,11 +216,11 @@ struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)
 
 	alg = crypto_alg_lookup(name, type, mask);
 	if (!alg) {
-		request_module("%s", name);
+		request_module("crypto-%s", name);
 
 		if (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &
 		      CRYPTO_ALG_NEED_FALLBACK))
-			request_module("%s-all", name);
+			request_module("crypto-%s-all", name);
 
 		alg = crypto_alg_lookup(name, type, mask);
 	}
diff --git a/crypto/arc4.c b/crypto/arc4.c
index 5a772c3..f1a8192 100644
--- a/crypto/arc4.c
+++ b/crypto/arc4.c
@@ -166,3 +166,4 @@ module_exit(arc4_exit);
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("ARC4 Cipher Algorithm");
 MODULE_AUTHOR("Jon Oberheide <jon@oberheide.org>");
+MODULE_ALIAS_CRYPTO("arc4");
diff --git a/crypto/authenc.c b/crypto/authenc.c
index 528b00b..a2cfae2 100644
--- a/crypto/authenc.c
+++ b/crypto/authenc.c
@@ -709,3 +709,4 @@ module_exit(crypto_authenc_module_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Simple AEAD wrapper for IPsec");
+MODULE_ALIAS_CRYPTO("authenc");
diff --git a/crypto/authencesn.c b/crypto/authencesn.c
index ab53762..16c225c 100644
--- a/crypto/authencesn.c
+++ b/crypto/authencesn.c
@@ -832,3 +832,4 @@ module_exit(crypto_authenc_esn_module_exit);
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Steffen Klassert <steffen.klassert@secunet.com>");
 MODULE_DESCRIPTION("AEAD wrapper for IPsec with extended sequence numbers");
+MODULE_ALIAS_CRYPTO("authencesn");
diff --git a/crypto/blowfish_generic.c b/crypto/blowfish_generic.c
index 8baf544..87b392a 100644
--- a/crypto/blowfish_generic.c
+++ b/crypto/blowfish_generic.c
@@ -138,4 +138,5 @@ module_exit(blowfish_mod_fini);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Blowfish Cipher Algorithm");
-MODULE_ALIAS("blowfish");
+MODULE_ALIAS_CRYPTO("blowfish");
+MODULE_ALIAS_CRYPTO("blowfish-generic");
diff --git a/crypto/camellia_generic.c b/crypto/camellia_generic.c
index 75efa20..029587f 100644
--- a/crypto/camellia_generic.c
+++ b/crypto/camellia_generic.c
@@ -1098,4 +1098,5 @@ module_exit(camellia_fini);
 
 MODULE_DESCRIPTION("Camellia Cipher Algorithm");
 MODULE_LICENSE("GPL");
-MODULE_ALIAS("camellia");
+MODULE_ALIAS_CRYPTO("camellia");
+MODULE_ALIAS_CRYPTO("camellia-generic");
diff --git a/crypto/cast5_generic.c b/crypto/cast5_generic.c
index 5558f63..df5c726 100644
--- a/crypto/cast5_generic.c
+++ b/crypto/cast5_generic.c
@@ -549,4 +549,5 @@ module_exit(cast5_mod_fini);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Cast5 Cipher Algorithm");
-MODULE_ALIAS("cast5");
+MODULE_ALIAS_CRYPTO("cast5");
+MODULE_ALIAS_CRYPTO("cast5-generic");
diff --git a/crypto/cast6_generic.c b/crypto/cast6_generic.c
index de73252..058c8d7 100644
--- a/crypto/cast6_generic.c
+++ b/crypto/cast6_generic.c
@@ -291,4 +291,5 @@ module_exit(cast6_mod_fini);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Cast6 Cipher Algorithm");
-MODULE_ALIAS("cast6");
+MODULE_ALIAS_CRYPTO("cast6");
+MODULE_ALIAS_CRYPTO("cast6-generic");
diff --git a/crypto/cbc.c b/crypto/cbc.c
index 61ac42e..780ee27 100644
--- a/crypto/cbc.c
+++ b/crypto/cbc.c
@@ -289,3 +289,4 @@ module_exit(crypto_cbc_module_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("CBC block cipher algorithm");
+MODULE_ALIAS_CRYPTO("cbc");
diff --git a/crypto/ccm.c b/crypto/ccm.c
index ed009b7..c569c9c 100644
--- a/crypto/ccm.c
+++ b/crypto/ccm.c
@@ -879,5 +879,6 @@ module_exit(crypto_ccm_module_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Counter with CBC MAC");
-MODULE_ALIAS("ccm_base");
-MODULE_ALIAS("rfc4309");
+MODULE_ALIAS_CRYPTO("ccm_base");
+MODULE_ALIAS_CRYPTO("rfc4309");
+MODULE_ALIAS_CRYPTO("ccm");
diff --git a/crypto/chainiv.c b/crypto/chainiv.c
index 834d8dd..22b7e55 100644
--- a/crypto/chainiv.c
+++ b/crypto/chainiv.c
@@ -359,3 +359,4 @@ module_exit(chainiv_module_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Chain IV Generator");
+MODULE_ALIAS_CRYPTO("chainiv");
diff --git a/crypto/cmac.c b/crypto/cmac.c
index 50880cf..7a8bfbd 100644
--- a/crypto/cmac.c
+++ b/crypto/cmac.c
@@ -313,3 +313,4 @@ module_exit(crypto_cmac_module_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("CMAC keyed hash algorithm");
+MODULE_ALIAS_CRYPTO("cmac");
diff --git a/crypto/crc32.c b/crypto/crc32.c
index 9d1c415..187ded2 100644
--- a/crypto/crc32.c
+++ b/crypto/crc32.c
@@ -156,3 +156,4 @@ module_exit(crc32_mod_fini);
 MODULE_AUTHOR("Alexander Boyko <alexander_boyko@xyratex.com>");
 MODULE_DESCRIPTION("CRC32 calculations wrapper for lib/crc32");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS_CRYPTO("crc32");
diff --git a/crypto/crc32c.c b/crypto/crc32c.c
index 06f7018..238f0e6 100644
--- a/crypto/crc32c.c
+++ b/crypto/crc32c.c
@@ -170,3 +170,4 @@ module_exit(crc32c_mod_fini);
 MODULE_AUTHOR("Clay Haapala <chaapala@cisco.com>");
 MODULE_DESCRIPTION("CRC32c (Castagnoli) calculations wrapper for lib/crc32c");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS_CRYPTO("crc32c");
diff --git a/crypto/cryptd.c b/crypto/cryptd.c
index 7bdd61b..75c415d 100644
--- a/crypto/cryptd.c
+++ b/crypto/cryptd.c
@@ -955,3 +955,4 @@ module_exit(cryptd_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Software async crypto daemon");
+MODULE_ALIAS_CRYPTO("cryptd");
diff --git a/crypto/crypto_null.c b/crypto/crypto_null.c
index fee7265..7b39fa3 100644
--- a/crypto/crypto_null.c
+++ b/crypto/crypto_null.c
@@ -149,9 +149,9 @@ static struct crypto_alg null_algs[3] = { {
 	.coa_decompress		=	null_compress } }
 } };
 
-MODULE_ALIAS("compress_null");
-MODULE_ALIAS("digest_null");
-MODULE_ALIAS("cipher_null");
+MODULE_ALIAS_CRYPTO("compress_null");
+MODULE_ALIAS_CRYPTO("digest_null");
+MODULE_ALIAS_CRYPTO("cipher_null");
 
 static int __init crypto_null_mod_init(void)
 {
diff --git a/crypto/ctr.c b/crypto/ctr.c
index f2b94f2..2386f73 100644
--- a/crypto/ctr.c
+++ b/crypto/ctr.c
@@ -466,4 +466,5 @@ module_exit(crypto_ctr_module_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("CTR Counter block mode");
-MODULE_ALIAS("rfc3686");
+MODULE_ALIAS_CRYPTO("rfc3686");
+MODULE_ALIAS_CRYPTO("ctr");
diff --git a/crypto/cts.c b/crypto/cts.c
index 042223f..60b9da3 100644
--- a/crypto/cts.c
+++ b/crypto/cts.c
@@ -350,3 +350,4 @@ module_exit(crypto_cts_module_exit);
 
 MODULE_LICENSE("Dual BSD/GPL");
 MODULE_DESCRIPTION("CTS-CBC CipherText Stealing for CBC");
+MODULE_ALIAS_CRYPTO("cts");
diff --git a/crypto/deflate.c b/crypto/deflate.c
index b57d70e..95d8d37 100644
--- a/crypto/deflate.c
+++ b/crypto/deflate.c
@@ -222,4 +222,4 @@ module_exit(deflate_mod_fini);
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Deflate Compression Algorithm for IPCOMP");
 MODULE_AUTHOR("James Morris <jmorris@intercode.com.au>");
-
+MODULE_ALIAS_CRYPTO("deflate");
diff --git a/crypto/des_generic.c b/crypto/des_generic.c
index f6cf63f..3ec6071 100644
--- a/crypto/des_generic.c
+++ b/crypto/des_generic.c
@@ -971,8 +971,6 @@ static struct crypto_alg des_algs[2] = { {
 	.cia_decrypt		=	des3_ede_decrypt } }
 } };
 
-MODULE_ALIAS("des3_ede");
-
 static int __init des_generic_mod_init(void)
 {
 	return crypto_register_algs(des_algs, ARRAY_SIZE(des_algs));
@@ -989,4 +987,7 @@ module_exit(des_generic_mod_fini);
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("DES & Triple DES EDE Cipher Algorithms");
 MODULE_AUTHOR("Dag Arne Osvik <da@osvik.no>");
-MODULE_ALIAS("des");
+MODULE_ALIAS_CRYPTO("des");
+MODULE_ALIAS_CRYPTO("des-generic");
+MODULE_ALIAS_CRYPTO("des3_ede");
+MODULE_ALIAS_CRYPTO("des3_ede-generic");
diff --git a/crypto/ecb.c b/crypto/ecb.c
index 935cfef..12011af 100644
--- a/crypto/ecb.c
+++ b/crypto/ecb.c
@@ -185,3 +185,4 @@ module_exit(crypto_ecb_module_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("ECB block cipher algorithm");
+MODULE_ALIAS_CRYPTO("ecb");
diff --git a/crypto/eseqiv.c b/crypto/eseqiv.c
index 42ce9f5..388f582 100644
--- a/crypto/eseqiv.c
+++ b/crypto/eseqiv.c
@@ -267,3 +267,4 @@ module_exit(eseqiv_module_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Encrypted Sequence Number IV Generator");
+MODULE_ALIAS_CRYPTO("eseqiv");
diff --git a/crypto/fcrypt.c b/crypto/fcrypt.c
index 3b2cf56..300f5b8 100644
--- a/crypto/fcrypt.c
+++ b/crypto/fcrypt.c
@@ -420,3 +420,4 @@ module_exit(fcrypt_mod_fini);
 MODULE_LICENSE("Dual BSD/GPL");
 MODULE_DESCRIPTION("FCrypt Cipher Algorithm");
 MODULE_AUTHOR("David Howells <dhowells@redhat.com>");
+MODULE_ALIAS_CRYPTO("fcrypt");
diff --git a/crypto/gcm.c b/crypto/gcm.c
index 43e1fb0..b4c2520 100644
--- a/crypto/gcm.c
+++ b/crypto/gcm.c
@@ -1441,6 +1441,7 @@ module_exit(crypto_gcm_module_exit);
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Galois/Counter Mode");
 MODULE_AUTHOR("Mikko Herranen <mh1@iki.fi>");
-MODULE_ALIAS("gcm_base");
-MODULE_ALIAS("rfc4106");
-MODULE_ALIAS("rfc4543");
+MODULE_ALIAS_CRYPTO("gcm_base");
+MODULE_ALIAS_CRYPTO("rfc4106");
+MODULE_ALIAS_CRYPTO("rfc4543");
+MODULE_ALIAS_CRYPTO("gcm");
diff --git a/crypto/ghash-generic.c b/crypto/ghash-generic.c
index 9d3f0c6..bac7099 100644
--- a/crypto/ghash-generic.c
+++ b/crypto/ghash-generic.c
@@ -172,4 +172,5 @@ module_exit(ghash_mod_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("GHASH Message Digest Algorithm");
-MODULE_ALIAS("ghash");
+MODULE_ALIAS_CRYPTO("ghash");
+MODULE_ALIAS_CRYPTO("ghash-generic");
diff --git a/crypto/hmac.c b/crypto/hmac.c
index 8d9544c..ade790b 100644
--- a/crypto/hmac.c
+++ b/crypto/hmac.c
@@ -271,3 +271,4 @@ module_exit(hmac_module_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("HMAC hash algorithm");
+MODULE_ALIAS_CRYPTO("hmac");
diff --git a/crypto/khazad.c b/crypto/khazad.c
index 60e7cd6..873eb5d 100644
--- a/crypto/khazad.c
+++ b/crypto/khazad.c
@@ -880,3 +880,4 @@ module_exit(khazad_mod_fini);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Khazad Cryptographic Algorithm");
+MODULE_ALIAS_CRYPTO("khazad");
diff --git a/crypto/krng.c b/crypto/krng.c
index a2d2b72..0224841 100644
--- a/crypto/krng.c
+++ b/crypto/krng.c
@@ -62,4 +62,5 @@ module_exit(krng_mod_fini);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Kernel Random Number Generator");
-MODULE_ALIAS("stdrng");
+MODULE_ALIAS_CRYPTO("stdrng");
+MODULE_ALIAS_CRYPTO("krng");
diff --git a/crypto/lrw.c b/crypto/lrw.c
index ba42acc..6f9908a 100644
--- a/crypto/lrw.c
+++ b/crypto/lrw.c
@@ -400,3 +400,4 @@ module_exit(crypto_module_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("LRW block cipher mode");
+MODULE_ALIAS_CRYPTO("lrw");
diff --git a/crypto/lzo.c b/crypto/lzo.c
index 1c2aa69..d1ff694 100644
--- a/crypto/lzo.c
+++ b/crypto/lzo.c
@@ -103,3 +103,4 @@ module_exit(lzo_mod_fini);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("LZO Compression Algorithm");
+MODULE_ALIAS_CRYPTO("lzo");
diff --git a/crypto/md4.c b/crypto/md4.c
index 0477a6a..3515af4 100644
--- a/crypto/md4.c
+++ b/crypto/md4.c
@@ -255,4 +255,4 @@ module_exit(md4_mod_fini);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("MD4 Message Digest Algorithm");
-
+MODULE_ALIAS_CRYPTO("md4");
diff --git a/crypto/md5.c b/crypto/md5.c
index 7febeaa..36f5e5b 100644
--- a/crypto/md5.c
+++ b/crypto/md5.c
@@ -168,3 +168,4 @@ module_exit(md5_mod_fini);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("MD5 Message Digest Algorithm");
+MODULE_ALIAS_CRYPTO("md5");
diff --git a/crypto/michael_mic.c b/crypto/michael_mic.c
index 079b761..46195e0 100644
--- a/crypto/michael_mic.c
+++ b/crypto/michael_mic.c
@@ -184,3 +184,4 @@ module_exit(michael_mic_exit);
 MODULE_LICENSE("GPL v2");
 MODULE_DESCRIPTION("Michael MIC");
 MODULE_AUTHOR("Jouni Malinen <j@w1.fi>");
+MODULE_ALIAS_CRYPTO("michael_mic");
diff --git a/crypto/pcbc.c b/crypto/pcbc.c
index d1b8bdf..f654965 100644
--- a/crypto/pcbc.c
+++ b/crypto/pcbc.c
@@ -295,3 +295,4 @@ module_exit(crypto_pcbc_module_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("PCBC block cipher algorithm");
+MODULE_ALIAS_CRYPTO("pcbc");
diff --git a/crypto/pcrypt.c b/crypto/pcrypt.c
index b2c99dc..61ff946 100644
--- a/crypto/pcrypt.c
+++ b/crypto/pcrypt.c
@@ -565,3 +565,4 @@ module_exit(pcrypt_exit);
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Steffen Klassert <steffen.klassert@secunet.com>");
 MODULE_DESCRIPTION("Parallel crypto wrapper");
+MODULE_ALIAS_CRYPTO("pcrypt");
diff --git a/crypto/rmd128.c b/crypto/rmd128.c
index 8a0f68b..049486e 100644
--- a/crypto/rmd128.c
+++ b/crypto/rmd128.c
@@ -327,3 +327,4 @@ module_exit(rmd128_mod_fini);
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Adrian-Ken Rueegsegger <ken@codelabs.ch>");
 MODULE_DESCRIPTION("RIPEMD-128 Message Digest");
+MODULE_ALIAS_CRYPTO("rmd128");
diff --git a/crypto/rmd160.c b/crypto/rmd160.c
index 525d7bb..de585e5 100644
--- a/crypto/rmd160.c
+++ b/crypto/rmd160.c
@@ -371,3 +371,4 @@ module_exit(rmd160_mod_fini);
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Adrian-Ken Rueegsegger <ken@codelabs.ch>");
 MODULE_DESCRIPTION("RIPEMD-160 Message Digest");
+MODULE_ALIAS_CRYPTO("rmd160");
diff --git a/crypto/rmd256.c b/crypto/rmd256.c
index 69293d9..4ec02a7 100644
--- a/crypto/rmd256.c
+++ b/crypto/rmd256.c
@@ -346,3 +346,4 @@ module_exit(rmd256_mod_fini);
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Adrian-Ken Rueegsegger <ken@codelabs.ch>");
 MODULE_DESCRIPTION("RIPEMD-256 Message Digest");
+MODULE_ALIAS_CRYPTO("rmd256");
diff --git a/crypto/rmd320.c b/crypto/rmd320.c
index 09f97df..770f2cb 100644
--- a/crypto/rmd320.c
+++ b/crypto/rmd320.c
@@ -395,3 +395,4 @@ module_exit(rmd320_mod_fini);
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Adrian-Ken Rueegsegger <ken@codelabs.ch>");
 MODULE_DESCRIPTION("RIPEMD-320 Message Digest");
+MODULE_ALIAS_CRYPTO("rmd320");
diff --git a/crypto/salsa20_generic.c b/crypto/salsa20_generic.c
index 9a4770c..f550b5d 100644
--- a/crypto/salsa20_generic.c
+++ b/crypto/salsa20_generic.c
@@ -248,4 +248,5 @@ module_exit(salsa20_generic_mod_fini);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION ("Salsa20 stream cipher algorithm");
-MODULE_ALIAS("salsa20");
+MODULE_ALIAS_CRYPTO("salsa20");
+MODULE_ALIAS_CRYPTO("salsa20-generic");
diff --git a/crypto/seed.c b/crypto/seed.c
index 9c904d6..c6ba843 100644
--- a/crypto/seed.c
+++ b/crypto/seed.c
@@ -476,3 +476,4 @@ module_exit(seed_fini);
 MODULE_DESCRIPTION("SEED Cipher Algorithm");
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Hye-Shik Chang <perky@FreeBSD.org>, Kim Hyun <hkim@kisa.or.kr>");
+MODULE_ALIAS_CRYPTO("seed");
diff --git a/crypto/seqiv.c b/crypto/seqiv.c
index f2cba4ed..49a4069 100644
--- a/crypto/seqiv.c
+++ b/crypto/seqiv.c
@@ -362,3 +362,4 @@ module_exit(seqiv_module_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Sequence Number IV Generator");
+MODULE_ALIAS_CRYPTO("seqiv");
diff --git a/crypto/serpent_generic.c b/crypto/serpent_generic.c
index 7ddbd7e..94970a7 100644
--- a/crypto/serpent_generic.c
+++ b/crypto/serpent_generic.c
@@ -665,5 +665,6 @@ module_exit(serpent_mod_fini);
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Serpent and tnepres (kerneli compatible serpent reversed) Cipher Algorithm");
 MODULE_AUTHOR("Dag Arne Osvik <osvik@ii.uib.no>");
-MODULE_ALIAS("tnepres");
-MODULE_ALIAS("serpent");
+MODULE_ALIAS_CRYPTO("tnepres");
+MODULE_ALIAS_CRYPTO("serpent");
+MODULE_ALIAS_CRYPTO("serpent-generic");
diff --git a/crypto/sha1_generic.c b/crypto/sha1_generic.c
index 4279480..fdf7c00 100644
--- a/crypto/sha1_generic.c
+++ b/crypto/sha1_generic.c
@@ -153,4 +153,5 @@ module_exit(sha1_generic_mod_fini);
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("SHA1 Secure Hash Algorithm");
 
-MODULE_ALIAS("sha1");
+MODULE_ALIAS_CRYPTO("sha1");
+MODULE_ALIAS_CRYPTO("sha1-generic");
diff --git a/crypto/sha256_generic.c b/crypto/sha256_generic.c
index 5433667..136381b 100644
--- a/crypto/sha256_generic.c
+++ b/crypto/sha256_generic.c
@@ -384,5 +384,7 @@ module_exit(sha256_generic_mod_fini);
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("SHA-224 and SHA-256 Secure Hash Algorithm");
 
-MODULE_ALIAS("sha224");
-MODULE_ALIAS("sha256");
+MODULE_ALIAS_CRYPTO("sha224");
+MODULE_ALIAS_CRYPTO("sha224-generic");
+MODULE_ALIAS_CRYPTO("sha256");
+MODULE_ALIAS_CRYPTO("sha256-generic");
diff --git a/crypto/sha512_generic.c b/crypto/sha512_generic.c
index 4c58620..fb2d7b8 100644
--- a/crypto/sha512_generic.c
+++ b/crypto/sha512_generic.c
@@ -285,5 +285,7 @@ module_exit(sha512_generic_mod_fini);
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("SHA-512 and SHA-384 Secure Hash Algorithms");
 
-MODULE_ALIAS("sha384");
-MODULE_ALIAS("sha512");
+MODULE_ALIAS_CRYPTO("sha384");
+MODULE_ALIAS_CRYPTO("sha384-generic");
+MODULE_ALIAS_CRYPTO("sha512");
+MODULE_ALIAS_CRYPTO("sha512-generic");
diff --git a/crypto/tea.c b/crypto/tea.c
index 0a57232..b70b441 100644
--- a/crypto/tea.c
+++ b/crypto/tea.c
@@ -270,8 +270,9 @@ static void __exit tea_mod_fini(void)
 	crypto_unregister_algs(tea_algs, ARRAY_SIZE(tea_algs));
 }
 
-MODULE_ALIAS("xtea");
-MODULE_ALIAS("xeta");
+MODULE_ALIAS_CRYPTO("tea");
+MODULE_ALIAS_CRYPTO("xtea");
+MODULE_ALIAS_CRYPTO("xeta");
 
 module_init(tea_mod_init);
 module_exit(tea_mod_fini);
diff --git a/crypto/tgr192.c b/crypto/tgr192.c
index 8740355..f7ed2fb 100644
--- a/crypto/tgr192.c
+++ b/crypto/tgr192.c
@@ -676,8 +676,9 @@ static void __exit tgr192_mod_fini(void)
 	crypto_unregister_shashes(tgr_algs, ARRAY_SIZE(tgr_algs));
 }
 
-MODULE_ALIAS("tgr160");
-MODULE_ALIAS("tgr128");
+MODULE_ALIAS_CRYPTO("tgr192");
+MODULE_ALIAS_CRYPTO("tgr160");
+MODULE_ALIAS_CRYPTO("tgr128");
 
 module_init(tgr192_mod_init);
 module_exit(tgr192_mod_fini);
diff --git a/crypto/twofish_generic.c b/crypto/twofish_generic.c
index 2d50005..ebf7a3e 100644
--- a/crypto/twofish_generic.c
+++ b/crypto/twofish_generic.c
@@ -211,4 +211,5 @@ module_exit(twofish_mod_fini);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION ("Twofish Cipher Algorithm");
-MODULE_ALIAS("twofish");
+MODULE_ALIAS_CRYPTO("twofish");
+MODULE_ALIAS_CRYPTO("twofish-generic");
diff --git a/crypto/vmac.c b/crypto/vmac.c
index 2eb11a3..bf2d3a8 100644
--- a/crypto/vmac.c
+++ b/crypto/vmac.c
@@ -713,3 +713,4 @@ module_exit(vmac_module_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("VMAC hash algorithm");
+MODULE_ALIAS_CRYPTO("vmac");
diff --git a/crypto/wp512.c b/crypto/wp512.c
index 180f1d6..253db94 100644
--- a/crypto/wp512.c
+++ b/crypto/wp512.c
@@ -1167,8 +1167,9 @@ static void __exit wp512_mod_fini(void)
 	crypto_unregister_shashes(wp_algs, ARRAY_SIZE(wp_algs));
 }
 
-MODULE_ALIAS("wp384");
-MODULE_ALIAS("wp256");
+MODULE_ALIAS_CRYPTO("wp512");
+MODULE_ALIAS_CRYPTO("wp384");
+MODULE_ALIAS_CRYPTO("wp256");
 
 module_init(wp512_mod_init);
 module_exit(wp512_mod_fini);
diff --git a/crypto/xcbc.c b/crypto/xcbc.c
index a5fbdf3..df90b33 100644
--- a/crypto/xcbc.c
+++ b/crypto/xcbc.c
@@ -286,3 +286,4 @@ module_exit(crypto_xcbc_module_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("XCBC keyed hash algorithm");
+MODULE_ALIAS_CRYPTO("xcbc");
diff --git a/crypto/xts.c b/crypto/xts.c
index ca1608f..f6fd43f 100644
--- a/crypto/xts.c
+++ b/crypto/xts.c
@@ -362,3 +362,4 @@ module_exit(crypto_module_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("XTS block cipher mode");
+MODULE_ALIAS_CRYPTO("xts");
diff --git a/crypto/zlib.c b/crypto/zlib.c
index 06b62e5..d980788 100644
--- a/crypto/zlib.c
+++ b/crypto/zlib.c
@@ -378,3 +378,4 @@ module_exit(zlib_mod_fini);
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Zlib Compression Algorithm");
 MODULE_AUTHOR("Sony Corporation");
+MODULE_ALIAS_CRYPTO("zlib");
diff --git a/drivers/acpi/video.c b/drivers/acpi/video.c
index 82a01cc..0dc9ff6 100644
--- a/drivers/acpi/video.c
+++ b/drivers/acpi/video.c
@@ -1953,6 +1953,17 @@ EXPORT_SYMBOL(acpi_video_unregister);
 
 static int __init acpi_video_init(void)
 {
+	/*
+	 * Let the module load even if ACPI is disabled (e.g. due to
+	 * a broken BIOS) so that i915.ko can still be loaded on such
+	 * old systems without an AcpiOpRegion.
+	 *
+	 * acpi_video_register() will report -ENODEV later as well due
+	 * to acpi_disabled when i915.ko tries to register itself afterwards.
+	 */
+	if (acpi_disabled)
+		return 0;
+
 	dmi_check_system(video_dmi_table);
 
 	if (intel_opregion_present())
diff --git a/drivers/ata/libata-sff.c b/drivers/ata/libata-sff.c
index 37acda6..136803c 100644
--- a/drivers/ata/libata-sff.c
+++ b/drivers/ata/libata-sff.c
@@ -1333,7 +1333,19 @@ void ata_sff_flush_pio_task(struct ata_port *ap)
 	DPRINTK("ENTER\n");
 
 	cancel_delayed_work_sync(&ap->sff_pio_task);
+
+	/*
+	 * We wanna reset the HSM state to IDLE.  If we do so without
+	 * grabbing the port lock, critical sections protected by it which
+	 * expect the HSM state to stay stable may get surprised.  For
+	 * example, we may set IDLE in between the time
+	 * __ata_sff_port_intr() checks for HSM_ST_IDLE and before it calls
+	 * ata_sff_hsm_move() causing ata_sff_hsm_move() to BUG().
+	 */
+	spin_lock_irq(ap->lock);
 	ap->hsm_task_state = HSM_ST_IDLE;
+	spin_unlock_irq(ap->lock);
+
 	ap->sff_pio_task_link = NULL;
 
 	if (ata_msg_ctl(ap))
diff --git a/drivers/ata/sata_dwc_460ex.c b/drivers/ata/sata_dwc_460ex.c
index 2e39173..776b59f 100644
--- a/drivers/ata/sata_dwc_460ex.c
+++ b/drivers/ata/sata_dwc_460ex.c
@@ -797,7 +797,7 @@ static int dma_dwc_init(struct sata_dwc_device *hsdev, int irq)
 	if (err) {
 		dev_err(host_pvt.dwc_dev, "%s: dma_request_interrupts returns"
 			" %d\n", __func__, err);
-		goto error_out;
+		return err;
 	}
 
 	/* Enabe DMA */
@@ -808,11 +808,6 @@ static int dma_dwc_init(struct sata_dwc_device *hsdev, int irq)
 		sata_dma_regs);
 
 	return 0;
-
-error_out:
-	dma_dwc_exit(hsdev);
-
-	return err;
 }
 
 static int sata_dwc_scr_read(struct ata_link *link, unsigned int scr, u32 *val)
@@ -1662,7 +1657,7 @@ static int sata_dwc_probe(struct platform_device *ofdev)
 	char *ver = (char *)&versionr;
 	u8 *base = NULL;
 	int err = 0;
-	int irq, rc;
+	int irq;
 	struct ata_host *host;
 	struct ata_port_info pi = sata_dwc_port_info[0];
 	const struct ata_port_info *ppi[] = { &pi, NULL };
@@ -1725,7 +1720,7 @@ static int sata_dwc_probe(struct platform_device *ofdev)
 	if (irq == NO_IRQ) {
 		dev_err(&ofdev->dev, "no SATA DMA irq\n");
 		err = -ENODEV;
-		goto error_out;
+		goto error_iomap;
 	}
 
 	/* Get physical SATA DMA register base address */
@@ -1734,14 +1729,16 @@ static int sata_dwc_probe(struct platform_device *ofdev)
 		dev_err(&ofdev->dev, "ioremap failed for AHBDMA register"
 			" address\n");
 		err = -ENODEV;
-		goto error_out;
+		goto error_iomap;
 	}
 
 	/* Save dev for later use in dev_xxx() routines */
 	host_pvt.dwc_dev = &ofdev->dev;
 
 	/* Initialize AHB DMAC */
-	dma_dwc_init(hsdev, irq);
+	err = dma_dwc_init(hsdev, irq);
+	if (err)
+		goto error_dma_iomap;
 
 	/* Enable SATA Interrupts */
 	sata_dwc_enable_interrupts(hsdev);
@@ -1759,9 +1756,8 @@ static int sata_dwc_probe(struct platform_device *ofdev)
 	 * device discovery process, invoking our port_start() handler &
 	 * error_handler() to execute a dummy Softreset EH session
 	 */
-	rc = ata_host_activate(host, irq, sata_dwc_isr, 0, &sata_dwc_sht);
-
-	if (rc != 0)
+	err = ata_host_activate(host, irq, sata_dwc_isr, 0, &sata_dwc_sht);
+	if (err)
 		dev_err(&ofdev->dev, "failed to activate host");
 
 	dev_set_drvdata(&ofdev->dev, host);
@@ -1770,7 +1766,8 @@ static int sata_dwc_probe(struct platform_device *ofdev)
 error_out:
 	/* Free SATA DMA resources */
 	dma_dwc_exit(hsdev);
-
+error_dma_iomap:
+	iounmap((void __iomem *)host_pvt.sata_dma_regs);
 error_iomap:
 	iounmap(base);
 error_kmalloc:
@@ -1791,6 +1788,7 @@ static int sata_dwc_remove(struct platform_device *ofdev)
 	/* Free SATA DMA resources */
 	dma_dwc_exit(hsdev);
 
+	iounmap((void __iomem *)host_pvt.sata_dma_regs);
 	iounmap(hsdev->reg_base);
 	kfree(hsdev);
 	kfree(host);
diff --git a/drivers/base/power/main.c b/drivers/base/power/main.c
index bc0e7a9..7f0cda6 100644
--- a/drivers/base/power/main.c
+++ b/drivers/base/power/main.c
@@ -36,7 +36,7 @@
 #include "../base.h"
 #include "power.h"
 
-#define LOG
+// #define LOG
 
 #define HIB_DPM_DEBUG 0
 #define _TAG_HIB_M "HIB/DPM"
diff --git a/drivers/block/drbd/drbd_req.c b/drivers/block/drbd/drbd_req.c
index c24379f..b2ae184 100644
--- a/drivers/block/drbd/drbd_req.c
+++ b/drivers/block/drbd/drbd_req.c
@@ -1309,6 +1309,7 @@ int drbd_merge_bvec(struct request_queue *q, struct bvec_merge_data *bvm, struct
 		struct request_queue * const b =
 			mdev->ldev->backing_bdev->bd_disk->queue;
 		if (b->merge_bvec_fn) {
+			bvm->bi_bdev = mdev->ldev->backing_bdev;
 			backing_limit = b->merge_bvec_fn(b, bvm, bvec);
 			limit = min(limit, backing_limit);
 		}
diff --git a/drivers/block/rbd.c b/drivers/block/rbd.c
index 9951e66..7e3f451 100644
--- a/drivers/block/rbd.c
+++ b/drivers/block/rbd.c
@@ -2149,7 +2149,6 @@ static void rbd_img_obj_callback(struct rbd_obj_request *obj_request)
 	rbd_assert(img_request->obj_request_count > 0);
 	rbd_assert(which != BAD_WHICH);
 	rbd_assert(which < img_request->obj_request_count);
-	rbd_assert(which >= img_request->next_completion);
 
 	spin_lock_irq(&img_request->completion_lock);
 	if (which != img_request->next_completion)
diff --git a/drivers/bluetooth/ath3k.c b/drivers/bluetooth/ath3k.c
index 2acabda..dad8891 100644
--- a/drivers/bluetooth/ath3k.c
+++ b/drivers/bluetooth/ath3k.c
@@ -151,6 +151,8 @@ static struct usb_device_id ath3k_blist_tbl[] = {
 #define USB_REQ_DFU_DNLOAD	1
 #define BULK_SIZE		4096
 #define FW_HDR_SIZE		20
+#define TIMEGAP_USEC_MIN	50
+#define TIMEGAP_USEC_MAX	100
 
 static int ath3k_load_firmware(struct usb_device *udev,
 				const struct firmware *firmware)
@@ -181,6 +183,9 @@ static int ath3k_load_firmware(struct usb_device *udev,
 	count -= 20;
 
 	while (count) {
+		/* workaround the compatibility issue with xHCI controller*/
+		usleep_range(TIMEGAP_USEC_MIN, TIMEGAP_USEC_MAX);
+
 		size = min_t(uint, count, BULK_SIZE);
 		pipe = usb_sndbulkpipe(udev, 0x02);
 		memcpy(send_buf, firmware->data + sent, size);
@@ -277,6 +282,9 @@ static int ath3k_load_fwfile(struct usb_device *udev,
 	count -= size;
 
 	while (count) {
+		/* workaround the compatibility issue with xHCI controller*/
+		usleep_range(TIMEGAP_USEC_MIN, TIMEGAP_USEC_MAX);
+
 		size = min_t(uint, count, BULK_SIZE);
 		pipe = usb_sndbulkpipe(udev, 0x02);
 
diff --git a/drivers/bus/mvebu-mbus.c b/drivers/bus/mvebu-mbus.c
index 5dcc830..711dcf4 100644
--- a/drivers/bus/mvebu-mbus.c
+++ b/drivers/bus/mvebu-mbus.c
@@ -209,12 +209,25 @@ static void mvebu_mbus_disable_window(struct mvebu_mbus_state *mbus,
 }
 
 /* Checks whether the given window number is available */
+
+/* On Armada XP, 375 and 38x the MBus window 13 has the remap
+ * capability, like windows 0 to 7. However, the mvebu-mbus driver
+ * isn't currently taking into account this special case, which means
+ * that when window 13 is actually used, the remap registers are left
+ * to 0, making the device using this MBus window unavailable. The
+ * quick fix for stable is to not use window 13. A follow up patch
+ * will correctly handle this window.
+*/
 static int mvebu_mbus_window_is_free(struct mvebu_mbus_state *mbus,
 				     const int win)
 {
 	void __iomem *addr = mbus->mbuswins_base +
 		mbus->soc->win_cfg_offset(win);
 	u32 ctrl = readl(addr + WIN_CTRL_OFF);
+
+	if (win == 13)
+		return false;
+
 	return !(ctrl & WIN_CTRL_ENABLE);
 }
 
diff --git a/drivers/char/tpm/tpm_i2c_stm_st33.c b/drivers/char/tpm/tpm_i2c_stm_st33.c
index 156bd3c..3925f7b 100644
--- a/drivers/char/tpm/tpm_i2c_stm_st33.c
+++ b/drivers/char/tpm/tpm_i2c_stm_st33.c
@@ -488,7 +488,7 @@ static int tpm_stm_i2c_send(struct tpm_chip *chip, unsigned char *buf,
 		if (burstcnt < 0)
 			return burstcnt;
 		size = min_t(int, len - i - 1, burstcnt);
-		ret = I2C_WRITE_DATA(client, TPM_DATA_FIFO, buf, size);
+		ret = I2C_WRITE_DATA(client, TPM_DATA_FIFO, buf + i, size);
 		if (ret < 0)
 			goto out_err;
 
diff --git a/drivers/char/tpm/tpm_ibmvtpm.c b/drivers/char/tpm/tpm_ibmvtpm.c
index 56b07c3..538856f 100644
--- a/drivers/char/tpm/tpm_ibmvtpm.c
+++ b/drivers/char/tpm/tpm_ibmvtpm.c
@@ -148,7 +148,8 @@ static int tpm_ibmvtpm_send(struct tpm_chip *chip, u8 *buf, size_t count)
 	crq.len = (u16)count;
 	crq.data = ibmvtpm->rtce_dma_handle;
 
-	rc = ibmvtpm_send_crq(ibmvtpm->vdev, word[0], word[1]);
+	rc = ibmvtpm_send_crq(ibmvtpm->vdev, cpu_to_be64(word[0]),
+			      cpu_to_be64(word[1]));
 	if (rc != H_SUCCESS) {
 		dev_err(ibmvtpm->dev, "tpm_ibmvtpm_send failed rc=%d\n", rc);
 		rc = 0;
@@ -186,7 +187,8 @@ static int ibmvtpm_crq_get_rtce_size(struct ibmvtpm_dev *ibmvtpm)
 	crq.valid = (u8)IBMVTPM_VALID_CMD;
 	crq.msg = (u8)VTPM_GET_RTCE_BUFFER_SIZE;
 
-	rc = ibmvtpm_send_crq(ibmvtpm->vdev, buf[0], buf[1]);
+	rc = ibmvtpm_send_crq(ibmvtpm->vdev, cpu_to_be64(buf[0]),
+			      cpu_to_be64(buf[1]));
 	if (rc != H_SUCCESS)
 		dev_err(ibmvtpm->dev,
 			"ibmvtpm_crq_get_rtce_size failed rc=%d\n", rc);
@@ -212,7 +214,8 @@ static int ibmvtpm_crq_get_version(struct ibmvtpm_dev *ibmvtpm)
 	crq.valid = (u8)IBMVTPM_VALID_CMD;
 	crq.msg = (u8)VTPM_GET_VERSION;
 
-	rc = ibmvtpm_send_crq(ibmvtpm->vdev, buf[0], buf[1]);
+	rc = ibmvtpm_send_crq(ibmvtpm->vdev, cpu_to_be64(buf[0]),
+			      cpu_to_be64(buf[1]));
 	if (rc != H_SUCCESS)
 		dev_err(ibmvtpm->dev,
 			"ibmvtpm_crq_get_version failed rc=%d\n", rc);
@@ -307,6 +310,14 @@ static int tpm_ibmvtpm_remove(struct vio_dev *vdev)
 static unsigned long tpm_ibmvtpm_get_desired_dma(struct vio_dev *vdev)
 {
 	struct ibmvtpm_dev *ibmvtpm = ibmvtpm_get_data(&vdev->dev);
+
+	/* ibmvtpm initializes at probe time, so the data we are
+	* asking for may not be set yet. Estimate that 4K required
+	* for TCE-mapped buffer in addition to CRQ.
+	*/
+	if (!ibmvtpm)
+		return CRQ_RES_BUF_SIZE + PAGE_SIZE;
+
 	return CRQ_RES_BUF_SIZE + ibmvtpm->rtce_size;
 }
 
@@ -327,7 +338,8 @@ static int tpm_ibmvtpm_suspend(struct device *dev)
 	crq.valid = (u8)IBMVTPM_VALID_CMD;
 	crq.msg = (u8)VTPM_PREPARE_TO_SUSPEND;
 
-	rc = ibmvtpm_send_crq(ibmvtpm->vdev, buf[0], buf[1]);
+	rc = ibmvtpm_send_crq(ibmvtpm->vdev, cpu_to_be64(buf[0]),
+			      cpu_to_be64(buf[1]));
 	if (rc != H_SUCCESS)
 		dev_err(ibmvtpm->dev,
 			"tpm_ibmvtpm_suspend failed rc=%d\n", rc);
@@ -511,11 +523,11 @@ static void ibmvtpm_crq_process(struct ibmvtpm_crq *crq,
 	case IBMVTPM_VALID_CMD:
 		switch (crq->msg) {
 		case VTPM_GET_RTCE_BUFFER_SIZE_RES:
-			if (crq->len <= 0) {
+			if (be16_to_cpu(crq->len) <= 0) {
 				dev_err(ibmvtpm->dev, "Invalid rtce size\n");
 				return;
 			}
-			ibmvtpm->rtce_size = crq->len;
+			ibmvtpm->rtce_size = be16_to_cpu(crq->len);
 			ibmvtpm->rtce_buf = kmalloc(ibmvtpm->rtce_size,
 						    GFP_KERNEL);
 			if (!ibmvtpm->rtce_buf) {
@@ -536,11 +548,11 @@ static void ibmvtpm_crq_process(struct ibmvtpm_crq *crq,
 
 			return;
 		case VTPM_GET_VERSION_RES:
-			ibmvtpm->vtpm_version = crq->data;
+			ibmvtpm->vtpm_version = be32_to_cpu(crq->data);
 			return;
 		case VTPM_TPM_COMMAND_RES:
 			/* len of the data in rtce buffer */
-			ibmvtpm->res_len = crq->len;
+			ibmvtpm->res_len = be16_to_cpu(crq->len);
 			wake_up_interruptible(&ibmvtpm->wq);
 			return;
 		default:
diff --git a/drivers/char/tpm/tpm_tis.c b/drivers/char/tpm/tpm_tis.c
index 72f2137..323d02d 100644
--- a/drivers/char/tpm/tpm_tis.c
+++ b/drivers/char/tpm/tpm_tis.c
@@ -75,6 +75,10 @@ enum tis_defaults {
 #define	TPM_DID_VID(l)			(0x0F00 | ((l) << 12))
 #define	TPM_RID(l)			(0x0F04 | ((l) << 12))
 
+struct priv_data {
+	bool irq_tested;
+};
+
 static LIST_HEAD(tis_chips);
 static DEFINE_MUTEX(tis_lock);
 
@@ -338,12 +342,27 @@ out_err:
 	return rc;
 }
 
+static void disable_interrupts(struct tpm_chip *chip)
+{
+	u32 intmask;
+
+	intmask =
+	    ioread32(chip->vendor.iobase +
+		     TPM_INT_ENABLE(chip->vendor.locality));
+	intmask &= ~TPM_GLOBAL_INT_ENABLE;
+	iowrite32(intmask,
+		  chip->vendor.iobase +
+		  TPM_INT_ENABLE(chip->vendor.locality));
+	free_irq(chip->vendor.irq, chip);
+	chip->vendor.irq = 0;
+}
+
 /*
  * If interrupts are used (signaled by an irq set in the vendor structure)
  * tpm.c can skip polling for the data to be available as the interrupt is
  * waited for here
  */
-static int tpm_tis_send(struct tpm_chip *chip, u8 *buf, size_t len)
+static int tpm_tis_send_main(struct tpm_chip *chip, u8 *buf, size_t len)
 {
 	int rc;
 	u32 ordinal;
@@ -373,6 +392,30 @@ out_err:
 	return rc;
 }
 
+static int tpm_tis_send(struct tpm_chip *chip, u8 *buf, size_t len)
+{
+	int rc, irq;
+	struct priv_data *priv = chip->vendor.priv;
+
+	if (!chip->vendor.irq || priv->irq_tested)
+		return tpm_tis_send_main(chip, buf, len);
+
+	/* Verify receipt of the expected IRQ */
+	irq = chip->vendor.irq;
+	chip->vendor.irq = 0;
+	rc = tpm_tis_send_main(chip, buf, len);
+	chip->vendor.irq = irq;
+	if (!priv->irq_tested)
+		msleep(1);
+	if (!priv->irq_tested) {
+		disable_interrupts(chip);
+		dev_err(chip->dev,
+			FW_BUG "TPM interrupt not working, polling instead\n");
+	}
+	priv->irq_tested = true;
+	return rc;
+}
+
 struct tis_vendor_timeout_override {
 	u32 did_vid;
 	unsigned long timeout_us[4];
@@ -546,6 +589,7 @@ static irqreturn_t tis_int_handler(int dummy, void *dev_id)
 	if (interrupt == 0)
 		return IRQ_NONE;
 
+	((struct priv_data *)chip->vendor.priv)->irq_tested = true;
 	if (interrupt & TPM_INTF_DATA_AVAIL_INT)
 		wake_up_interruptible(&chip->vendor.read_queue);
 	if (interrupt & TPM_INTF_LOCALITY_CHANGE_INT)
@@ -575,9 +619,14 @@ static int tpm_tis_init(struct device *dev, resource_size_t start,
 	u32 vendor, intfcaps, intmask;
 	int rc, i, irq_s, irq_e, probe;
 	struct tpm_chip *chip;
+	struct priv_data *priv;
 
+	priv = devm_kzalloc(dev, sizeof(struct priv_data), GFP_KERNEL);
+	if (priv == NULL)
+		return -ENOMEM;
 	if (!(chip = tpm_register_hardware(dev, &tpm_tis)))
 		return -ENODEV;
+	chip->vendor.priv = priv;
 
 	chip->vendor.iobase = ioremap(start, len);
 	if (!chip->vendor.iobase) {
@@ -646,19 +695,6 @@ static int tpm_tis_init(struct device *dev, resource_size_t start,
 	if (intfcaps & TPM_INTF_DATA_AVAIL_INT)
 		dev_dbg(dev, "\tData Avail Int Support\n");
 
-	/* get the timeouts before testing for irqs */
-	if (tpm_get_timeouts(chip)) {
-		dev_err(dev, "Could not get TPM timeouts and durations\n");
-		rc = -ENODEV;
-		goto out_err;
-	}
-
-	if (tpm_do_selftest(chip)) {
-		dev_err(dev, "TPM self test failed\n");
-		rc = -ENODEV;
-		goto out_err;
-	}
-
 	/* INTERRUPT Setup */
 	init_waitqueue_head(&chip->vendor.read_queue);
 	init_waitqueue_head(&chip->vendor.int_queue);
@@ -760,6 +796,18 @@ static int tpm_tis_init(struct device *dev, resource_size_t start,
 		}
 	}
 
+	if (tpm_get_timeouts(chip)) {
+		dev_err(dev, "Could not get TPM timeouts and durations\n");
+		rc = -ENODEV;
+		goto out_err;
+	}
+
+	if (tpm_do_selftest(chip)) {
+		dev_err(dev, "TPM self test failed\n");
+		rc = -ENODEV;
+		goto out_err;
+	}
+
 	INIT_LIST_HEAD(&chip->vendor.list);
 	mutex_lock(&tis_lock);
 	list_add(&chip->vendor.list, &tis_chips);
diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index 88523f9..7555793 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -70,7 +70,7 @@ static unsigned long clk_factors_recalc_rate(struct clk_hw *hw,
 		p = FACTOR_GET(config->pshift, config->pwidth, reg);
 
 	/* Calculate the rate */
-	rate = (parent_rate * n * (k + 1) >> p) / (m + 1);
+	rate = (parent_rate * (n + config->n_start) * (k + 1) >> p) / (m + 1);
 
 	return rate;
 }
diff --git a/drivers/clk/sunxi/clk-factors.h b/drivers/clk/sunxi/clk-factors.h
index f49851c..441fdc3 100644
--- a/drivers/clk/sunxi/clk-factors.h
+++ b/drivers/clk/sunxi/clk-factors.h
@@ -15,6 +15,7 @@ struct clk_factors_config {
 	u8 mwidth;
 	u8 pshift;
 	u8 pwidth;
+	u8 n_start;
 };
 
 struct clk *clk_register_factors(struct device *dev, const char *name,
diff --git a/drivers/clocksource/exynos_mct.c b/drivers/clocksource/exynos_mct.c
index b796018..3dfa3e5 100644
--- a/drivers/clocksource/exynos_mct.c
+++ b/drivers/clocksource/exynos_mct.c
@@ -94,8 +94,8 @@ static void exynos4_mct_write(unsigned int value, unsigned long offset)
 	__raw_writel(value, reg_base + offset);
 
 	if (likely(offset >= EXYNOS4_MCT_L_BASE(0))) {
-		stat_addr = (offset & ~EXYNOS4_MCT_L_MASK) + MCT_L_WSTAT_OFFSET;
-		switch (offset & EXYNOS4_MCT_L_MASK) {
+		stat_addr = (offset & EXYNOS4_MCT_L_MASK) + MCT_L_WSTAT_OFFSET;
+		switch (offset & ~EXYNOS4_MCT_L_MASK) {
 		case MCT_L_TCON_OFFSET:
 			mask = 1 << 3;		/* L_TCON write status */
 			break;
diff --git a/drivers/cpufreq/speedstep-lib.c b/drivers/cpufreq/speedstep-lib.c
index 7047821..4ab7a21 100644
--- a/drivers/cpufreq/speedstep-lib.c
+++ b/drivers/cpufreq/speedstep-lib.c
@@ -400,6 +400,7 @@ unsigned int speedstep_get_freqs(enum speedstep_processor processor,
 
 	pr_debug("previous speed is %u\n", prev_speed);
 
+	preempt_disable();
 	local_irq_save(flags);
 
 	/* switch to low state */
@@ -464,6 +465,8 @@ unsigned int speedstep_get_freqs(enum speedstep_processor processor,
 
 out:
 	local_irq_restore(flags);
+	preempt_enable();
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(speedstep_get_freqs);
diff --git a/drivers/cpufreq/speedstep-smi.c b/drivers/cpufreq/speedstep-smi.c
index f5a6b70..2844009 100644
--- a/drivers/cpufreq/speedstep-smi.c
+++ b/drivers/cpufreq/speedstep-smi.c
@@ -188,6 +188,7 @@ static void speedstep_set_state(unsigned int state)
 		return;
 
 	/* Disable IRQs */
+	preempt_disable();
 	local_irq_save(flags);
 
 	command = (smi_sig & 0xffffff00) | (smi_cmd & 0xff);
@@ -198,9 +199,19 @@ static void speedstep_set_state(unsigned int state)
 
 	do {
 		if (retry) {
+			/*
+			 * We need to enable interrupts, otherwise the blockage
+			 * won't resolve.
+			 *
+			 * We disable preemption so that other processes don't
+			 * run. If other processes were running, they could
+			 * submit more DMA requests, making the blockage worse.
+			 */
 			pr_debug("retry %u, previous result %u, waiting...\n",
 					retry, result);
+			local_irq_enable();
 			mdelay(retry * 50);
+			local_irq_disable();
 		}
 		retry++;
 		__asm__ __volatile__(
@@ -217,6 +228,7 @@ static void speedstep_set_state(unsigned int state)
 
 	/* enable IRQs */
 	local_irq_restore(flags);
+	preempt_enable();
 
 	if (new_state == state)
 		pr_debug("change to %u MHz succeeded after %u tries "
diff --git a/drivers/crypto/padlock-aes.c b/drivers/crypto/padlock-aes.c
index 633ba94..c178ed8 100644
--- a/drivers/crypto/padlock-aes.c
+++ b/drivers/crypto/padlock-aes.c
@@ -563,4 +563,4 @@ MODULE_DESCRIPTION("VIA PadLock AES algorithm support");
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Michal Ludvig");
 
-MODULE_ALIAS("aes");
+MODULE_ALIAS_CRYPTO("aes");
diff --git a/drivers/crypto/padlock-sha.c b/drivers/crypto/padlock-sha.c
index 9266c0e..93d7753 100644
--- a/drivers/crypto/padlock-sha.c
+++ b/drivers/crypto/padlock-sha.c
@@ -593,7 +593,7 @@ MODULE_DESCRIPTION("VIA PadLock SHA1/SHA256 algorithms support.");
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Michal Ludvig");
 
-MODULE_ALIAS("sha1-all");
-MODULE_ALIAS("sha256-all");
-MODULE_ALIAS("sha1-padlock");
-MODULE_ALIAS("sha256-padlock");
+MODULE_ALIAS_CRYPTO("sha1-all");
+MODULE_ALIAS_CRYPTO("sha256-all");
+MODULE_ALIAS_CRYPTO("sha1-padlock");
+MODULE_ALIAS_CRYPTO("sha256-padlock");
diff --git a/drivers/crypto/ux500/cryp/cryp_core.c b/drivers/crypto/ux500/cryp/cryp_core.c
index 3833bd7..e08275d 100644
--- a/drivers/crypto/ux500/cryp/cryp_core.c
+++ b/drivers/crypto/ux500/cryp/cryp_core.c
@@ -1775,7 +1775,7 @@ module_exit(ux500_cryp_mod_fini);
 module_param(cryp_mode, int, 0);
 
 MODULE_DESCRIPTION("Driver for ST-Ericsson UX500 CRYP crypto engine.");
-MODULE_ALIAS("aes-all");
-MODULE_ALIAS("des-all");
+MODULE_ALIAS_CRYPTO("aes-all");
+MODULE_ALIAS_CRYPTO("des-all");
 
 MODULE_LICENSE("GPL");
diff --git a/drivers/crypto/ux500/hash/hash_core.c b/drivers/crypto/ux500/hash/hash_core.c
index cf55089..6789c16 100644
--- a/drivers/crypto/ux500/hash/hash_core.c
+++ b/drivers/crypto/ux500/hash/hash_core.c
@@ -1998,7 +1998,7 @@ module_exit(ux500_hash_mod_fini);
 MODULE_DESCRIPTION("Driver for ST-Ericsson UX500 HASH engine.");
 MODULE_LICENSE("GPL");
 
-MODULE_ALIAS("sha1-all");
-MODULE_ALIAS("sha256-all");
-MODULE_ALIAS("hmac-sha1-all");
-MODULE_ALIAS("hmac-sha256-all");
+MODULE_ALIAS_CRYPTO("sha1-all");
+MODULE_ALIAS_CRYPTO("sha256-all");
+MODULE_ALIAS_CRYPTO("hmac-sha1-all");
+MODULE_ALIAS_CRYPTO("hmac-sha256-all");
diff --git a/drivers/firmware/efi/efi-pstore.c b/drivers/firmware/efi/efi-pstore.c
index 202d2c8..9b2622e 100644
--- a/drivers/firmware/efi/efi-pstore.c
+++ b/drivers/firmware/efi/efi-pstore.c
@@ -38,6 +38,12 @@ struct pstore_read_data {
 	char **buf;
 };
 
+static inline u64 generic_id(unsigned long timestamp,
+			     unsigned int part, int count)
+{
+	return (timestamp * 100 + part) * 1000 + count;
+}
+
 static int efi_pstore_read_func(struct efivar_entry *entry, void *data)
 {
 	efi_guid_t vendor = LINUX_EFI_CRASH_GUID;
@@ -56,7 +62,7 @@ static int efi_pstore_read_func(struct efivar_entry *entry, void *data)
 
 	if (sscanf(name, "dump-type%u-%u-%d-%lu",
 		   cb_data->type, &part, &cnt, &time) == 4) {
-		*cb_data->id = part;
+		*cb_data->id = generic_id(time, part, cnt);
 		*cb_data->count = cnt;
 		cb_data->timespec->tv_sec = time;
 		cb_data->timespec->tv_nsec = 0;
@@ -67,7 +73,7 @@ static int efi_pstore_read_func(struct efivar_entry *entry, void *data)
 		 * which doesn't support holding
 		 * multiple logs, remains.
 		 */
-		*cb_data->id = part;
+		*cb_data->id = generic_id(time, part, 0);
 		*cb_data->count = 0;
 		cb_data->timespec->tv_sec = time;
 		cb_data->timespec->tv_nsec = 0;
@@ -185,14 +191,16 @@ static int efi_pstore_erase(enum pstore_type_id type, u64 id, int count,
 	char name[DUMP_NAME_LEN];
 	efi_char16_t efi_name[DUMP_NAME_LEN];
 	int found, i;
+	unsigned int part;
 
-	sprintf(name, "dump-type%u-%u-%d-%lu", type, (unsigned int)id, count,
-		time.tv_sec);
+	do_div(id, 1000);
+	part = do_div(id, 100);
+	sprintf(name, "dump-type%u-%u-%d-%lu", type, part, count, time.tv_sec);
 
 	for (i = 0; i < DUMP_NAME_LEN; i++)
 		efi_name[i] = name[i];
 
-	edata.id = id;
+	edata.id = part;
 	edata.type = type;
 	edata.count = count;
 	edata.time = time;
diff --git a/drivers/gpio/gpio-tps65912.c b/drivers/gpio/gpio-tps65912.c
index 30a5844..8457304 100644
--- a/drivers/gpio/gpio-tps65912.c
+++ b/drivers/gpio/gpio-tps65912.c
@@ -26,9 +26,12 @@ struct tps65912_gpio_data {
 	struct gpio_chip gpio_chip;
 };
 
+#define to_tgd(gc) container_of(gc, struct tps65912_gpio_data, gpio_chip)
+
 static int tps65912_gpio_get(struct gpio_chip *gc, unsigned offset)
 {
-	struct tps65912 *tps65912 = container_of(gc, struct tps65912, gpio);
+	struct tps65912_gpio_data *tps65912_gpio = to_tgd(gc);
+	struct tps65912 *tps65912 = tps65912_gpio->tps65912;
 	int val;
 
 	val = tps65912_reg_read(tps65912, TPS65912_GPIO1 + offset);
@@ -42,7 +45,8 @@ static int tps65912_gpio_get(struct gpio_chip *gc, unsigned offset)
 static void tps65912_gpio_set(struct gpio_chip *gc, unsigned offset,
 			      int value)
 {
-	struct tps65912 *tps65912 = container_of(gc, struct tps65912, gpio);
+	struct tps65912_gpio_data *tps65912_gpio = to_tgd(gc);
+	struct tps65912 *tps65912 = tps65912_gpio->tps65912;
 
 	if (value)
 		tps65912_set_bits(tps65912, TPS65912_GPIO1 + offset,
@@ -55,7 +59,8 @@ static void tps65912_gpio_set(struct gpio_chip *gc, unsigned offset,
 static int tps65912_gpio_output(struct gpio_chip *gc, unsigned offset,
 				int value)
 {
-	struct tps65912 *tps65912 = container_of(gc, struct tps65912, gpio);
+	struct tps65912_gpio_data *tps65912_gpio = to_tgd(gc);
+	struct tps65912 *tps65912 = tps65912_gpio->tps65912;
 
 	/* Set the initial value */
 	tps65912_gpio_set(gc, offset, value);
@@ -66,7 +71,8 @@ static int tps65912_gpio_output(struct gpio_chip *gc, unsigned offset,
 
 static int tps65912_gpio_input(struct gpio_chip *gc, unsigned offset)
 {
-	struct tps65912 *tps65912 = container_of(gc, struct tps65912, gpio);
+	struct tps65912_gpio_data *tps65912_gpio = to_tgd(gc);
+	struct tps65912 *tps65912 = tps65912_gpio->tps65912;
 
 	return tps65912_clear_bits(tps65912, TPS65912_GPIO1 + offset,
 								GPIO_CFG_MASK);
diff --git a/drivers/gpio/gpiolib-of.c b/drivers/gpio/gpiolib-of.c
index 665f953..7476972 100644
--- a/drivers/gpio/gpiolib-of.c
+++ b/drivers/gpio/gpiolib-of.c
@@ -12,6 +12,7 @@
  */
 
 #include <linux/device.h>
+#include <linux/err.h>
 #include <linux/errno.h>
 #include <linux/module.h>
 #include <linux/io.h>
@@ -42,8 +43,14 @@ static int of_gpiochip_find_and_xlate(struct gpio_chip *gc, void *data)
 		return false;
 
 	ret = gc->of_xlate(gc, &gg_data->gpiospec, gg_data->flags);
-	if (ret < 0)
-		return false;
+	if (ret < 0) {
+		/* We've found the gpio chip, but the translation failed.
+		 * Return true to stop looking and return the translation
+		 * error via out_gpio
+		 */
+		gg_data->out_gpio = ret;
+		return true;
+	 }
 
 	gg_data->out_gpio = ret + gc->base;
 	return true;
diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c
index a35c5b9..931bdf3 100644
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@ -362,7 +362,7 @@ static ssize_t gpio_value_store(struct device *dev,
 	return status;
 }
 
-static const DEVICE_ATTR(value, 0644,
+static DEVICE_ATTR(value, 0644,
 		gpio_value_show, gpio_value_store);
 
 static irqreturn_t gpio_sysfs_irq(int irq, void *priv)
@@ -580,17 +580,17 @@ static ssize_t gpio_active_low_store(struct device *dev,
 	return status ? : size;
 }
 
-static const DEVICE_ATTR(active_low, 0644,
+static DEVICE_ATTR(active_low, 0644,
 		gpio_active_low_show, gpio_active_low_store);
 
-static const struct attribute *gpio_attrs[] = {
+static struct attribute *gpio_attrs[] = {
 	&dev_attr_value.attr,
 	&dev_attr_active_low.attr,
 	NULL,
 };
 
 static const struct attribute_group gpio_attr_group = {
-	.attrs = (struct attribute **) gpio_attrs,
+	.attrs = gpio_attrs,
 };
 
 /*
@@ -627,7 +627,7 @@ static ssize_t chip_ngpio_show(struct device *dev,
 }
 static DEVICE_ATTR(ngpio, 0444, chip_ngpio_show, NULL);
 
-static const struct attribute *gpiochip_attrs[] = {
+static struct attribute *gpiochip_attrs[] = {
 	&dev_attr_base.attr,
 	&dev_attr_label.attr,
 	&dev_attr_ngpio.attr,
@@ -635,7 +635,7 @@ static const struct attribute *gpiochip_attrs[] = {
 };
 
 static const struct attribute_group gpiochip_attr_group = {
-	.attrs = (struct attribute **) gpiochip_attrs,
+	.attrs = gpiochip_attrs,
 };
 
 /*
@@ -806,20 +806,24 @@ static int gpiod_export(struct gpio_desc *desc, bool direction_may_change)
 	if (direction_may_change) {
 		status = device_create_file(dev, &dev_attr_direction);
 		if (status)
-			goto fail_unregister_device;
+			goto fail_remove_attr_group;
 	}
 
 	if (gpiod_to_irq(desc) >= 0 && (direction_may_change ||
 				       !test_bit(FLAG_IS_OUT, &desc->flags))) {
 		status = device_create_file(dev, &dev_attr_edge);
 		if (status)
-			goto fail_unregister_device;
+			goto fail_remove_attr_direction;
 	}
 
 	set_bit(FLAG_EXPORT, &desc->flags);
 	mutex_unlock(&sysfs_lock);
 	return 0;
 
+fail_remove_attr_direction:
+	device_remove_file(dev, &dev_attr_direction);
+fail_remove_attr_group:
+	sysfs_remove_group(&dev->kobj, &gpio_attr_group);
 fail_unregister_device:
 	device_unregister(dev);
 fail_unlock:
@@ -870,6 +874,7 @@ static int gpiod_export_link(struct device *dev, const char *name,
 		if (tdev != NULL) {
 			status = sysfs_create_link(&dev->kobj, &tdev->kobj,
 						name);
+			put_device(tdev);
 		} else {
 			status = -ENODEV;
 		}
@@ -923,7 +928,7 @@ static int gpiod_sysfs_set_active_low(struct gpio_desc *desc, int value)
 	}
 
 	status = sysfs_set_active_low(desc, dev, value);
-
+	put_device(dev);
 unlock:
 	mutex_unlock(&sysfs_lock);
 
@@ -971,6 +976,9 @@ static void gpiod_unexport(struct gpio_desc *desc)
 	mutex_unlock(&sysfs_lock);
 
 	if (dev) {
+		device_remove_file(dev, &dev_attr_edge);
+		device_remove_file(dev, &dev_attr_direction);
+		sysfs_remove_group(&dev->kobj, &gpio_attr_group);
 		device_unregister(dev);
 		put_device(dev);
 	}
@@ -1036,6 +1044,7 @@ static void gpiochip_unexport(struct gpio_chip *chip)
 	mutex_lock(&sysfs_lock);
 	dev = class_find_device(&gpio_class, NULL, chip, match_export);
 	if (dev) {
+		sysfs_remove_group(&dev->kobj, &gpiochip_attr_group);
 		put_device(dev);
 		device_unregister(dev);
 		chip->exported = 0;
diff --git a/drivers/gpu/drm/i915/i915_gem.c b/drivers/gpu/drm/i915/i915_gem.c
index 0a30088..0b71a0a 100644
--- a/drivers/gpu/drm/i915/i915_gem.c
+++ b/drivers/gpu/drm/i915/i915_gem.c
@@ -4449,7 +4449,7 @@ static bool mutex_is_locked_by(struct mutex *mutex, struct task_struct *task)
 	if (!mutex_is_locked(mutex))
 		return false;
 
-#if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_MUTEXES)
+#if defined(CONFIG_SMP) && !defined(CONFIG_DEBUG_MUTEXES)
 	return mutex->owner == task;
 #else
 	/* Since UP may be pre-empted, we cannot assume that we own the lock */
diff --git a/drivers/gpu/drm/i915/i915_reg.h b/drivers/gpu/drm/i915/i915_reg.h
index 2d90f96..7695b5d 100644
--- a/drivers/gpu/drm/i915/i915_reg.h
+++ b/drivers/gpu/drm/i915/i915_reg.h
@@ -317,6 +317,7 @@
 #define   PIPE_CONTROL_GLOBAL_GTT_IVB			(1<<24) /* gen7+ */
 #define   PIPE_CONTROL_CS_STALL				(1<<20)
 #define   PIPE_CONTROL_TLB_INVALIDATE			(1<<18)
+#define   PIPE_CONTROL_MEDIA_STATE_CLEAR		(1<<16)
 #define   PIPE_CONTROL_QW_WRITE				(1<<14)
 #define   PIPE_CONTROL_DEPTH_STALL			(1<<13)
 #define   PIPE_CONTROL_WRITE_FLUSH			(1<<12)
diff --git a/drivers/gpu/drm/i915/intel_ringbuffer.c b/drivers/gpu/drm/i915/intel_ringbuffer.c
index 4605c38..ef4cde1 100644
--- a/drivers/gpu/drm/i915/intel_ringbuffer.c
+++ b/drivers/gpu/drm/i915/intel_ringbuffer.c
@@ -314,12 +314,15 @@ gen7_render_ring_flush(struct intel_ring_buffer *ring,
 		flags |= PIPE_CONTROL_VF_CACHE_INVALIDATE;
 		flags |= PIPE_CONTROL_CONST_CACHE_INVALIDATE;
 		flags |= PIPE_CONTROL_STATE_CACHE_INVALIDATE;
+		flags |= PIPE_CONTROL_MEDIA_STATE_CLEAR;
 		/*
 		 * TLB invalidate requires a post-sync write.
 		 */
 		flags |= PIPE_CONTROL_QW_WRITE;
 		flags |= PIPE_CONTROL_GLOBAL_GTT_IVB;
 
+		flags |= PIPE_CONTROL_STALL_AT_SCOREBOARD;
+
 		/* Workaround: we must issue a pipe_control with CS-stall bit
 		 * set before a pipe_control command that has the state cache
 		 * invalidate bit set. */
diff --git a/drivers/gpu/drm/radeon/atombios_dp.c b/drivers/gpu/drm/radeon/atombios_dp.c
index 4c05f2b..d4a5118 100644
--- a/drivers/gpu/drm/radeon/atombios_dp.c
+++ b/drivers/gpu/drm/radeon/atombios_dp.c
@@ -574,6 +574,10 @@ int radeon_dp_mode_valid_helper(struct drm_connector *connector,
 	struct radeon_connector_atom_dig *dig_connector;
 	int dp_clock;
 
+	if ((mode->clock > 340000) &&
+	    (!radeon_connector_is_dp12_capable(connector)))
+		return MODE_CLOCK_HIGH;
+
 	if (!radeon_connector->con_priv)
 		return MODE_CLOCK_HIGH;
 	dig_connector = radeon_connector->con_priv;
diff --git a/drivers/gpu/drm/radeon/ni.c b/drivers/gpu/drm/radeon/ni.c
index 451d788..c254e46 100644
--- a/drivers/gpu/drm/radeon/ni.c
+++ b/drivers/gpu/drm/radeon/ni.c
@@ -930,12 +930,12 @@ static void cayman_gpu_init(struct radeon_device *rdev)
 
 	if ((rdev->config.cayman.max_backends_per_se == 1) &&
 	    (rdev->flags & RADEON_IS_IGP)) {
-		if ((disabled_rb_mask & 3) == 1) {
-			/* RB0 disabled, RB1 enabled */
-			tmp = 0x11111111;
-		} else {
+		if ((disabled_rb_mask & 3) == 2) {
 			/* RB1 disabled, RB0 enabled */
 			tmp = 0x00000000;
+		} else {
+			/* RB0 disabled, RB1 enabled */
+			tmp = 0x11111111;
 		}
 	} else {
 		tmp = gb_addr_config & NUM_PIPES_MASK;
diff --git a/drivers/gpu/drm/radeon/radeon_ttm.c b/drivers/gpu/drm/radeon/radeon_ttm.c
index 6c0ce89..4a14e11 100644
--- a/drivers/gpu/drm/radeon/radeon_ttm.c
+++ b/drivers/gpu/drm/radeon/radeon_ttm.c
@@ -189,7 +189,7 @@ static void radeon_evict_flags(struct ttm_buffer_object *bo,
 	rbo = container_of(bo, struct radeon_bo, tbo);
 	switch (bo->mem.mem_type) {
 	case TTM_PL_VRAM:
-		if (rbo->rdev->ring[RADEON_RING_TYPE_GFX_INDEX].ready == false)
+		if (rbo->rdev->ring[radeon_copy_ring_index(rbo->rdev)].ready == false)
 			radeon_ttm_placement_from_domain(rbo, RADEON_GEM_DOMAIN_CPU);
 		else
 			radeon_ttm_placement_from_domain(rbo, RADEON_GEM_DOMAIN_GTT);
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c b/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c
index c62d20e..ee742f1 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c
@@ -1049,6 +1049,8 @@ int vmw_event_fence_action_create(struct drm_file *file_priv,
 	if (ret != 0)
 		goto out_no_queue;
 
+	return 0;
+
 out_no_queue:
 	event->base.destroy(&event->base);
 out_no_event:
@@ -1123,17 +1125,10 @@ int vmw_fence_event_ioctl(struct drm_device *dev, void *data,
 
 	BUG_ON(fence == NULL);
 
-	if (arg->flags & DRM_VMW_FE_FLAG_REQ_TIME)
-		ret = vmw_event_fence_action_create(file_priv, fence,
-						    arg->flags,
-						    arg->user_data,
-						    true);
-	else
-		ret = vmw_event_fence_action_create(file_priv, fence,
-						    arg->flags,
-						    arg->user_data,
-						    true);
-
+	ret = vmw_event_fence_action_create(file_priv, fence,
+					    arg->flags,
+					    arg->user_data,
+					    true);
 	if (unlikely(ret != 0)) {
 		if (ret != -ERESTARTSYS)
 			DRM_ERROR("Failed to attach event to fence.\n");
diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 6676354..1419f8b 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1083,6 +1083,23 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 		return;
 	}
 
+	/*
+	 * Ignore reports for absolute data if the data didn't change. This is
+	 * not only an optimization but also fixes 'dead' key reports. Some
+	 * RollOver implementations for localized keys (like BACKSLASH/PIPE; HID
+	 * 0x31 and 0x32) report multiple keys, even though a localized keyboard
+	 * can only have one of them physically available. The 'dead' keys
+	 * report constant 0. As all map to the same keycode, they'd confuse
+	 * the input layer. If we filter the 'dead' keys on the HID level, we
+	 * skip the keycode translation and only forward real events.
+	 */
+	if (!(field->flags & (HID_MAIN_ITEM_RELATIVE |
+	                      HID_MAIN_ITEM_BUFFERED_BYTE)) &&
+			      (field->flags & HID_MAIN_ITEM_VARIABLE) &&
+	    usage->usage_index < field->maxusage &&
+	    value == field->value[usage->usage_index])
+		return;
+
 	/* report the usage code as scancode if the key status has changed */
 	if (usage->type == EV_KEY && !!test_bit(usage->code, input->key) != value)
 		input_event(input, EV_MSC, MSC_SCAN, usage->hid);
diff --git a/drivers/hid/i2c-hid/i2c-hid.c b/drivers/hid/i2c-hid/i2c-hid.c
index 469daa0..ccc2f36 100644
--- a/drivers/hid/i2c-hid/i2c-hid.c
+++ b/drivers/hid/i2c-hid/i2c-hid.c
@@ -341,7 +341,10 @@ static int i2c_hid_hwreset(struct i2c_client *client)
 static void i2c_hid_get_input(struct i2c_hid *ihid)
 {
 	int ret, ret_size;
-	int size = ihid->bufsize;
+	int size = le16_to_cpu(ihid->hdesc.wMaxInputLength);
+
+	if (size > ihid->bufsize)
+		size = ihid->bufsize;
 
 	ret = i2c_master_recv(ihid->client, ihid->inbuf, size);
 	if (ret != size) {
diff --git a/drivers/hv/vmbus_drv.c b/drivers/hv/vmbus_drv.c
index 4004e54..f445b08 100644
--- a/drivers/hv/vmbus_drv.c
+++ b/drivers/hv/vmbus_drv.c
@@ -686,7 +686,7 @@ int vmbus_device_register(struct hv_device *child_device_obj)
 	if (ret)
 		pr_err("Unable to register child device\n");
 	else
-		pr_info("child device %s registered\n",
+		pr_debug("child device %s registered\n",
 			dev_name(&child_device_obj->device));
 
 	return ret;
@@ -698,14 +698,14 @@ int vmbus_device_register(struct hv_device *child_device_obj)
  */
 void vmbus_device_unregister(struct hv_device *device_obj)
 {
+	pr_debug("child device %s unregistered\n",
+		dev_name(&device_obj->device));
+
 	/*
 	 * Kick off the process of unregistering the device.
 	 * This will call vmbus_remove() and eventually vmbus_device_release()
 	 */
 	device_unregister(&device_obj->device);
-
-	pr_info("child device %s unregistered\n",
-		dev_name(&device_obj->device));
 }
 
 
diff --git a/drivers/iio/imu/adis16400_core.c b/drivers/iio/imu/adis16400_core.c
index d6ece2d..7d60c85 100644
--- a/drivers/iio/imu/adis16400_core.c
+++ b/drivers/iio/imu/adis16400_core.c
@@ -26,6 +26,7 @@
 #include <linux/list.h>
 #include <linux/module.h>
 #include <linux/debugfs.h>
+#include <linux/bitops.h>
 
 #include <linux/iio/iio.h>
 #include <linux/iio/sysfs.h>
@@ -447,7 +448,7 @@ static int adis16400_read_raw(struct iio_dev *indio_dev,
 		mutex_unlock(&indio_dev->mlock);
 		if (ret)
 			return ret;
-		val16 = ((val16 & 0xFFF) << 4) >> 4;
+		val16 = sign_extend32(val16, 11);
 		*val = val16;
 		return IIO_VAL_INT;
 	case IIO_CHAN_INFO_OFFSET:
diff --git a/drivers/infiniband/hw/qib/qib.h b/drivers/infiniband/hw/qib/qib.h
index 4d11575..d1b30c6 100644
--- a/drivers/infiniband/hw/qib/qib.h
+++ b/drivers/infiniband/hw/qib/qib.h
@@ -1055,12 +1055,6 @@ struct qib_devdata {
 	/* control high-level access to EEPROM */
 	struct mutex eep_lock;
 	uint64_t traffic_wds;
-	/* active time is kept in seconds, but logged in hours */
-	atomic_t active_time;
-	/* Below are nominal shadow of EEPROM, new since last EEPROM update */
-	uint8_t eep_st_errs[QIB_EEP_LOG_CNT];
-	uint8_t eep_st_new_errs[QIB_EEP_LOG_CNT];
-	uint16_t eep_hrs;
 	/*
 	 * masks for which bits of errs, hwerrs that cause
 	 * each of the counters to increment.
@@ -1278,8 +1272,7 @@ int qib_twsi_blk_rd(struct qib_devdata *dd, int dev, int addr, void *buffer,
 int qib_twsi_blk_wr(struct qib_devdata *dd, int dev, int addr,
 		    const void *buffer, int len);
 void qib_get_eeprom_info(struct qib_devdata *);
-int qib_update_eeprom_log(struct qib_devdata *dd);
-void qib_inc_eeprom_err(struct qib_devdata *dd, u32 eidx, u32 incr);
+#define qib_inc_eeprom_err(dd, eidx, incr)
 void qib_dump_lookup_output_queue(struct qib_devdata *);
 void qib_force_pio_avail_update(struct qib_devdata *);
 void qib_clear_symerror_on_linkup(unsigned long opaque);
diff --git a/drivers/infiniband/hw/qib/qib_eeprom.c b/drivers/infiniband/hw/qib/qib_eeprom.c
index 4d5d71a..e2280b0 100644
--- a/drivers/infiniband/hw/qib/qib_eeprom.c
+++ b/drivers/infiniband/hw/qib/qib_eeprom.c
@@ -267,190 +267,9 @@ void qib_get_eeprom_info(struct qib_devdata *dd)
 			"Board SN %s did not pass functional test: %s\n",
 			dd->serial, ifp->if_comment);
 
-	memcpy(&dd->eep_st_errs, &ifp->if_errcntp, QIB_EEP_LOG_CNT);
-	/*
-	 * Power-on (actually "active") hours are kept as little-endian value
-	 * in EEPROM, but as seconds in a (possibly as small as 24-bit)
-	 * atomic_t while running.
-	 */
-	atomic_set(&dd->active_time, 0);
-	dd->eep_hrs = ifp->if_powerhour[0] | (ifp->if_powerhour[1] << 8);
-
 done:
 	vfree(buf);
 
 bail:;
 }
 
-/**
- * qib_update_eeprom_log - copy active-time and error counters to eeprom
- * @dd: the qlogic_ib device
- *
- * Although the time is kept as seconds in the qib_devdata struct, it is
- * rounded to hours for re-write, as we have only 16 bits in EEPROM.
- * First-cut code reads whole (expected) struct qib_flash, modifies,
- * re-writes. Future direction: read/write only what we need, assuming
- * that the EEPROM had to have been "good enough" for driver init, and
- * if not, we aren't making it worse.
- *
- */
-int qib_update_eeprom_log(struct qib_devdata *dd)
-{
-	void *buf;
-	struct qib_flash *ifp;
-	int len, hi_water;
-	uint32_t new_time, new_hrs;
-	u8 csum;
-	int ret, idx;
-	unsigned long flags;
-
-	/* first, check if we actually need to do anything. */
-	ret = 0;
-	for (idx = 0; idx < QIB_EEP_LOG_CNT; ++idx) {
-		if (dd->eep_st_new_errs[idx]) {
-			ret = 1;
-			break;
-		}
-	}
-	new_time = atomic_read(&dd->active_time);
-
-	if (ret == 0 && new_time < 3600)
-		goto bail;
-
-	/*
-	 * The quick-check above determined that there is something worthy
-	 * of logging, so get current contents and do a more detailed idea.
-	 * read full flash, not just currently used part, since it may have
-	 * been written with a newer definition
-	 */
-	len = sizeof(struct qib_flash);
-	buf = vmalloc(len);
-	ret = 1;
-	if (!buf) {
-		qib_dev_err(dd,
-			"Couldn't allocate memory to read %u bytes from eeprom for logging\n",
-			len);
-		goto bail;
-	}
-
-	/* Grab semaphore and read current EEPROM. If we get an
-	 * error, let go, but if not, keep it until we finish write.
-	 */
-	ret = mutex_lock_interruptible(&dd->eep_lock);
-	if (ret) {
-		qib_dev_err(dd, "Unable to acquire EEPROM for logging\n");
-		goto free_bail;
-	}
-	ret = qib_twsi_blk_rd(dd, dd->twsi_eeprom_dev, 0, buf, len);
-	if (ret) {
-		mutex_unlock(&dd->eep_lock);
-		qib_dev_err(dd, "Unable read EEPROM for logging\n");
-		goto free_bail;
-	}
-	ifp = (struct qib_flash *)buf;
-
-	csum = flash_csum(ifp, 0);
-	if (csum != ifp->if_csum) {
-		mutex_unlock(&dd->eep_lock);
-		qib_dev_err(dd, "EEPROM cks err (0x%02X, S/B 0x%02X)\n",
-			    csum, ifp->if_csum);
-		ret = 1;
-		goto free_bail;
-	}
-	hi_water = 0;
-	spin_lock_irqsave(&dd->eep_st_lock, flags);
-	for (idx = 0; idx < QIB_EEP_LOG_CNT; ++idx) {
-		int new_val = dd->eep_st_new_errs[idx];
-		if (new_val) {
-			/*
-			 * If we have seen any errors, add to EEPROM values
-			 * We need to saturate at 0xFF (255) and we also
-			 * would need to adjust the checksum if we were
-			 * trying to minimize EEPROM traffic
-			 * Note that we add to actual current count in EEPROM,
-			 * in case it was altered while we were running.
-			 */
-			new_val += ifp->if_errcntp[idx];
-			if (new_val > 0xFF)
-				new_val = 0xFF;
-			if (ifp->if_errcntp[idx] != new_val) {
-				ifp->if_errcntp[idx] = new_val;
-				hi_water = offsetof(struct qib_flash,
-						    if_errcntp) + idx;
-			}
-			/*
-			 * update our shadow (used to minimize EEPROM
-			 * traffic), to match what we are about to write.
-			 */
-			dd->eep_st_errs[idx] = new_val;
-			dd->eep_st_new_errs[idx] = 0;
-		}
-	}
-	/*
-	 * Now update active-time. We would like to round to the nearest hour
-	 * but unless atomic_t are sure to be proper signed ints we cannot,
-	 * because we need to account for what we "transfer" to EEPROM and
-	 * if we log an hour at 31 minutes, then we would need to set
-	 * active_time to -29 to accurately count the _next_ hour.
-	 */
-	if (new_time >= 3600) {
-		new_hrs = new_time / 3600;
-		atomic_sub((new_hrs * 3600), &dd->active_time);
-		new_hrs += dd->eep_hrs;
-		if (new_hrs > 0xFFFF)
-			new_hrs = 0xFFFF;
-		dd->eep_hrs = new_hrs;
-		if ((new_hrs & 0xFF) != ifp->if_powerhour[0]) {
-			ifp->if_powerhour[0] = new_hrs & 0xFF;
-			hi_water = offsetof(struct qib_flash, if_powerhour);
-		}
-		if ((new_hrs >> 8) != ifp->if_powerhour[1]) {
-			ifp->if_powerhour[1] = new_hrs >> 8;
-			hi_water = offsetof(struct qib_flash, if_powerhour) + 1;
-		}
-	}
-	/*
-	 * There is a tiny possibility that we could somehow fail to write
-	 * the EEPROM after updating our shadows, but problems from holding
-	 * the spinlock too long are a much bigger issue.
-	 */
-	spin_unlock_irqrestore(&dd->eep_st_lock, flags);
-	if (hi_water) {
-		/* we made some change to the data, uopdate cksum and write */
-		csum = flash_csum(ifp, 1);
-		ret = eeprom_write_with_enable(dd, 0, buf, hi_water + 1);
-	}
-	mutex_unlock(&dd->eep_lock);
-	if (ret)
-		qib_dev_err(dd, "Failed updating EEPROM\n");
-
-free_bail:
-	vfree(buf);
-bail:
-	return ret;
-}
-
-/**
- * qib_inc_eeprom_err - increment one of the four error counters
- * that are logged to EEPROM.
- * @dd: the qlogic_ib device
- * @eidx: 0..3, the counter to increment
- * @incr: how much to add
- *
- * Each counter is 8-bits, and saturates at 255 (0xFF). They
- * are copied to the EEPROM (aka flash) whenever qib_update_eeprom_log()
- * is called, but it can only be called in a context that allows sleep.
- * This function can be called even at interrupt level.
- */
-void qib_inc_eeprom_err(struct qib_devdata *dd, u32 eidx, u32 incr)
-{
-	uint new_val;
-	unsigned long flags;
-
-	spin_lock_irqsave(&dd->eep_st_lock, flags);
-	new_val = dd->eep_st_new_errs[eidx] + incr;
-	if (new_val > 255)
-		new_val = 255;
-	dd->eep_st_new_errs[eidx] = new_val;
-	spin_unlock_irqrestore(&dd->eep_st_lock, flags);
-}
diff --git a/drivers/infiniband/hw/qib/qib_iba6120.c b/drivers/infiniband/hw/qib/qib_iba6120.c
index 0232ae5..4e26133 100644
--- a/drivers/infiniband/hw/qib/qib_iba6120.c
+++ b/drivers/infiniband/hw/qib/qib_iba6120.c
@@ -2682,8 +2682,6 @@ static void qib_get_6120_faststats(unsigned long opaque)
 	spin_lock_irqsave(&dd->eep_st_lock, flags);
 	traffic_wds -= dd->traffic_wds;
 	dd->traffic_wds += traffic_wds;
-	if (traffic_wds  >= QIB_TRAFFIC_ACTIVE_THRESHOLD)
-		atomic_add(5, &dd->active_time); /* S/B #define */
 	spin_unlock_irqrestore(&dd->eep_st_lock, flags);
 
 	qib_chk_6120_errormask(dd);
diff --git a/drivers/infiniband/hw/qib/qib_iba7220.c b/drivers/infiniband/hw/qib/qib_iba7220.c
index 64d0ecb..3dbabf3 100644
--- a/drivers/infiniband/hw/qib/qib_iba7220.c
+++ b/drivers/infiniband/hw/qib/qib_iba7220.c
@@ -3299,8 +3299,6 @@ static void qib_get_7220_faststats(unsigned long opaque)
 	spin_lock_irqsave(&dd->eep_st_lock, flags);
 	traffic_wds -= dd->traffic_wds;
 	dd->traffic_wds += traffic_wds;
-	if (traffic_wds  >= QIB_TRAFFIC_ACTIVE_THRESHOLD)
-		atomic_add(5, &dd->active_time); /* S/B #define */
 	spin_unlock_irqrestore(&dd->eep_st_lock, flags);
 done:
 	mod_timer(&dd->stats_timer, jiffies + HZ * ACTIVITY_TIMER);
diff --git a/drivers/infiniband/hw/qib/qib_iba7322.c b/drivers/infiniband/hw/qib/qib_iba7322.c
index 14103ff..5f5f20f 100644
--- a/drivers/infiniband/hw/qib/qib_iba7322.c
+++ b/drivers/infiniband/hw/qib/qib_iba7322.c
@@ -4854,8 +4854,6 @@ static void qib_get_7322_faststats(unsigned long opaque)
 		spin_lock_irqsave(&ppd->dd->eep_st_lock, flags);
 		traffic_wds -= ppd->dd->traffic_wds;
 		ppd->dd->traffic_wds += traffic_wds;
-		if (traffic_wds >= QIB_TRAFFIC_ACTIVE_THRESHOLD)
-			atomic_add(ACTIVITY_TIMER, &ppd->dd->active_time);
 		spin_unlock_irqrestore(&ppd->dd->eep_st_lock, flags);
 		if (ppd->cpspec->qdr_dfe_on && (ppd->link_speed_active &
 						QIB_IB_QDR) &&
diff --git a/drivers/infiniband/hw/qib/qib_init.c b/drivers/infiniband/hw/qib/qib_init.c
index 173f805..8f936e3 100644
--- a/drivers/infiniband/hw/qib/qib_init.c
+++ b/drivers/infiniband/hw/qib/qib_init.c
@@ -892,7 +892,6 @@ static void qib_shutdown_device(struct qib_devdata *dd)
 		}
 	}
 
-	qib_update_eeprom_log(dd);
 }
 
 /**
diff --git a/drivers/infiniband/hw/qib/qib_sysfs.c b/drivers/infiniband/hw/qib/qib_sysfs.c
index 3c8e4e3..b9ccbda 100644
--- a/drivers/infiniband/hw/qib/qib_sysfs.c
+++ b/drivers/infiniband/hw/qib/qib_sysfs.c
@@ -611,28 +611,6 @@ bail:
 	return ret < 0 ? ret : count;
 }
 
-static ssize_t show_logged_errs(struct device *device,
-				struct device_attribute *attr, char *buf)
-{
-	struct qib_ibdev *dev =
-		container_of(device, struct qib_ibdev, ibdev.dev);
-	struct qib_devdata *dd = dd_from_dev(dev);
-	int idx, count;
-
-	/* force consistency with actual EEPROM */
-	if (qib_update_eeprom_log(dd) != 0)
-		return -ENXIO;
-
-	count = 0;
-	for (idx = 0; idx < QIB_EEP_LOG_CNT; ++idx) {
-		count += scnprintf(buf + count, PAGE_SIZE - count, "%d%c",
-				   dd->eep_st_errs[idx],
-				   idx == (QIB_EEP_LOG_CNT - 1) ? '\n' : ' ');
-	}
-
-	return count;
-}
-
 /*
  * Dump tempsense regs. in decimal, to ease shell-scripts.
  */
@@ -679,7 +657,6 @@ static DEVICE_ATTR(nctxts, S_IRUGO, show_nctxts, NULL);
 static DEVICE_ATTR(nfreectxts, S_IRUGO, show_nfreectxts, NULL);
 static DEVICE_ATTR(serial, S_IRUGO, show_serial, NULL);
 static DEVICE_ATTR(boardversion, S_IRUGO, show_boardversion, NULL);
-static DEVICE_ATTR(logged_errors, S_IRUGO, show_logged_errs, NULL);
 static DEVICE_ATTR(tempsense, S_IRUGO, show_tempsense, NULL);
 static DEVICE_ATTR(localbus_info, S_IRUGO, show_localbus_info, NULL);
 static DEVICE_ATTR(chip_reset, S_IWUSR, NULL, store_chip_reset);
@@ -693,7 +670,6 @@ static struct device_attribute *qib_attributes[] = {
 	&dev_attr_nfreectxts,
 	&dev_attr_serial,
 	&dev_attr_boardversion,
-	&dev_attr_logged_errors,
 	&dev_attr_tempsense,
 	&dev_attr_localbus_info,
 	&dev_attr_chip_reset,
diff --git a/drivers/infiniband/ulp/isert/ib_isert.c b/drivers/infiniband/ulp/isert/ib_isert.c
index 5d4a458..8019e64 100644
--- a/drivers/infiniband/ulp/isert/ib_isert.c
+++ b/drivers/infiniband/ulp/isert/ib_isert.c
@@ -40,8 +40,15 @@ static DEFINE_MUTEX(device_list_mutex);
 static LIST_HEAD(device_list);
 static struct workqueue_struct *isert_rx_wq;
 static struct workqueue_struct *isert_comp_wq;
+static struct workqueue_struct *isert_release_wq;
 static struct kmem_cache *isert_cmd_cache;
 
+static int
+isert_rdma_post_recvl(struct isert_conn *isert_conn);
+static int
+isert_rdma_accept(struct isert_conn *isert_conn);
+struct rdma_cm_id *isert_setup_id(struct isert_np *isert_np);
+
 static void
 isert_qp_event_callback(struct ib_event *e, void *context)
 {
@@ -107,9 +114,12 @@ isert_conn_setup_qp(struct isert_conn *isert_conn, struct rdma_cm_id *cma_id)
 	attr.cap.max_recv_wr = ISERT_QP_MAX_RECV_DTOS;
 	/*
 	 * FIXME: Use devattr.max_sge - 2 for max_send_sge as
-	 * work-around for RDMA_READ..
+	 * work-around for RDMA_READs with ConnectX-2.
+	 *
+	 * Also, still make sure to have at least two SGEs for
+	 * outgoing control PDU responses.
 	 */
-	attr.cap.max_send_sge = devattr.max_sge - 2;
+	attr.cap.max_send_sge = max(2, devattr.max_sge - 2);
 	isert_conn->max_sge = attr.cap.max_send_sge;
 
 	attr.cap.max_recv_sge = 1;
@@ -124,12 +134,18 @@ isert_conn_setup_qp(struct isert_conn *isert_conn, struct rdma_cm_id *cma_id)
 	ret = rdma_create_qp(cma_id, isert_conn->conn_pd, &attr);
 	if (ret) {
 		pr_err("rdma_create_qp failed for cma_id %d\n", ret);
-		return ret;
+		goto err;
 	}
 	isert_conn->conn_qp = cma_id->qp;
 	pr_debug("rdma_create_qp() returned success >>>>>>>>>>>>>>>>>>>>>>>>>.\n");
 
 	return 0;
+err:
+	mutex_lock(&device_list_mutex);
+	device->cq_active_qps[min_index]--;
+	mutex_unlock(&device_list_mutex);
+
+	return ret;
 }
 
 static void
@@ -212,6 +228,13 @@ isert_create_device_ib_res(struct isert_device *device)
 	struct ib_device *ib_dev = device->ib_device;
 	struct isert_cq_desc *cq_desc;
 	int ret = 0, i, j;
+	int max_rx_cqe, max_tx_cqe;
+	struct ib_device_attr dev_attr;
+
+	memset(&dev_attr, 0, sizeof(struct ib_device_attr));
+	ret = isert_query_device(device->ib_device, &dev_attr);
+	if (ret)
+		return ret;
 
 	device->cqs_used = min_t(int, num_online_cpus(),
 				 device->ib_device->num_comp_vectors);
@@ -234,6 +257,9 @@ isert_create_device_ib_res(struct isert_device *device)
 		goto out_cq_desc;
 	}
 
+	max_rx_cqe = min(ISER_MAX_RX_CQ_LEN, dev_attr.max_cqe);
+	max_tx_cqe = min(ISER_MAX_TX_CQ_LEN, dev_attr.max_cqe);
+
 	for (i = 0; i < device->cqs_used; i++) {
 		cq_desc[i].device = device;
 		cq_desc[i].cq_index = i;
@@ -242,7 +268,7 @@ isert_create_device_ib_res(struct isert_device *device)
 						isert_cq_rx_callback,
 						isert_cq_event_callback,
 						(void *)&cq_desc[i],
-						ISER_MAX_RX_CQ_LEN, i);
+						max_rx_cqe, i);
 		if (IS_ERR(device->dev_rx_cq[i])) {
 			ret = PTR_ERR(device->dev_rx_cq[i]);
 			device->dev_rx_cq[i] = NULL;
@@ -253,7 +279,7 @@ isert_create_device_ib_res(struct isert_device *device)
 						isert_cq_tx_callback,
 						isert_cq_event_callback,
 						(void *)&cq_desc[i],
-						ISER_MAX_TX_CQ_LEN, i);
+						max_tx_cqe, i);
 		if (IS_ERR(device->dev_tx_cq[i])) {
 			ret = PTR_ERR(device->dev_tx_cq[i]);
 			device->dev_tx_cq[i] = NULL;
@@ -375,8 +401,8 @@ isert_device_find_by_ib_dev(struct rdma_cm_id *cma_id)
 static int
 isert_connect_request(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)
 {
-	struct iscsi_np *np = cma_id->context;
-	struct isert_np *isert_np = np->np_context;
+	struct isert_np *isert_np = cma_id->context;
+	struct iscsi_np *np = isert_np->np;
 	struct isert_conn *isert_conn;
 	struct isert_device *device;
 	struct ib_device *ib_dev = cma_id->device;
@@ -401,12 +427,12 @@ isert_connect_request(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)
 	isert_conn->state = ISER_CONN_INIT;
 	INIT_LIST_HEAD(&isert_conn->conn_accept_node);
 	init_completion(&isert_conn->conn_login_comp);
+	init_completion(&isert_conn->login_req_comp);
 	init_completion(&isert_conn->conn_wait);
 	init_completion(&isert_conn->conn_wait_comp_err);
 	kref_init(&isert_conn->conn_kref);
 	mutex_init(&isert_conn->conn_mutex);
 
-	cma_id->context = isert_conn;
 	isert_conn->conn_cm_id = cma_id;
 	isert_conn->responder_resources = event->param.conn.responder_resources;
 	isert_conn->initiator_depth = event->param.conn.initiator_depth;
@@ -466,6 +492,14 @@ isert_connect_request(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)
 	if (ret)
 		goto out_conn_dev;
 
+	ret = isert_rdma_post_recvl(isert_conn);
+	if (ret)
+		goto out_conn_dev;
+
+	ret = isert_rdma_accept(isert_conn);
+	if (ret)
+		goto out_conn_dev;
+
 	mutex_lock(&isert_np->np_accept_mutex);
 	list_add_tail(&isert_conn->conn_accept_node, &isert_np->np_accept_list);
 	mutex_unlock(&isert_np->np_accept_mutex);
@@ -486,6 +520,7 @@ out_login_buf:
 	kfree(isert_conn->login_buf);
 out:
 	kfree(isert_conn);
+	rdma_reject(cma_id, NULL, 0);
 	return ret;
 }
 
@@ -498,18 +533,20 @@ isert_connect_release(struct isert_conn *isert_conn)
 
 	pr_debug("Entering isert_connect_release(): >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n");
 
+	isert_free_rx_descriptors(isert_conn);
+	rdma_destroy_id(isert_conn->conn_cm_id);
+
 	if (isert_conn->conn_qp) {
 		cq_index = ((struct isert_cq_desc *)
 			isert_conn->conn_qp->recv_cq->cq_context)->cq_index;
 		pr_debug("isert_connect_release: cq_index: %d\n", cq_index);
+		mutex_lock(&device_list_mutex);
 		isert_conn->conn_device->cq_active_qps[cq_index]--;
+		mutex_unlock(&device_list_mutex);
 
-		rdma_destroy_qp(isert_conn->conn_cm_id);
+		ib_destroy_qp(isert_conn->conn_qp);
 	}
 
-	isert_free_rx_descriptors(isert_conn);
-	rdma_destroy_id(isert_conn->conn_cm_id);
-
 	if (isert_conn->login_buf) {
 		ib_dma_unmap_single(ib_dev, isert_conn->login_rsp_dma,
 				    ISER_RX_LOGIN_SIZE, DMA_TO_DEVICE);
@@ -529,9 +566,19 @@ isert_connect_release(struct isert_conn *isert_conn)
 static void
 isert_connected_handler(struct rdma_cm_id *cma_id)
 {
-	struct isert_conn *isert_conn = cma_id->context;
+	struct isert_conn *isert_conn = cma_id->qp->qp_context;
+
+	pr_info("conn %p\n", isert_conn);
 
-	kref_get(&isert_conn->conn_kref);
+	if (!kref_get_unless_zero(&isert_conn->conn_kref)) {
+		pr_warn("conn %p connect_release is running\n", isert_conn);
+		return;
+	}
+
+	mutex_lock(&isert_conn->conn_mutex);
+	if (isert_conn->state != ISER_CONN_FULL_FEATURE)
+		isert_conn->state = ISER_CONN_UP;
+	mutex_unlock(&isert_conn->conn_mutex);
 }
 
 static void
@@ -552,65 +599,108 @@ isert_put_conn(struct isert_conn *isert_conn)
 	kref_put(&isert_conn->conn_kref, isert_release_conn_kref);
 }
 
+/**
+ * isert_conn_terminate() - Initiate connection termination
+ * @isert_conn: isert connection struct
+ *
+ * Notes:
+ * In case the connection state is FULL_FEATURE, move state
+ * to TEMINATING and start teardown sequence (rdma_disconnect).
+ * In case the connection state is UP, complete flush as well.
+ *
+ * This routine must be called with conn_mutex held. Thus it is
+ * safe to call multiple times.
+ */
 static void
-isert_disconnect_work(struct work_struct *work)
+isert_conn_terminate(struct isert_conn *isert_conn)
 {
-	struct isert_conn *isert_conn = container_of(work,
-				struct isert_conn, conn_logout_work);
+	int err;
 
-	pr_debug("isert_disconnect_work(): >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n");
-	mutex_lock(&isert_conn->conn_mutex);
-	if (isert_conn->state == ISER_CONN_UP)
+	switch (isert_conn->state) {
+	case ISER_CONN_TERMINATING:
+		break;
+	case ISER_CONN_UP:
+		/*
+		 * No flush completions will occur as we didn't
+		 * get to ISER_CONN_FULL_FEATURE yet, complete
+		 * to allow teardown progress.
+		 */
+		complete(&isert_conn->conn_wait_comp_err);
+	case ISER_CONN_FULL_FEATURE: /* FALLTHRU */
+		pr_info("Terminating conn %p state %d\n",
+			   isert_conn, isert_conn->state);
 		isert_conn->state = ISER_CONN_TERMINATING;
-
-	if (isert_conn->post_recv_buf_count == 0 &&
-	    atomic_read(&isert_conn->post_send_buf_count) == 0) {
-		mutex_unlock(&isert_conn->conn_mutex);
-		goto wake_up;
-	}
-	if (!isert_conn->conn_cm_id) {
-		mutex_unlock(&isert_conn->conn_mutex);
-		isert_put_conn(isert_conn);
-		return;
+		err = rdma_disconnect(isert_conn->conn_cm_id);
+		if (err)
+			pr_warn("Failed rdma_disconnect isert_conn %p\n",
+				   isert_conn);
+		break;
+	default:
+		pr_warn("conn %p teminating in state %d\n",
+			   isert_conn, isert_conn->state);
 	}
+}
 
-	if (isert_conn->disconnect) {
-		/* Send DREQ/DREP towards our initiator */
-		rdma_disconnect(isert_conn->conn_cm_id);
-	}
+static int
+isert_np_cma_handler(struct isert_np *isert_np,
+		     enum rdma_cm_event_type event)
+{
+	pr_debug("isert np %p, handling event %d\n", isert_np, event);
 
-	mutex_unlock(&isert_conn->conn_mutex);
+	switch (event) {
+	case RDMA_CM_EVENT_DEVICE_REMOVAL:
+		isert_np->np_cm_id = NULL;
+		break;
+	case RDMA_CM_EVENT_ADDR_CHANGE:
+		isert_np->np_cm_id = isert_setup_id(isert_np);
+		if (IS_ERR(isert_np->np_cm_id)) {
+			pr_err("isert np %p setup id failed: %ld\n",
+				 isert_np, PTR_ERR(isert_np->np_cm_id));
+			isert_np->np_cm_id = NULL;
+		}
+		break;
+	default:
+		pr_err("isert np %p Unexpected event %d\n",
+			  isert_np, event);
+	}
 
-wake_up:
-	complete(&isert_conn->conn_wait);
+	return -1;
 }
 
 static int
-isert_disconnected_handler(struct rdma_cm_id *cma_id, bool disconnect)
+isert_disconnected_handler(struct rdma_cm_id *cma_id,
+			   enum rdma_cm_event_type event)
 {
+	struct isert_np *isert_np = cma_id->context;
 	struct isert_conn *isert_conn;
 
-	if (!cma_id->qp) {
-		struct isert_np *isert_np = cma_id->context;
+	if (isert_np->np_cm_id == cma_id)
+		return isert_np_cma_handler(cma_id->context, event);
 
-		isert_np->np_cm_id = NULL;
-		return -1;
-	}
+	isert_conn = cma_id->qp->qp_context;
 
-	isert_conn = (struct isert_conn *)cma_id->context;
+	mutex_lock(&isert_conn->conn_mutex);
+	isert_conn_terminate(isert_conn);
+	mutex_unlock(&isert_conn->conn_mutex);
 
-	isert_conn->disconnect = disconnect;
-	INIT_WORK(&isert_conn->conn_logout_work, isert_disconnect_work);
-	schedule_work(&isert_conn->conn_logout_work);
+	pr_info("conn %p completing conn_wait\n", isert_conn);
+	complete(&isert_conn->conn_wait);
 
 	return 0;
 }
 
+static void
+isert_connect_error(struct rdma_cm_id *cma_id)
+{
+	struct isert_conn *isert_conn = cma_id->qp->qp_context;
+
+	isert_put_conn(isert_conn);
+}
+
 static int
 isert_cma_handler(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)
 {
 	int ret = 0;
-	bool disconnect = false;
 
 	pr_debug("isert_cma_handler: event %d status %d conn %p id %p\n",
 		 event->event, event->status, cma_id->context, cma_id);
@@ -628,11 +718,14 @@ isert_cma_handler(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)
 	case RDMA_CM_EVENT_ADDR_CHANGE:    /* FALLTHRU */
 	case RDMA_CM_EVENT_DISCONNECTED:   /* FALLTHRU */
 	case RDMA_CM_EVENT_DEVICE_REMOVAL: /* FALLTHRU */
-		disconnect = true;
 	case RDMA_CM_EVENT_TIMEWAIT_EXIT:  /* FALLTHRU */
-		ret = isert_disconnected_handler(cma_id, disconnect);
+		ret = isert_disconnected_handler(cma_id, event->event);
 		break;
+	case RDMA_CM_EVENT_REJECTED:       /* FALLTHRU */
+	case RDMA_CM_EVENT_UNREACHABLE:    /* FALLTHRU */
 	case RDMA_CM_EVENT_CONNECT_ERROR:
+		isert_connect_error(cma_id);
+		break;
 	default:
 		pr_err("Unhandled RDMA CMA event: %d\n", event->event);
 		break;
@@ -834,7 +927,10 @@ isert_put_login_tx(struct iscsi_conn *conn, struct iscsi_login *login,
 			if (ret)
 				return ret;
 
-			isert_conn->state = ISER_CONN_UP;
+			/* Now we are in FULL_FEATURE phase */
+			mutex_lock(&isert_conn->conn_mutex);
+			isert_conn->state = ISER_CONN_FULL_FEATURE;
+			mutex_unlock(&isert_conn->conn_mutex);
 			goto post_send;
 		}
 
@@ -851,18 +947,17 @@ post_send:
 }
 
 static void
-isert_rx_login_req(struct iser_rx_desc *rx_desc, int rx_buflen,
-		   struct isert_conn *isert_conn)
+isert_rx_login_req(struct isert_conn *isert_conn)
 {
+	struct iser_rx_desc *rx_desc = (void *)isert_conn->login_req_buf;
+	int rx_buflen = isert_conn->login_req_len;
 	struct iscsi_conn *conn = isert_conn->conn;
 	struct iscsi_login *login = conn->conn_login;
 	int size;
 
-	if (!login) {
-		pr_err("conn->conn_login is NULL\n");
-		dump_stack();
-		return;
-	}
+	pr_info("conn %p\n", isert_conn);
+
+	WARN_ON_ONCE(!login);
 
 	if (login->first_request) {
 		struct iscsi_login_req *login_req =
@@ -892,7 +987,8 @@ isert_rx_login_req(struct iser_rx_desc *rx_desc, int rx_buflen,
 		 size, rx_buflen, MAX_KEY_VALUE_PAIRS);
 	memcpy(login->req_buf, &rx_desc->data[0], size);
 
-	complete(&isert_conn->conn_login_comp);
+	if (login->first_request)
+		complete(&isert_conn->conn_login_comp);
 }
 
 static void
@@ -1169,11 +1265,20 @@ isert_rx_completion(struct iser_rx_desc *desc, struct isert_conn *isert_conn,
 		 hdr->opcode, hdr->itt, hdr->flags,
 		 (int)(xfer_len - ISER_HEADERS_LEN));
 
-	if ((char *)desc == isert_conn->login_req_buf)
-		isert_rx_login_req(desc, xfer_len - ISER_HEADERS_LEN,
-				   isert_conn);
-	else
+	if ((char *)desc == isert_conn->login_req_buf) {
+		isert_conn->login_req_len = xfer_len - ISER_HEADERS_LEN;
+		if (isert_conn->conn) {
+			struct iscsi_login *login = isert_conn->conn->conn_login;
+
+			if (login && !login->first_request)
+				isert_rx_login_req(isert_conn);
+		}
+		mutex_lock(&isert_conn->conn_mutex);
+		complete(&isert_conn->login_req_comp);
+		mutex_unlock(&isert_conn->conn_mutex);
+	} else {
 		isert_rx_do_work(desc, isert_conn);
+	}
 
 	ib_dma_sync_single_for_device(ib_dev, rx_dma, rx_buflen,
 				      DMA_FROM_DEVICE);
@@ -1483,7 +1588,7 @@ isert_cq_rx_comp_err(struct isert_conn *isert_conn)
 		msleep(3000);
 
 	mutex_lock(&isert_conn->conn_mutex);
-	isert_conn->state = ISER_CONN_DOWN;
+	isert_conn_terminate(isert_conn);
 	mutex_unlock(&isert_conn->conn_mutex);
 
 	iscsit_cause_connection_reinstatement(isert_conn->conn, 0);
@@ -2044,13 +2149,51 @@ isert_response_queue(struct iscsi_conn *conn, struct iscsi_cmd *cmd, int state)
 	return ret;
 }
 
+struct rdma_cm_id *
+isert_setup_id(struct isert_np *isert_np)
+{
+	struct iscsi_np *np = isert_np->np;
+	struct rdma_cm_id *id;
+	struct sockaddr *sa;
+	int ret;
+
+	sa = (struct sockaddr *)&np->np_sockaddr;
+	pr_debug("ksockaddr: %p, sa: %p\n", &np->np_sockaddr, sa);
+
+	id = rdma_create_id(isert_cma_handler, isert_np,
+			    RDMA_PS_TCP, IB_QPT_RC);
+	if (IS_ERR(id)) {
+		pr_err("rdma_create_id() failed: %ld\n", PTR_ERR(id));
+		ret = PTR_ERR(id);
+		goto out;
+	}
+	pr_debug("id %p context %p\n", id, id->context);
+
+	ret = rdma_bind_addr(id, sa);
+	if (ret) {
+		pr_err("rdma_bind_addr() failed: %d\n", ret);
+		goto out_id;
+	}
+
+	ret = rdma_listen(id, ISERT_RDMA_LISTEN_BACKLOG);
+	if (ret) {
+		pr_err("rdma_listen() failed: %d\n", ret);
+		goto out_id;
+	}
+
+	return id;
+out_id:
+	rdma_destroy_id(id);
+out:
+	return ERR_PTR(ret);
+}
+
 static int
 isert_setup_np(struct iscsi_np *np,
 	       struct __kernel_sockaddr_storage *ksockaddr)
 {
 	struct isert_np *isert_np;
 	struct rdma_cm_id *isert_lid;
-	struct sockaddr *sa;
 	int ret;
 
 	isert_np = kzalloc(sizeof(struct isert_np), GFP_KERNEL);
@@ -2062,9 +2205,8 @@ isert_setup_np(struct iscsi_np *np,
 	mutex_init(&isert_np->np_accept_mutex);
 	INIT_LIST_HEAD(&isert_np->np_accept_list);
 	init_completion(&isert_np->np_login_comp);
+	isert_np->np = np;
 
-	sa = (struct sockaddr *)ksockaddr;
-	pr_debug("ksockaddr: %p, sa: %p\n", ksockaddr, sa);
 	/*
 	 * Setup the np->np_sockaddr from the passed sockaddr setup
 	 * in iscsi_target_configfs.c code..
@@ -2072,37 +2214,20 @@ isert_setup_np(struct iscsi_np *np,
 	memcpy(&np->np_sockaddr, ksockaddr,
 	       sizeof(struct __kernel_sockaddr_storage));
 
-	isert_lid = rdma_create_id(isert_cma_handler, np, RDMA_PS_TCP,
-				IB_QPT_RC);
+	isert_lid = isert_setup_id(isert_np);
 	if (IS_ERR(isert_lid)) {
-		pr_err("rdma_create_id() for isert_listen_handler failed: %ld\n",
-		       PTR_ERR(isert_lid));
 		ret = PTR_ERR(isert_lid);
 		goto out;
 	}
 
-	ret = rdma_bind_addr(isert_lid, sa);
-	if (ret) {
-		pr_err("rdma_bind_addr() for isert_lid failed: %d\n", ret);
-		goto out_lid;
-	}
-
-	ret = rdma_listen(isert_lid, ISERT_RDMA_LISTEN_BACKLOG);
-	if (ret) {
-		pr_err("rdma_listen() for isert_lid failed: %d\n", ret);
-		goto out_lid;
-	}
-
 	isert_np->np_cm_id = isert_lid;
 	np->np_context = isert_np;
-	pr_debug("Setup isert_lid->context: %p\n", isert_lid->context);
 
 	return 0;
 
-out_lid:
-	rdma_destroy_id(isert_lid);
 out:
 	kfree(isert_np);
+
 	return ret;
 }
 
@@ -2138,13 +2263,27 @@ isert_get_login_rx(struct iscsi_conn *conn, struct iscsi_login *login)
 	struct isert_conn *isert_conn = (struct isert_conn *)conn->context;
 	int ret;
 
-	pr_debug("isert_get_login_rx before conn_login_comp conn: %p\n", conn);
+	pr_info("before login_req comp conn: %p\n", isert_conn);
+	ret = wait_for_completion_interruptible(&isert_conn->login_req_comp);
+	if (ret) {
+		pr_err("isert_conn %p interrupted before got login req\n",
+			isert_conn);
+		return ret;
+	}
+	isert_conn->login_req_comp.done = 0;
+
+	if (!login->first_request)
+		return 0;
+
+	isert_rx_login_req(isert_conn);
+
+	pr_info("before conn_login_comp conn: %p\n", conn);
 
 	ret = wait_for_completion_interruptible(&isert_conn->conn_login_comp);
 	if (ret)
 		return ret;
 
-	pr_debug("isert_get_login_rx processing login->req: %p\n", login->req);
+	pr_info("processing login->req: %p\n", login->req);
 	return 0;
 }
 
@@ -2222,17 +2361,10 @@ accept_wait:
 	isert_conn->conn = conn;
 	max_accept = 0;
 
-	ret = isert_rdma_post_recvl(isert_conn);
-	if (ret)
-		return ret;
-
-	ret = isert_rdma_accept(isert_conn);
-	if (ret)
-		return ret;
-
 	isert_set_conn_info(np, conn, isert_conn);
 
-	pr_debug("Processing isert_accept_np: isert_conn: %p\n", isert_conn);
+	pr_debug("Processing isert_conn: %p\n", isert_conn);
+
 	return 0;
 }
 
@@ -2248,6 +2380,24 @@ isert_free_np(struct iscsi_np *np)
 	kfree(isert_np);
 }
 
+static void isert_release_work(struct work_struct *work)
+{
+	struct isert_conn *isert_conn = container_of(work,
+						     struct isert_conn,
+						     release_work);
+
+	pr_info("Starting release conn %p\n", isert_conn);
+
+	wait_for_completion(&isert_conn->conn_wait);
+
+	mutex_lock(&isert_conn->conn_mutex);
+	isert_conn->state = ISER_CONN_DOWN;
+	mutex_unlock(&isert_conn->conn_mutex);
+
+	pr_info("Destroying conn %p\n", isert_conn);
+	isert_put_conn(isert_conn);
+}
+
 static void isert_wait_conn(struct iscsi_conn *conn)
 {
 	struct isert_conn *isert_conn = conn->context;
@@ -2255,10 +2405,6 @@ static void isert_wait_conn(struct iscsi_conn *conn)
 	pr_debug("isert_wait_conn: Starting \n");
 
 	mutex_lock(&isert_conn->conn_mutex);
-	if (isert_conn->conn_cm_id) {
-		pr_debug("Calling rdma_disconnect from isert_wait_conn\n");
-		rdma_disconnect(isert_conn->conn_cm_id);
-	}
 	/*
 	 * Only wait for conn_wait_comp_err if the isert_conn made it
 	 * into full feature phase..
@@ -2267,14 +2413,13 @@ static void isert_wait_conn(struct iscsi_conn *conn)
 		mutex_unlock(&isert_conn->conn_mutex);
 		return;
 	}
-	if (isert_conn->state == ISER_CONN_UP)
-		isert_conn->state = ISER_CONN_TERMINATING;
+	isert_conn_terminate(isert_conn);
 	mutex_unlock(&isert_conn->conn_mutex);
 
 	wait_for_completion(&isert_conn->conn_wait_comp_err);
 
-	wait_for_completion(&isert_conn->conn_wait);
-	isert_put_conn(isert_conn);
+	INIT_WORK(&isert_conn->release_work, isert_release_work);
+	queue_work(isert_release_wq, &isert_conn->release_work);
 }
 
 static void isert_free_conn(struct iscsi_conn *conn)
@@ -2320,20 +2465,30 @@ static int __init isert_init(void)
 		goto destroy_rx_wq;
 	}
 
+	isert_release_wq = alloc_workqueue("isert_release_wq", WQ_UNBOUND,
+					WQ_UNBOUND_MAX_ACTIVE);
+	if (!isert_release_wq) {
+		pr_err("Unable to allocate isert_release_wq\n");
+		ret = -ENOMEM;
+		goto destroy_comp_wq;
+	}
+
 	isert_cmd_cache = kmem_cache_create("isert_cmd_cache",
 			sizeof(struct isert_cmd), __alignof__(struct isert_cmd),
 			0, NULL);
 	if (!isert_cmd_cache) {
 		pr_err("Unable to create isert_cmd_cache\n");
 		ret = -ENOMEM;
-		goto destroy_tx_cq;
+		goto destroy_release_wq;
 	}
 
 	iscsit_register_transport(&iser_target_transport);
-	pr_debug("iSER_TARGET[0] - Loaded iser_target_transport\n");
+	pr_info("iSER_TARGET[0] - Loaded iser_target_transport\n");
 	return 0;
 
-destroy_tx_cq:
+destroy_release_wq:
+	destroy_workqueue(isert_release_wq);
+destroy_comp_wq:
 	destroy_workqueue(isert_comp_wq);
 destroy_rx_wq:
 	destroy_workqueue(isert_rx_wq);
@@ -2344,6 +2499,7 @@ static void __exit isert_exit(void)
 {
 	flush_scheduled_work();
 	kmem_cache_destroy(isert_cmd_cache);
+	destroy_workqueue(isert_release_wq);
 	destroy_workqueue(isert_comp_wq);
 	destroy_workqueue(isert_rx_wq);
 	iscsit_unregister_transport(&iser_target_transport);
diff --git a/drivers/infiniband/ulp/isert/ib_isert.h b/drivers/infiniband/ulp/isert/ib_isert.h
index 032f65a..b233ee5 100644
--- a/drivers/infiniband/ulp/isert/ib_isert.h
+++ b/drivers/infiniband/ulp/isert/ib_isert.h
@@ -21,6 +21,7 @@ enum iser_ib_op_code {
 enum iser_conn_state {
 	ISER_CONN_INIT,
 	ISER_CONN_UP,
+	ISER_CONN_FULL_FEATURE,
 	ISER_CONN_TERMINATING,
 	ISER_CONN_DOWN,
 };
@@ -87,6 +88,7 @@ struct isert_conn {
 	char			*login_req_buf;
 	char			*login_rsp_buf;
 	u64			login_req_dma;
+	int			login_req_len;
 	u64			login_rsp_dma;
 	unsigned int		conn_rx_desc_head;
 	struct iser_rx_desc	*conn_rx_descs;
@@ -94,18 +96,18 @@ struct isert_conn {
 	struct iscsi_conn	*conn;
 	struct list_head	conn_accept_node;
 	struct completion	conn_login_comp;
+	struct completion	login_req_comp;
 	struct iser_tx_desc	conn_login_tx_desc;
 	struct rdma_cm_id	*conn_cm_id;
 	struct ib_pd		*conn_pd;
 	struct ib_mr		*conn_mr;
 	struct ib_qp		*conn_qp;
 	struct isert_device	*conn_device;
-	struct work_struct	conn_logout_work;
 	struct mutex		conn_mutex;
 	struct completion	conn_wait;
 	struct completion	conn_wait_comp_err;
 	struct kref		conn_kref;
-	bool			disconnect;
+	struct work_struct	release_work;
 };
 
 #define ISERT_MAX_CQ 64
@@ -131,6 +133,7 @@ struct isert_device {
 };
 
 struct isert_np {
+	struct iscsi_np         *np;
 	struct semaphore	np_sem;
 	struct rdma_cm_id	*np_cm_id;
 	struct mutex		np_accept_mutex;
diff --git a/drivers/input/serio/i8042-x86ia64io.h b/drivers/input/serio/i8042-x86ia64io.h
index ce715b1..4de2571 100644
--- a/drivers/input/serio/i8042-x86ia64io.h
+++ b/drivers/input/serio/i8042-x86ia64io.h
@@ -152,6 +152,14 @@ static const struct dmi_system_id __initconst i8042_dmi_noloop_table[] = {
 		},
 	},
 	{
+		/* Medion Akoya E7225 */
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Medion"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Akoya E7225"),
+			DMI_MATCH(DMI_PRODUCT_VERSION, "1.0"),
+		},
+	},
+	{
 		/* Blue FB5601 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "blue"),
@@ -408,6 +416,13 @@ static const struct dmi_system_id __initconst i8042_dmi_nomux_table[] = {
 		},
 	},
 	{
+		/* Acer Aspire 7738 */
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Acer"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Aspire 7738"),
+		},
+	},
+	{
 		/* Gericom Bellagio */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Gericom"),
@@ -721,6 +736,35 @@ static const struct dmi_system_id __initconst i8042_dmi_dritek_table[] = {
 	{ }
 };
 
+/*
+ * Some laptops need keyboard reset before probing for the trackpad to get
+ * it detected, initialised & finally work.
+ */
+static const struct dmi_system_id __initconst i8042_dmi_kbdreset_table[] = {
+	{
+		/* Gigabyte P35 v2 - Elantech touchpad */
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GIGABYTE"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "P35V2"),
+		},
+	},
+		{
+		/* Aorus branded Gigabyte X3 Plus - Elantech touchpad */
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GIGABYTE"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "X3"),
+		},
+	},
+	{
+		/* Gigabyte P34 - Elantech touchpad */
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GIGABYTE"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "P34"),
+		},
+	},
+	{ }
+};
+
 #endif /* CONFIG_X86 */
 
 #ifdef CONFIG_PNP
@@ -1001,6 +1045,9 @@ static int __init i8042_platform_init(void)
 	if (dmi_check_system(i8042_dmi_dritek_table))
 		i8042_dritek = true;
 
+	if (dmi_check_system(i8042_dmi_kbdreset_table))
+		i8042_kbdreset = true;
+
 	/*
 	 * A20 was already enabled during early kernel init. But some buggy
 	 * BIOSes (in MSI Laptops) require A20 to be enabled using 8042 to
diff --git a/drivers/input/serio/i8042.c b/drivers/input/serio/i8042.c
index 78e4de4..9870c54 100644
--- a/drivers/input/serio/i8042.c
+++ b/drivers/input/serio/i8042.c
@@ -67,6 +67,10 @@ static bool i8042_notimeout;
 module_param_named(notimeout, i8042_notimeout, bool, 0);
 MODULE_PARM_DESC(notimeout, "Ignore timeouts signalled by i8042");
 
+static bool i8042_kbdreset;
+module_param_named(kbdreset, i8042_kbdreset, bool, 0);
+MODULE_PARM_DESC(kbdreset, "Reset device connected to KBD port");
+
 #ifdef CONFIG_X86
 static bool i8042_dritek;
 module_param_named(dritek, i8042_dritek, bool, 0);
@@ -783,6 +787,16 @@ static int __init i8042_check_aux(void)
 		return -1;
 
 /*
+ * Reset keyboard (needed on some laptops to successfully detect
+ * touchpad, e.g., some Gigabyte laptop models with Elantech
+ * touchpads).
+ */
+	if (i8042_kbdreset) {
+		pr_warn("Attempting to reset device connected to KBD port\n");
+		i8042_kbd_write(NULL, (unsigned char) 0xff);
+	}
+
+/*
  * Test AUX IRQ delivery to make sure BIOS did not grab the IRQ and
  * used it for a PCI card or somethig else.
  */
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 46de11a..04a79b0 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -421,6 +421,9 @@ config TOUCHSCREEN_MTK
 	help
 	  Say Y here if you have MediaTek touch panel.
 
+config TOUCHSCREEN_RESOLUTION_DIFF
+	bool "MediaTek EVB using same custom folder with different touch resolution"
+
 config TOUCHSCREEN_MTK_GT9XX
 	bool "GT9XX for Mediatek package"
 	depends on TOUCHSCREEN_MTK
@@ -508,7 +511,7 @@ config MTK_FT5406
         
 config MTK_FT5436I
         bool "FT5436I for Mediatek package"
-        default n        
+        default n
 
 config MTK_FT5406_82
         bool "FT5406_82 for Mediatek package"
diff --git a/drivers/input/touchscreen/mediatek/FT5436I/Makefile b/drivers/input/touchscreen/mediatek/FT5436I/Makefile
index 31312bb..c0b64d8 100644
--- a/drivers/input/touchscreen/mediatek/FT5436I/Makefile
+++ b/drivers/input/touchscreen/mediatek/FT5436I/Makefile
@@ -3,7 +3,7 @@ include $(srctree)/drivers/misc/mediatek/Makefile.custom
 # Linux driver folder
 ccflags-y += -I$(srctree)/drivers/input/touchscreen/mediatek/
 
-obj-y	+=  focaltech_driver.o focaltech_ex_fun.o focaltech_ctl.o fts_alsps.o
+obj-y	+=  focaltech_driver.o focaltech_ex_fun.o focaltech_ctl.o fts_alsps.o 
 ifeq ($(ARCH),arm)
 obj-y	+=  32bit/ft_gesture_lib.a
 else
diff --git a/drivers/input/touchscreen/mediatek/FT5436I/focaltech_driver.c b/drivers/input/touchscreen/mediatek/FT5436I/focaltech_driver.c
index 2c148b2..db586e5 100644
--- a/drivers/input/touchscreen/mediatek/FT5436I/focaltech_driver.c
+++ b/drivers/input/touchscreen/mediatek/FT5436I/focaltech_driver.c
@@ -37,12 +37,14 @@
 #include <cust_eint.h>
 #include <cust_alsps.h>
 
+
 /*if need these function, pls enable this MACRO*/
 //#define MT_PROTOCOL_B
 //#define TPD_PROXIMITY
+//#define FTS_GESTRUE
 //#define TPD_AUTO_UPGRADE				
 
-#define FTS_CTL_IIC
+//#define FTS_CTL_IIC
 #define SYSFS_DEBUG
 //#define FTS_APK_DEBUG
 int fts_load_status = 0;
@@ -91,23 +93,44 @@ int fts_load_status = 0;
 #endif
 #define FT_PROXIMITY_ENABLE		1
 #define FT_PROXIMITY_DISABLE	0
-
 /*GESTRUE*/
-#define FTS_GESTRUE
 #ifdef FTS_GESTRUE
 	#include "ft_gesture_lib.h"
 
-#define GESTURE_DOUBLECLICK				0x24
-#define GESTURE_HOMEKEY_DOUBLECLICK		0x26
-
 	#define FTS_GESTRUE_POINTS 				255
 	#define FTS_GESTRUE_POINTS_ONETIME  		62
 	#define FTS_GESTRUE_POINTS_HEADER 		8
 	#define FTS_GESTURE_OUTPUT_ADRESS 		0xD3
 	#define FTS_GESTURE_OUTPUT_UNIT_LENGTH 	4
 
+	#define KEY_GESTURE_U 						KEY_U
+	#define KEY_GESTURE_UP 						KEY_UP
+	#define KEY_GESTURE_DOWN 					KEY_DOWN
+	#define KEY_GESTURE_LEFT 					KEY_LEFT 
+	#define KEY_GESTURE_RIGHT 					KEY_RIGHT
+	#define KEY_GESTURE_O 						KEY_O
+	#define KEY_GESTURE_E 						KEY_E
+	#define KEY_GESTURE_M 						KEY_M 
+	#define KEY_GESTURE_L 						KEY_L
+	#define KEY_GESTURE_W 						KEY_W
+	#define KEY_GESTURE_S 						KEY_S 
+	#define KEY_GESTURE_V 						KEY_V
+	#define KEY_GESTURE_Z 						KEY_Z
+
+	#define GESTURE_LEFT						0x20
+	#define GESTURE_RIGHT						0x21
+	#define GESTURE_UP		    					0x22
+	#define GESTURE_DOWN						0x23
+	#define GESTURE_DOUBLECLICK				0x24
+	#define GESTURE_O		    					0x30
+	#define GESTURE_W		    					0x31
+	#define GESTURE_M		    					0x32
+	#define GESTURE_E		    					0x33
+	#define GESTURE_L		    					0x44
+	#define GESTURE_S		    					0x46
+	#define GESTURE_V		    					0x54
+	#define GESTURE_Z		    					0x41
 
-short pointnum = 0;
 	unsigned short coordinate_x[150] = {0};
 	unsigned short coordinate_y[150] = {0};
 #endif
@@ -150,8 +173,6 @@ extern void mt_eint_set_polarity(unsigned int eint_num, unsigned int pol);
 extern unsigned int mt_eint_set_sens(unsigned int eint_num, unsigned int sens);
 extern void mt_eint_registration(unsigned int eint_num, unsigned int flow, void (EINT_FUNC_PTR)(void), unsigned int is_auto_umask);
 
-static int wakeup_flag 	= 0;//add by wangyang
-
 /*dma declare, allocate and release*/
 #define __MSG_DMA_MODE__
 #ifdef __MSG_DMA_MODE__
@@ -255,7 +276,7 @@ static u8 buf_value[2] = { 0 };
 *	open/release/(I/O) control tpd device
 *
 */
-#define VELOCITY_CUSTOM_fts
+//#define VELOCITY_CUSTOM_fts
 #ifdef VELOCITY_CUSTOM_fts
 #include <linux/device.h>
 #include <linux/miscdevice.h>
@@ -272,8 +293,6 @@ static u8 buf_value[2] = { 0 };
 #define TOUCH_IOC_MAGIC 						'A'
 #define TPD_GET_VELOCITY_CUSTOM_X 			_IO(TOUCH_IOC_MAGIC,0)
 #define TPD_GET_VELOCITY_CUSTOM_Y 			_IO(TOUCH_IOC_MAGIC,1)
-#define TPD_SET_WAKEUP_FEATURE 		_IOW(TOUCH_IOC_MAGIC,2,int)//add by wangyang
-#define TPD_GET_WAKEUP_FEATURE 		_IOR(TOUCH_IOC_MAGIC,3,int)
 
 int g_v_magnify_x =TPD_VELOCITY_CUSTOM_X;
 int g_v_magnify_y =TPD_VELOCITY_CUSTOM_Y;
@@ -315,7 +334,6 @@ static long tpd_unlocked_ioctl(struct file *file, unsigned int cmd,
 
 	void __user *data;
 	
-	int wakeup = 0;
 	long err = 0;
 	
 	if(_IOC_DIR(cmd) & _IOC_READ)
@@ -365,24 +383,6 @@ static long tpd_unlocked_ioctl(struct file *file, unsigned int cmd,
 			}				 
 			break;
 
-		case TPD_SET_WAKEUP_FEATURE://add by wangyang
-			data = (void __user *) arg;
-			if(data == NULL)
-			{
-				err = -EINVAL;
-				break;	  
-			}			
-			if(copy_from_user(&wakeup, data, sizeof(wakeup)))
-			{
-				err = -EFAULT;
-				break;
-			}				 
-			printk("tpd: wakeup	%d\n",wakeup);
-			if(wakeup != 1)
-				wakeup_flag = 0;
-			else
-				wakeup_flag = 1;
-			break;
 
 		default:
 			printk("tpd: unknown IOCTL: 0x%08x\n", cmd);
@@ -653,30 +653,29 @@ void fts_get_upgrade_array(void)
 ***********************************************************************/
 static void tpd_down(int x, int y, int p) {
 	
-	//if(x > TPD_RES_X)
-	//{
-	//	TPD_DEBUG("warning: IC have sampled wrong value.\n");;
-	//	return;
-	//}
+	if(x > TPD_RES_X)
+	{
+		TPD_DEBUG("warning: IC have sampled wrong value.\n");;
+		return;
+	}
 	input_report_key(tpd->dev, BTN_TOUCH, 1);
-	//input_report_abs(tpd->dev, ABS_MT_TOUCH_MAJOR, 20);
-	//input_report_abs(tpd->dev, ABS_MT_PRESSURE, 0x3f);
+	input_report_abs(tpd->dev, ABS_MT_TOUCH_MAJOR, 20);
+	input_report_abs(tpd->dev, ABS_MT_PRESSURE, 0x3f);
 	input_report_abs(tpd->dev, ABS_MT_POSITION_X, x);
 	input_report_abs(tpd->dev, ABS_MT_POSITION_Y, y);
 	//printk("tpd:D[%4d %4d %4d] ", x, y, p);
 	/* track id Start 0 */
-     	input_report_abs(tpd->dev, ABS_MT_TRACKING_ID, p); 
+     	//input_report_abs(tpd->dev, ABS_MT_TRACKING_ID, p); 
 	input_mt_sync(tpd->dev);
-
      	if (FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode())
      	{   
        	tpd_button(x, y, 1);  
      	}
-	//if(y > TPD_RES_Y) //virtual key debounce to avoid android ANR issue
-	//{
-    //   	//msleep(50);
-	//	printk("D virtual key \n");
-	// }
+	if(y > TPD_RES_Y) //virtual key debounce to avoid android ANR issue
+	{
+       	//msleep(50);
+		printk("D virtual key \n");
+	 }
 	 TPD_EM_PRINT(x, y, x, y, p-1, 1);
  }
  /************************************************************************
@@ -1112,16 +1111,82 @@ static void check_gesture(int gesture_id)
     	//printk("fts gesture_id==0x%x\n ",gesture_id);
 	switch(gesture_id)
 	{
+		case GESTURE_LEFT:
+				input_report_key(tpd->dev, KEY_GESTURE_LEFT, 1);
+				input_sync(tpd->dev);
+				input_report_key(tpd->dev, KEY_GESTURE_LEFT, 0);
+				input_sync(tpd->dev);
+			break;
+		case GESTURE_RIGHT:
+				input_report_key(tpd->dev, KEY_GESTURE_RIGHT, 1);
+				input_sync(tpd->dev);
+				input_report_key(tpd->dev, KEY_GESTURE_RIGHT, 0);
+				input_sync(tpd->dev);
+			break;
+		case GESTURE_UP:
+				input_report_key(tpd->dev, KEY_GESTURE_UP, 1);
+				input_sync(tpd->dev);
+				input_report_key(tpd->dev, KEY_GESTURE_UP, 0);
+				input_sync(tpd->dev);			
+			break;
+		case GESTURE_DOWN:
+				input_report_key(tpd->dev, KEY_GESTURE_DOWN, 1);
+				input_sync(tpd->dev);
+				input_report_key(tpd->dev, KEY_GESTURE_DOWN, 0);
+				input_sync(tpd->dev);
+			break;
 		case GESTURE_DOUBLECLICK:
 				input_report_key(tpd->dev, KEY_GESTURE_U, 1);
 				input_sync(tpd->dev);
 				input_report_key(tpd->dev, KEY_GESTURE_U, 0);
 				input_sync(tpd->dev);
 			break;
-		case GESTURE_HOMEKEY_DOUBLECLICK:
-				input_report_key(tpd->dev, KEY_GESTURE_H, 1);
+		case GESTURE_O:
+				input_report_key(tpd->dev, KEY_GESTURE_O, 1);
+				input_sync(tpd->dev);
+				input_report_key(tpd->dev, KEY_GESTURE_O, 0);
+				input_sync(tpd->dev);
+			break;
+		case GESTURE_W:
+				input_report_key(tpd->dev, KEY_GESTURE_W, 1);
+				input_sync(tpd->dev);
+				input_report_key(tpd->dev, KEY_GESTURE_W, 0);
+				input_sync(tpd->dev);
+			break;
+		case GESTURE_M:
+				input_report_key(tpd->dev, KEY_GESTURE_M, 1);
+				input_sync(tpd->dev);
+				input_report_key(tpd->dev, KEY_GESTURE_M, 0);
+				input_sync(tpd->dev);
+			break;
+		case GESTURE_E:
+				input_report_key(tpd->dev, KEY_GESTURE_E, 1);
+				input_sync(tpd->dev);
+				input_report_key(tpd->dev, KEY_GESTURE_E, 0);
+				input_sync(tpd->dev);
+			break;
+		case GESTURE_L:
+				input_report_key(tpd->dev, KEY_GESTURE_L, 1);
+				input_sync(tpd->dev);
+				input_report_key(tpd->dev, KEY_GESTURE_L, 0);
+				input_sync(tpd->dev);
+			break;
+		case GESTURE_S:
+				input_report_key(tpd->dev, KEY_GESTURE_S, 1);
+				input_sync(tpd->dev);
+				input_report_key(tpd->dev, KEY_GESTURE_S, 0);
+				input_sync(tpd->dev);
+			break;
+		case GESTURE_V:
+				input_report_key(tpd->dev, KEY_GESTURE_V, 1);
+				input_sync(tpd->dev);
+				input_report_key(tpd->dev, KEY_GESTURE_V, 0);
+				input_sync(tpd->dev);
+			break;
+		case GESTURE_Z:
+				input_report_key(tpd->dev, KEY_GESTURE_Z, 1);
 				input_sync(tpd->dev);
-				input_report_key(tpd->dev, KEY_GESTURE_H, 0);
+				input_report_key(tpd->dev, KEY_GESTURE_Z, 0);
 				input_sync(tpd->dev);
 			break;
 		default:
@@ -1137,34 +1202,92 @@ static void check_gesture(int gesture_id)
 ***********************************************************************/
 static int fts_read_Gestruedata(void)
 {
-    unsigned char buf[FTS_GESTRUE_POINTS * 4+2+6] = { 0 };
+    unsigned char buf[FTS_GESTRUE_POINTS * 3] = { 0 };
     int ret = -1;
     int i = 0;
     buf[0] = 0xd3;
     int gestrue_id = 0;
-    pointnum = 0;
+    short pointnum = 0;
 
+    pointnum = 0;
     ret = fts_i2c_Read(i2c_client, buf, 1, buf, FTS_GESTRUE_POINTS_HEADER);
+	//printk( "tpd read FTS_GESTRUE_POINTS_HEADER.\n");
     if (ret < 0)
     {
-        printk( "%s read touchdata failed.\n", __func__);
-        return ret;
+	        	printk( "%s read touchdata failed.\n", __func__);
+	        	return ret;
     }
 
-    if (GESTURE_DOUBLECLICK == buf[0])
+    /* FW */
+     if (fts_updateinfo_curr.CHIP_ID==0x54|| fts_updateinfo_curr.CHIP_ID==0x58)
+     {
+	     		 gestrue_id = buf[0];
+			 pointnum = (short)(buf[1]) & 0xff;
+		 	 buf[0] = 0xd3;
+		 
+		 	 if((pointnum * 4 + 8)<255)
+		 	 {
+		 	    	 ret = fts_i2c_Read(i2c_client, buf, 1, buf, (pointnum * 4 + 8));
+		 	 }
+		 	 else
+		 	 {
+		 	        ret = fts_i2c_Read(i2c_client, buf, 1, buf, 255);
+		 	        ret = fts_i2c_Read(i2c_client, buf, 0, buf+255, (pointnum * 4 + 8) -255);
+		 	 }
+		 	 if (ret < 0)
+		 	 {
+		 	       printk( "%s read touchdata failed.\n", __func__);
+		 	       return ret;
+		 	 }
+	        	 check_gesture(gestrue_id);
+			 for(i = 0;i < pointnum;i++)
+		        {
+		        	coordinate_x[i] =  (((s16) buf[0 + (4 * i)]) & 0x0F) <<
+		            	8 | (((s16) buf[1 + (4 * i)])& 0xFF);
+		        	coordinate_y[i] = (((s16) buf[2 + (4 * i)]) & 0x0F) <<
+		            	8 | (((s16) buf[3 + (4 * i)]) & 0xFF);
+		   	 }
+	        	 return -1;
+     }
+
+    if (0x24 == buf[0])
 
     {
-	        	gestrue_id = GESTURE_DOUBLECLICK;
+	        	gestrue_id = 0x24;
 	        	check_gesture(gestrue_id);
+		 	printk( "tpd %d check_gesture gestrue_id.\n", gestrue_id);
 	        	return -1;
     }
-	if (GESTURE_HOMEKEY_DOUBLECLICK == buf[0])
+	
+    pointnum = (short)(buf[1]) & 0xff;
+    buf[0] = 0xd3;
+    if((pointnum * 4 + 8)<255)
     {
-        gestrue_id = GESTURE_HOMEKEY_DOUBLECLICK;
-        check_gesture(gestrue_id);
-        return -1;
+    			ret = fts_i2c_Read(i2c_client, buf, 1, buf, (pointnum * 4 + 8));
     }
-	
+    else
+    {
+	         	ret = fts_i2c_Read(i2c_client, buf, 1, buf, 255);
+	         	ret = fts_i2c_Read(i2c_client, buf, 0, buf+255, (pointnum * 4 + 8) -255);
+    }
+    if (ret < 0)
+    {
+	        	printk( "%s read touchdata failed.\n", __func__);
+	        	return ret;
+    }
+
+    gestrue_id = fetch_object_sample(buf, pointnum);
+    check_gesture(gestrue_id);
+    //printk( "tpd %d read gestrue_id.\n", gestrue_id);
+
+    for(i = 0;i < pointnum;i++)
+    {
+	        	coordinate_x[i] =  (((s16) buf[0 + (4 * i)]) & 0x0F) <<
+	            			8 | (((s16) buf[1 + (4 * i)])& 0xFF);
+	        	coordinate_y[i] = (((s16) buf[2 + (4 * i)]) & 0x0F) <<
+	            			8 | (((s16) buf[3 + (4 * i)]) & 0xFF);
+    }
+    return -1;
 }
 #endif
  /************************************************************************
@@ -1459,12 +1582,12 @@ extern int register_alsps(void);
 * Output: no
 * Return: 0
 ***********************************************************************/
-static int tpd_probe(struct i2c_client *client, const struct i2c_device_id *id)
+ static int tpd_probe(struct i2c_client *client, const struct i2c_device_id *id)
  {	 
 	int retval = TPD_OK;
 	char data;
 	u8 report_rate=0;
-	int err=0;
+	//int err=0;
 	int reset_count = 0;
 	unsigned char uc_reg_value;
 	unsigned char uc_reg_addr;
@@ -1574,19 +1697,7 @@ static int tpd_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		  TPD_DMESG(TPD_DEVICE " failed to create kernel thread: %d\n", retval);
 	}
 
-	#ifdef FTS_GESTRUE
-		//init_para(480,854,60,0,0);
-	 
-		input_set_capability(tpd->dev, EV_KEY, KEY_POWER);
-		input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_U); 
-		input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_H);
-	
-		__set_bit(KEY_GESTURE_U, tpd->dev->keybit);
-		__set_bit(KEY_GESTURE_H, tpd->dev->keybit);
 
-		__set_bit(EV_KEY, tpd->dev->evbit);
-		__set_bit(EV_SYN, tpd->dev->evbit);
-	#endif
 	
 	#ifdef SYSFS_DEBUG
                 fts_create_sysfs(i2c_client);
@@ -1623,6 +1734,39 @@ static int tpd_probe(struct i2c_client *client, const struct i2c_device_id *id)
     		queue_delayed_work(gtp_esd_check_workqueue, &gtp_esd_check_work, TPD_ESD_CHECK_CIRCLE);
 	#endif
 
+	#ifdef FTS_GESTRUE
+		init_para(480,854,60,0,0);
+	 
+		input_set_capability(tpd->dev, EV_KEY, KEY_POWER);
+		input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_U); 
+		input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_UP); 
+		input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_DOWN);
+		input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_LEFT); 
+		input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_RIGHT); 
+		input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_O);
+		input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_E); 
+		input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_M); 
+		input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_L);
+		input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_W);
+		input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_S); 
+		input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_V);
+		input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_Z);
+			
+		__set_bit(KEY_GESTURE_RIGHT, tpd->dev->keybit);
+		__set_bit(KEY_GESTURE_LEFT, tpd->dev->keybit);
+		__set_bit(KEY_GESTURE_UP, tpd->dev->keybit);
+		__set_bit(KEY_GESTURE_DOWN, tpd->dev->keybit);
+		__set_bit(KEY_GESTURE_U, tpd->dev->keybit);
+		__set_bit(KEY_GESTURE_O, tpd->dev->keybit);
+		__set_bit(KEY_GESTURE_E, tpd->dev->keybit);
+		__set_bit(KEY_GESTURE_M, tpd->dev->keybit);
+		__set_bit(KEY_GESTURE_W, tpd->dev->keybit);
+		__set_bit(KEY_GESTURE_L, tpd->dev->keybit);
+		__set_bit(KEY_GESTURE_S, tpd->dev->keybit);
+		__set_bit(KEY_GESTURE_V, tpd->dev->keybit);
+		__set_bit(KEY_GESTURE_Z, tpd->dev->keybit);
+	#endif
+
 	#ifdef MT_PROTOCOL_B
 		#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0))
 			input_mt_init_slots(tpd->dev, MT_MAX_TOUCH_POINTS);
@@ -1936,7 +2080,7 @@ FOCAL_RESET_A3_REGISTER:
  static void tpd_resume( struct early_suspend *h )
  {
 	int i=0,ret = 0;
-
+	
  	TPD_DMESG("TPD wake up\n");
 	buf_addr[0]=0xC0;
 	buf_addr[1]=0x8B;
@@ -1966,7 +2110,6 @@ FOCAL_RESET_A3_REGISTER:
  	#ifdef FTS_GESTRUE
     		fts_write_reg(i2c_client,0xD0,0x00);
 	#endif
-   	TPD_DMESG("TPD wake up\n");
 	#ifdef TPD_CLOSE_POWER_IN_SLEEP	
 		hwPowerOn(TPD_POWER_SOURCE,VOL_3300,"TP");
 	#else
@@ -1974,11 +2117,10 @@ FOCAL_RESET_A3_REGISTER:
 	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
     	mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
     	mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);  
-    	msleep(2);  
-    	//mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-    	//mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
+    	msleep(1);  
+    	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
+    	mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
     	mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
-	TPD_DMESG("TPD RST\n");
 	#endif
 	mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);  
 	msleep(30);
@@ -2015,6 +2157,7 @@ FOCAL_RESET_A3_REGISTER:
 			//return ret;
 		}
 	}
+
 			
 	TPD_DMESG("TPD enter sleep\n");
 	#ifdef TPD_PROXIMITY
@@ -2023,14 +2166,9 @@ FOCAL_RESET_A3_REGISTER:
 		tpd_proximity_flag_one = 1;	
 		return;
 	}
-	#ifdef GTP_ESD_PROTECT
-	cancel_delayed_work_sync(&gtp_esd_check_work);
-	#endif
 	#endif
-		
-	if(wakeup_flag)
-	{
-#ifdef FTS_GESTRUE
+
+	#ifdef FTS_GESTRUE
         	fts_write_reg(i2c_client, 0xd0, 0x01);
 		if (fts_updateinfo_curr.CHIP_ID==0x54 || fts_updateinfo_curr.CHIP_ID==0x58)
 		{
@@ -2041,14 +2179,13 @@ FOCAL_RESET_A3_REGISTER:
 			fts_write_reg(i2c_client, 0xd7, 0xff);
 			fts_write_reg(i2c_client, 0xd8, 0xff);
 		}
-		tpd_halt = 1;
-		return ;
-#endif
-	}else
-	{
+        	return;
+	#endif
+	#ifdef GTP_ESD_PROTECT
+    		cancel_delayed_work_sync(&gtp_esd_check_work);
+	#endif
  	 tpd_halt = 1;
 
-	TPD_DMESG("TPD enter sleep\n");
 	 mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
 	 mutex_lock(&i2c_access);
 	#ifdef TPD_CLOSE_POWER_IN_SLEEP	
@@ -2077,8 +2214,26 @@ FOCAL_RESET_A3_REGISTER:
 		}
 	#endif
 	mutex_unlock(&i2c_access);
-}
-    	
+
+	//disable_irq_nosync(ts->pdata->intr_gpio);
+	//
+
+	//if ((fts_updateinfo_curr.CHIP_ID==0x59))
+		//fts_write_reg(ts->client,0xa5,0x02);
+	//else
+		//fts_write_reg(ts->client,0xa5,0x03);	
+	//msleep(10);
+	/*release add touches*/
+			
+	//for (i = 0; i <CFG_MAX_TOUCH_POINTS; i++) 
+	//{
+	//	input_mt_slot(ts->input_dev, i);
+	//	input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, 0);
+	//}
+	//input_mt_report_pointer_emulation(ts->input_dev, false);
+	//input_sync(ts->input_dev);
+	
+    	TPD_DMESG("TPD enter sleep done\n");
 
  } 
 
diff --git a/drivers/input/touchscreen/mediatek/FT5436I/tpd_custom_fts.h b/drivers/input/touchscreen/mediatek/FT5436I/tpd_custom_fts.h
index 9c8b3e0..aba404d 100644
--- a/drivers/input/touchscreen/mediatek/FT5436I/tpd_custom_fts.h
+++ b/drivers/input/touchscreen/mediatek/FT5436I/tpd_custom_fts.h
@@ -120,7 +120,7 @@ FHD   1920x1080  2key ( (160,2100);(920,2100) )           3key  ( (160,2100);(54
 #define TPD_I2C_NUMBER           				0
 #define TPD_WAKEUP_TRIAL         				60
 #define TPD_WAKEUP_DELAY         				100
-
+#define VELOCITY_CUSTOM
 #define TPD_VELOCITY_CUSTOM_X 				15
 #define TPD_VELOCITY_CUSTOM_Y 				20
 
diff --git a/drivers/input/touchscreen/mediatek/GT9XX_hotknot/gt9xx_driver.c b/drivers/input/touchscreen/mediatek/GT9XX_hotknot/gt9xx_driver.c
index 128340f..0b5798e 100644
--- a/drivers/input/touchscreen/mediatek/GT9XX_hotknot/gt9xx_driver.c
+++ b/drivers/input/touchscreen/mediatek/GT9XX_hotknot/gt9xx_driver.c
@@ -1372,9 +1372,8 @@ static s32 gtp_init_panel(struct i2c_client *client)
 	int TPD_LCM_WIDTH = 0;
 	int TPD_LCM_HEIGHT = 0;
 
-	TPD_LCM_WIDTH = simple_strtoul(CONFIG_LCM_WIDTH, NULL, 0);
-	TPD_LCM_HEIGHT = simple_strtoul(CONFIG_LCM_HEIGHT, NULL, 0);
-
+	TPD_LCM_WIDTH = GTP_MAX_WIDTH;
+	TPD_LCM_HEIGHT = GTP_MAX_HEIGHT;
 
     config[RESOLUTION_LOC]     = (u8)TPD_LCM_WIDTH;
     config[RESOLUTION_LOC + 1] = (u8)(TPD_LCM_WIDTH>>8);
diff --git a/drivers/md/dm-cache-metadata.c b/drivers/md/dm-cache-metadata.c
index de737ba..4a10c15 100644
--- a/drivers/md/dm-cache-metadata.c
+++ b/drivers/md/dm-cache-metadata.c
@@ -88,6 +88,9 @@ struct cache_disk_superblock {
 } __packed;
 
 struct dm_cache_metadata {
+	atomic_t ref_count;
+	struct list_head list;
+
 	struct block_device *bdev;
 	struct dm_block_manager *bm;
 	struct dm_space_map *metadata_sm;
@@ -634,10 +637,10 @@ static void unpack_value(__le64 value_le, dm_oblock_t *block, unsigned *flags)
 
 /*----------------------------------------------------------------*/
 
-struct dm_cache_metadata *dm_cache_metadata_open(struct block_device *bdev,
-						 sector_t data_block_size,
-						 bool may_format_device,
-						 size_t policy_hint_size)
+static struct dm_cache_metadata *metadata_open(struct block_device *bdev,
+					       sector_t data_block_size,
+					       bool may_format_device,
+					       size_t policy_hint_size)
 {
 	int r;
 	struct dm_cache_metadata *cmd;
@@ -645,9 +648,10 @@ struct dm_cache_metadata *dm_cache_metadata_open(struct block_device *bdev,
 	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
 	if (!cmd) {
 		DMERR("could not allocate metadata struct");
-		return NULL;
+		return ERR_PTR(-ENOMEM);
 	}
 
+	atomic_set(&cmd->ref_count, 1);
 	init_rwsem(&cmd->root_lock);
 	cmd->bdev = bdev;
 	cmd->data_block_size = data_block_size;
@@ -670,10 +674,96 @@ struct dm_cache_metadata *dm_cache_metadata_open(struct block_device *bdev,
 	return cmd;
 }
 
+/*
+ * We keep a little list of ref counted metadata objects to prevent two
+ * different target instances creating separate bufio instances.  This is
+ * an issue if a table is reloaded before the suspend.
+ */
+static DEFINE_MUTEX(table_lock);
+static LIST_HEAD(table);
+
+static struct dm_cache_metadata *lookup(struct block_device *bdev)
+{
+	struct dm_cache_metadata *cmd;
+
+	list_for_each_entry(cmd, &table, list)
+		if (cmd->bdev == bdev) {
+			atomic_inc(&cmd->ref_count);
+			return cmd;
+		}
+
+	return NULL;
+}
+
+static struct dm_cache_metadata *lookup_or_open(struct block_device *bdev,
+						sector_t data_block_size,
+						bool may_format_device,
+						size_t policy_hint_size)
+{
+	struct dm_cache_metadata *cmd, *cmd2;
+
+	mutex_lock(&table_lock);
+	cmd = lookup(bdev);
+	mutex_unlock(&table_lock);
+
+	if (cmd)
+		return cmd;
+
+	cmd = metadata_open(bdev, data_block_size, may_format_device, policy_hint_size);
+	if (!IS_ERR(cmd)) {
+		mutex_lock(&table_lock);
+		cmd2 = lookup(bdev);
+		if (cmd2) {
+			mutex_unlock(&table_lock);
+			__destroy_persistent_data_objects(cmd);
+			kfree(cmd);
+			return cmd2;
+		}
+		list_add(&cmd->list, &table);
+		mutex_unlock(&table_lock);
+	}
+
+	return cmd;
+}
+
+static bool same_params(struct dm_cache_metadata *cmd, sector_t data_block_size)
+{
+	if (cmd->data_block_size != data_block_size) {
+		DMERR("data_block_size (%llu) different from that in metadata (%llu)\n",
+		      (unsigned long long) data_block_size,
+		      (unsigned long long) cmd->data_block_size);
+		return false;
+	}
+
+	return true;
+}
+
+struct dm_cache_metadata *dm_cache_metadata_open(struct block_device *bdev,
+						 sector_t data_block_size,
+						 bool may_format_device,
+						 size_t policy_hint_size)
+{
+	struct dm_cache_metadata *cmd = lookup_or_open(bdev, data_block_size,
+						       may_format_device, policy_hint_size);
+
+	if (!IS_ERR(cmd) && !same_params(cmd, data_block_size)) {
+		dm_cache_metadata_close(cmd);
+		return ERR_PTR(-EINVAL);
+	}
+
+	return cmd;
+}
+
 void dm_cache_metadata_close(struct dm_cache_metadata *cmd)
 {
-	__destroy_persistent_data_objects(cmd);
-	kfree(cmd);
+	if (atomic_dec_and_test(&cmd->ref_count)) {
+		mutex_lock(&table_lock);
+		list_del(&cmd->list);
+		mutex_unlock(&table_lock);
+
+		__destroy_persistent_data_objects(cmd);
+		kfree(cmd);
+	}
 }
 
 int dm_cache_resize(struct dm_cache_metadata *cmd, dm_cblock_t new_cache_size)
diff --git a/drivers/md/dm-io.c b/drivers/md/dm-io.c
index d1de162..17cb217 100644
--- a/drivers/md/dm-io.c
+++ b/drivers/md/dm-io.c
@@ -291,6 +291,12 @@ static void do_region(int rw, unsigned region, struct dm_io_region *where,
 	unsigned short logical_block_size = queue_logical_block_size(q);
 	sector_t num_sectors;
 
+	/* Reject unsupported discard requests */
+	if ((rw & REQ_DISCARD) && !blk_queue_discard(q)) {
+		dec_count(io, region, -EOPNOTSUPP);
+		return;
+	}
+
 	/*
 	 * where->count may be zero if rw holds a flush and we need to
 	 * send a zero-sized flush.
diff --git a/drivers/md/dm-raid1.c b/drivers/md/dm-raid1.c
index 699b5be..678556b 100644
--- a/drivers/md/dm-raid1.c
+++ b/drivers/md/dm-raid1.c
@@ -604,6 +604,15 @@ static void write_callback(unsigned long error, void *context)
 		return;
 	}
 
+	/*
+	 * If the bio is discard, return an error, but do not
+	 * degrade the array.
+	 */
+	if (bio->bi_rw & REQ_DISCARD) {
+		bio_endio(bio, -EOPNOTSUPP);
+		return;
+	}
+
 	for (i = 0; i < ms->nr_mirrors; i++)
 		if (test_bit(i, &error))
 			fail_mirror(ms->mirror + i, DM_RAID1_WRITE_ERROR);
diff --git a/drivers/md/dm-snap.c b/drivers/md/dm-snap.c
index 944690b..d892a05 100644
--- a/drivers/md/dm-snap.c
+++ b/drivers/md/dm-snap.c
@@ -1439,8 +1439,6 @@ out:
 		full_bio->bi_end_io = pe->full_bio_end_io;
 		full_bio->bi_private = pe->full_bio_private;
 	}
-	free_pending_exception(pe);
-
 	increment_pending_exceptions_done_count();
 
 	up_write(&s->lock);
@@ -1457,6 +1455,8 @@ out:
 	}
 
 	retry_origin_bios(s, origin_bios);
+
+	free_pending_exception(pe);
 }
 
 static void commit_callback(void *context, int success)
diff --git a/drivers/md/dm-thin.c b/drivers/md/dm-thin.c
index 86a2a5e..39996ca 100644
--- a/drivers/md/dm-thin.c
+++ b/drivers/md/dm-thin.c
@@ -2457,6 +2457,12 @@ static int pool_message(struct dm_target *ti, unsigned argc, char **argv)
 	struct pool_c *pt = ti->private;
 	struct pool *pool = pt->pool;
 
+	if (get_pool_mode(pool) >= PM_READ_ONLY) {
+		DMERR("%s: unable to service pool target messages in READ_ONLY or FAIL mode",
+		      dm_device_name(pool->pool_md));
+		return -EINVAL;
+	}
+
 	if (!strcasecmp(argv[0], "create_thin"))
 		r = process_create_thin_mesg(argc, argv, pool);
 
diff --git a/drivers/md/dm-verity.c b/drivers/md/dm-verity.c
index 0d2e812..fe07d91 100644
--- a/drivers/md/dm-verity.c
+++ b/drivers/md/dm-verity.c
@@ -18,20 +18,36 @@
 
 #include <linux/module.h>
 #include <linux/device-mapper.h>
+#include <linux/reboot.h>
 #include <crypto/hash.h>
 
 #define DM_MSG_PREFIX			"verity"
 
+#define DM_VERITY_ENV_LENGTH		42
+#define DM_VERITY_ENV_VAR_NAME		"VERITY_ERR_BLOCK_NR"
+
 #define DM_VERITY_IO_VEC_INLINE		16
 #define DM_VERITY_MEMPOOL_SIZE		4
 #define DM_VERITY_DEFAULT_PREFETCH_SIZE	262144
 
 #define DM_VERITY_MAX_LEVELS		63
+#define DM_VERITY_MAX_CORRUPTED_ERRS	100
 
 static unsigned dm_verity_prefetch_cluster = DM_VERITY_DEFAULT_PREFETCH_SIZE;
 
 module_param_named(prefetch_cluster, dm_verity_prefetch_cluster, uint, S_IRUGO | S_IWUSR);
 
+enum verity_mode {
+	DM_VERITY_MODE_EIO = 0,
+	DM_VERITY_MODE_LOGGING = 1,
+	DM_VERITY_MODE_RESTART = 2
+};
+
+enum verity_block_type {
+	DM_VERITY_BLOCK_TYPE_DATA,
+	DM_VERITY_BLOCK_TYPE_METADATA
+};
+
 struct dm_verity {
 	struct dm_dev *data_dev;
 	struct dm_dev *hash_dev;
@@ -54,6 +70,8 @@ struct dm_verity {
 	unsigned digest_size;	/* digest size for the current hash algorithm */
 	unsigned shash_descsize;/* the size of temporary space for crypto */
 	int hash_failed;	/* set to 1 if hash of any block failed */
+	enum verity_mode mode;	/* mode for handling verification errors */
+	unsigned corrupted_errs;/* Number of errors for corrupted blocks */
 
 	mempool_t *vec_mempool;	/* mempool of bio vector */
 
@@ -180,6 +198,54 @@ static void verity_hash_at_level(struct dm_verity *v, sector_t block, int level,
 }
 
 /*
+ * Handle verification errors.
+ */
+static int verity_handle_err(struct dm_verity *v, enum verity_block_type type,
+				 unsigned long long block)
+{
+	char verity_env[DM_VERITY_ENV_LENGTH];
+	char *envp[] = { verity_env, NULL };
+	const char *type_str = "";
+	struct mapped_device *md = dm_table_get_md(v->ti->table);
+
+	if (v->corrupted_errs >= DM_VERITY_MAX_CORRUPTED_ERRS)
+		goto out;
+
+	++v->corrupted_errs;
+
+	switch (type) {
+	case DM_VERITY_BLOCK_TYPE_DATA:
+		type_str = "data";
+		break;
+	case DM_VERITY_BLOCK_TYPE_METADATA:
+		type_str = "metadata";
+		break;
+	default:
+		BUG();
+	}
+
+	DMERR_LIMIT("%s: %s block %llu is corrupted", v->data_dev->name,
+                type_str, block);
+
+	if (v->corrupted_errs == DM_VERITY_MAX_CORRUPTED_ERRS)
+		DMERR("%s: reached maximum errors", v->data_dev->name);
+
+	snprintf(verity_env, DM_VERITY_ENV_LENGTH, "%s=%d,%llu",
+		DM_VERITY_ENV_VAR_NAME, type, block);
+
+	kobject_uevent_env(&disk_to_dev(dm_disk(md))->kobj, KOBJ_CHANGE, envp);
+
+out:
+	if (v->mode == DM_VERITY_MODE_LOGGING)
+		return 0;
+
+	if (v->mode == DM_VERITY_MODE_RESTART)
+		kernel_restart("dm-verity device corrupted");
+
+	return 1;
+}
+
+/*
  * Verify hash of a metadata block pertaining to the specified data block
  * ("block" argument) at a specified level ("level" argument).
  *
@@ -256,11 +322,13 @@ static int verity_verify_level(struct dm_verity_io *io, sector_t block,
 			goto release_ret_r;
 		}
 		if (unlikely(memcmp(result, io_want_digest(v, io), v->digest_size))) {
-			DMERR_LIMIT("metadata block %llu is corrupted",
-				(unsigned long long)hash_block);
 			v->hash_failed = 1;
-			r = -EIO;
-			goto release_ret_r;
+
+			if (verity_handle_err(v, DM_VERITY_BLOCK_TYPE_METADATA,
+					      hash_block)) {
+				r = -EIO;
+				goto release_ret_r;
+			}
 		} else
 			aux->hash_verified = 1;
 	}
@@ -377,10 +445,11 @@ test_block_hash:
 			return r;
 		}
 		if (unlikely(memcmp(result, io_want_digest(v, io), v->digest_size))) {
-			DMERR_LIMIT("data block %llu is corrupted",
-				(unsigned long long)(io->block + b));
 			v->hash_failed = 1;
-			return -EIO;
+
+			if (verity_handle_err(v, DM_VERITY_BLOCK_TYPE_DATA,
+					      io->block + b))
+				return -EIO;
 		}
 	}
 	BUG_ON(vector != io->io_vec_size);
@@ -689,8 +758,8 @@ static int verity_ctr(struct dm_target *ti, unsigned argc, char **argv)
 		goto bad;
 	}
 
-	if (argc != 10) {
-		ti->error = "Invalid argument count: exactly 10 arguments required";
+	if (argc < 10 || argc > 11) {
+		ti->error = "Invalid argument count: 10-11 arguments required";
 		r = -EINVAL;
 		goto bad;
 	}
@@ -811,6 +880,17 @@ static int verity_ctr(struct dm_target *ti, unsigned argc, char **argv)
 		}
 	}
 
+	if (argc > 10) {
+		if (sscanf(argv[10], "%d%c", &num, &dummy) != 1 ||
+			num < DM_VERITY_MODE_EIO ||
+			num > DM_VERITY_MODE_RESTART) {
+			ti->error = "Invalid mode";
+			r = -EINVAL;
+			goto bad;
+		}
+		v->mode = num;
+	}
+
 	v->hash_per_block_bits =
 		fls((1 << v->hash_dev_block_bits) / v->digest_size) - 1;
 
diff --git a/drivers/md/dm.c b/drivers/md/dm.c
index 204a59f..a87f0c4 100644
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@ -2270,7 +2270,7 @@ int dm_setup_md_queue(struct mapped_device *md)
 	return 0;
 }
 
-static struct mapped_device *dm_find_md(dev_t dev)
+struct mapped_device *dm_get_md(dev_t dev)
 {
 	struct mapped_device *md;
 	unsigned minor = MINOR(dev);
@@ -2281,12 +2281,15 @@ static struct mapped_device *dm_find_md(dev_t dev)
 	spin_lock(&_minor_lock);
 
 	md = idr_find(&_minor_idr, minor);
-	if (md && (md == MINOR_ALLOCED ||
-		   (MINOR(disk_devt(dm_disk(md))) != minor) ||
-		   dm_deleting_md(md) ||
-		   test_bit(DMF_FREEING, &md->flags))) {
-		md = NULL;
-		goto out;
+	if (md) {
+		if ((md == MINOR_ALLOCED ||
+		     (MINOR(disk_devt(dm_disk(md))) != minor) ||
+		     dm_deleting_md(md) ||
+		     test_bit(DMF_FREEING, &md->flags))) {
+			md = NULL;
+			goto out;
+		}
+		dm_get(md);
 	}
 
 out:
@@ -2294,16 +2297,6 @@ out:
 
 	return md;
 }
-
-struct mapped_device *dm_get_md(dev_t dev)
-{
-	struct mapped_device *md = dm_find_md(dev);
-
-	if (md)
-		dm_get(md);
-
-	return md;
-}
 EXPORT_SYMBOL_GPL(dm_get_md);
 
 void *dm_get_mdptr(struct mapped_device *md)
diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c
index e885dbf..86ac4a4 100644
--- a/drivers/md/raid1.c
+++ b/drivers/md/raid1.c
@@ -557,7 +557,7 @@ static int read_balance(struct r1conf *conf, struct r1bio *r1_bio, int *max_sect
 		if (test_bit(WriteMostly, &rdev->flags)) {
 			/* Don't balance among write-mostly, just
 			 * use the first as a last resort */
-			if (best_disk < 0) {
+			if (best_dist_disk < 0) {
 				if (is_badblock(rdev, this_sector, sectors,
 						&first_bad, &bad_sectors)) {
 					if (first_bad < this_sector)
@@ -566,7 +566,8 @@ static int read_balance(struct r1conf *conf, struct r1bio *r1_bio, int *max_sect
 					best_good_sectors = first_bad - this_sector;
 				} else
 					best_good_sectors = sectors;
-				best_disk = disk;
+				best_dist_disk = disk;
+				best_pending_disk = disk;
 			}
 			continue;
 		}
diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c
index 2332b5c..1b6986c 100644
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@ -2678,7 +2678,8 @@ static int fetch_block(struct stripe_head *sh, struct stripe_head_state *s,
 	     (s->failed >= 2 && fdev[1]->toread) ||
 	     (sh->raid_conf->level <= 5 && s->failed && fdev[0]->towrite &&
 	      !test_bit(R5_OVERWRITE, &fdev[0]->flags)) ||
-	     (sh->raid_conf->level == 6 && s->failed && s->to_write))) {
+	     ((sh->raid_conf->level == 6 || sh->sector >= sh->raid_conf->mddev->recovery_cp)
+	      && s->failed && s->to_write))) {
 		/* we would like to get this block, possibly by computing it,
 		 * otherwise read it if the backing disk is insync
 		 */
@@ -2852,7 +2853,8 @@ static void handle_stripe_dirtying(struct r5conf *conf,
 	 * generate correct data from the parity.
 	 */
 	if (conf->max_degraded == 2 ||
-	    (recovery_cp < MaxSector && sh->sector >= recovery_cp)) {
+	    (recovery_cp < MaxSector && sh->sector >= recovery_cp &&
+	     s->failed == 0)) {
 		/* Calculate the real rcw later - for now make it
 		 * look like rcw is cheaper
 		 */
diff --git a/drivers/media/i2c/smiapp-pll.c b/drivers/media/i2c/smiapp-pll.c
index d8d5da7..9423051 100644
--- a/drivers/media/i2c/smiapp-pll.c
+++ b/drivers/media/i2c/smiapp-pll.c
@@ -67,7 +67,7 @@ static void print_pll(struct device *dev, struct smiapp_pll *pll)
 {
 	dev_dbg(dev, "pre_pll_clk_div\t%d\n",  pll->pre_pll_clk_div);
 	dev_dbg(dev, "pll_multiplier \t%d\n",  pll->pll_multiplier);
-	if (pll->flags != SMIAPP_PLL_FLAG_NO_OP_CLOCKS) {
+	if (!(pll->flags & SMIAPP_PLL_FLAG_NO_OP_CLOCKS)) {
 		dev_dbg(dev, "op_sys_clk_div \t%d\n", pll->op_sys_clk_div);
 		dev_dbg(dev, "op_pix_clk_div \t%d\n", pll->op_pix_clk_div);
 	}
@@ -77,7 +77,7 @@ static void print_pll(struct device *dev, struct smiapp_pll *pll)
 	dev_dbg(dev, "ext_clk_freq_hz \t%d\n", pll->ext_clk_freq_hz);
 	dev_dbg(dev, "pll_ip_clk_freq_hz \t%d\n", pll->pll_ip_clk_freq_hz);
 	dev_dbg(dev, "pll_op_clk_freq_hz \t%d\n", pll->pll_op_clk_freq_hz);
-	if (pll->flags & SMIAPP_PLL_FLAG_NO_OP_CLOCKS) {
+	if (!(pll->flags & SMIAPP_PLL_FLAG_NO_OP_CLOCKS)) {
 		dev_dbg(dev, "op_sys_clk_freq_hz \t%d\n",
 			pll->op_sys_clk_freq_hz);
 		dev_dbg(dev, "op_pix_clk_freq_hz \t%d\n",
diff --git a/drivers/media/i2c/smiapp/smiapp-core.c b/drivers/media/i2c/smiapp/smiapp-core.c
index b280216..de8bc35 100644
--- a/drivers/media/i2c/smiapp/smiapp-core.c
+++ b/drivers/media/i2c/smiapp/smiapp-core.c
@@ -2629,7 +2629,9 @@ static int smiapp_registered(struct v4l2_subdev *subdev)
 		pll->flags |= SMIAPP_PLL_FLAG_OP_PIX_CLOCK_PER_LANE;
 	pll->scale_n = sensor->limits[SMIAPP_LIMIT_SCALER_N_MIN];
 
+	mutex_lock(&sensor->mutex);
 	rval = smiapp_update_mode(sensor);
+	mutex_unlock(&sensor->mutex);
 	if (rval) {
 		dev_err(&client->dev, "update mode failed\n");
 		goto out_nvm_release;
diff --git a/drivers/media/rc/ir-lirc-codec.c b/drivers/media/rc/ir-lirc-codec.c
index e456126..a895ed0 100644
--- a/drivers/media/rc/ir-lirc-codec.c
+++ b/drivers/media/rc/ir-lirc-codec.c
@@ -42,11 +42,17 @@ static int ir_lirc_decode(struct rc_dev *dev, struct ir_raw_event ev)
 		return -EINVAL;
 
 	/* Packet start */
-	if (ev.reset)
-		return 0;
+	if (ev.reset) {
+		/* Userspace expects a long space event before the start of
+		 * the signal to use as a sync.  This may be done with repeat
+		 * packets and normal samples.  But if a reset has been sent
+		 * then we assume that a long time has passed, so we send a
+		 * space with the maximum time value. */
+		sample = LIRC_SPACE(LIRC_VALUE_MASK);
+		IR_dprintk(2, "delivering reset sync space to lirc_dev\n");
 
 	/* Carrier reports */
-	if (ev.carrier_report) {
+	} else if (ev.carrier_report) {
 		sample = LIRC_FREQUENCY(ev.carrier);
 		IR_dprintk(2, "carrier report (freq: %d)\n", sample);
 
diff --git a/drivers/media/usb/dvb-usb-v2/lmedm04.c b/drivers/media/usb/dvb-usb-v2/lmedm04.c
index b3fd0ff..fc28d51 100644
--- a/drivers/media/usb/dvb-usb-v2/lmedm04.c
+++ b/drivers/media/usb/dvb-usb-v2/lmedm04.c
@@ -350,6 +350,7 @@ static int lme2510_int_read(struct dvb_usb_adapter *adap)
 {
 	struct dvb_usb_device *d = adap_to_d(adap);
 	struct lme2510_state *lme_int = adap_to_priv(adap);
+	struct usb_host_endpoint *ep;
 
 	lme_int->lme_urb = usb_alloc_urb(0, GFP_ATOMIC);
 
@@ -371,6 +372,12 @@ static int lme2510_int_read(struct dvb_usb_adapter *adap)
 				adap,
 				8);
 
+	/* Quirk of pipe reporting PIPE_BULK but behaves as interrupt */
+	ep = usb_pipe_endpoint(d->udev, lme_int->lme_urb->pipe);
+
+	if (usb_endpoint_type(&ep->desc) == USB_ENDPOINT_XFER_BULK)
+		lme_int->lme_urb->pipe = usb_rcvbulkpipe(d->udev, 0xa),
+
 	lme_int->lme_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 
 	usb_submit_urb(lme_int->lme_urb, GFP_ATOMIC);
diff --git a/drivers/media/usb/dvb-usb/af9005.c b/drivers/media/usb/dvb-usb/af9005.c
index af176b6..e6d3561 100644
--- a/drivers/media/usb/dvb-usb/af9005.c
+++ b/drivers/media/usb/dvb-usb/af9005.c
@@ -1081,9 +1081,12 @@ static int __init af9005_usb_module_init(void)
 		err("usb_register failed. (%d)", result);
 		return result;
 	}
+#if IS_MODULE(CONFIG_DVB_USB_AF9005) || defined(CONFIG_DVB_USB_AF9005_REMOTE)
+	/* FIXME: convert to todays kernel IR infrastructure */
 	rc_decode = symbol_request(af9005_rc_decode);
 	rc_keys = symbol_request(rc_map_af9005_table);
 	rc_keys_size = symbol_request(rc_map_af9005_table_size);
+#endif
 	if (rc_decode == NULL || rc_keys == NULL || rc_keys_size == NULL) {
 		err("af9005_rc_decode function not found, disabling remote");
 		af9005_properties.rc.legacy.rc_query = NULL;
diff --git a/drivers/media/usb/uvc/uvc_driver.c b/drivers/media/usb/uvc/uvc_driver.c
index 5dbefa6..363cdbf 100644
--- a/drivers/media/usb/uvc/uvc_driver.c
+++ b/drivers/media/usb/uvc/uvc_driver.c
@@ -1603,12 +1603,12 @@ static void uvc_delete(struct uvc_device *dev)
 {
 	struct list_head *p, *n;
 
-	usb_put_intf(dev->intf);
-	usb_put_dev(dev->udev);
-
 	uvc_status_cleanup(dev);
 	uvc_ctrl_cleanup_device(dev);
 
+	usb_put_intf(dev->intf);
+	usb_put_dev(dev->udev);
+
 	if (dev->vdev.dev)
 		v4l2_device_unregister(&dev->vdev);
 #ifdef CONFIG_MEDIA_CONTROLLER
diff --git a/drivers/misc/mediatek/Kconfig.drivers b/drivers/misc/mediatek/Kconfig.drivers
index b02905c..3c43ead 100644
--- a/drivers/misc/mediatek/Kconfig.drivers
+++ b/drivers/misc/mediatek/Kconfig.drivers
@@ -688,6 +688,10 @@ config MT6326_PMIC
 	depends on ARCH_MT6516
 	default y
 
+config MTK_HAFG_20
+	bool "MediaTek Fuel Gauge 2.0"
+	default n
+
 config MTK_SMART_BATTERY
 	tristate "MediaTek Smart Battery Driver"
 	default y
@@ -927,7 +931,7 @@ config MTK_EPL2182_NEW
 config MTK_STK3310
 	bool "STK3310 for MediaTek package"
 	default n
-	
+
 config MTK_STK3X1X
 	bool "STK3X1X for MediaTek package"
 	default n
@@ -1016,6 +1020,11 @@ config MTK_LSM6DS3
 config MTK_MXC400X_NEW
 	bool "MXC400X for MediaTek package"
 	default n	
+	
+config MTK_DA213
+        bool "DA213 for MediaTek package"
+        default n
+        
 # Gyro sensor
 config MTK_MPU3050C
 	bool "MPU3050C for MediaTek package"
@@ -1124,7 +1133,7 @@ config MTK_YAS532
 config MTK_YAS532_NEW
         bool "YAS532 for Mediatek package"
         default n
-        
+
 config MTK_IST8303
 			 bool "MTK_ist8303 for MediaTek package"
 			 default n
@@ -1132,7 +1141,7 @@ config MTK_IST8303
 config MTK_ST480
 	bool "ST480 for MediaTek package"
 	default n
-	
+			 
 # Barometer sensor
 config MTK_BMP180_NEW
 	bool "BMP180 for MediaTek package"
@@ -1451,7 +1460,7 @@ config MTK_STAGING
 
 config MTKPASR
 	bool "MTK proprietary PASR mechanism"
-	depends on SYSFS && ZSMALLOC && ARM && HIGHMEM
+	depends on SYSFS && ZSMALLOC
 	select MTKPASR_RDIRECT
 	select MTKPASR_MAFL
 	select MTKPASR_DEBUG
@@ -1488,7 +1497,7 @@ config MTKPASR_DEBUG
 	  This option adds additional debugging code to MTK PASR
 
 config MTKPASR_NO_LASTBANK
-	bool "Modem occupies last bank"
+	bool "Modem/TEE/Others occupy the last bank"
 	depends on MTKPASR
 	default n
 
@@ -1695,6 +1704,10 @@ config MTK_OD_SUPPORT
 	bool "MTK_OD_SUPPORT"
 	default n
 
+config MTK_DISPLAY_120HZ_SUPPORT
+	bool "MTK_DISPLAY_120HZ_SUPPORT"
+	default n
+
 #
 # LENS
 #
diff --git a/drivers/misc/mediatek/Kconfig.kernel b/drivers/misc/mediatek/Kconfig.kernel
index e6f80ab..4c0614a 100644
--- a/drivers/misc/mediatek/Kconfig.kernel
+++ b/drivers/misc/mediatek/Kconfig.kernel
@@ -13,7 +13,6 @@ config MTK_SCHED_TRACERS
 config MTK_FTRACE_DEFAULT_ENABLE
     bool "enable MTK events by default"
     depends on MTK_SCHED_TRACERS 
-    depends on !MTK_GMO_RAM_OPTIMIZE || MTK_EXTMEM 
     default n
     help
         update ring buffer and enable MTK events by default
@@ -63,9 +62,6 @@ config MTPROF_CPUTIME
 
 endmenu
 
-config MTPROF_IRQ_DURATION
-	bool "mt IRQ/ISR profiling"
-
 config MTK_AEE_FEATURE
 	tristate "Enable Android Exception Enhancement"
 	default n
@@ -93,15 +89,6 @@ config ANDROID_VMEM
 	tristate "Virutally continuous memory allocator"
 	default y
 
-config CPUTIME_SUPPORT
-	bool "cputime profiling support for functions"
-	default n
-
-config CPUTIME_STATS
-	tristate "cputime profiling module for functions"
-	select CPUTIME_SUPPORT
-	default n
-	
 config MTK_RAM_CONSOLE
 	bool "mt ram console" 
 
diff --git a/drivers/misc/mediatek/Makefile.custom b/drivers/misc/mediatek/Makefile.custom
index 20c6cf9..4eca217 100644
--- a/drivers/misc/mediatek/Makefile.custom
+++ b/drivers/misc/mediatek/Makefile.custom
@@ -52,6 +52,7 @@ ccflags-y += -I$(MTK_CUSTOM_PATH)/accdet/$(MTK_PLATFORM) \
              -I$(MTK_CUSTOM_PATH)/cmdq/$(MTK_PLATFORM) \
              -I$(MTK_CUSTOM_PATH)/devinfo/$(MTK_PLATFORM) \
              -I$(MTK_CUSTOM_PATH)/dispsys/$(MTK_PLATFORM) \
+             -I$(MTK_CUSTOM_PATH)/videox/$(MTK_PLATFORM) \
              -I$(MTK_CUSTOM_PATH)/dual_ccci/$(MTK_PLATFORM)/include \
              -I$(MTK_CUSTOM_PATH)/dual_ccci/include \
              -I$(MTK_CUSTOM_PATH)/flashlight/inc \
diff --git a/drivers/misc/mediatek/accdet/mt6752/accdet.c b/drivers/misc/mediatek/accdet/mt6752/accdet.c
index 8ca9e45..ccc57b8 100644
--- a/drivers/misc/mediatek/accdet/mt6752/accdet.c
+++ b/drivers/misc/mediatek/accdet/mt6752/accdet.c
@@ -5,11 +5,17 @@
 #include <cust_gpio_usage.h>
 #include <mach/mt_gpio.h>
 #include <mach/eint.h>
+#include <mach/upmu_common.h>
+#include <linux/timer.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include "cust_pmic.h"
 
 
 #define SW_WORK_AROUND_ACCDET_REMOTE_BUTTON_ISSUE
 #define DEBUG_THREAD 1
-         
+//#define GET_ADC_DIRECTLY
+
 /*----------------------------------------------------------------------
 static variable defination
 ----------------------------------------------------------------------*/
@@ -20,13 +26,16 @@ static variable defination
 static int button_press_debounce = 0x400;
 
 static int debug_enable = 1;
+int cur_key = 0;
 
+int accdet_irq;
+unsigned int gpiopin,headsetdebounce;
 struct headset_mode_settings *cust_headset_settings = NULL;
 
 #define ACCDET_DEBUG(format, args...) do{ \
 	if(debug_enable) \
 	{\
-		printk(KERN_DEBUG format,##args);\
+		printk(KERN_WARNING format,##args);\
 	}\
 }while(0)
 
@@ -42,7 +51,7 @@ static int pre_status = 0;
 static int pre_state_swctrl = 0;
 static int accdet_status = PLUG_OUT;
 static int cable_type = 0;
-#if defined ACCDET_EINT && defined ACCDET_PIN_RECOGNIZATION
+#ifdef ACCDET_PIN_RECOGNIZATION
 //add for new feature PIN recognition
 static int cable_pin_recognition = 0;
 static int show_icon_delay = 0;
@@ -71,39 +80,15 @@ static struct workqueue_struct * accdet_workqueue = NULL;
 
 static int long_press_time;
 
-//Jeffrey modify for headset quick press -start
-static int sum_press_num = 0;
-static int key_event_flag = 0;
-#define QUICK_KEY_MD 1
-#define QUICK_KEY_DW 2
-#define QUICK_KEY_UP 3
-static DEFINE_MUTEX(sum_press_num_sync_mutex);
-//Jeffrey modify for headset quick press -end
 static DEFINE_MUTEX(accdet_eint_irq_sync_mutex);
 
 static inline void clear_accdet_interrupt(void);
+static inline void clear_accdet_eint_interrupt(void);
 
-#ifdef ACCDET_EINT
-
-#ifndef ACCDET_MULTI_KEY_FEATURE
-static int g_accdet_working_in_suspend =0;
-#endif
-
+#if defined ACCDET_EINT || defined ACCDET_EINT_IRQ
 static struct work_struct accdet_eint_work;
 static struct workqueue_struct * accdet_eint_workqueue = NULL;
-
 static inline void accdet_init(void);
-
-
-#ifdef ACCDET_LOW_POWER
-//Jeffrey modify for headset quick press -start
-#define QUICK_PRESS_DELAY   msecs_to_jiffies(300)        //300 ms
-struct timer_list quick_press_timer;
-#define LONG_PRESS_DELAY   msecs_to_jiffies(1000)        //1000 ms
-struct timer_list long_press_timer;
-//Jeffrey modify for headset quick press -end
-
-#include <linux/timer.h>
 #define MICBIAS_DISABLE_TIMER   (6 *HZ)         //6 seconds
 struct timer_list micbias_timer;
 static void disable_micbias(unsigned long a);
@@ -113,9 +98,8 @@ static void disable_micbias(unsigned long a);
 int cur_eint_state = EINT_PIN_PLUG_OUT;
 static struct work_struct accdet_disable_work;
 static struct workqueue_struct * accdet_disable_workqueue = NULL;
-
-#endif
-
+#else
+//static int g_accdet_working_in_suspend =0;
 #endif//end ACCDET_EINT
 
 extern S32 pwrap_read( U32  adr, U32 *rdata );
@@ -172,72 +156,84 @@ int accdet_get_cable_type(void)
 }
 void accdet_auxadc_switch(int enable)
 {
-   if (enable) {
-	#ifndef ACCDET_28V_MODE
-	 pmic_pwrap_write(ACCDET_RSV, ACCDET_1V9_MODE_ON);
-     ACCDET_DEBUG("ACCDET enable switch in 1.9v mode \n");
-	#else
-	 pmic_pwrap_write(ACCDET_RSV, ACCDET_2V8_MODE_ON);
-	 ACCDET_DEBUG("ACCDET enable switch in 2.8v mode \n");
-	#endif
-   }else {
-   	#ifndef ACCDET_28V_MODE
-	 pmic_pwrap_write(ACCDET_RSV, ACCDET_1V9_MODE_OFF);
-     ACCDET_DEBUG("ACCDET diable switch in 1.9v mode \n");
-	#else
-	 pmic_pwrap_write(ACCDET_RSV, ACCDET_2V8_MODE_OFF);
-	 ACCDET_DEBUG("ACCDET diable switch in 2.8v mode \n");
-	#endif
-   }
-   	
+	if(enable) { 
+		 pmic_pwrap_write(ACCDET_EINT_NV, pmic_pwrap_read(ACCDET_EINT_NV)|ACCDET_BF_ON);
+		 //ACCDET_DEBUG("ACCDET enable switch \n");
+	}else {
+		 pmic_pwrap_write(ACCDET_EINT_NV, pmic_pwrap_read(ACCDET_EINT_NV)&~(ACCDET_BF_ON));
+		 //ACCDET_DEBUG("ACCDET diable switch \n");
+	}
 }
 
 /****************************************************************/
 /*******static function defination                             **/
 /****************************************************************/
+static U64 accdet_get_current_time(void)
+{
+	return sched_clock(); 
+}
+static BOOL accdet_timeout_ns (U64 start_time_ns, U64 timeout_time_ns)
+{
+	U64 cur_time=0;
+	U64 elapse_time=0;
+
+	// get current tick
+	cur_time = accdet_get_current_time();//ns
+	if(cur_time < start_time_ns){
+		ACCDET_DEBUG("@@@@Timer overflow! start%lld cur timer%lld\n",start_time_ns,cur_time);
+		start_time_ns=cur_time;
+		timeout_time_ns=400*1000; //400us
+		ACCDET_DEBUG("@@@@reset timer! start%lld setting%lld\n",start_time_ns,timeout_time_ns);
+	}
+	elapse_time=cur_time-start_time_ns;
+
+	// check if timeout
+	if (timeout_time_ns <= elapse_time)
+	{
+		// timeout
+		ACCDET_DEBUG("@@@@ACCDET IRQ clear Timeout\n");
+		return FALSE;
+	}
+	return TRUE;
+}
+
 // pmic wrap read and write func
 static U32 pmic_pwrap_read(U32 addr)
 {
-
 	U32 val =0;
 	pwrap_read(addr, &val);
 	//ACCDET_DEBUG("[Accdet]wrap write func addr=0x%x, val=0x%x\n", addr, val);
 	return val;
-	
 }
 
 static void pmic_pwrap_write(unsigned int addr, unsigned int wdata)
-
 {
     pwrap_write(addr, wdata);
 	//ACCDET_DEBUG("[Accdet]wrap write func addr=0x%x, wdate=0x%x\n", addr, wdata);
 }
-#ifndef ACCDET_MULTI_KEY_FEATURE
-//detect if remote button is short pressed or long pressed
-static bool is_long_press(void)
+
+#ifdef GET_ADC_DIRECTLY
+static int Accdet_PMIC_IMM_GetOneChannelValue(int deCount)
 {
-	int current_status = 0;
-	int index = 0;
-	int count = long_press_time / 100;
-	while(index++ < count)
-	{ 
-		current_status = ((pmic_pwrap_read(ACCDET_STATE_RG) & 0xc0)>>6);
-		if(current_status != 0)
-		{
-			return false;
-		}
-			
-		msleep(100);
-	}
-	
-	return true;
-}
+	unsigned int raw_data, vol_val = 0;
+
+#if 0 // because the auto-sampling is enabled.
+	pmic_pwrap_write(ACCDET_AUXADC_CTL_SET, 0);
+	ndelay(10000); // add 10 usec delay
+	pmic_pwrap_write(ACCDET_AUXADC_CTL_SET, ACCDET_CH_REQ_EN);
+	ndelay(400000); // add 400 usec delay
 #endif
-#ifdef ACCDET_PIN_RECOGNIZATION
-static void headset_standard_judge_message(void)
-{
-	ACCDET_DEBUG("[Accdet]Dear user: You plug in a headset which this phone doesn't support!!\n");
+	
+	while((pmic_pwrap_read(ACCDET_AUXADC_REG)&ACCDET_DATA_READY)!=ACCDET_DATA_READY) 
+	{
+		ACCDET_DEBUG("ACCDET read ADC is not ready. (ongoing)\n\r");
+
+	} //wait AUXADC data ready
+	raw_data = (pmic_pwrap_read(ACCDET_AUXADC_REG) & ACCDET_DATA_MASK);
+	vol_val = (raw_data*1800)/32768; //mv
+	ACCDET_DEBUG("ACCDET read Voltage:(%d*1800)/32768 = %d mV!! \n\r", raw_data, vol_val);
 
+	return vol_val;
 }
 #endif
 
@@ -278,17 +274,15 @@ static void inline enable_accdet(u32 state_swctrl)
    pmic_pwrap_write(TOP_CKPDN_CLR, RG_ACCDET_CLK_CLR); 
    
    pmic_pwrap_write(ACCDET_STATE_SWCTRL, pmic_pwrap_read(ACCDET_STATE_SWCTRL)|state_swctrl);
-   pmic_pwrap_write(ACCDET_CTRL, ACCDET_ENABLE);
+   pmic_pwrap_write(ACCDET_CTRL, pmic_pwrap_read(ACCDET_CTRL)|ACCDET_ENABLE);
   
 
 }
 
-#ifdef ACCDET_EINT
 static void inline disable_accdet(void)
 {
 	int irq_temp = 0;
 	//sync with accdet_irq_handler set clear accdet irq bit to avoid  set clear accdet irq bit after disable accdet
-	
 	//disable accdet irq
 	pmic_pwrap_write(INT_CON_ACCDET_CLR, RG_ACCDET_IRQ_CLR);
 	clear_accdet_interrupt();
@@ -307,12 +301,21 @@ static void inline disable_accdet(void)
    // disable ACCDET unit
    ACCDET_DEBUG("accdet: disable_accdet\n");
    pre_state_swctrl = pmic_pwrap_read(ACCDET_STATE_SWCTRL);
-   
-   pmic_pwrap_write(ACCDET_CTRL, ACCDET_DISABLE);
+   #ifdef ACCDET_EINT
    pmic_pwrap_write(ACCDET_STATE_SWCTRL, 0);
-//disable clock
-   pmic_pwrap_write(TOP_CKPDN_SET, RG_ACCDET_CLK_SET);  
+   pmic_pwrap_write(ACCDET_CTRL, ACCDET_DISABLE);
+   //disable clock and Analog control
+   //mt6331_upmu_set_rg_audmicbias1vref(0x0);
+   pmic_pwrap_write(TOP_CKPDN_SET, RG_ACCDET_CLK_SET); 
+   #endif
+   #ifdef ACCDET_EINT_IRQ
+   pmic_pwrap_write(ACCDET_STATE_SWCTRL, pmic_pwrap_read(ACCDET_STATE_SWCTRL)&(~ACCDET_SWCTRL_EN));
+   pmic_pwrap_write(ACCDET_CTRL, pmic_pwrap_read(ACCDET_CTRL)&(~(ACCDET_ENABLE)));
+   #endif
+
 }
+
+#if defined ACCDET_EINT || defined ACCDET_EINT_IRQ
 static void disable_micbias(unsigned long a)
 {
 	  int ret = 0;
@@ -333,12 +336,10 @@ static void disable_micbias_callback(struct work_struct *work)
 				pmic_pwrap_write(ACCDET_PWM_WIDTH, cust_headset_settings->pwm_width);
     			pmic_pwrap_write(ACCDET_PWM_THRESH, cust_headset_settings->pwm_thresh);
 			#endif
-                // setting pwm idle;
-            #ifdef ACCDET_MULTI_KEY_FEATURE  
-   				pmic_pwrap_write(ACCDET_STATE_SWCTRL, pmic_pwrap_read(ACCDET_STATE_SWCTRL)&~ACCDET_SWCTRL_IDLE_EN);
-		    #endif 
+            // setting pwm idle;
+   			pmic_pwrap_write(ACCDET_STATE_SWCTRL, pmic_pwrap_read(ACCDET_STATE_SWCTRL)&~ACCDET_SWCTRL_IDLE_EN);
 			#ifdef ACCDET_PIN_SWAP
-		    	//accdet_FSA8049_disable();  //disable GPIO209 for PIN swap 
+		    	//accdet_FSA8049_disable();  //disable GPIOxxx for PIN swap 
 		    	//ACCDET_DEBUG("[Accdet] FSA8049 disable!\n");
 			#endif
                 disable_accdet();
@@ -355,25 +356,80 @@ static void disable_micbias_callback(struct work_struct *work)
 
 static void accdet_eint_work_callback(struct work_struct *work)
 {
+#ifdef ACCDET_EINT_IRQ
+	int irq_temp = 0;
+	if (cur_eint_state == EINT_PIN_PLUG_IN) {
+		ACCDET_DEBUG("[Accdet]EINT func :plug-in\n");
+		mutex_lock(&accdet_eint_irq_sync_mutex);
+		eint_accdet_sync_flag = 1;
+		mutex_unlock(&accdet_eint_irq_sync_mutex);
+		wake_lock_timeout(&accdet_timer_lock, 7*HZ);
+		#ifdef ACCDET_PIN_SWAP
+			//pmic_pwrap_write(0x0400, pmic_pwrap_read(0x0400)|(1<<14)); 
+			msleep(800);
+		    accdet_FSA8049_enable();  //enable GPIOxxx for PIN swap 
+		    ACCDET_DEBUG("[Accdet] FSA8049 enable!\n");
+			msleep(250); //PIN swap need ms 
+		#endif
+		
+			accdet_init();// do set pwm_idle on in accdet_init
+		
+		#ifdef ACCDET_PIN_RECOGNIZATION
+		  show_icon_delay = 1;
+		//micbias always on during detected PIN recognition
+		  pmic_pwrap_write(ACCDET_PWM_WIDTH, cust_headset_settings->pwm_width);
+    	  pmic_pwrap_write(ACCDET_PWM_THRESH, cust_headset_settings->pwm_width);
+		  ACCDET_DEBUG("[Accdet]pin recog start!  micbias always on!\n");
+		#endif
+		//set PWM IDLE  on
+			pmic_pwrap_write(ACCDET_STATE_SWCTRL, (pmic_pwrap_read(ACCDET_STATE_SWCTRL)|ACCDET_SWCTRL_IDLE_EN));
+		//enable ACCDET unit
+			enable_accdet(ACCDET_SWCTRL_EN); 
+    } else {
+//EINT_PIN_PLUG_OUT
+//Disable ACCDET
+		ACCDET_DEBUG("[Accdet]EINT func :plug-out\n");
+		mutex_lock(&accdet_eint_irq_sync_mutex);
+		eint_accdet_sync_flag = 0;
+		mutex_unlock(&accdet_eint_irq_sync_mutex);
+		del_timer_sync(&micbias_timer);
+		#ifdef ACCDET_PIN_RECOGNIZATION
+		  show_icon_delay = 0;
+		  cable_pin_recognition = 0;
+		#endif
+		#ifdef ACCDET_PIN_SWAP
+			//pmic_pwrap_write(0x0400, pmic_pwrap_read(0x0400)&~(1<<14)); 
+		    accdet_FSA8049_disable();  //disable GPIOxxx for PIN swap 
+		    ACCDET_DEBUG("[Accdet] FSA8049 disable!\n");
+		#endif
+			//accdet_auxadc_switch(0);
+			disable_accdet();			   
+			headset_plug_out();
+		 //recover EINT irq clear bit                                  
+		 ///TODO: need think~~~
+		 irq_temp = pmic_pwrap_read(ACCDET_IRQ_STS);
+		 irq_temp = irq_temp & (~IRQ_EINT_CLR_BIT);
+		 pmic_pwrap_write(ACCDET_IRQ_STS, irq_temp); 
+    }
+#else
    //KE under fastly plug in and plug out
+#ifdef CONFIG_OF
+    disable_irq(accdet_irq);
+#else
     mt_eint_mask(CUST_EINT_ACCDET_NUM);
+#endif
+	
    
     if (cur_eint_state == EINT_PIN_PLUG_IN) {
 		ACCDET_DEBUG("[Accdet]EINT func :plug-in\n");
 		mutex_lock(&accdet_eint_irq_sync_mutex);
 		eint_accdet_sync_flag = 1;
 		mutex_unlock(&accdet_eint_irq_sync_mutex);
-		#ifdef ACCDET_LOW_POWER
 		wake_lock_timeout(&accdet_timer_lock, 7*HZ);
-		#endif
-		#ifdef ACCDET_28V_MODE
-		pmic_pwrap_write(ACCDET_RSV, ACCDET_2V8_MODE_OFF);
-		ACCDET_DEBUG("ACCDET use in 2.8V mode!! \n");
-  		#endif
 		#ifdef ACCDET_PIN_SWAP
-			pmic_pwrap_write(0x0400, pmic_pwrap_read(0x0400)|(1<<14)); 
+			//pmic_pwrap_write(0x0400, pmic_pwrap_read(0x0400)|(1<<14)); 
 			msleep(800);
-		    accdet_FSA8049_enable();  //enable GPIO209 for PIN swap 
+		    accdet_FSA8049_enable();  //enable GPIOxxx for PIN swap 
 		    ACCDET_DEBUG("[Accdet] FSA8049 enable!\n");
 			msleep(250); //PIN swap need ms 
 		#endif
@@ -388,11 +444,9 @@ static void accdet_eint_work_callback(struct work_struct *work)
 		  ACCDET_DEBUG("[Accdet]pin recog start!  micbias always on!\n");
 		#endif
 		//set PWM IDLE  on
-		#ifdef ACCDET_MULTI_KEY_FEATURE
-			pmic_pwrap_write(ACCDET_STATE_SWCTRL, (pmic_pwrap_read(ACCDET_STATE_SWCTRL)|ACCDET_SWCTRL_IDLE_EN));
-		#endif  
+		pmic_pwrap_write(ACCDET_STATE_SWCTRL, (pmic_pwrap_read(ACCDET_STATE_SWCTRL)|ACCDET_SWCTRL_IDLE_EN));
 		//enable ACCDET unit
-			enable_accdet(ACCDET_SWCTRL_EN); 
+		enable_accdet(ACCDET_SWCTRL_EN); 
     } else {
 //EINT_PIN_PLUG_OUT
 //Disable ACCDET
@@ -400,36 +454,98 @@ static void accdet_eint_work_callback(struct work_struct *work)
 		mutex_lock(&accdet_eint_irq_sync_mutex);
 		eint_accdet_sync_flag = 0;
 		mutex_unlock(&accdet_eint_irq_sync_mutex);
-
-		#ifdef ACCDET_LOW_POWER
-			del_timer_sync(&micbias_timer);
-		#endif
+		del_timer_sync(&micbias_timer);
 		#ifdef ACCDET_PIN_RECOGNIZATION
 		  show_icon_delay = 0;
 		  cable_pin_recognition = 0;
 		#endif
 		#ifdef ACCDET_PIN_SWAP
-			pmic_pwrap_write(0x0400, pmic_pwrap_read(0x0400)&~(1<<14)); 
-		    accdet_FSA8049_disable();  //disable GPIO209 for PIN swap 
+			//pmic_pwrap_write(0x0400, pmic_pwrap_read(0x0400)&~(1<<14)); 
+		    accdet_FSA8049_disable();  //disable GPIOxxx for PIN swap 
 		    ACCDET_DEBUG("[Accdet] FSA8049 disable!\n");
 		#endif
-			accdet_auxadc_switch(0);
+			//accdet_auxadc_switch(0);
 			disable_accdet();			   
 			headset_plug_out();
-			#ifdef ACCDET_28V_MODE
-			pmic_pwrap_write(ACCDET_RSV, ACCDET_1V9_MODE_OFF);
-			ACCDET_DEBUG("ACCDET use in 1.9V mode!! \n");
-  			#endif
-		  
     }
     //unmask EINT
     //msleep(500);
+#ifdef CONFIG_OF
+	enable_irq(accdet_irq);
+	ACCDET_DEBUG("[Accdet]enable_irq  !!!!!!\n");
+#else
     mt_eint_unmask(CUST_EINT_ACCDET_NUM);
     ACCDET_DEBUG("[Accdet]eint unmask  !!!!!!\n");
-    
+#endif   
+#endif   
 }
 
+#ifdef CONFIG_OF
+static irqreturn_t accdet_eint_func(int irq,void *data)
+{
+	int ret=0;
+	if(cur_eint_state ==  EINT_PIN_PLUG_IN ) 
+	{
+	/*
+	To trigger EINT when the headset was plugged in
+	We set the polarity back as we initialed.
+	*/
+	#ifndef ACCDET_EINT_IRQ
+		if (CUST_EINT_ACCDET_TYPE == CUST_EINTF_TRIGGER_HIGH){
+		    irq_set_irq_type(accdet_irq,IRQ_TYPE_LEVEL_HIGH);
+		}else{
+		    irq_set_irq_type(accdet_irq,IRQ_TYPE_LEVEL_LOW);
+		}
+	#endif
+	#ifdef ACCDET_EINT_IRQ
+		pmic_pwrap_write(ACCDET_EINT_CTL, pmic_pwrap_read(ACCDET_EINT_CTL)&(~(7<<4)));
+		pmic_pwrap_write(ACCDET_EINT_CTL, pmic_pwrap_read(ACCDET_EINT_CTL)|EINT_IRQ_DE_IN);//debounce=256ms
+	#else
+		mt_gpio_set_debounce(gpiopin,headsetdebounce);
+	#endif
+
+		/* update the eint status */
+		cur_eint_state = EINT_PIN_PLUG_OUT;
+//#ifdef ACCDET_LOW_POWER
+//		del_timer_sync(&micbias_timer);
+//#endif
+	} 
+	else 
+	{
+	/* 
+	To trigger EINT when the headset was plugged out 
+	We set the opposite polarity to what we initialed. 
+	*/
+	#ifndef ACCDET_EINT_IRQ
+		if (CUST_EINT_ACCDET_TYPE == CUST_EINTF_TRIGGER_HIGH){
+		    irq_set_irq_type(accdet_irq,IRQ_TYPE_LEVEL_LOW);
+		}else{
+		    irq_set_irq_type(accdet_irq,IRQ_TYPE_LEVEL_HIGH);
+		}
+	#endif
+	
+	#ifdef ACCDET_EINT_IRQ
+		pmic_pwrap_write(ACCDET_EINT_CTL, pmic_pwrap_read(ACCDET_EINT_CTL)&(~(7<<4)));
+		pmic_pwrap_write(ACCDET_EINT_CTL, pmic_pwrap_read(ACCDET_EINT_CTL)|EINT_IRQ_DE_OUT);//debounce=16ms
+	#else
+		mt_gpio_set_debounce(gpiopin,ACCDET_SHORT_PLUGOUT_DEBOUNCE_CN*1000);
+	#endif  
+		/* update the eint status */
+		cur_eint_state = EINT_PIN_PLUG_IN;
+
+		//INIT the timer to disable micbias.
+					
+		init_timer(&micbias_timer);
+		micbias_timer.expires = jiffies + MICBIAS_DISABLE_TIMER;
+		micbias_timer.function = &disable_micbias;
+		micbias_timer.data = ((unsigned long) 0 );
+		add_timer(&micbias_timer);
+	}
 
+	ret = queue_work(accdet_eint_workqueue, &accdet_eint_work);	
+	return IRQ_HANDLED;
+}
+#else
 static void accdet_eint_func(void)
 {
 	int ret=0;
@@ -439,15 +555,19 @@ static void accdet_eint_func(void)
 	To trigger EINT when the headset was plugged in
 	We set the polarity back as we initialed.
 	*/
+	#ifndef ACCDET_EINT_IRQ
 		if (CUST_EINT_ACCDET_TYPE == CUST_EINTF_TRIGGER_HIGH){
 					mt_eint_set_polarity(CUST_EINT_ACCDET_NUM, (1));
 		}else{
 					mt_eint_set_polarity(CUST_EINT_ACCDET_NUM, (0));
 		}
-
-#ifdef ACCDET_SHORT_PLUGOUT_DEBOUNCE
+	#endif
+	#ifdef ACCDET_EINT_IRQ
+		pmic_pwrap_write(ACCDET_EINT_CTL, pmic_pwrap_read(ACCDET_EINT_CTL)&(~(7<<4)));
+		pmic_pwrap_write(ACCDET_EINT_CTL, pmic_pwrap_read(ACCDET_EINT_CTL)|EINT_IRQ_DE_IN);//debounce=256ms
+	#else
         mt_eint_set_hw_debounce(CUST_EINT_ACCDET_NUM, CUST_EINT_ACCDET_DEBOUNCE_CN);
-#endif
+	#endif
 
 		/* update the eint status */
 		cur_eint_state = EINT_PIN_PLUG_OUT;
@@ -461,18 +581,23 @@ static void accdet_eint_func(void)
 	To trigger EINT when the headset was plugged out 
 	We set the opposite polarity to what we initialed. 
 	*/
+	#ifndef ACCDET_EINT_IRQ
 		if (CUST_EINT_ACCDET_TYPE == CUST_EINTF_TRIGGER_HIGH){
 				mt_eint_set_polarity(CUST_EINT_ACCDET_NUM, !(1));
 		}else{
 				mt_eint_set_polarity(CUST_EINT_ACCDET_NUM, !(0));
 		}
-	/* update the eint status */
-#ifdef ACCDET_SHORT_PLUGOUT_DEBOUNCE
+	#endif
+
+	#ifdef ACCDET_EINT_IRQ
+		pmic_pwrap_write(ACCDET_EINT_CTL, pmic_pwrap_read(ACCDET_EINT_CTL)&(~(7<<4)));
+		pmic_pwrap_write(ACCDET_EINT_CTL, pmic_pwrap_read(ACCDET_EINT_CTL)|EINT_IRQ_DE_OUT);//debounce=16ms
+	#else
         mt_eint_set_hw_debounce(CUST_EINT_ACCDET_NUM, ACCDET_SHORT_PLUGOUT_DEBOUNCE_CN);
-#endif        
+	#endif  
+		/* update the eint status */
 		cur_eint_state = EINT_PIN_PLUG_IN;
-	
-#ifdef ACCDET_LOW_POWER
+
 		//INIT the timer to disable micbias.
 					
 		init_timer(&micbias_timer);
@@ -480,79 +605,54 @@ static void accdet_eint_func(void)
 		micbias_timer.function = &disable_micbias;
 		micbias_timer.data = ((unsigned long) 0 );
 		add_timer(&micbias_timer);
-					
-#endif
 	}
 
 	ret = queue_work(accdet_eint_workqueue, &accdet_eint_work);	
-      if(!ret)
-      {
-  	    //ACCDET_DEBUG("[Accdet]accdet_eint_func:accdet_work return:%d!\n", ret);  		
-      }
 }
-
-
-static inline int accdet_setup_eint(void)
+#endif
+#ifndef ACCDET_EINT_IRQ
+static inline int accdet_setup_eint(void) 
 {
-	
+	int ret;
+#ifdef CONFIG_OF
+	u32 ints[2]={0,0};
+	struct device_node *node;
+#endif
 	/*configure to GPIO function, external interrupt*/
     ACCDET_DEBUG("[Accdet]accdet_setup_eint\n");
-	
 	mt_set_gpio_mode(GPIO_ACCDET_EINT_PIN, GPIO_ACCDET_EINT_PIN_M_EINT);
     mt_set_gpio_dir(GPIO_ACCDET_EINT_PIN, GPIO_DIR_IN);
     mt_set_gpio_pull_enable(GPIO_ACCDET_EINT_PIN, GPIO_PULL_DISABLE); //To disable GPIO PULL.
-
+    
+#ifdef CONFIG_OF
+    node = of_find_compatible_node(NULL,NULL,"mediatek, ACCDET-eint");
+	if(node) {
+        of_property_read_u32_array(node,"debounce",ints,ARRAY_SIZE(ints));
+		gpiopin = ints[0];
+		headsetdebounce = ints[1];
+		mt_gpio_set_debounce(gpiopin,headsetdebounce);
+		accdet_irq = irq_of_parse_and_map(node,0);
+		ret = request_irq(accdet_irq,accdet_eint_func,IRQF_TRIGGER_NONE,"ACCDET-eint",NULL);
+		if(ret>0){
+            ACCDET_DEBUG("[Accdet]EINT IRQ LINENNOT AVAILABLE\n");
+		}
+	}
+	else {
+        ACCDET_DEBUG("[Accdet]%s can't find compatible node\n", __func__);
+	}
+#else
 	mt_eint_set_hw_debounce(CUST_EINT_ACCDET_NUM, CUST_EINT_ACCDET_DEBOUNCE_CN);
 	mt_eint_registration(CUST_EINT_ACCDET_NUM, CUST_EINT_ACCDET_TYPE, accdet_eint_func, 0);
 	ACCDET_DEBUG("[Accdet]accdet set EINT finished, accdet_eint_num=%d, accdet_eint_debounce_en=%d, accdet_eint_polarity=%d\n", CUST_EINT_ACCDET_NUM, CUST_EINT_ACCDET_DEBOUNCE_EN, CUST_EINT_ACCDET_TYPE);
-	
 	mt_eint_unmask(CUST_EINT_ACCDET_NUM);  
+#endif
+
 	return 0;
 }
-
+#endif//ACCDET_EINT_IRQ
 #endif//endif ACCDET_EINT
 
-//Jeffrey modify for headset quick press -start
-void send_quick_key_event(void)
-{
-    //mutex_lock(&sum_press_num_sync_mutex);
-    ACCDET_DEBUG("accdet: send_quick_key_event: key_release_flag = %d , sum_press_num = %d\n", key_event_flag, sum_press_num);
-    if(key_event_flag)
-    {
-          if(PLUG_OUT !=accdet_status)
-        	{
-		        	switch(sum_press_num)
-					{
-    					case QUICK_KEY_MD:
-							input_report_key(kpd_accdet_dev, KEY_PLAYPAUSE, 1);
-							input_report_key(kpd_accdet_dev, KEY_PLAYPAUSE, 0);					
-							input_sync(kpd_accdet_dev);	
-							ACCDET_DEBUG("accdet: press play/pause song!!\n");
-						break;
-						case QUICK_KEY_DW:
-							input_report_key(kpd_accdet_dev, KEY_NEXTSONG, 1);
-							input_report_key(kpd_accdet_dev, KEY_NEXTSONG, 0);					
-							input_sync(kpd_accdet_dev);	
-							ACCDET_DEBUG("accdet: press next song!!\n");
-						break;
-		       		case QUICK_KEY_UP:
-							input_report_key(kpd_accdet_dev, KEY_PREVIOUSSONG, 1);
-							input_report_key(kpd_accdet_dev, KEY_PREVIOUSSONG, 0);					
-							input_sync(kpd_accdet_dev);	
-							ACCDET_DEBUG("accdet: press previous song!!\n");
-						break;
-						default :
-						ACCDET_DEBUG("accdet: quick key status error!!\n");
-					}
-                    
-			}
-		sum_press_num =0;
-		key_event_flag=0;
-    	}
-		//mutex_unlock(&sum_press_num_sync_mutex);
-}
-//Jeffrey modify for headset quick press -end
-#ifdef ACCDET_MULTI_KEY_FEATURE
+#if defined ACCDET_EINT || defined ACCDET_EINT_IRQ
 extern int PMIC_IMM_GetOneChannelValue(int dwChannel, int deCount, int trimd);
 
 #define KEY_SAMPLE_PERIOD        (60)            //ms
@@ -562,36 +662,23 @@ extern int PMIC_IMM_GetOneChannelValue(int dwChannel, int deCount, int trimd);
 #define UP_KEY			 (0x01)
 #define MD_KEY		  	 (0x02)
 #define DW_KEY			 (0x04)
-
-#define SHORT_PRESS		 (0x0)
-#define LONG_PRESS		 (0x10)
-#define SHORT_UP                 ((UP_KEY) | SHORT_PRESS)
-#define SHORT_MD             	 ((MD_KEY) | SHORT_PRESS)
-#define SHORT_DW                 ((DW_KEY) | SHORT_PRESS)
-#define LONG_UP                  ((UP_KEY) | LONG_PRESS)
-#define LONG_MD                  ((MD_KEY) | LONG_PRESS)
-#define LONG_DW                  ((DW_KEY) | LONG_PRESS)
-
-#define KEYDOWN_FLAG 1
-#define KEYUP_FLAG 0
-//static int g_adcMic_channel_num =0;
-
+#define AS_KEY			 (0x08)
 
 static DEFINE_MUTEX(accdet_multikey_mutex);
 
-
+#ifndef FOUR_KEY_HEADSET
 
 /*
 
         MD              UP                DW
 |---------|-----------|----------|
-0V<=MD< 0.09V<= UP<0.24V<=DW <0.5V
+0V<=MD< 0.08V<= UP<0.22V<=DW <0.5V
 
 */
 
 #define DW_KEY_HIGH_THR	 (500) //0.50v=500000uv
-#define DW_KEY_THR		 (240) //0.24v=240000uv
-#define UP_KEY_THR       (90) //0.09v=90000uv
+#define DW_KEY_THR		 (220) //0.22v=220000uv
+#define UP_KEY_THR       (80) //0.08v=80000uv
 #define MD_KEY_THR		 (0)
 
 static int key_check(int b)
@@ -599,108 +686,118 @@ static int key_check(int b)
 	//ACCDET_DEBUG("adc_data: %d v\n",b);
 	
 	/* 0.24V ~ */
-	ACCDET_DEBUG("accdet: come in key_check!!\n");
+	ACCDET_DEBUG("[accdet] come in key_check!!\n");
 	if((b<DW_KEY_HIGH_THR)&&(b >= DW_KEY_THR)) 
 	{
-		ACCDET_DEBUG("adc_data: %d mv\n",b);
+		ACCDET_DEBUG("[accdet]adc_data: %d mv\n",b);
 		return DW_KEY;
 	} 
 	else if ((b < DW_KEY_THR)&& (b >= UP_KEY_THR))
 	{
-		ACCDET_DEBUG("adc_data: %d mv\n",b);
+		ACCDET_DEBUG("[accdet]adc_data: %d mv\n",b);
 		return UP_KEY;
 	}
 	else if ((b < UP_KEY_THR) && (b >= MD_KEY_THR))
 	{
-		ACCDET_DEBUG("adc_data: %d mv\n",b);
+		ACCDET_DEBUG("[accdet]adc_data: %d mv\n",b);
 		return MD_KEY;
 	}
-	ACCDET_DEBUG("accdet: leave key_check!!\n");
+	ACCDET_DEBUG("[accdet] leave key_check!!\n");
 	return NO_KEY;
 }
+#else
+
+/*
+
+   MD           VOICE          UP         DW
+|---------|----------------|----------|--------
+0V<=MD< 0.059V<= VOICE<0.123V<=UP <0.195V<=DW
+
+*/
+
+#define DW_KEY_THR		 (195) 
+#define UP_KEY_THR       (123) 
+#define AS_KEY_THR       (59) 
+#define MD_KEY_THR		 (0)
+
+static int key_check(int b)
+{
+	//ACCDET_DEBUG("adc_data: %d v\n",b);
+	
+	/* 0.24V ~ */
+	ACCDET_DEBUG("[accdet] come in key_check!!\n");
+	if((b >= DW_KEY_THR)) 
+	{
+		ACCDET_DEBUG("[accdet]adc_data: %d mv\n",b);
+		return DW_KEY;
+	} 
+	else if ((b < DW_KEY_THR)&& (b >= UP_KEY_THR))
+	{
+		ACCDET_DEBUG("[accdet]adc_data: %d mv\n",b);
+		return UP_KEY;
+	}
+	else if ((b < UP_KEY_THR)&& (b >= AS_KEY_THR))
+	{
+		ACCDET_DEBUG("[accdet]adc_data: %d mv\n",b);
+		return AS_KEY;
+	}
+	else if ((b < AS_KEY_THR) && (b >= MD_KEY_THR))
+	{
+		ACCDET_DEBUG("[accdet]adc_data: %d mv\n",b);
+		return MD_KEY;
+	}
+	ACCDET_DEBUG("[accdet] leave key_check!!\n");
+	return NO_KEY;
+}
+
+#endif
 
 static void send_key_event(int keycode,int flag)
 {
-    if(call_status == 0)
-    {
-                switch (keycode)
-                {
-                case DW_KEY:
-					input_report_key(kpd_accdet_dev, KEY_NEXTSONG, flag);
-					input_sync(kpd_accdet_dev);
-					ACCDET_DEBUG("KEY_NEXTSONG %d\n",flag);
-					break;
-				case UP_KEY:
-		   	        input_report_key(kpd_accdet_dev, KEY_PREVIOUSSONG, flag);
-                    input_sync(kpd_accdet_dev);
-					ACCDET_DEBUG("KEY_PREVIOUSSONG %d\n",flag);
-		   	        break;
-                }
-     }
-	else
+	switch (keycode)
 	{
-	          switch (keycode)
-              {
-                case DW_KEY:
-					input_report_key(kpd_accdet_dev, KEY_VOLUMEDOWN, flag);
-					input_sync(kpd_accdet_dev);
-					ACCDET_DEBUG("KEY_VOLUMEDOWN %d\n",flag);
-					break;
-				case UP_KEY:
-		   	        input_report_key(kpd_accdet_dev, KEY_VOLUMEUP, flag);
-                    input_sync(kpd_accdet_dev);
-					ACCDET_DEBUG("KEY_VOLUMEUP %d\n",flag);
-		   	        break;
-	          }
+	case DW_KEY:
+		input_report_key(kpd_accdet_dev, KEY_VOLUMEDOWN, flag);
+		input_sync(kpd_accdet_dev);
+		ACCDET_DEBUG("[accdet]KEY_VOLUMEDOWN %d\n",flag);
+		break;
+	case UP_KEY:
+		input_report_key(kpd_accdet_dev, KEY_VOLUMEUP, flag);
+		input_sync(kpd_accdet_dev);
+		ACCDET_DEBUG("[accdet]KEY_VOLUMEUP %d\n",flag);
+		break;
+	case MD_KEY:
+		input_report_key(kpd_accdet_dev, KEY_PLAYPAUSE, flag);
+		input_sync(kpd_accdet_dev);
+		ACCDET_DEBUG("[accdet]KEY_PLAYPAUSE %d\n",flag);
+		break;
+#ifdef FOUR_KEY_HEADSET
+	case AS_KEY:
+		input_report_key(kpd_accdet_dev, KEY_VOICECOMMAND, flag);
+		input_sync(kpd_accdet_dev);
+		ACCDET_DEBUG("[accdet]KEY_VOICECOMMAND %d\n",flag);
+		break;
+#endif
 	}
 }
-static int multi_key_detection(void)
+static void multi_key_detection(int current_status)
 {
-    int current_status = 0;
-	int index = 0;
-	int count = long_press_time / (KEY_SAMPLE_PERIOD + 40 ); //ADC delay
+	//int index = 0;
 	int m_key = 0;
-	int cur_key = 0;
 	int cali_voltage=0;
 	
-	cali_voltage = PMIC_IMM_GetOneChannelValue(MULTIKEY_ADC_CHANNEL,1,1);
-	ACCDET_DEBUG("[Accdet]adc cali_voltage1 = %d mv\n", cali_voltage);
+	if(0 == current_status){
+#ifdef GET_ADC_DIRECTLY	
+	cali_voltage = Accdet_PMIC_IMM_GetOneChannelValue(1);
+#else
+	cali_voltage = PMIC_IMM_GetOneChannelValue(AUX_VACCDET_AP,1,0);
+#endif
+		ACCDET_DEBUG("[Accdet]adc cali_voltage1 = %d mv\n", cali_voltage);
 	m_key = cur_key = key_check(cali_voltage);
-
-	send_key_event(m_key, KEYDOWN_FLAG);
-
-	while(index++ < count)
-	{
-
-		/* Check if the current state has been changed */
-		current_status = ((pmic_pwrap_read(ACCDET_STATE_RG) & 0xc0)>>6);
-		ACCDET_DEBUG("[Accdet]accdet current_status = %d\n", current_status);
-		if(current_status != 0)
-		{
-		      send_key_event(m_key, KEYUP_FLAG);
-			return (m_key | SHORT_PRESS);
-		}
-
-		/* Check if the voltage has been changed (press one key and another) */
-		//IMM_GetOneChannelValue(g_adcMic_channel_num, adc_data, &adc_raw);
-		cali_voltage = PMIC_IMM_GetOneChannelValue(MULTIKEY_ADC_CHANNEL,1,1);
-		ACCDET_DEBUG("[Accdet]adc in while loop [%d]= %d mv\n", index, cali_voltage);
-		cur_key = key_check(cali_voltage);
-		if(m_key != cur_key)
-		{
-		       send_key_event(m_key, KEYUP_FLAG);
-			ACCDET_DEBUG("[Accdet]accdet press one key and another happen!!\n");   
-			return (m_key | SHORT_PRESS);
-		}
-		else
-		{
-			m_key = cur_key;
 		}
 		
-		msleep(KEY_SAMPLE_PERIOD);
-	}
+	send_key_event(cur_key, !current_status);
 	
-	return (m_key | LONG_PRESS);
 }
 
 #endif
@@ -717,178 +814,91 @@ static void accdet_workqueue_func(void)
 
 int accdet_irq_handler(void)
 {
-	int i = 0;
+	U64 cur_time = 0;
+	cur_time = accdet_get_current_time();
+#ifdef ACCDET_EINT_IRQ
+	if((pmic_pwrap_read(ACCDET_IRQ_STS) & IRQ_STATUS_BIT)&&((pmic_pwrap_read(ACCDET_IRQ_STS) & EINT_IRQ_STATUS_BIT)!=EINT_IRQ_STATUS_BIT)) {
+		clear_accdet_interrupt();	
+		if (accdet_status == MIC_BIAS){
+			//accdet_auxadc_switch(1);
+			pmic_pwrap_write(ACCDET_PWM_WIDTH, REGISTER_VALUE(cust_headset_settings->pwm_width));
+			pmic_pwrap_write(ACCDET_PWM_THRESH, REGISTER_VALUE(cust_headset_settings->pwm_width));
+		}
+		accdet_workqueue_func();  
+		while(((pmic_pwrap_read(ACCDET_IRQ_STS) & IRQ_STATUS_BIT) && (accdet_timeout_ns(cur_time, ACCDET_TIME_OUT)))) {
+		}
+	}else if((pmic_pwrap_read(ACCDET_IRQ_STS) & EINT_IRQ_STATUS_BIT)==EINT_IRQ_STATUS_BIT) {
+		if(cur_eint_state ==  EINT_PIN_PLUG_IN ) {
+			//#ifdef CUST_ACCDET_EINT_LOW
+			if (CUST_EINT_ACCDET_TYPE == CUST_EINTF_TRIGGER_HIGH){
+				pmic_pwrap_write(ACCDET_IRQ_STS, pmic_pwrap_read(ACCDET_IRQ_STS)|EINT_IRQ_POL_HIGH);
+			//#else
+			}else{
+				pmic_pwrap_write(ACCDET_IRQ_STS, pmic_pwrap_read(ACCDET_IRQ_STS)&~EINT_IRQ_POL_LOW);
+			}
+			//#endif
+		}else {
+			//#ifdef CUST_ACCDET_EINT_LOW
+			if (CUST_EINT_ACCDET_TYPE == CUST_EINTF_TRIGGER_HIGH){
+				pmic_pwrap_write(ACCDET_IRQ_STS, pmic_pwrap_read(ACCDET_IRQ_STS)&~EINT_IRQ_POL_LOW);
+			}else{
+			//#else
+				pmic_pwrap_write(ACCDET_IRQ_STS, pmic_pwrap_read(ACCDET_IRQ_STS)|EINT_IRQ_POL_HIGH);
+			}
+			//#endif
+		}
+		clear_accdet_eint_interrupt();
+		while(((pmic_pwrap_read(ACCDET_IRQ_STS) & EINT_IRQ_STATUS_BIT) && (accdet_timeout_ns(cur_time, ACCDET_TIME_OUT)))) {
+		}
+		accdet_eint_func();  
+	}else {
+		 ACCDET_DEBUG("ACCDET IRQ and EINT IRQ don't be triggerred!!\n");
+	}	
+#else
 	if((pmic_pwrap_read(ACCDET_IRQ_STS) & IRQ_STATUS_BIT)) {
 		clear_accdet_interrupt();
 	}
-	#ifdef ACCDET_MULTI_KEY_FEATURE
     if (accdet_status == MIC_BIAS){
-		accdet_auxadc_switch(1);
+		//accdet_auxadc_switch(1);
     	pmic_pwrap_write(ACCDET_PWM_WIDTH, REGISTER_VALUE(cust_headset_settings->pwm_width));
 	 	pmic_pwrap_write(ACCDET_PWM_THRESH, REGISTER_VALUE(cust_headset_settings->pwm_width));
     }
-	#endif
     accdet_workqueue_func();  
-	while(((pmic_pwrap_read(ACCDET_IRQ_STS) & IRQ_STATUS_BIT) && i<10)) {
-		i++;
-		udelay(200);
+	while(((pmic_pwrap_read(ACCDET_IRQ_STS) & IRQ_STATUS_BIT) && 
+		   (accdet_timeout_ns(cur_time, ACCDET_TIME_OUT)))) {
 	}
+#endif
+#ifdef ACCDET_NEGV_IRQ
+	cur_time = accdet_get_current_time();
+	if((pmic_pwrap_read(ACCDET_IRQ_STS) & NEGV_IRQ_STATUS_BIT)==NEGV_IRQ_STATUS_BIT) {
+		ACCDET_DEBUG("[ACCDET NEGV detect]plug in a error Headset\n\r");
+		pmic_pwrap_write(ACCDET_IRQ_STS, (IRQ_NEGV_CLR_BIT));
+		while(((pmic_pwrap_read(ACCDET_IRQ_STS) & NEGV_IRQ_STATUS_BIT) && 
+			   (accdet_timeout_ns(cur_time, ACCDET_TIME_OUT)))) {
+		} 
+		//recover EINT irq clear bit
+		pmic_pwrap_write(ACCDET_IRQ_STS, (pmic_pwrap_read(ACCDET_IRQ_STS)&(~IRQ_NEGV_CLR_BIT))); 
+	}
+#endif
+
     return 1;
 }
 
 //clear ACCDET IRQ in accdet register
 static inline void clear_accdet_interrupt(void)
 {
-
 	//it is safe by using polling to adjust when to clear IRQ_CLR_BIT
 	pmic_pwrap_write(ACCDET_IRQ_STS, (IRQ_CLR_BIT));
-	ACCDET_DEBUG("[Accdet]clear_accdet_interrupt: ACCDET_IRQ_STS = 0x%x\n", pmic_pwrap_read(ACCDET_IRQ_STS));
+	ACCDET_DEBUG("[Accdet]clear_accdet_interrupt: ACCDET_IRQ_STS (%x) = 0x%x\n", ACCDET_IRQ_STS, pmic_pwrap_read(ACCDET_IRQ_STS));
 }
-
-#ifdef SW_WORK_AROUND_ACCDET_REMOTE_BUTTON_ISSUE
-
-
-#define    ACC_ANSWER_CALL      1
-#define    ACC_END_CALL         2
-#define    ACC_MEDIA_PLAYPAUSE  3
-
-#ifdef ACCDET_MULTI_KEY_FEATURE
-#define    ACC_MEDIA_STOP       4
-#define    ACC_MEDIA_NEXT       5
-#define    ACC_MEDIA_PREVIOUS   6
-#define    ACC_VOLUMEUP   7
-#define    ACC_VOLUMEDOWN   8
-#endif
-
-static atomic_t send_event_flag = ATOMIC_INIT(0);
-
-static DECLARE_WAIT_QUEUE_HEAD(send_event_wq);
-
-
-static int accdet_key_event=0;
-
-static int sendKeyEvent(void *unuse)
+static inline void clear_accdet_eint_interrupt(void)
 {
-    while(1)
-    {
-        ACCDET_DEBUG( " accdet:sendKeyEvent wait\n");
-        //wait for signal
-        wait_event_interruptible(send_event_wq, (atomic_read(&send_event_flag) != 0));
-
-        wake_lock_timeout(&accdet_key_lock, 2*HZ);    //set the wake lock.
-        ACCDET_DEBUG( " accdet:going to send event %d\n", accdet_key_event);
-		
-        if(PLUG_OUT !=accdet_status)
-        {
-            //send key event
-            if(ACC_ANSWER_CALL == accdet_key_event)
-            {
-				//Jeffrey modify for headset quick press -start
-				if(call_status == CALL_RINGING)
-				{
-					ACCDET_DEBUG("[Accdet] answer call!\n");
-					input_report_key(kpd_accdet_dev, KEY_CALL, 1);
-					input_report_key(kpd_accdet_dev, KEY_CALL, 0);
-					input_sync(kpd_accdet_dev);
-				}else if(call_status == CALL_ACTIVE)
-				{	
-					ACCDET_DEBUG("[Accdet][key] end call!\n");
-                input_report_key(kpd_accdet_dev, KEY_ENDCALL, 1);
-                input_report_key(kpd_accdet_dev, KEY_ENDCALL, 0);
-                input_sync(kpd_accdet_dev);
-            }
-			}else if(ACC_END_CALL == accdet_key_event)
-            {
-				if(call_status == CALL_RINGING)
-				{
-					ACCDET_DEBUG("[Accdet][key] end call!\n");
-					input_report_key(kpd_accdet_dev, KEY_ENDCALL, 1);
-					input_report_key(kpd_accdet_dev, KEY_ENDCALL, 0);
-					input_sync(kpd_accdet_dev);
-				} else if(call_status == CALL_ACTIVE)
-				{
-					ACCDET_DEBUG("[Accdet][key] end call!\n");
-					input_report_key(kpd_accdet_dev, KEY_ENDCALL, 1);
-					input_report_key(kpd_accdet_dev, KEY_ENDCALL, 0);
-					input_sync(kpd_accdet_dev);
-				}
-			}
-			//Jeffrey modify for headset quick press -end
-#ifdef ACCDET_MULTI_KEY_FEATURE
-            if(ACC_MEDIA_PLAYPAUSE == accdet_key_event)
-            {
-                                ACCDET_DEBUG("[Accdet] PLAY_PAUSE !\n");
-                                input_report_key(kpd_accdet_dev, KEY_PLAYPAUSE, 1);
-                                input_report_key(kpd_accdet_dev, KEY_PLAYPAUSE, 0);
-                                input_sync(kpd_accdet_dev);
-            }
-// next, previous, volumeup, volumedown send key in multi_key_detection()
-            if(ACC_MEDIA_NEXT == accdet_key_event)
-            {
-                                ACCDET_DEBUG("[Accdet] NEXT ..\n");
-                      
-            }
-            if(ACC_MEDIA_PREVIOUS == accdet_key_event)
-            {
-                                ACCDET_DEBUG("[Accdet] PREVIOUS..\n");
-                           
-            }
-	      if(ACC_VOLUMEUP== accdet_key_event)
-            {
-                                ACCDET_DEBUG("[Accdet] VOLUMUP ..\n");
-                           
-            }
-	       if(ACC_VOLUMEDOWN== accdet_key_event)
-            {
-                                ACCDET_DEBUG("[Accdet] VOLUMDOWN..\n");
-                     
-            }
-
-#endif
-        }
-        atomic_set(&send_event_flag, 0);
-
-      //  wake_unlock(&accdet_key_lock); //unlock wake lock
-    }
-    return 0;
+	pmic_pwrap_write(ACCDET_IRQ_STS, (IRQ_EINT_CLR_BIT));
+	ACCDET_DEBUG("[Accdet]clear_accdet_eint_interrupt: ACCDET_IRQ_STS = 0x%x\n", pmic_pwrap_read(ACCDET_IRQ_STS));
 }
 
-static ssize_t notify_sendKeyEvent(int event)
-{
-	 
-    accdet_key_event = event;
-    atomic_set(&send_event_flag, 1);
-    wake_up(&send_event_wq);
-    ACCDET_DEBUG( " accdet:notify_sendKeyEvent !\n");
-    return 0;
-}
 
 
-#endif
-//Jeffrey modify for headset quick press -start
-void send_long_key_event(void)
-{
-    if(PLUG_OUT !=accdet_status)
-    {   
-    	if(call_status != 0) 
-    	{
-			ACCDET_DEBUG("[Accdet]send long press remote button event %d \n",ACC_END_CALL);
-        	notify_sendKeyEvent(ACC_END_CALL);
-         
-    	}else{
-    		ACCDET_DEBUG("[Accdet][key] STOP !!!!\n");
-    		input_report_key(kpd_accdet_dev, KEY_STOPCD, 1);
-    		input_report_key(kpd_accdet_dev, KEY_STOPCD, 0);
-    		input_sync(kpd_accdet_dev);
-		}
-    }
-    //mutex_lock(&sum_press_num_sync_mutex);
-    sum_press_num =0;
-    key_event_flag=0;
-    //mutex_unlock(&sum_press_num_sync_mutex);
-}
-//Jeffrey modify for headset quick press -end
-
 static inline void check_cable_type(void)
 {
     int current_status = 0;
@@ -900,8 +910,9 @@ static inline void check_cable_type(void)
 #endif
     
     current_status = ((pmic_pwrap_read(ACCDET_STATE_RG) & 0xc0)>>6); //A=bit1; B=bit0
-    ACCDET_DEBUG("[Accdet]accdet interrupt happen:[%s]current AB = %d\n", 
-		accdet_status_string[accdet_status], current_status);
+    
+    ACCDET_DEBUG("[Accdet]accdet interrupt happen:[%s] AB=%d [0x%x]\n", 
+		accdet_status_string[accdet_status], current_status, pmic_pwrap_read(ACCDET_STATE_RG));
 	    	
     button_status = 0;
     pre_status = accdet_status;
@@ -926,13 +937,16 @@ static inline void check_cable_type(void)
 				 current_status = ((pmic_pwrap_read(ACCDET_STATE_RG) & 0xc0)>>6); //A=bit1; B=bit0
 				 if (current_status == 0 && show_icon_delay != 0)
 				 {
-					accdet_auxadc_switch(1);//switch on when need to use auxadc read voltage
-					pin_adc_value = PMIC_IMM_GetOneChannelValue(8,10,1);
+					//accdet_auxadc_switch(1);//switch on when need to use auxadc read voltage
+#ifdef GET_ADC_DIRECTLY	
+					pin_adc_value = Accdet_PMIC_IMM_GetOneChannelValue(1);
+#else
+					pin_adc_value = PMIC_IMM_GetOneChannelValue(AUX_VACCDET_AP,1,0);
+#endif
 					ACCDET_DEBUG("[Accdet]pin_adc_value = %d mv!\n", pin_adc_value);
-					accdet_auxadc_switch(0);			
-					if (200 > pin_adc_value && pin_adc_value> 100) //100mv   ilegal headset
+					//accdet_auxadc_switch(0);			
+					if (180 > pin_adc_value && pin_adc_value> 90) //90mv   ilegal headset
 					{
-						headset_standard_judge_message();
 						mutex_lock(&accdet_eint_irq_sync_mutex);
 						if(1 == eint_accdet_sync_flag) {
 						cable_type = HEADSET_NO_MIC;
@@ -992,7 +1006,7 @@ static inline void check_cable_type(void)
             else if(current_status == 3)
             {
                 ACCDET_DEBUG("[Accdet]PLUG_OUT state not change!\n");
-		    	#ifdef ACCDET_MULTI_KEY_FEATURE
+		    	#ifdef ACCDET_EINT
 		    		ACCDET_DEBUG("[Accdet] do not send plug out event in plug out\n");
 		    	#else
 				mutex_lock(&accdet_eint_irq_sync_mutex);
@@ -1003,9 +1017,6 @@ static inline void check_cable_type(void)
 					ACCDET_DEBUG("[Accdet] Headset has plugged out\n");
 				}
 				mutex_unlock(&accdet_eint_irq_sync_mutex);
-		    	#ifdef ACCDET_EINT
-		     		disable_accdet();
-		    	#endif
 		        #endif
             }
             else
@@ -1021,7 +1032,6 @@ static inline void check_cable_type(void)
 			
             if(current_status == 0)
             {
-            
 			mutex_lock(&accdet_eint_irq_sync_mutex);
 			if(1 == eint_accdet_sync_flag) {
 				while((pmic_pwrap_read(ACCDET_IRQ_STS) & IRQ_STATUS_BIT) && (wait_clear_irq_times<3))
@@ -1042,94 +1052,19 @@ static inline void check_cable_type(void)
 		    button_status = 1;
 			if(button_status)
 		    {	
-			#ifdef ACCDET_MULTI_KEY_FEATURE		
-				int multi_key = NO_KEY;		
-			  	//mdelay(10);
-			   	//if plug out don't send key
 			    mutex_lock(&accdet_eint_irq_sync_mutex);
-				if(1 == eint_accdet_sync_flag) {   
-					multi_key = multi_key_detection();
+				if(1 == eint_accdet_sync_flag) {
+#if defined ACCDET_EINT || defined ACCDET_EINT_IRQ
+					multi_key_detection(current_status);
+#endif
 				}else {
 					ACCDET_DEBUG("[Accdet] multi_key_detection: Headset has plugged out\n");
 				}
 				mutex_unlock(&accdet_eint_irq_sync_mutex);
-				accdet_auxadc_switch(0);
+				//accdet_auxadc_switch(0);
 			//recover  pwm frequency and duty
                 pmic_pwrap_write(ACCDET_PWM_WIDTH, REGISTER_VALUE(cust_headset_settings->pwm_width));
                 pmic_pwrap_write(ACCDET_PWM_THRESH, REGISTER_VALUE(cust_headset_settings->pwm_thresh));
-			switch (multi_key) 
-			{
-			case SHORT_UP:
-				ACCDET_DEBUG("[Accdet] Short press up (0x%x)\n", multi_key);
-                           if(call_status == 0)
-                           {
-                                 notify_sendKeyEvent(ACC_MEDIA_PREVIOUS);
-                           }
-					       else
-						   {
-							     notify_sendKeyEvent(ACC_VOLUMEUP);
-						    }
-				break;
-			case SHORT_MD:
-				ACCDET_DEBUG("[Accdet] Short press middle (0x%x)\n", multi_key);
-                                 notify_sendKeyEvent(ACC_MEDIA_PLAYPAUSE);
-				break;
-			case SHORT_DW:
-				ACCDET_DEBUG("[Accdet] Short press down (0x%x)\n", multi_key);
-                           if(call_status == 0)
-                            {
-                                 notify_sendKeyEvent(ACC_MEDIA_NEXT);
-                            }
-							else
-							{
-							     notify_sendKeyEvent(ACC_VOLUMEDOWN);
-							}
-				break;
-			case LONG_UP:
-				ACCDET_DEBUG("[Accdet] Long press up (0x%x)\n", multi_key);
-                                 send_key_event(UP_KEY, KEYUP_FLAG);
-                            
-				break;
-			case LONG_MD:
-				ACCDET_DEBUG("[Accdet] Long press middle (0x%x)\n", multi_key);
-
-                                 notify_sendKeyEvent(ACC_END_CALL);
-				break;
-			case LONG_DW:
-				ACCDET_DEBUG("[Accdet] Long press down (0x%x)\n", multi_key);			
-                                 send_key_event(DW_KEY, KEYUP_FLAG);
-							
-				break;
-			default:
-				ACCDET_DEBUG("[Accdet] unkown key (0x%x)\n", multi_key);
-				break;
-			}
-			#else
-#if 0
-                if(call_status != 0) 
-	            {
-	                   if(is_long_press())
-	                   {
-                             ACCDET_DEBUG("[Accdet]send long press remote button event %d \n",ACC_END_CALL);
-                             notify_sendKeyEvent(ACC_END_CALL);
-                       } else {
-                             ACCDET_DEBUG("[Accdet]send short press remote button event %d\n",ACC_ANSWER_CALL);
-                             notify_sendKeyEvent(ACC_MEDIA_PLAYPAUSE);
-                       }
-                 }
-#else
-               //Jeffrey modify for headset quick press -start
-				mod_timer(&long_press_timer, jiffies + LONG_PRESS_DELAY);
-
-				if(!key_event_flag)
-				{
-	                key_event_flag=1;	
-				}else {
-					del_timer_sync(&quick_press_timer);
-				}
-		        //Jeffrey modify for headset quick press -end
-#endif
-			#endif////end  ifdef ACCDET_MULTI_KEY_FEATURE else
 	     }
 }
           else if(current_status == 1)
@@ -1146,7 +1081,7 @@ static inline void check_cable_type(void)
           }
           else if(current_status == 3)
           {
-           #ifdef ACCDET_MULTI_KEY_FEATURE
+		   #if defined ACCDET_EINT || defined ACCDET_EINT_IRQ
 		   		ACCDET_DEBUG("[Accdet]do not send plug ou in micbiast\n");
 		        mutex_lock(&accdet_eint_irq_sync_mutex);
 		        if(1 == eint_accdet_sync_flag) {
@@ -1164,9 +1099,6 @@ static inline void check_cable_type(void)
 					ACCDET_DEBUG("[Accdet] Headset has plugged out\n");
 			 	}
 			 	mutex_unlock(&accdet_eint_irq_sync_mutex);
-		   #ifdef ACCDET_EINT
-		   		disable_accdet();
-		   #endif
 		   #endif
           }
           else
@@ -1193,12 +1125,16 @@ static inline void check_cable_type(void)
             {
 				mutex_lock(&accdet_eint_irq_sync_mutex);
 		        if(1 == eint_accdet_sync_flag) {
+#if defined ACCDET_EINT || defined ACCDET_EINT_IRQ
+					multi_key_detection(current_status);
+#endif
 					accdet_status = MIC_BIAS;		
 	        		cable_type = HEADSET_MIC;
 				}else {
 					ACCDET_DEBUG("[Accdet] Headset has plugged out\n");
 			 	}
 			 	mutex_unlock(&accdet_eint_irq_sync_mutex);
+				//accdet_auxadc_switch(0);
 				#ifdef ACCDET_PIN_RECOGNIZATION
 				cable_pin_recognition = 0;
 				ACCDET_DEBUG("[Accdet] cable_pin_recognition = %d\n", cable_pin_recognition);
@@ -1211,24 +1147,6 @@ static inline void check_cable_type(void)
 				//#ifdef ACCDET_LOW_POWER
 				//wake_unlock(&accdet_timer_lock);//add for suspend disable accdet more than 5S
 				//#endif
-				//Jeffrey modify for headset quick press -start
-				del_timer_sync(&long_press_timer);
-				if(key_event_flag)
-				{
-                    if(call_status != 0) 
-                		{
-							ACCDET_DEBUG("[Accdet]send short press remote button event %d\n",ACC_ANSWER_CALL);
-        					notify_sendKeyEvent(ACC_ANSWER_CALL);
-                            key_event_flag=0;
-         				}else{
-							mutex_lock(&sum_press_num_sync_mutex);
-                   		    sum_press_num ++;
-                   		    mutex_unlock(&sum_press_num_sync_mutex);
-							ACCDET_DEBUG("[Accdet] sum_press_num = %d,  key_release_flag= %d\n", sum_press_num, key_event_flag);
-							mod_timer(&quick_press_timer, jiffies + QUICK_PRESS_DELAY);
-					   }	
-				}
-				//Jeffrey modify for headset quick press -end				
             }
             else if(current_status == 3)
             {
@@ -1244,7 +1162,7 @@ static inline void check_cable_type(void)
 			 	}
 			 	mutex_unlock(&accdet_eint_irq_sync_mutex);
 			 #endif
-             #ifdef ACCDET_MULTI_KEY_FEATURE
+             #if defined ACCDET_EINT || defined ACCDET_EINT_IRQ
 			 	ACCDET_DEBUG("[Accdet] do not send plug out event in hook switch\n"); 
 			 	mutex_lock(&accdet_eint_irq_sync_mutex);
 		        if(1 == eint_accdet_sync_flag) {
@@ -1262,21 +1180,17 @@ static inline void check_cable_type(void)
 					ACCDET_DEBUG("[Accdet] Headset has plugged out\n");
 			 	}
 			 	mutex_unlock(&accdet_eint_irq_sync_mutex);
-			 #ifdef ACCDET_EINT
-		       	disable_accdet();
-		     #endif
 		     #endif
             }
             else
             {
                 ACCDET_DEBUG("[Accdet]HOOK_SWITCH can't change to this state!\n"); 
             }
-            break;
-			
+            break;			
 	case STAND_BY:
 			if(current_status == 3)
 			{
-                 #ifdef ACCDET_MULTI_KEY_FEATURE
+                 #if defined ACCDET_EINT || defined ACCDET_EINT_IRQ
 						ACCDET_DEBUG("[Accdet]accdet do not send plug out event in stand by!\n");
 		    	 #else
 				 		mutex_lock(&accdet_eint_irq_sync_mutex);
@@ -1287,9 +1201,6 @@ static inline void check_cable_type(void)
 							ACCDET_DEBUG("[Accdet] Headset has plugged out\n");
 			 			 }
 			 			mutex_unlock(&accdet_eint_irq_sync_mutex);
-				#ifdef ACCDET_EINT
-						disable_accdet();
-			    #endif
 			    #endif
 			 }
 			 else
@@ -1354,53 +1265,103 @@ static void accdet_work_callback(struct work_struct *work)
 static inline void accdet_init(void)
 { 
 	ACCDET_DEBUG("[Accdet]accdet hardware init\n");
-    
+    //clock
     pmic_pwrap_write(TOP_CKPDN_CLR, RG_ACCDET_CLK_CLR);  
 	ACCDET_DEBUG("[Accdet]accdet TOP_CKPDN=0x%x!\n", pmic_pwrap_read(TOP_CKPDN));	
     //reset the accdet unit
-
 	ACCDET_DEBUG("ACCDET reset : reset start!! \n\r");
 	pmic_pwrap_write(TOP_RST_ACCDET_SET, ACCDET_RESET_SET);
-
 	ACCDET_DEBUG("ACCDET reset function test: reset finished!! \n\r");
 	pmic_pwrap_write(TOP_RST_ACCDET_CLR, ACCDET_RESET_CLR);
-		
 	//init  pwm frequency and duty
     pmic_pwrap_write(ACCDET_PWM_WIDTH, REGISTER_VALUE(cust_headset_settings->pwm_width));
     pmic_pwrap_write(ACCDET_PWM_THRESH, REGISTER_VALUE(cust_headset_settings->pwm_thresh));
-
+	pmic_pwrap_write(ACCDET_STATE_SWCTRL, 0x07);
 	
-	pwrap_write(ACCDET_STATE_SWCTRL, 0x07);
-   			
-
+   	//rise and fall delay of PWM
 	pmic_pwrap_write(ACCDET_EN_DELAY_NUM,
 		(cust_headset_settings->fall_delay << 15 | cust_headset_settings->rise_delay));
-
     // init the debounce time
    #ifdef ACCDET_PIN_RECOGNIZATION
     pmic_pwrap_write(ACCDET_DEBOUNCE0, cust_headset_settings->debounce0);
     pmic_pwrap_write(ACCDET_DEBOUNCE1, 0xFFFF);
     pmic_pwrap_write(ACCDET_DEBOUNCE3, cust_headset_settings->debounce3);	
+	pmic_pwrap_write(ACCDET_DEBOUNCE4, ACCDET_DE4);	
    #else
     pmic_pwrap_write(ACCDET_DEBOUNCE0, cust_headset_settings->debounce0);
     pmic_pwrap_write(ACCDET_DEBOUNCE1, cust_headset_settings->debounce1);
     pmic_pwrap_write(ACCDET_DEBOUNCE3, cust_headset_settings->debounce3);	
+	pmic_pwrap_write(ACCDET_DEBOUNCE4, ACCDET_DE4);
    #endif
+   //enable INT 
     pmic_pwrap_write(ACCDET_IRQ_STS, pmic_pwrap_read(ACCDET_IRQ_STS)&(~IRQ_CLR_BIT));
 	pmic_pwrap_write(INT_CON_ACCDET_SET, RG_ACCDET_IRQ_SET);
-    #ifdef ACCDET_EINT
+   #ifdef ACCDET_EINT_IRQ
+	pmic_pwrap_write(INT_CON_ACCDET_SET, RG_ACCDET_EINT_IRQ_SET);
+   #endif
+   #ifdef ACCDET_NEGV_IRQ
+	pmic_pwrap_write(INT_CON_ACCDET_SET, RG_ACCDET_NEGV_IRQ_SET);
+   #endif
+   /*********************ACCDET Analog Setting***********************************************************/
+   #ifndef ACCDET_WQHD
+   	//pmic_pwrap_write(ACCDET_ADC_REG, pmic_pwrap_read(ACCDET_ADC_REG)|(ACCDET_MIC_VOL<<8));
+    mt6325_upmu_set_rg_audmicbiasvref(ACCDET_MIC_VOL);
+   mt6325_upmu_set_rg_audmicbiaslowpen(1);
+   #else
+   	pmic_pwrap_write(ACCDET_ADC_REG, 0x068F);//for wqhd project
+   #endif
+
+    //pmic_pwrap_write(ACCDET_EINT_NV, ACCDET_BF_MOD); // SW mode
+   
+	pmic_pwrap_write(ACCDET_RSV, 0x1290);    ///TODO: need confirm pull low // 6325 bit[12] =1
+   #ifdef ACCDET_EINT_IRQ
+	pmic_pwrap_write(ACCDET_RSV, pmic_pwrap_read(ACCDET_RSV)|ACCDET_INPUT_MICP);
+    pmic_pwrap_write(ACCDET_EINT_NV, pmic_pwrap_read(ACCDET_EINT_NV)|ACCDET_EINT_CON_EN);
+   #endif
+   #ifdef ACCDET_NEGV_IRQ
+	pmic_pwrap_write(ACCDET_EINT_NV, pmic_pwrap_read(ACCDET_EINT_NV)|ACCDET_NEGV_DT_EN);
+   #endif
+
+	#if  (ACCDET_MIC_MODE==1) // ACC mode
+	mt6325_upmu_set_rg_audmicbias1dcswpen(0);
+	#elif (ACCDET_MIC_MODE==2) // Low cost mode without internal bias
+	pmic_pwrap_write(ACCDET_RSV, pmic_pwrap_read(ACCDET_RSV)|ACCDET_INPUT_MICP);
+	#elif  (ACCDET_MIC_MODE==6)  // Low cost mode with internal bias
+	pmic_pwrap_write(ACCDET_RSV, pmic_pwrap_read(ACCDET_RSV)|ACCDET_INPUT_MICP);
+	mt6325_upmu_set_rg_audmicbias1dcswpen(1);
+	#endif
+	
+   ACCDET_DEBUG(" ACCDET_ADC_REG =%x\n",pmic_pwrap_read(ACCDET_ADC_REG));
+   ACCDET_DEBUG(" ACCDET_EINT_NV =%x\n",pmic_pwrap_read(ACCDET_EINT_NV));
+   ACCDET_DEBUG(" ACCDET_RSV =%x\n",pmic_pwrap_read(ACCDET_RSV));
+    /**************************************************************************************************/
+   #if defined ACCDET_EINT
     // disable ACCDET unit
 	pre_state_swctrl = pmic_pwrap_read(ACCDET_STATE_SWCTRL);
     pmic_pwrap_write(ACCDET_CTRL, ACCDET_DISABLE);
     pmic_pwrap_write(ACCDET_STATE_SWCTRL, 0x0);
 	pmic_pwrap_write(TOP_CKPDN_SET, RG_ACCDET_CLK_SET);
-	#else
-	
+   #elif defined ACCDET_EINT_IRQ
+    pmic_pwrap_write(ACCDET_EINT_CTL, pmic_pwrap_read(ACCDET_EINT_CTL)|EINT_IRQ_DE_IN);//debounce=256ms
+    // disable ACCDET unit, except CLK of ACCDET
+	pre_state_swctrl = pmic_pwrap_read(ACCDET_STATE_SWCTRL);
+    pmic_pwrap_write(ACCDET_CTRL, ACCDET_DISABLE);
+	pmic_pwrap_write(ACCDET_CTRL, ACCDET_EINT_EN);
+	pmic_pwrap_write(ACCDET_STATE_SWCTRL, pmic_pwrap_read(ACCDET_STATE_SWCTRL)&(~ACCDET_SWCTRL_EN));
+    pmic_pwrap_write(ACCDET_STATE_SWCTRL, pmic_pwrap_read(ACCDET_STATE_SWCTRL)|ACCDET_EINT_PWM_EN);
+   #else
     // enable ACCDET unit
    // pmic_pwrap_write(ACCDET_STATE_SWCTRL, ACCDET_SWCTRL_EN);
     pmic_pwrap_write(ACCDET_CTRL, ACCDET_ENABLE); 
-	#endif
-
+   #endif
+   #ifdef ACCDET_NEGV_IRQ
+   	pmic_pwrap_write(ACCDET_EINT_PWM_DELAY, pmic_pwrap_read(ACCDET_EINT_PWM_DELAY)&(~0x1F)); 
+	pmic_pwrap_write(ACCDET_EINT_PWM_DELAY, pmic_pwrap_read(ACCDET_EINT_PWM_DELAY)|0x0F); 
+   	pmic_pwrap_write(ACCDET_CTRL, pmic_pwrap_read(ACCDET_CTRL)|ACCDET_NEGV_EN);
+   #endif
+   /**************************************AUXADC enable auto sample****************************************/
+   mt6325_upmu_set_auxadc_accdet_auto_spl(1);
+   /**************************************************************************************************/
 #ifdef GPIO_FSA8049_PIN
     //mt_set_gpio_out(GPIO_FSA8049_PIN, GPIO_OUT_ONE);
 #endif
@@ -1414,14 +1375,15 @@ static inline void accdet_init(void)
 static int dump_register(void)
 {
    int i=0;
-   for (i=0x077A; i<= 0x079A; i+=2)
+   for (i=ACCDET_BASE_OFFSET; i<= ACCDET_END_OFFSET; i+=2)
    {
      ACCDET_DEBUG(" ACCDET_BASE + %x=%x\n",i,pmic_pwrap_read(ACCDET_BASE + i));
    }
 
-   ACCDET_DEBUG(" TOP_RST_ACCDET =%x\n",pmic_pwrap_read(TOP_RST_ACCDET));// reset register in 6320
-   ACCDET_DEBUG(" INT_CON_ACCDET =%x\n",pmic_pwrap_read(INT_CON_ACCDET));//INT register in 6320
-   ACCDET_DEBUG(" TOP_CKPDN =%x\n",pmic_pwrap_read(TOP_CKPDN));// clock register in 6320
+   ACCDET_DEBUG(" TOP_RST_ACCDET(0x%x) =%x\n", TOP_RST_ACCDET, pmic_pwrap_read(TOP_RST_ACCDET));
+   ACCDET_DEBUG(" INT_CON_ACCDET(0x%x) =%x\n", INT_CON_ACCDET, pmic_pwrap_read(INT_CON_ACCDET));
+   ACCDET_DEBUG(" TOP_CKPDN(0x%x) =%x\n", TOP_CKPDN, pmic_pwrap_read(TOP_CKPDN));
+   ACCDET_DEBUG(" ACCDET_ADC_REG(0x%x) =%x\n", ACCDET_ADC_REG, pmic_pwrap_read(ACCDET_ADC_REG));
   #ifdef ACCDET_PIN_SWAP
    //ACCDET_DEBUG(" 0x00004000 =%x\n",pmic_pwrap_read(0x00004000));//VRF28 power for PIN swap feature
   #endif
@@ -1597,10 +1559,6 @@ static int accdet_create_attr(struct device_driver *driver)
 int mt_accdet_probe(void)	
 {
 	int ret = 0;
-#ifdef SW_WORK_AROUND_ACCDET_REMOTE_BUTTON_ISSUE
-     struct task_struct *keyEvent_thread = NULL;
-	 int error=0;
-#endif
 #if DEBUG_THREAD
 		 struct platform_driver accdet_driver_hal = accdet_driver_func();
 #endif
@@ -1663,13 +1621,16 @@ int mt_accdet_probe(void)
 	__set_bit(EV_KEY, kpd_accdet_dev->evbit);
 	__set_bit(KEY_CALL, kpd_accdet_dev->keybit);
 	__set_bit(KEY_ENDCALL, kpd_accdet_dev->keybit);
-    __set_bit(KEY_NEXTSONG, kpd_accdet_dev->keybit);
-    __set_bit(KEY_PREVIOUSSONG, kpd_accdet_dev->keybit);
-    __set_bit(KEY_PLAYPAUSE, kpd_accdet_dev->keybit);
-    __set_bit(KEY_STOPCD, kpd_accdet_dev->keybit);
+	__set_bit(KEY_NEXTSONG, kpd_accdet_dev->keybit);
+	__set_bit(KEY_PREVIOUSSONG, kpd_accdet_dev->keybit);
+	__set_bit(KEY_PLAYPAUSE, kpd_accdet_dev->keybit);
+	__set_bit(KEY_STOPCD, kpd_accdet_dev->keybit);
 	__set_bit(KEY_VOLUMEDOWN, kpd_accdet_dev->keybit);
-    __set_bit(KEY_VOLUMEUP, kpd_accdet_dev->keybit);
-	
+	__set_bit(KEY_VOLUMEUP, kpd_accdet_dev->keybit);
+#ifdef FOUR_KEY_HEADSET
+	__set_bit(KEY_VOICECOMMAND, kpd_accdet_dev->keybit);
+#endif	
+
 	kpd_accdet_dev->id.bustype = BUS_HOST;
 	kpd_accdet_dev->name = "ACCDET";
 	if(input_register_device(kpd_accdet_dev))
@@ -1693,17 +1654,6 @@ int mt_accdet_probe(void)
     wake_lock_init(&accdet_irq_lock, WAKE_LOCK_SUSPEND, "accdet irq wakelock");
     wake_lock_init(&accdet_key_lock, WAKE_LOCK_SUSPEND, "accdet key wakelock");
 	wake_lock_init(&accdet_timer_lock, WAKE_LOCK_SUSPEND, "accdet timer wakelock");
-#ifdef SW_WORK_AROUND_ACCDET_REMOTE_BUTTON_ISSUE
-     init_waitqueue_head(&send_event_wq);
-     //start send key event thread
-	 keyEvent_thread = kthread_run(sendKeyEvent, 0, "keyEvent_send");
-     if (IS_ERR(keyEvent_thread)) 
-	 { 
-        error = PTR_ERR(keyEvent_thread);
-        ACCDET_DEBUG( " failed to create kernel thread: %d\n", error);
-     }
-#endif
-	
 #if DEBUG_THREAD
  	 if((ret = accdet_create_attr(&accdet_driver_hal.driver))!=0)
 	 {
@@ -1720,21 +1670,22 @@ int mt_accdet_probe(void)
 		long_press_time_ns = (s64)long_press_time * NSEC_PER_MSEC;
 		
 		eint_accdet_sync_flag = 1;
-		
-		//Accdet Hardware Init
-		pmic_pwrap_write(ACCDET_RSV, ACCDET_1V9_MODE_OFF);
-		ACCDET_DEBUG("ACCDET use in 1.9V mode!! \n");
+		#ifdef ACCDET_EINT_IRQ
+          accdet_eint_workqueue = create_singlethread_workqueue("accdet_eint");
+	      INIT_WORK(&accdet_eint_work, accdet_eint_work_callback);
+		  accdet_disable_workqueue = create_singlethread_workqueue("accdet_disable");
+	      INIT_WORK(&accdet_disable_work, disable_micbias_callback);
+        #endif
+	    //Accdet Hardware Init
 		accdet_init();   
-		queue_work(accdet_workqueue, &accdet_work); //schedule a work for the first detection					
+		queue_work(accdet_workqueue, &accdet_work); //schedule a work for the first detection				
 		#ifdef ACCDET_EINT
-
+		  accdet_disable_workqueue = create_singlethread_workqueue("accdet_disable");
+	      INIT_WORK(&accdet_disable_work, disable_micbias_callback);
           accdet_eint_workqueue = create_singlethread_workqueue("accdet_eint");
 	      INIT_WORK(&accdet_eint_work, accdet_eint_work_callback);
 	      accdet_setup_eint();
-		  accdet_disable_workqueue = create_singlethread_workqueue("accdet_disable");
-	      INIT_WORK(&accdet_disable_work, disable_micbias_callback);
-	 	
-       #endif
+        #endif
 		g_accdet_first = 0;
 	}
 	
@@ -1743,10 +1694,6 @@ int mt_accdet_probe(void)
 	//pmic_pwrap_write(0x0400, 0x1000); 
 	//ACCDET_DEBUG("[Accdet]accdet enable VRF28 power!\n");
 //#endif
-    //Jeffrey modify for headset quick press -start
-    setup_timer(&quick_press_timer, send_quick_key_event, 0);
-	setup_timer(&long_press_timer, send_long_key_event, 0);
-    //Jeffrey modify for headset quick press -end
 		
 	    return 0;
 }
@@ -1755,12 +1702,8 @@ void mt_accdet_remove(void)
 {
 	ACCDET_DEBUG("[Accdet]accdet_remove begin!\n");
 	
-	//Jeffrey modify for headset quick press -start
-	del_timer_sync(&quick_press_timer);
-	del_timer_sync(&long_press_timer);
-	//Jeffrey modify for headset quick press -end
 	//cancel_delayed_work(&accdet_work);
-	#ifdef ACCDET_EINT
+	#if defined ACCDET_EINT || defined ACCDET_EINT_IRQ
 	destroy_workqueue(accdet_eint_workqueue);
 	#endif
 	destroy_workqueue(accdet_workqueue);
@@ -1782,25 +1725,10 @@ void mt_accdet_suspend(void)  // only one suspend mode
 //		accdet_FSA8049_disable(); 
 //#endif
 
-#ifdef ACCDET_MULTI_KEY_FEATURE
+#if defined ACCDET_EINT || defined ACCDET_EINT_IRQ
 	ACCDET_DEBUG("[Accdet] in suspend1: ACCDET_IRQ_STS = 0x%x\n", pmic_pwrap_read(ACCDET_IRQ_STS));
 #else
-
 #if 0
-#ifdef ACCDET_EINT
-    if(accdet_get_enable_RG()&& call_status == 0)
-    {
-	   //record accdet status
-	   //ACCDET_DEBUG("[Accdet]accdet_working_in_suspend\n");
-	   printk(KERN_DEBUG "[Accdet]accdet_working_in_suspend\n");
-	   g_accdet_working_in_suspend = 1;
-       pre_state_swctrl = accdet_get_swctrl();
-	   // disable ACCDET unit
-       accdet_disable_hal();
-	   //disable_clock
-	   accdet_disable_clk();
-    }
-#else
     // disable ACCDET unit
     if(call_status == 0)
     {
@@ -1809,7 +1737,6 @@ void mt_accdet_suspend(void)  // only one suspend mode
        //disable_clock
        accdet_disable_clk(); 
     }
-#endif	
 #endif 
 	printk(KERN_DEBUG "[Accdet]accdet_suspend: ACCDET_CTRL=[0x%x], STATE=[0x%x]->[0x%x]\n", pmic_pwrap_read(ACCDET_CTRL), pre_state_swctrl, pmic_pwrap_read(ACCDET_STATE_SWCTRL));
 #endif
@@ -1821,30 +1748,15 @@ void mt_accdet_resume(void) // wake up
 //		pmic_pwrap_write(0x0400, 0x1000); 
 //		accdet_FSA8049_enable(); 
 //#endif
-
-#ifdef ACCDET_MULTI_KEY_FEATURE
+#if defined ACCDET_EINT || defined ACCDET_EINT_IRQ
 	ACCDET_DEBUG("[Accdet] in resume1: ACCDET_IRQ_STS = 0x%x\n", pmic_pwrap_read(ACCDET_IRQ_STS));
 #else
 #if 0
-#ifdef ACCDET_EINT
-
-	if(1==g_accdet_working_in_suspend &&  0== call_status)
-	{
-	
-	   //enable_clock
-	   accdet_enable_hal(pre_state_swctrl); 
-       //clear g_accdet_working_in_suspend
-	   g_accdet_working_in_suspend =0;
-	   ACCDET_DEBUG("[Accdet]accdet_resume : recovery accdet register\n");
-	   
-	}
-#else
 	if(call_status == 0)
 	{
        accdet_enable_hal(pre_state_swctrl);
 	}
 #endif
-#endif
 	printk(KERN_DEBUG "[Accdet]accdet_resume: ACCDET_CTRL=[0x%x], STATE_SWCTRL=[0x%x]\n", pmic_pwrap_read(ACCDET_CTRL), pmic_pwrap_read(ACCDET_STATE_SWCTRL));
 
 #endif
@@ -1861,10 +1773,15 @@ static void mt_accdet_pm_disable(unsigned long a)
 	if (cable_type == NO_DEVICE && eint_accdet_sync_flag ==0) {
 		//disable accdet
 		pre_state_swctrl = pmic_pwrap_read(ACCDET_STATE_SWCTRL);	
-    	pmic_pwrap_write(ACCDET_CTRL, ACCDET_DISABLE);
-   		pmic_pwrap_write(ACCDET_STATE_SWCTRL, 0);
+		pmic_pwrap_write(ACCDET_STATE_SWCTRL, 0);
+    	#ifdef ACCDET_EINT
+   		pmic_pwrap_write(ACCDET_CTRL, ACCDET_DISABLE);
 		//disable clock
     	pmic_pwrap_write(TOP_CKPDN_SET, RG_ACCDET_CLK_SET); 
+   		#endif
+   		#ifdef ACCDET_EINT_IRQ
+   		pmic_pwrap_write(ACCDET_CTRL, pmic_pwrap_read(ACCDET_CTRL)&(~(ACCDET_ENABLE)));
+   		#endif
 		printk("[Accdet]daccdet_pm_disable: disable!\n");
 	}
 	else
@@ -1877,13 +1794,25 @@ void mt_accdet_pm_restore_noirq(void)
 {
 	int current_status_restore = 0;
     printk("[Accdet]accdet_pm_restore_noirq start!\n");
-	//enable accdet
-	pmic_pwrap_write(ACCDET_STATE_SWCTRL, (pmic_pwrap_read(ACCDET_STATE_SWCTRL)|ACCDET_SWCTRL_IDLE_EN));
 	// enable ACCDET unit
     ACCDET_DEBUG("accdet: enable_accdet\n");
     //enable clock
     pmic_pwrap_write(TOP_CKPDN_CLR, RG_ACCDET_CLK_CLR); 
+  #ifdef ACCDET_EINT_IRQ
+	pmic_pwrap_write(TOP_CKPDN_CLR, RG_ACCDET_EINT_IRQ_CLR); 
+    pmic_pwrap_write(ACCDET_RSV, pmic_pwrap_read(ACCDET_RSV)|ACCDET_INPUT_MICP);
+    pmic_pwrap_write(ACCDET_EINT_NV, pmic_pwrap_read(ACCDET_EINT_NV)|ACCDET_EINT_CON_EN);
+	pmic_pwrap_write(ACCDET_EINT_NV, pmic_pwrap_read(ACCDET_EINT_NV)|ACCDET_EINT_CON_EN);
+    pmic_pwrap_write(ACCDET_CTRL, ACCDET_EINT_EN);
+  #endif
+  #ifdef ACCDET_NEGV_IRQ
+	pmic_pwrap_write(TOP_CKPDN_CLR, RG_ACCDET_NEGV_IRQ_CLR);
+  	pmic_pwrap_write(ACCDET_EINT_NV, pmic_pwrap_read(ACCDET_EINT_NV)|ACCDET_NEGV_DT_EN);
+   	pmic_pwrap_write(ACCDET_CTRL, pmic_pwrap_read(ACCDET_CTRL)|ACCDET_NEGV_EN);
+  #endif
     enable_accdet(ACCDET_SWCTRL_EN);
+  	pmic_pwrap_write(ACCDET_STATE_SWCTRL, (pmic_pwrap_read(ACCDET_STATE_SWCTRL)|ACCDET_SWCTRL_IDLE_EN));
+	
 	eint_accdet_sync_flag = 1;
 	current_status_restore = ((pmic_pwrap_read(ACCDET_STATE_RG) & 0xc0)>>6); //AB
 		
@@ -1915,13 +1844,17 @@ void mt_accdet_pm_restore_noirq(void)
 		printk("[Accdet]enable! pm timer\n");	
 
     #else
-		//eint_accdet_sync_flag = 0;
 		//disable accdet
 		pre_state_swctrl = pmic_pwrap_read(ACCDET_STATE_SWCTRL);	
-    	pmic_pwrap_write(ACCDET_CTRL, ACCDET_DISABLE);
-   		pmic_pwrap_write(ACCDET_STATE_SWCTRL, 0);
+	   	pmic_pwrap_write(ACCDET_STATE_SWCTRL, 0);
+    	#ifdef ACCDET_EINT
+   		pmic_pwrap_write(ACCDET_CTRL, ACCDET_DISABLE);
 		//disable clock
     	pmic_pwrap_write(TOP_CKPDN_SET, RG_ACCDET_CLK_SET);
+   		#endif
+   		#ifdef ACCDET_EINT_IRQ
+   		pmic_pwrap_write(ACCDET_CTRL, pmic_pwrap_read(ACCDET_CTRL)&(~(ACCDET_ENABLE)));
+   		#endif
 	#endif
 	}
 
diff --git a/drivers/misc/mediatek/aee/aed/aed-main.c b/drivers/misc/mediatek/aee/aed/aed-main.c
index f107642..755a41b 100644
--- a/drivers/misc/mediatek/aee/aed/aed-main.c
+++ b/drivers/misc/mediatek/aee/aed/aed-main.c
@@ -47,7 +47,7 @@ static DEFINE_SEMAPHORE(aed_ee_sem);
  *  may be accessed from irq
 */
 static spinlock_t aed_device_lock;
-int aee_mode = AEE_MODE_CUSTOMER_USER;
+int aee_mode = AEE_MODE_NOT_INIT;
 static int force_red_screen = AEE_FORCE_NOT_SET;
 
 static struct proc_dir_entry *aed_proc_dir;
@@ -1720,7 +1720,7 @@ static void kernel_reportAPI(const AE_DEFECT_ATTR attr, const int db_opt, const
 {
 	struct aee_oops *oops;
 	int n = 0;
-	if (aee_mode >= AEE_MODE_CUSTOMER_USER || (aee_mode == AEE_MODE_CUSTOMER_ENG && attr > AE_DEFECT_EXCEPTION))
+	if (aee_mode == AEE_MODE_CUSTOMER_USER || (aee_mode == AEE_MODE_CUSTOMER_ENG && attr == AE_DEFECT_WARNING))
 		return;
 	oops = aee_oops_create(attr, AE_KERNEL_PROBLEM_REPORT, module);
 	if (NULL != oops) {
diff --git a/drivers/misc/mediatek/aee/aed/aed.h b/drivers/misc/mediatek/aee/aed/aed.h
index bbfd8af..6fff1bc 100644
--- a/drivers/misc/mediatek/aee/aed/aed.h
+++ b/drivers/misc/mediatek/aee/aed/aed.h
@@ -24,7 +24,8 @@ typedef enum {
 	AEE_MODE_MTK_ENG = 1,
 	AEE_MODE_MTK_USER,
 	AEE_MODE_CUSTOMER_ENG,
-	AEE_MODE_CUSTOMER_USER
+	AEE_MODE_CUSTOMER_USER,
+    AEE_MODE_NOT_INIT
 } AEE_MODE;
 
 typedef enum {
diff --git a/drivers/misc/mediatek/aee/ipanic/ipanic_rom.c b/drivers/misc/mediatek/aee/ipanic/ipanic_rom.c
index 8165203..c30e51e 100644
--- a/drivers/misc/mediatek/aee/ipanic/ipanic_rom.c
+++ b/drivers/misc/mediatek/aee/ipanic/ipanic_rom.c
@@ -188,11 +188,15 @@ static int ipanic_memory_buffer(void *data, unsigned char *buffer, size_t sz_buf
 
 static int ipanic_alog_buffer(void *data, unsigned char *buffer, size_t sz_buf)
 {
+#ifdef CONFIG_HAVE_XLOG_FEATURE
 	int rc;
 	rc = panic_dump_android_log(buffer, sz_buf, (unsigned long)data);
 	if (rc < 0)
 		rc = -1;
 	return rc;
+#else
+	return -1;
+#endif	
 }
 
 inline int ipanic_func_write(fn_next next, void *data, int off, int total, int encrypt)
@@ -615,7 +619,7 @@ static int ipanic_die(struct notifier_block *self, unsigned long cmd, void *ptr)
 
 	if (aee_rr_curr_exp_type() == 2)
 	/* No return if mrdump is enable */
-		aee_kdump_reboot(AEE_REBOOT_MODE_KERNEL_OOPS, "Kernel Oops");
+		__mrdump_create_oops_dump(AEE_REBOOT_MODE_KERNEL_OOPS, dargs->regs, "Kernel Oops");
 
 	smp_send_stop();
 
diff --git a/drivers/misc/mediatek/aee/mrdump/mrdump_mini.c b/drivers/misc/mediatek/aee/mrdump/mrdump_mini.c
index b69b883..5d489bc 100644
--- a/drivers/misc/mediatek/aee/mrdump/mrdump_mini.c
+++ b/drivers/misc/mediatek/aee/mrdump/mrdump_mini.c
@@ -486,11 +486,13 @@ static void mrdump_mini_build_elf_misc(void)
 	memset(&misc, 0, sizeof(struct mrdump_mini_elf_misc));
 	get_kernel_log_buffer(&misc.vaddr, &misc.size, &misc.start);
 	mrdump_mini_add_misc(misc.vaddr, misc.size, misc.start, "_KERNEL_LOG_");
+	#ifdef CONFIG_HAVE_XLOG_FEATURE
 	for (i = 0; i < 4; i++) {
 		memset(&misc, 0, sizeof(struct mrdump_mini_elf_misc));
 		get_android_log_buffer(&misc.vaddr, &misc.size, &misc.start, i + 1);
 		mrdump_mini_add_misc(misc.vaddr, misc.size, misc.start, log_type[i]);
 	}
+	#endif
 }
 extern raw_spinlock_t logbuf_lock;
 extern unsigned long *stack_trace;
diff --git a/drivers/misc/mediatek/alsps/Makefile b/drivers/misc/mediatek/alsps/Makefile
index c3c316b..d1a759f 100644
--- a/drivers/misc/mediatek/alsps/Makefile
+++ b/drivers/misc/mediatek/alsps/Makefile
@@ -46,11 +46,9 @@ endif
 ifeq ($(CONFIG_MTK_STK3X1X_NEW),y)
 obj-y	+=  stk3x1x-new/
 endif
-
 ifeq ($(CONFIG_MTK_STK3310),y)
 obj-y	+=  stk3310/
 endif
-
 ifeq ($(CONFIG_MTK_RPR410),y)
 obj-y	+=  rpr410/
-endif
+endif
\ No newline at end of file
diff --git a/drivers/misc/mediatek/alsps/alsps.c b/drivers/misc/mediatek/alsps/alsps.c
index 927a06d..03e2f25 100644
--- a/drivers/misc/mediatek/alsps/alsps.c
+++ b/drivers/misc/mediatek/alsps/alsps.c
@@ -392,7 +392,7 @@ static int ps_enable_data(int enable)
     	{
        	ALSPS_LOG("PS enable data\n");
 	   	cxt->is_ps_active_data =true;
-      	cxt->is_ps_first_data_after_enable = true;
+      	 	cxt->is_ps_first_data_after_enable = true;
 	   	cxt->ps_ctl.open_report_data(1);
 		ps_real_enable(enable);
 	   	if(false == cxt->is_ps_polling_run && cxt->is_ps_batch_enable == false)
diff --git a/drivers/misc/mediatek/btif/inc/mtk_btif.h b/drivers/misc/mediatek/btif/inc/mtk_btif.h
index fc4e8f8..999a902 100644
--- a/drivers/misc/mediatek/btif/inc/mtk_btif.h
+++ b/drivers/misc/mediatek/btif/inc/mtk_btif.h
@@ -123,7 +123,7 @@ typedef struct _mtk_btif_register_ {
 
 typedef struct _btif_buf_str_ {
 	unsigned int size;
-	unsigned char buf[BTIF_RX_BUFFER_SIZE];
+	unsigned char *p_buf;
 	/*For Tx: next Tx data pointer to FIFO;
 	For Rx: next read data pointer from BTIF user */
 	unsigned int rd_idx;
@@ -178,7 +178,7 @@ typedef struct _btif_log_queue_t_ {
 	unsigned int out;
 	unsigned int size;
 	spinlock_t lock;
-	BTIF_LOG_BUF_T queue[BTIF_LOG_ENTRY_NUM];
+	P_BTIF_LOG_BUF_T p_queue[BTIF_LOG_ENTRY_NUM];
 } BTIF_LOG_QUEUE_T, *P_BTIF_LOG_QUEUE_T;
 
 /*---------------------------------------------------------------------------*/
@@ -286,7 +286,7 @@ typedef struct _mtk_btif_user_ {
 } mtk_btif_user, *p_mtk_btif_user;
 
 /*---------------------------------------------------------------------------*/
-#define BBS_PTR(ptr, idx) (&((ptr)->buf[idx]))
+#define BBS_PTR(ptr, idx) ((ptr->p_buf) + idx)
 
 #define BBS_SIZE(ptr) ((ptr)->size)
 #define BBS_MASK(ptr) (BBS_SIZE(ptr) - 1)
diff --git a/drivers/misc/mediatek/btif/mtk_btif.c b/drivers/misc/mediatek/btif/mtk_btif.c
index 0096145..8918a16 100644
--- a/drivers/misc/mediatek/btif/mtk_btif.c
+++ b/drivers/misc/mediatek/btif/mtk_btif.c
@@ -1042,7 +1042,7 @@ unsigned int btif_dma_rx_data_receiver(P_MTK_DMA_INFO_STR p_dma_info,
 	_btif_dump_memory("<DMA Rx>", p_buf, buf_len);
 #endif
 
-	btif_bbs_write(&p_btif->btif_buf, p_buf, buf_len);
+	btif_bbs_write(&(p_btif->btif_buf), p_buf, buf_len);
 /*save DMA Rx packet here*/
 	if (0 < buf_len)
 		btif_log_buf_dmp_in(&p_btif->rx_log, p_buf, buf_len);
@@ -1060,7 +1060,7 @@ unsigned int btif_pio_rx_data_receiver(P_MTK_BTIF_INFO_STR p_btif_info,
 #if 0
 	_btif_dump_memory("<PIO Rx>", p_buf, buf_len);
 #endif
-	btif_bbs_write(&p_btif->btif_buf, p_buf, buf_len);
+	btif_bbs_write(&(p_btif->btif_buf), p_buf, buf_len);
 
 /*save PIO Rx packet here*/
 	if (0 < buf_len)
@@ -1077,7 +1077,7 @@ bool btif_parser_wmt_evt(p_mtk_btif p_btif,
 	unsigned int copy_cnt = 0;
 	char *local_buf = NULL;
 	bool b_ret = false;
-	p_btif_buf_str p_bbs = &p_btif->btif_buf;
+	p_btif_buf_str p_bbs = &(p_btif->btif_buf);
 	unsigned int wr_idx = p_bbs->wr_idx;
 	unsigned int rd_idx = p_bbs->rd_idx;
 	
@@ -2543,7 +2543,7 @@ unsigned int btif_bbs_read(p_btif_buf_str p_bbs,
 			} else {
 				memcpy(p_buf, BBS_PTR(p_bbs, p_bbs->rd_idx), tail_len);
 				memcpy(p_buf + tail_len,
-				       &(p_bbs)->buf[0], rd_len - tail_len);
+				       &(p_bbs)->p_buf, rd_len - tail_len);
 				(p_bbs)->rd_idx = rd_len - tail_len;
 			}
 		}
@@ -2563,8 +2563,8 @@ unsigned int btif_bbs_wr_direct(p_btif_buf_str p_bbs,
 
 	l = min(tail_len, buf_len);
 
-	memcpy(&p_bbs->buf[tmp_wr_idx & BBS_MASK(p_bbs)], p_buf, l);
-	memcpy(&p_bbs->buf[0], p_buf + l, buf_len - l);
+	memcpy((p_bbs->p_buf) + (tmp_wr_idx & BBS_MASK(p_bbs)), p_buf, l);
+	memcpy(p_bbs->p_buf, p_buf + l, buf_len - l);
 
 	dsb();
 
@@ -2852,7 +2852,7 @@ int btif_log_buf_dmp_in(P_BTIF_LOG_QUEUE_T p_log_que, const char *p_buf,
 	spin_lock_irqsave(&(p_log_que->lock), flags);
 
 /*get next log buffer for record usage*/
-	p_log_buf = &(p_log_que->queue[p_log_que->in]);
+	p_log_buf = p_log_que->p_queue[0] + p_log_que->in;
 	p_timer = &p_log_buf->timer;
 
 /*log time stamp*/
@@ -2917,7 +2917,7 @@ int btif_log_buf_dmp_out(P_BTIF_LOG_QUEUE_T p_log_que)
 
 	if (0 != dump_size) {
 		while (dump_size--) {
-			p_log_buf = &p_log_que->queue[out_index];
+			p_log_buf = p_log_que->p_queue[0] + out_index;
 
 			len = p_log_buf->len;
 			p_buf = p_log_buf->buffer;
@@ -3002,7 +3002,7 @@ int btif_log_buf_reset(P_BTIF_LOG_QUEUE_T p_log_que)
 	p_log_que->out = 0;
 	p_log_que->size = 0;
 	p_log_que->enable = true;
-	memset(p_log_que->queue, 0, sizeof(p_log_que->queue));
+	memset((p_log_que->p_queue[0]), 0, sizeof(BTIF_LOG_BUF_T));
 
 	spin_unlock_irqrestore(&p_log_que->lock, flags);
 	BTIF_INFO_FUNC("reset %s log buffer\n",
@@ -3020,7 +3020,8 @@ int btif_log_buf_init(p_mtk_btif p_btif)
 	p_btif->tx_log.output_flag = false;
 	p_btif->tx_log.enable = true;
 	spin_lock_init(&(p_btif->tx_log.lock));
-	memset(p_btif->tx_log.queue, 0, sizeof(p_btif->tx_log.queue));
+	BTIF_DBG_FUNC("tx_log.p_queue:0x%p\n", p_btif->tx_log.p_queue[0]);
+	memset((p_btif->tx_log.p_queue[0]), 0, sizeof(BTIF_LOG_BUF_T));
 
 /*rx log buffer init*/
 	p_btif->rx_log.dir = BTIF_RX;
@@ -3030,7 +3031,8 @@ int btif_log_buf_init(p_mtk_btif p_btif)
 	p_btif->rx_log.output_flag = false;
 	p_btif->rx_log.enable = true;
 	spin_lock_init(&(p_btif->rx_log.lock));
-	memset(p_btif->rx_log.queue, 0, sizeof(p_btif->rx_log.queue));
+	BTIF_DBG_FUNC("rx_log.p_queue:0x%p\n", p_btif->rx_log.p_queue[0]);
+	memset((p_btif->rx_log.p_queue[0]), 0, sizeof(BTIF_LOG_BUF_T));
 
 	return 0;
 }
@@ -3063,7 +3065,10 @@ static int BTIF_init(void)
 	int index = 0;
 	p_mtk_btif_dma p_tx_dma = NULL;
 	p_mtk_btif_dma p_rx_dma = NULL;
-
+	unsigned char *p_btif_buffer = NULL;
+	unsigned char *p_tx_queue = NULL;
+	unsigned char *p_rx_queue = NULL;
+	
 	BTIF_DBG_FUNC("++\n");
 
 /*Platform Driver initialization*/
@@ -3083,6 +3088,25 @@ static int BTIF_init(void)
 
 /*SW init*/
 	for (index = 0; index < BTIF_PORT_NR; index++) {
+		p_btif_buffer = (char *) vmalloc(BTIF_RX_BUFFER_SIZE);
+		if (!p_btif_buffer) {
+			BTIF_ERR_FUNC("vmalloc memory fail\n");
+			return false;
+		} else
+			BTIF_INFO_FUNC("p_btif_buffer get memory 0x%p\n", p_btif_buffer);
+		p_tx_queue = (char *) vmalloc(BTIF_LOG_ENTRY_NUM * sizeof(BTIF_LOG_BUF_T));
+		if (!p_tx_queue) {
+			BTIF_ERR_FUNC("vmalloc memory fail\n");
+			return false;
+		} else
+			BTIF_INFO_FUNC("p_tx_queue get memory 0x%p\n", p_tx_queue);
+		p_rx_queue = (char *) vmalloc(BTIF_LOG_ENTRY_NUM * sizeof(BTIF_LOG_BUF_T));
+		if (!p_rx_queue) {
+			BTIF_ERR_FUNC("vmalloc memory fail\n");
+			return false;
+		} else
+			BTIF_INFO_FUNC("p_rx_queue get memory 0x%p\n", p_rx_queue);
+
 		INIT_LIST_HEAD(&(g_btif[index].user_list));
 		BBS_INIT(&(g_btif[index].btif_buf));
 		g_btif[index].enable = false;
@@ -3096,6 +3120,9 @@ static int BTIF_init(void)
 		g_btif[index].lpbk_flag = false;
 		g_btif[index].rx_cb = NULL;
 		g_btif[index].rx_notify = NULL;
+		g_btif[index].btif_buf.p_buf = p_btif_buffer;
+		g_btif[index].tx_log.p_queue[0] = (P_BTIF_LOG_BUF_T) p_tx_queue;
+		g_btif[index].rx_log.p_queue[0] = (P_BTIF_LOG_BUF_T) p_rx_queue;
 		btif_log_buf_init(&g_btif[index]);
 
 #if !(MTK_BTIF_ENABLE_CLK_REF_COUNTER)
diff --git a/drivers/misc/mediatek/cmdq/cmdq_core.c b/drivers/misc/mediatek/cmdq/cmdq_core.c
index 674f878..1be5d7a 100644
--- a/drivers/misc/mediatek/cmdq/cmdq_core.c
+++ b/drivers/misc/mediatek/cmdq/cmdq_core.c
@@ -1216,11 +1216,6 @@ void cmdq_core_reset_thread_struct(void)
 	for (index = 0; index < CMDQ_MAX_THREAD_COUNT; index++) {
 		pThread[index].allowDispatching = 1;
 	}
-
-	/* Initialize work queue per thread */
-	for (index = 0; index < CMDQ_MAX_THREAD_COUNT; index++) {
-		gCmdqContext.thread[index].taskThreadAutoReleaseWQ = create_singlethread_workqueue("cmdq_auto_release_thread");
-	}
 }
 
 int32_t cmdqCoreInitialize(void)
@@ -1267,6 +1262,11 @@ int32_t cmdqCoreInitialize(void)
 	gCmdqContext.taskAutoReleaseWQ = create_singlethread_workqueue("cmdq_auto_release");
 	gCmdqContext.taskConsumeWQ = create_singlethread_workqueue("cmdq_task");
 
+	/* Initialize work queue per thread */
+	for (index = 0; index < CMDQ_MAX_THREAD_COUNT; index++) {
+		gCmdqContext.thread[index].taskThreadAutoReleaseWQ = create_singlethread_workqueue("cmdq_auto_release_thread");
+	}
+
 #ifdef CMDQ_DUMP_FIRSTERROR
 	/* Reset overall first error dump */
 	memset(&gCmdqDumpFirstError, 0x0, sizeof(DumpFirstErrorStruct));
@@ -4758,7 +4758,7 @@ DEBUG_STATIC int32_t cmdq_core_exec_task_async_secure_impl(TaskStruct *pTask, in
 
 	do {
 		/* setup whole patah */
-		status = cmdq_sec_allocate_path_resource_unlocked();
+		status = cmdq_sec_allocate_path_resource_unlocked(true);
 		if (0 > status) {
 			break;
 		}
@@ -5106,15 +5106,9 @@ DEBUG_STATIC void cmdq_core_handle_done_with_cookie_impl(int32_t thread,
 
 	if (pThread->waitCookie <= cookie) {
 		count = cookie - pThread->waitCookie + 1;
-	} else if ((cookie+1) % CMDQ_MAX_COOKIE_VALUE == pThread->waitCookie) {
-		count = 0;
-		CMDQ_MSG("IRQ: duplicated cookie: waitCookie:%d, hwCookie:%d", 
-			pThread->waitCookie, cookie);
 	} else {
 		/* Counter wrapped */
 		count = (CMDQ_MAX_COOKIE_VALUE - pThread->waitCookie + 1) + (cookie + 1);
-		CMDQ_ERR("IRQ: counter wrapped: waitCookie:%d, hwCookie:%d, count=%d", 
-			pThread->waitCookie, cookie, count);
 	}
 
 	for (inner = (pThread->waitCookie % CMDQ_MAX_TASK_IN_THREAD); count > 0; count--, inner++) {
@@ -5284,15 +5278,9 @@ DEBUG_STATIC void cmdqCoreHandleError(int32_t thread, int32_t value, CMDQ_TIME *
 	/* Set the remain tasks to done state */
 	if (pThread->waitCookie <= cookie) {
 		count = cookie - pThread->waitCookie + 1;
-	} else if ((cookie+1) % CMDQ_MAX_COOKIE_VALUE == pThread->waitCookie) {
-		count = 0;
-		CMDQ_MSG("IRQ: duplicated cookie: waitCookie:%d, hwCookie:%d", 
-			pThread->waitCookie, cookie);
 	} else {
 		/* Counter wrapped */
 		count = (CMDQ_MAX_COOKIE_VALUE - pThread->waitCookie + 1) + (cookie + 1);
-		CMDQ_ERR("IRQ: counter wrapped: waitCookie:%d, hwCookie:%d, count=%d", 
-			pThread->waitCookie, cookie, count);
 	}
 
 	for (inner = (pThread->waitCookie % CMDQ_MAX_TASK_IN_THREAD); count > 0; count--, inner++) {
diff --git a/drivers/misc/mediatek/cmdq/cmdq_sec.c b/drivers/misc/mediatek/cmdq/cmdq_sec.c
index 7f572c1..a4a3a1b 100644
--- a/drivers/misc/mediatek/cmdq/cmdq_sec.c
+++ b/drivers/misc/mediatek/cmdq/cmdq_sec.c
@@ -206,26 +206,29 @@ int32_t cmdq_sec_init_session_unlocked(const struct mc_uuid_t *uuid,
 
 		CMDQ_PROF_START("CMDQ_SEC_INIT");
 
-		/* open mobicore device */
-		openRet = cmdq_sec_open_mobicore_impl(deviceId);
-		if (-EEXIST == openRet) {
-			/* mobicore has been opened in this process context */
-			/* it is a ok case, so continue to execute */
-			status = 0;
-			(*openMobicoreByOther) = 1;
-		} else if (0 > openRet) {
-			status = -1;
-			break;
+		if (IWC_MOBICORE_OPENED > (*pIwcState)) {
+			/* open mobicore device */
+			openRet = cmdq_sec_open_mobicore_impl(deviceId);
+			if (-EEXIST == openRet) {
+				/* mobicore has been opened in this process context */
+				/* it is a ok case, so continue to execute */
+				status = 0;
+				(*openMobicoreByOther) = 1;
+			} else if (0 > openRet) {
+				status = -1;
+				break;
+			}
+			(*pIwcState) = IWC_MOBICORE_OPENED;
 		}
-		(*pIwcState) = IWC_MOBICORE_OPENED;
 
-
-		/* allocate world shared memory */
-		if (0 > cmdq_sec_allocate_wsm_impl(deviceId, ppWsm, wsmSize)) {
-			status = -1;
-			break;
+		if (IWC_WSM_ALLOCATED > (*pIwcState)) {
+			/* allocate world shared memory */
+			if (0 > cmdq_sec_allocate_wsm_impl(deviceId, ppWsm, wsmSize)) {
+				status = -1;
+				break;
+			}
+			(*pIwcState) = IWC_WSM_ALLOCATED;
 		}
-		(*pIwcState) = IWC_WSM_ALLOCATED;
 
 		/* open a secure session */
 		if (0 >
@@ -644,7 +647,7 @@ void cmdq_sec_track_task_record(const uint32_t iwcCommand,
 }
 
 int32_t cmdq_sec_submit_to_secure_world_async_unlocked(uint32_t iwcCommand,
-				TaskStruct *pTask, int32_t thread, CmdqSecFillIwcCB iwcFillCB, void *data)
+				TaskStruct *pTask, int32_t thread, CmdqSecFillIwcCB iwcFillCB, void *data, bool throwAEE)
 {
 	const int32_t tgid = current->tgid;
 	const int32_t pid = current->pid;
@@ -701,9 +704,14 @@ int32_t cmdq_sec_submit_to_secure_world_async_unlocked(uint32_t iwcCommand,
 	if (-ETIMEDOUT == status) {
 		/* t-base strange issue, mc_wait_notification false timeout when secure world has done */
 		/* becuase retry may failed, give up retry method */
-		CMDQ_AEE("CMDQ",
-			"[SEC]<--SEC_SUBMIT: err[%d][mc_wait_notification timeout], pTask[0x%p], THR[%d], tgid[%d:%d], config_duration_ms[%d], cmdId[%d]\n",
-			 status, pTask, thread, tgid, pid, duration, iwcCommand);
+		if(throwAEE){
+			CMDQ_AEE("CMDQ",
+				"[SEC]<--SEC_SUBMIT: err[%d][mc_wait_notification timeout], pTask[0x%p], THR[%d], tgid[%d:%d], config_duration_ms[%d], cmdId[%d]\n",
+				 status, pTask, thread, tgid, pid, duration, iwcCommand);
+		}else{
+			CMDQ_ERR("[SEC]<--SEC_SUBMIT: err[%d][mc_wait_notification timeout], pTask[0x%p], THR[%d], tgid[%d:%d], config_duration_ms[%d], cmdId[%d]\n",
+				 status, pTask, thread, tgid, pid, duration, iwcCommand);
+		}
 
 	} else if (0 > status) {
 		/* dump metadata first */
@@ -711,10 +719,16 @@ int32_t cmdq_sec_submit_to_secure_world_async_unlocked(uint32_t iwcCommand,
 			cmdq_core_dump_secure_metadata(&(pTask->secData));
 		}
 
-		/* throw AEE */
-		CMDQ_AEE("CMDQ",
-			 "[SEC]<--SEC_SUBMIT: err[%d], pTask[0x%p], THR[%d], tgid[%d:%d], config_duration_ms[%d], cmdId[%d]\n",
-			 status, pTask, thread, tgid, pid, duration, iwcCommand);
+		if(throwAEE){
+			/* throw AEE */
+			CMDQ_AEE("CMDQ",
+				 "[SEC]<--SEC_SUBMIT: err[%d], pTask[0x%p], THR[%d], tgid[%d:%d], config_duration_ms[%d], cmdId[%d]\n",
+				 status, pTask, thread, tgid, pid, duration, iwcCommand);
+		}else{
+			/* no throw AEE */
+			CMDQ_ERR("[SEC]<--SEC_SUBMIT: err[%d], pTask[0x%p], THR[%d], tgid[%d:%d], config_duration_ms[%d], cmdId[%d]\n",
+				 status, pTask, thread, tgid, pid, duration, iwcCommand);
+		}
 	} else {
 		CMDQ_LOG
 		    ("[SEC]<--SEC_SUBMIT: err[%d], pTask[0x%p], THR[%d], tgid[%d:%d], config_duration_ms[%d], cmdId[%d]\n",
@@ -729,7 +743,7 @@ int32_t cmdq_sec_init_allocate_resource_thread(void *data)
 
 	cmdq_sec_lock_secure_path();
 
-	status = cmdq_sec_allocate_path_resource_unlocked();
+	status = cmdq_sec_allocate_path_resource_unlocked(false);
 	
 	cmdq_sec_unlock_secure_path();
 	
@@ -785,7 +799,7 @@ static int cmdq_sec_sectrace_map(void *va, size_t size)
 	do {
 		/* HACK: submit a dummy message to ensure secure path init done */
 		status = cmdq_sec_submit_to_secure_world_async_unlocked(
-			CMD_CMDQ_TL_TEST_HELLO_TL, NULL, CMDQ_INVALID_THREAD, NULL, NULL);
+			CMD_CMDQ_TL_TEST_HELLO_TL, NULL, CMDQ_INVALID_THREAD, NULL, NULL, true);
 
 		/* map log buffer in NWd */
 		mcRet = mc_map(&(gCmdqSecContextHandle->sessionHandle),
@@ -806,7 +820,7 @@ static int cmdq_sec_sectrace_map(void *va, size_t size)
 					CMD_CMDQ_TL_SECTRACE_MAP,
 					NULL, CMDQ_INVALID_THREAD,
 					cmdq_sec_fill_iwc_command_sectrace_unlocked,
-					NULL);
+					NULL, true);
 		if(0 > status) {
 			CMDQ_ERR("[sectrace]map: failed in SWd: %d\n", status);
 			mc_unmap(&(gCmdqSecContextHandle->sessionHandle), va, &gCmdqSectraceMappedInfo);
@@ -840,7 +854,7 @@ static int cmdq_sec_sectrace_unmap(void *va, size_t size)
 					CMD_CMDQ_TL_SECTRACE_UNMAP,
 					NULL, CMDQ_INVALID_THREAD,
 					cmdq_sec_fill_iwc_command_sectrace_unlocked,
-					NULL);
+					NULL, true);
 		if(0 > status) {
 			CMDQ_ERR("[sectrace]unmap: failed in SWd: %d\n", status);
 			mc_unmap(&(gCmdqSecContextHandle->sessionHandle), va, &gCmdqSectraceMappedInfo);
@@ -868,7 +882,7 @@ static int cmdq_sec_sectrace_transact(void)
 	status = cmdq_sec_submit_to_secure_world_async_unlocked(
 				CMD_CMDQ_TL_SECTRACE_TRANSACT,
 				NULL, CMDQ_INVALID_THREAD,
-				cmdq_sec_fill_iwc_command_sectrace_unlocked, NULL);
+				cmdq_sec_fill_iwc_command_sectrace_unlocked, NULL, true);
 
 	CMDQ_LOG("[sectrace]<--transact: status: %d\n", status);
 
@@ -970,7 +984,7 @@ int32_t cmdq_sec_exec_task_async_unlocked(TaskStruct *pTask, int32_t thread)
 	int32_t status = 0;
 
 	status = cmdq_sec_submit_to_secure_world_async_unlocked(
-				CMD_CMDQ_TL_SUBMIT_TASK, pTask, thread, NULL, NULL);
+				CMD_CMDQ_TL_SUBMIT_TASK, pTask, thread, NULL, NULL, true);
 	if (0 > status) {
 		CMDQ_ERR("%s[%d]\n", __func__, status);
 	}
@@ -998,7 +1012,7 @@ int32_t cmdq_sec_cancel_error_task_unlocked(TaskStruct *pTask, int32_t thread, c
 	}
 
 	status = cmdq_sec_submit_to_secure_world_async_unlocked(CMD_CMDQ_TL_CANCEL_TASK,
-		pTask, thread, NULL ,(void*)pResult);
+		pTask, thread, NULL ,(void*)pResult, true);
 	return status;
 #else
 	CMDQ_ERR("secure path not support\n");
@@ -1010,7 +1024,7 @@ int32_t cmdq_sec_cancel_error_task_unlocked(TaskStruct *pTask, int32_t thread, c
 static atomic_t gCmdqSecPathResource = ATOMIC_INIT(0);
 #endif
 
-int32_t cmdq_sec_allocate_path_resource_unlocked(void)
+int32_t cmdq_sec_allocate_path_resource_unlocked(bool throwAEE)
 {
 #ifdef CMDQ_SECURE_PATH_SUPPORT
 	int32_t status = 0;
@@ -1021,7 +1035,7 @@ int32_t cmdq_sec_allocate_path_resource_unlocked(void)
 	}
 
 	status = cmdq_sec_submit_to_secure_world_async_unlocked(
-				CMD_CMDQ_TL_PATH_RES_ALLOCATE, NULL, CMDQ_INVALID_THREAD, NULL, NULL);
+				CMD_CMDQ_TL_PATH_RES_ALLOCATE, NULL, CMDQ_INVALID_THREAD, NULL, NULL, throwAEE);
 	if (0 > status) {
 		CMDQ_ERR("%s[%d]\n", __func__, status);
 	} else {
diff --git a/drivers/misc/mediatek/cmdq/cmdq_sec.h b/drivers/misc/mediatek/cmdq/cmdq_sec.h
index 8a126cf..c9c6072 100644
--- a/drivers/misc/mediatek/cmdq/cmdq_sec.h
+++ b/drivers/misc/mediatek/cmdq/cmdq_sec.h
@@ -87,7 +87,7 @@ typedef int32_t(*CmdqSecFillIwcCB) (int32_t, void *, int32_t, void *);
 
 int32_t cmdq_sec_exec_task_async_unlocked(TaskStruct *pTask, int32_t thread);
 int32_t cmdq_sec_cancel_error_task_unlocked(TaskStruct *pTask, int32_t thread, cmdqSecCancelTaskResultStruct *pResult);
-int32_t cmdq_sec_allocate_path_resource_unlocked(void);
+int32_t cmdq_sec_allocate_path_resource_unlocked(bool throwAEE);
 
 
 /**
diff --git a/drivers/misc/mediatek/conn_md/conn_md_log.c b/drivers/misc/mediatek/conn_md/conn_md_log.c
index 2909e25..a080f0c 100644
--- a/drivers/misc/mediatek/conn_md/conn_md_log.c
+++ b/drivers/misc/mediatek/conn_md/conn_md_log.c
@@ -1,7 +1,7 @@
 #include "conn_md_log.h"
 
 
-int g_conn_md_dbg_lvl = CONN_MD_LOG_DBG;	/* CONN_MD_LOG_INFO; */
+int g_conn_md_dbg_lvl = CONN_MD_LOG_INFO;
 
 
 /*Log defination*/
diff --git a/drivers/misc/mediatek/connectivity/combo/common/core/include/wmt_lib.h b/drivers/misc/mediatek/connectivity/combo/common/core/include/wmt_lib.h
index c96b208..21db3c2 100644
--- a/drivers/misc/mediatek/connectivity/combo/common/core/include/wmt_lib.h
+++ b/drivers/misc/mediatek/connectivity/combo/common/core/include/wmt_lib.h
@@ -159,6 +159,7 @@ typedef struct {
 typedef struct _DEV_WMT_ {
 
 	OSAL_SLEEPABLE_LOCK psm_lock;
+	OSAL_SLEEPABLE_LOCK idc_lock;
 	/* WMTd thread information */
 /* struct task_struct *pWmtd;  */ /* main thread (wmtd) handle */
 	OSAL_THREAD thread;
@@ -292,6 +293,8 @@ extern VOID ENABLE_PSM_MONITOR(VOID);
 extern INT32 wmt_lib_notify_stp_sleep(VOID);
 extern VOID wmt_lib_psm_lock_release(VOID);
 extern INT32 wmt_lib_psm_lock_aquire(VOID);
+extern VOID wmt_lib_idc_lock_release(VOID);
+extern INT32 wmt_lib_idc_lock_aquire(VOID);
 extern INT32 wmt_lib_set_stp_wmt_last_close(UINT32 value);
 
 extern VOID wmt_lib_set_patch_num(unsigned long num);
diff --git a/drivers/misc/mediatek/connectivity/combo/common/core/wmt_core.c b/drivers/misc/mediatek/connectivity/combo/common/core/wmt_core.c
index 37fecf7..28cb073 100644
--- a/drivers/misc/mediatek/connectivity/combo/common/core/wmt_core.c
+++ b/drivers/misc/mediatek/connectivity/combo/common/core/wmt_core.c
@@ -2409,7 +2409,7 @@ static INT32 opfunc_idc_msg_handling(P_WMT_OP pWmtOp)
 	UINT32 u4Res;
 	UINT8 host_lte_btwf_coex_cmd[] = { 0x01, 0x10, 0x00, 0x00, 0x00 };
 	UINT8 host_lte_btwf_coex_evt[] = { 0x02, 0x10, 0x01, 0x00, 0x00 };
-	ipc_ilm_t *pTxBuf = NULL;
+	UINT8 *pTxBuf = NULL;
 	UINT8 msg_local_buffer[1300] = { 0 };
 	UINT8 evtbuf[8] = { 0 };
 	INT32 iRet = -1;
@@ -2417,13 +2417,20 @@ static INT32 opfunc_idc_msg_handling(P_WMT_OP pWmtOp)
 	UINT32 total_len = 0;
 	UINT32 index = 0;
 
-	pTxBuf = (ipc_ilm_t *) pWmtOp->au4OpData[0];
+	pTxBuf = (UINT8 *) pWmtOp->au4OpData[0];
 	if (NULL == pTxBuf) {
 		WMT_ERR_FUNC("idc msg buffer is NULL\n");
 		return -1;
 	} else {
-		msg_len = pTxBuf->local_para_ptr->msg_len - osal_sizeof(local_para_struct);
+		iRet = wmt_lib_idc_lock_aquire();
+		if (iRet) {
+			WMT_ERR_FUNC("--->lock idc_lock failed, ret=%d\n", iRet);
+			return iRet;
+		}
+
+		osal_memcpy(&msg_len, &pTxBuf[0], osal_sizeof(msg_len));
 		if (msg_len > 1200) {
+			wmt_lib_idc_lock_release();
 			WMT_ERR_FUNC("abnormal idc msg len:%d\n", msg_len);
 			return -2;
 		}
@@ -2434,7 +2441,9 @@ static INT32 opfunc_idc_msg_handling(P_WMT_OP pWmtOp)
 		osal_memcpy(&msg_local_buffer[0], &host_lte_btwf_coex_cmd[0],
 			    osal_sizeof(host_lte_btwf_coex_cmd));
 		osal_memcpy(&msg_local_buffer[osal_sizeof(host_lte_btwf_coex_cmd)],
-			    &(pTxBuf->local_para_ptr->data[0]), msg_len - 1);
+			    &pTxBuf[osal_sizeof(msg_len)], msg_len - 1);
+
+		wmt_lib_idc_lock_release();
 
 		total_len = osal_sizeof(host_lte_btwf_coex_cmd) + msg_len - 1;
 
diff --git a/drivers/misc/mediatek/connectivity/combo/common/core/wmt_lib.c b/drivers/misc/mediatek/connectivity/combo/common/core/wmt_lib.c
index dbd5192..e114ebd 100644
--- a/drivers/misc/mediatek/connectivity/combo/common/core/wmt_lib.c
+++ b/drivers/misc/mediatek/connectivity/combo/common/core/wmt_lib.c
@@ -114,6 +114,16 @@ MTK_WCN_BOOL wmt_lib_hw_state_show(VOID);
 ********************************************************************************
 */
 
+INT32 wmt_lib_idc_lock_aquire(VOID)
+{
+	return osal_lock_sleepable_lock(&gDevWmt.idc_lock);
+}
+
+VOID wmt_lib_idc_lock_release(VOID)
+{
+	osal_unlock_sleepable_lock(&gDevWmt.idc_lock);
+}
+
 INT32 wmt_lib_psm_lock_aquire(VOID)
 {
 	return osal_lock_sleepable_lock(&gDevWmt.psm_lock);
@@ -195,6 +205,7 @@ INT32 wmt_lib_init(VOID)
 	/* Initialize WMTd Thread Information: Thread */
 	osal_event_init(&pDevWmt->rWmtdWq);
 	osal_sleepable_lock_init(&pDevWmt->psm_lock);
+	osal_sleepable_lock_init(&pDevWmt->idc_lock);
 	osal_sleepable_lock_init(&pDevWmt->rActiveOpQ.sLock);
 	osal_sleepable_lock_init(&pDevWmt->rFreeOpQ.sLock);
 	pDevWmt->state.data = 0;
@@ -332,6 +343,7 @@ INT32 wmt_lib_deinit(VOID)
 
 	osal_sleepable_lock_deinit(&pDevWmt->rFreeOpQ.sLock);
 	osal_sleepable_lock_deinit(&pDevWmt->rActiveOpQ.sLock);
+	osal_sleepable_lock_deinit(&pDevWmt->idc_lock);
 	osal_sleepable_lock_deinit(&pDevWmt->psm_lock);
 	osal_event_deinit(&pDevWmt->rWmtdWq);
 
@@ -535,11 +547,26 @@ MTK_WCN_BOOL wmt_lib_handle_idc_msg(ipc_ilm_t *idc_infor)
 	P_OSAL_OP lxop;
 	MTK_WCN_BOOL bRet = MTK_WCN_BOOL_FALSE;
 	P_OSAL_SIGNAL pSignal;
+	INT32 ret = 0;
+	UINT16 msg_len = 0;
+	static UINT8 msg_local_buffer[1300];
+
 #if	CFG_WMT_LTE_ENABLE_MSGID_MAPPING
 	MTK_WCN_BOOL unknow_msgid = MTK_WCN_BOOL_FALSE;
 #endif
 	WMT_INFO_FUNC("idc_infor from conn_md is 0x%p\n", idc_infor);
 
+	ret = wmt_lib_idc_lock_aquire();
+	if (ret) {
+		WMT_ERR_FUNC("--->lock idc_lock failed, ret=%d\n", ret);
+		return MTK_WCN_BOOL_FALSE;
+	}
+	msg_len = idc_infor->local_para_ptr->msg_len - osal_sizeof(local_para_struct);
+	osal_memcpy(&msg_local_buffer[0], &msg_len, osal_sizeof(msg_len));
+	osal_memcpy(&msg_local_buffer[osal_sizeof(msg_len)],
+			&(idc_infor->local_para_ptr->data[0]), msg_len - 1);
+	wmt_lib_idc_lock_release();
+
 	lxop = wmt_lib_get_free_op();
 	if (!lxop) {
 		WMT_WARN_FUNC("get_free_lxop fail\n");
@@ -548,7 +575,7 @@ MTK_WCN_BOOL wmt_lib_handle_idc_msg(ipc_ilm_t *idc_infor)
 	pSignal = &lxop->signal;
 	pSignal->timeoutValue = MAX_EACH_WMT_CMD;
 	lxop->op.opId = WMT_OPID_IDC_MSG_HANDLING;
-	lxop->op.au4OpData[0] = (size_t) idc_infor;
+	lxop->op.au4OpData[0] = (size_t) msg_local_buffer;
 
 	/*msg opcode fill rule is still not clrear,need scott comment */
 	/***********************************************************/
diff --git a/drivers/misc/mediatek/connectivity/combo/common/linux/hif_sdio.c b/drivers/misc/mediatek/connectivity/combo/common/linux/hif_sdio.c
index 322ed3e..dfcb8c1 100644
--- a/drivers/misc/mediatek/connectivity/combo/common/linux/hif_sdio.c
+++ b/drivers/misc/mediatek/connectivity/combo/common/linux/hif_sdio.c
@@ -1995,6 +1995,7 @@ INT32 hif_sdio_stp_on(VOID)
 	struct sdio_func *func;
 	UINT32 chip_id = 0;
 	UINT16 func_num = 0;
+	INT32 sdio_autok_flag = 0;
 	const MTK_WCN_HIF_SDIO_FUNCINFO *func_info = NULL;
 
 	HIF_SDIO_INFO_FUNC("start!\n");
@@ -2017,6 +2018,7 @@ INT32 hif_sdio_stp_on(VOID)
 	if ((probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x6630, 2)) >= 0) {
 		chip_id = 0x6630;
 		func_num = 2;
+		sdio_autok_flag = 1;
 		goto stp_on_exist;
 	}
 
@@ -2049,7 +2051,11 @@ INT32 hif_sdio_stp_on(VOID)
 
 	if ((clt_index = g_hif_sdio_probed_func_list[probe_index].clt_idx) >= 0) {	/* the function has been registered */
 
-
+		if (sdio_autok_flag) {
+			_hif_sdio_do_autok(g_hif_sdio_probed_func_list[probe_index].func);
+		} else {
+			HIF_SDIO_INFO_FUNC("sdio_autok_flag is not set\n", ret);
+		}
 		g_hif_sdio_probed_func_list[probe_index].sdio_irq_enabled = MTK_WCN_BOOL_FALSE;
 		/* 4 <4> claim irq for this function */
 		func = g_hif_sdio_probed_func_list[probe_index].func;
diff --git a/drivers/misc/mediatek/connectivity/combo/common/linux/stp_chrdev_bt.c b/drivers/misc/mediatek/connectivity/combo/common/linux/stp_chrdev_bt.c
index 24978f8..42c0ad9 100644
--- a/drivers/misc/mediatek/connectivity/combo/common/linux/stp_chrdev_bt.c
+++ b/drivers/misc/mediatek/connectivity/combo/common/linux/stp_chrdev_bt.c
@@ -28,13 +28,19 @@ MODULE_LICENSE("Dual BSD/GPL");
 #define BT_LOG_WARN                 1
 #define BT_LOG_ERR                  0
 
-#define COMBO_IOC_BT_HWVER           6
-
+#if 0
 #define COMBO_IOC_MAGIC        0xb0
 #define COMBO_IOCTL_FW_ASSERT  _IOWR(COMBO_IOC_MAGIC, 0, void*)
 #define COMBO_IOCTL_BT_IC_HW_VER  _IOWR(COMBO_IOC_MAGIC, 1, int)
 #define COMBO_IOCTL_BT_IC_FW_VER  _IOWR(COMBO_IOC_MAGIC, 2, int)
-
+#define COMBO_IOC_BT_HWVER           6
+#else
+#define COMBO_IOCTL_FW_ASSERT        2
+#define COMBO_IOCTL_BT_IC_HW_VER     3
+#define COMBO_IOCTL_BT_IC_FW_VER     4
+#define COMBO_IOC_BT_HWVER           5
+#define COMBO_IOC_BT_SET_PSM         6
+#endif
 
 static UINT32 gDbgLevel = BT_LOG_INFO;
 
@@ -330,9 +336,9 @@ long BT_unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
 	INT32 retval = 0;
 	MTK_WCN_BOOL bRet = MTK_WCN_BOOL_TRUE;
-
 	ENUM_WMTHWVER_TYPE_T hw_ver_sym = WMTHWVER_INVALID;
-	BT_DBG_FUNC("BT_ioctl(): cmd (%d)\n", cmd);
+	
+	BT_DBG_FUNC("cmd[0x%x]\n", cmd);
 
 	switch (cmd) {
 #if 0
@@ -364,7 +370,7 @@ long BT_unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 			BT_INFO_FUNC("BT Set fw assert OK\n");
 			retval = 0;
 		} else {
-			BT_INFO_FUNC("BT Set fw assert Failed\n");
+			BT_ERR_FUNC("BT Set fw assert Failed\n");
 			retval = (-1000);
 		}
 		break;
@@ -376,13 +382,23 @@ long BT_unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 		break;
 	default:
 		retval = -EFAULT;
-		BT_DBG_FUNC("BT_ioctl(): unknown cmd (%d)\n", cmd);
+		BT_ERR_FUNC("BT_ioctl(): unknown cmd (%d)\n", cmd);
 		break;
 	}
 
 	return retval;
 }
 
+long BT_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	long ret;
+
+	BT_INFO_FUNC("cmd[0x%x]\n", cmd);
+	ret = BT_unlocked_ioctl(filp, cmd, arg);
+	
+	return ret;
+}
+
 static int BT_open(struct inode *inode, struct file *file)
 {
 	BT_INFO_FUNC("%s: major %d minor %d (pid %d)\n", __func__,
@@ -465,8 +481,9 @@ struct file_operations BT_fops = {
 	.release = BT_close,
 	.read = BT_read,
 	.write = BT_write,
-/* .ioctl = BT_ioctl, */
+	/* .ioctl = BT_ioctl, */
 	.unlocked_ioctl = BT_unlocked_ioctl,
+	.compat_ioctl = BT_compat_ioctl,
 	.poll = BT_poll
 };
 
diff --git a/drivers/misc/mediatek/connectivity/combo/common/linux/stp_sdio.c b/drivers/misc/mediatek/connectivity/combo/common/linux/stp_sdio.c
index 31c9341..8b48818 100644
--- a/drivers/misc/mediatek/connectivity/combo/common/linux/stp_sdio.c
+++ b/drivers/misc/mediatek/connectivity/combo/common/linux/stp_sdio.c
@@ -2467,11 +2467,6 @@ stp_sdio_probe(const MTK_WCN_HIF_SDIO_CLTCTX clt_ctx,
 		STPSDIO_ERR_FUNC("osal_thread_create fail...\n");
 		goto out;
 	}
-	ret = osal_thread_run(&g_stp_sdio_host_info.tx_rx_thread);
-	if (ret < 0) {
-		STPSDIO_ERR_FUNC("osal_thread_run fail...\n");
-		goto out;
-	}
 #else
 	/* init tx_tasklet and rx work_queue */
 	INIT_WORK(&g_stp_sdio_host_info.tx_work, stp_sdio_tx_wkr);
@@ -2542,6 +2537,14 @@ using CMD52 write instead of CMD53 write for CCIR, CHLPCR, CSDIOCSR */
 
 	STPSDIO_DBG_FUNC("enable interrupt done\n");
 
+#if STP_SDIO_OWN_THREAD
+	ret = osal_thread_run(&g_stp_sdio_host_info.tx_rx_thread);
+	if (ret < 0) {
+		STPSDIO_ERR_FUNC("osal_thread_run fail...\n");
+		goto out;
+	}
+#endif
+
 	/* 4 <5> register mtk_wcn_stp_if_tx() to stp driver */
 	mtk_wcn_stp_register_if_tx(STP_SDIO_IF_TX, (MTK_WCN_STP_IF_TX)stp_sdio_tx);
 
@@ -2559,6 +2562,9 @@ using CMD52 write instead of CMD53 write for CCIR, CHLPCR, CSDIOCSR */
 	/* 4 <6> error handling */
 	/* TODO: error handling */
 	if (ret) {
+#if STP_SDIO_OWN_THREAD
+		osal_thread_destroy(&g_stp_sdio_host_info.tx_rx_thread);
+#endif
 		--g_stp_sdio_host_count;
 	}
 	return ret;
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/Makefile b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/Makefile
index 5857e53..ac59d0e 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/Makefile
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/Makefile
@@ -18,12 +18,6 @@ else
     ccflags-y += -DCFG_SUPPORT_CHNL_CONFLICT_REVISE=1
 endif
 
-ifeq ($(CONFIG_HAVE_XLOG_FEATURE), y)
-    ccflags-y += -DCFG_SUPPORT_XLOG=1
-else
-    ccflags-y += -DCFG_SUPPORT_XLOG=0
-endif
-
 ifeq ($(CONFIG_HAVE_AEE_FEATURE), y)
     ccflags-y += -DCFG_SUPPORT_AEE=1
 else
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/common/wlan_lib.c b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/common/wlan_lib.c
index 71d864a..5db8fa4 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/common/wlan_lib.c
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/common/wlan_lib.c
@@ -2083,7 +2083,7 @@ WLAN_STATUS wlanProcessCommandQueue(IN P_ADAPTER_T prAdapter, IN P_QUE_T prCmdQu
 
         case COMMAND_TYPE_MANAGEMENT_FRAME:
             /* inquire with QM */
-			prMsduInfo = (P_MSDU_INFO_T) (prCmdInfo->prPacket);
+			prMsduInfo = prCmdInfo->prMsduInfo;
 
             eFrameAction = qmGetFrameAction(prAdapter, prMsduInfo->ucBssIndex,
                     prMsduInfo->ucStaRecIndex, prMsduInfo, FRAME_TYPE_MMPDU, 
@@ -2723,25 +2723,27 @@ wlanReleaseCommand(IN P_ADAPTER_T prAdapter,
         break;
 
     case COMMAND_TYPE_SECURITY_FRAME:
-        DBGLOG(INIT, INFO, ("Free SEC Frame: BSS[%u] StaRec[%u] SeqNum[%u]\n",
-            prCmdInfo->ucBssIndex,
-            prCmdInfo->ucStaRecIndex,
-            prCmdInfo->ucCmdSeqNum));
+    case COMMAND_TYPE_MANAGEMENT_FRAME:
+		prMsduInfo = prCmdInfo->prMsduInfo;
 
-        kalSecurityFrameSendComplete(prAdapter->prGlueInfo,
-					     prCmdInfo->prPacket, WLAN_STATUS_FAILURE);
-        break;
+        if(prCmdInfo->eCmdType == COMMAND_TYPE_SECURITY_FRAME) {
+            kalSecurityFrameSendComplete(prAdapter->prGlueInfo,
+                prCmdInfo->prPacket, WLAN_STATUS_FAILURE);
 
-    case COMMAND_TYPE_MANAGEMENT_FRAME:
-		prMsduInfo = (P_MSDU_INFO_T) prCmdInfo->prPacket;
+            /* Avoid skb multiple free */
+            prMsduInfo->prPacket = NULL;
+        }
 
-        DBGLOG(INIT, INFO, ("Free MGMT Frame: BSS[%u] WIDX:PID[%u:%u] SEQ[%u] STA[%u] RSP[%u]\n",
+        DBGLOG(INIT, INFO, ("Free %s Frame: BSS[%u] WIDX:PID[%u:%u] SEQ[%u] " 
+            "STA[%u] RSP[%u] CMDSeq[%u]\n",
+            prCmdInfo->eCmdType == COMMAND_TYPE_SECURITY_FRAME?"SEC":"MGMT",
             prMsduInfo->ucBssIndex,
             prMsduInfo->ucWlanIndex,
             prMsduInfo->ucPID,
             prMsduInfo->ucTxSeqNum,
             prMsduInfo->ucStaRecIndex,
-            prMsduInfo->pfTxDoneHandler ? TRUE:FALSE));  
+            prMsduInfo->pfTxDoneHandler ? TRUE:FALSE, 
+            prCmdInfo->ucCmdSeqNum));
 
         /* invoke callbacks */
 		if (prMsduInfo->pfTxDoneHandler != NULL) {
@@ -4230,6 +4232,40 @@ BOOLEAN wlanProcessTxFrame(IN P_ADAPTER_T prAdapter, IN P_NATIVE_PACKET prPacket
         /* Save the value of Priority Parameter */
 		GLUE_SET_PKT_TID(prPacket, rTxPacketInfo.ucPriorityParam);
 
+#if 1
+        if(rTxPacketInfo.u2Flag) {
+    		if (rTxPacketInfo.u2Flag & BIT(ENUM_PKT_1X)) {
+                P_STA_RECORD_T          prStaRec;
+
+    			DBGLOG(RSN, INFO, ("T1X len=%d\n", rTxPacketInfo.u4PacketLen));
+
+    			prStaRec = cnmGetStaRecByAddress(prAdapter, 
+                    GLUE_GET_PKT_BSS_IDX(prPacket), rTxPacketInfo.aucEthDestAddr);
+
+                GLUE_SET_PKT_FLAG(prPacket, ENUM_PKT_1X);
+                
+    			if (secIsProtected1xFrame(prAdapter, prStaRec)) {
+                    GLUE_SET_PKT_FLAG(prPacket, ENUM_PKT_PROTECTED_1X);
+                }
+            }
+
+    		if (rTxPacketInfo.u2Flag & BIT(ENUM_PKT_802_3)) {
+                GLUE_SET_PKT_FLAG(prPacket, ENUM_PKT_802_3);
+            }
+
+    		if (rTxPacketInfo.u2Flag & BIT(ENUM_PKT_VLAN_EXIST)) {
+                GLUE_SET_PKT_FLAG(prPacket, ENUM_PKT_VLAN_EXIST);
+            }
+
+            if (rTxPacketInfo.u2Flag & BIT(ENUM_PKT_DHCP)) {
+                GLUE_SET_PKT_FLAG(prPacket, ENUM_PKT_DHCP);
+            }
+
+            if (rTxPacketInfo.u2Flag & BIT(ENUM_PKT_ARP)) {
+                GLUE_SET_PKT_FLAG(prPacket, ENUM_PKT_ARP);
+            }
+        }
+#else
 		if (rTxPacketInfo.fgIs1X) {
             P_STA_RECORD_T          prStaRec;
 
@@ -4237,22 +4273,31 @@ BOOLEAN wlanProcessTxFrame(IN P_ADAPTER_T prAdapter, IN P_NATIVE_PACKET prPacket
 
 			prStaRec = cnmGetStaRecByAddress(prAdapter, 
                 GLUE_GET_PKT_BSS_IDX(prPacket), rTxPacketInfo.aucEthDestAddr);
-            
-            GLUE_SET_PKT_FLAG_1X(prPacket);
+
+            GLUE_SET_PKT_FLAG(prPacket, ENUM_PKT_1X);
             
 			if (secIsProtected1xFrame(prAdapter, prStaRec)) {
-                GLUE_SET_PKT_FLAG_PROTECTED_1X(prPacket);
+                GLUE_SET_PKT_FLAG(prPacket, ENUM_PKT_PROTECTED_1X);
             }
         }
 
 		if (rTxPacketInfo.fgIs802_3) {
-            GLUE_SET_PKT_FLAG_802_3(prPacket);
+            GLUE_SET_PKT_FLAG(prPacket, ENUM_PKT_802_3);
         }
 
 		if (rTxPacketInfo.fgIsVlanExists) {
-            GLUE_SET_PKT_FLAG_VLAN_EXIST(prPacket);
+            GLUE_SET_PKT_FLAG(prPacket, ENUM_PKT_VLAN_EXIST);
         }
 
+        if(rTxPacketInfo.fgIsDhcp) {
+            GLUE_SET_PKT_FLAG(prPacket, ENUM_PKT_DHCP);
+        }
+
+        if(rTxPacketInfo.fgIsArp) {
+            GLUE_SET_PKT_FLAG(prPacket, ENUM_PKT_ARP);
+        }        
+#endif
+
         ucMacHeaderLen = ETHER_HEADER_LEN;
 
         /* Save the value of Header Length */
@@ -4290,33 +4335,34 @@ BOOLEAN wlanProcessSecurityFrame(IN P_ADAPTER_T prAdapter, IN P_NATIVE_PACKET pr
     P_STA_RECORD_T          prStaRec;
     UINT_8                  ucBssIndex;  
     UINT_32                 u4PacketLen;
-    P_SEC_FRAME_INFO_T      prSecFrameInfo;
     UINT_8                  aucEthDestAddr[PARAM_MAC_ADDR_LEN];
+    P_MSDU_INFO_T           prMsduInfo;
 
     ASSERT(prAdapter);
     ASSERT(prPacket);
 
-    prCmdInfo = cmdBufAllocateCmdInfo(prAdapter, sizeof(SEC_FRAME_INFO_T));
+    prCmdInfo = cmdBufAllocateCmdInfo(prAdapter, 0);
+    
+    /* Get MSDU_INFO for TxDone */
+    prMsduInfo = cnmPktAlloc(prAdapter, 0);
 
 	u4PacketLen = (UINT_32) GLUE_GET_PKT_FRAME_LEN(prPacket);
 
-    if (prCmdInfo) {
+    if (prCmdInfo && prMsduInfo) {
         ucBssIndex = GLUE_GET_PKT_BSS_IDX(prPacket);
 
         kalGetEthDestAddr(prAdapter->prGlueInfo, prPacket, aucEthDestAddr);
 
         prStaRec = cnmGetStaRecByAddress(prAdapter, ucBssIndex, aucEthDestAddr);
 
-		prSecFrameInfo = (P_SEC_FRAME_INFO_T) prCmdInfo->pucInfoBuffer;
-        prSecFrameInfo->fgIsProtected = GLUE_GET_PKT_IS_PROTECTED_1X(prPacket);
-
         prCmdInfo->eCmdType             = COMMAND_TYPE_SECURITY_FRAME;
-		prCmdInfo->u2InfoBufLen = (UINT_16) u4PacketLen;
+		prCmdInfo->u2InfoBufLen         = (UINT_16)u4PacketLen;
         prCmdInfo->prPacket             = prPacket;
+        prCmdInfo->prMsduInfo           = prMsduInfo;
 		if (prStaRec) {
-            prCmdInfo->ucStaRecIndex =  prStaRec->ucIndex;
+            prCmdInfo->ucStaRecIndex    =  prStaRec->ucIndex;
 		} else {
-            prCmdInfo->ucStaRecIndex =  STA_REC_INDEX_NOT_FOUND;
+            prCmdInfo->ucStaRecIndex    =  STA_REC_INDEX_NOT_FOUND;
         }
         prCmdInfo->ucBssIndex           = ucBssIndex;
         prCmdInfo->pfCmdDoneHandler     = wlanSecurityFrameTxDone;
@@ -4325,9 +4371,22 @@ BOOLEAN wlanProcessSecurityFrame(IN P_ADAPTER_T prAdapter, IN P_NATIVE_PACKET pr
         prCmdInfo->fgSetQuery           = TRUE;
         prCmdInfo->fgNeedResp           = FALSE;
 
+        /* Fill-up MSDU_INFO */
+        nicTxSetDataPacket(prAdapter, prMsduInfo, ucBssIndex, 
+            prCmdInfo->ucStaRecIndex, 0, u4PacketLen, nicTxDummyTxDone, 
+            MSDU_RATE_MODE_AUTO, TX_PACKET_OS, 0, FALSE, TRUE);
+
+        prMsduInfo->prPacket = prPacket; 
+    	/* No Tx descriptor template for MMPDU */
+        prMsduInfo->fgIsTXDTemplateValid = FALSE;
+        
+        if(GLUE_TEST_PKT_FLAG(prPacket, ENUM_PKT_PROTECTED_1X)) {
+            nicTxConfigPktOption(prMsduInfo, MSDU_OPT_PROTECTED_FRAME, TRUE);
+        }
+        
 #if CFG_SUPPORT_MULTITHREAD
-		nicTxComposeSecurityFrameDesc(prAdapter, prCmdInfo, prSecFrameInfo->ucTxDescBuffer,
-					      NULL);
+		nicTxComposeSecurityFrameDesc(prAdapter, prCmdInfo, 
+		    prMsduInfo->aucTxDescBuffer, NULL);
 #endif
 
 		kalEnqueueCommand(prAdapter->prGlueInfo, (P_QUE_ENTRY_T) prCmdInfo);
@@ -4336,7 +4395,9 @@ BOOLEAN wlanProcessSecurityFrame(IN P_ADAPTER_T prAdapter, IN P_NATIVE_PACKET pr
 
         return TRUE;
 	} else {
-        DBGLOG(RSN, INFO, ("Failed to allocate CMD_INFO for 1X frame!!\n"));
+        DBGLOG(RSN, INFO, ("Failed to alloc CMD/MGMT INFO for 1X frame!!\n"));
+        cmdBufFreeCmdInfo(prAdapter, prCmdInfo);
+        cnmPktFree(prAdapter, prMsduInfo);
     }
 
     return FALSE;
@@ -4378,8 +4439,8 @@ wlanSecurityFrameTxDone(IN P_ADAPTER_T prAdapter, IN P_CMD_INFO_T prCmdInfo, IN
         }
     }
 
-    kalSecurityFrameSendComplete(prAdapter->prGlueInfo,
-				     prCmdInfo->prPacket, WLAN_STATUS_SUCCESS);
+    kalSecurityFrameSendComplete(prAdapter->prGlueInfo, prCmdInfo->prPacket, 
+        WLAN_STATUS_SUCCESS);    
 }
 
 /*----------------------------------------------------------------------------*/
@@ -4398,8 +4459,8 @@ VOID wlanSecurityFrameTxTimeout(IN P_ADAPTER_T prAdapter, IN P_CMD_INFO_T prCmdI
     ASSERT(prAdapter);
     ASSERT(prCmdInfo);
 
-    kalSecurityFrameSendComplete(prAdapter->prGlueInfo,
-				     prCmdInfo->prPacket, WLAN_STATUS_FAILURE);
+    kalSecurityFrameSendComplete(prAdapter->prGlueInfo, prCmdInfo->prPacket, 
+        WLAN_STATUS_FAILURE);
 }
 
 
@@ -5361,38 +5422,33 @@ WLAN_STATUS wlanEnqueueTxPacket(IN P_ADAPTER_T prAdapter, IN P_NATIVE_PACKET prN
     P_TX_CTRL_T prTxCtrl;
     P_MSDU_INFO_T prMsduInfo;
 
-    KAL_SPIN_LOCK_DECLARATION();
-
     ASSERT(prAdapter);
 
     prTxCtrl = &prAdapter->rTxCtrl;
 
-    KAL_ACQUIRE_SPIN_LOCK(prAdapter, SPIN_LOCK_TX_MSDU_INFO_LIST);
-    QUEUE_REMOVE_HEAD(&prTxCtrl->rFreeMsduInfoList, prMsduInfo, P_MSDU_INFO_T);
-    KAL_RELEASE_SPIN_LOCK(prAdapter, SPIN_LOCK_TX_MSDU_INFO_LIST);
+    prMsduInfo = cnmPktAlloc(prAdapter, 0);
 
-	if (prMsduInfo == NULL) {
+	if (!prMsduInfo) {
         return WLAN_STATUS_RESOURCES;
-	} else {
-        prMsduInfo->eSrc = TX_PACKET_OS;
-
-		if (nicTxFillMsduInfo(prAdapter, prMsduInfo, prNativePacket) == FALSE) {
-
-            kalSendComplete(prAdapter->prGlueInfo,
-					prNativePacket, WLAN_STATUS_INVALID_PACKET);
+	}
+    
+	if (nicTxFillMsduInfo(prAdapter, prMsduInfo, prNativePacket)) {
+	    //prMsduInfo->eSrc = TX_PACKET_OS;
+	    
+	    /* Tx profiling */
+        wlanTxProfilingTagMsdu(prAdapter, prMsduInfo, TX_PROF_TAG_DRV_ENQUE);
+    
+		/* enqueue to QM */
+        nicTxEnqueueMsdu(prAdapter, prMsduInfo);
 
-            nicTxReturnMsduInfo(prAdapter, prMsduInfo);
+        return WLAN_STATUS_SUCCESS;        
+	} else {
+        kalSendComplete(prAdapter->prGlueInfo,
+				prNativePacket, WLAN_STATUS_INVALID_PACKET);
 
-            return WLAN_STATUS_INVALID_PACKET;
-		} else {
-		    /* Tx profiling */
-            wlanTxProfilingTagMsdu(prAdapter, prMsduInfo, TX_PROF_TAG_DRV_ENQUE);
-        
-			/* enqueue to QM */
-            nicTxEnqueueMsdu(prAdapter, prMsduInfo);
+        nicTxReturnMsduInfo(prAdapter, prMsduInfo);
 
-            return WLAN_STATUS_SUCCESS;
-        }
+        return WLAN_STATUS_INVALID_PACKET;
     }
 }
 
@@ -5981,6 +6037,8 @@ wlanDumpBssStatistics(IN P_ADAPTER_T prAdapter,
     P_BSS_INFO_T prBssInfo;
 	P_STA_RECORD_T prStaRec;
 	ENUM_WMM_ACI_T eAci;
+    WIFI_WMM_AC_STAT_T arLLStats[WMM_AC_INDEX_NUM];
+    UINT_8 ucIdx;
 
     if (ucBssIdx > MAX_BSS_INDEX) {
 		DBGLOG(SW4, INFO, ("Invalid BssInfo index[%u], skip dump!\n", ucBssIdx));
@@ -5994,7 +6052,7 @@ wlanDumpBssStatistics(IN P_ADAPTER_T prAdapter,
 	}
 
     //<1> fill per-BSS statistics
-    
+#if 0
     /*AIS*/
     if (prBssInfo->eCurrentOPMode == OP_MODE_INFRASTRUCTURE) {
         prStaRec = prBssInfo->prStaRecOfAP;
@@ -6008,22 +6066,68 @@ wlanDumpBssStatistics(IN P_ADAPTER_T prAdapter,
             }        
         }
     }
+#else
+    for(eAci = 0; eAci < WMM_AC_INDEX_NUM; eAci++) {
+        arLLStats[eAci].u4TxMsdu = prBssInfo->arLinkStatistics[eAci].u4TxMsdu;
+        arLLStats[eAci].u4RxMsdu = prBssInfo->arLinkStatistics[eAci].u4RxMsdu;
+        arLLStats[eAci].u4TxDropMsdu = prBssInfo->arLinkStatistics[eAci].u4TxDropMsdu;
+        arLLStats[eAci].u4TxFailMsdu = prBssInfo->arLinkStatistics[eAci].u4TxFailMsdu;
+        arLLStats[eAci].u4TxRetryMsdu = prBssInfo->arLinkStatistics[eAci].u4TxRetryMsdu;
+    }
+
+    for(ucIdx = 0; ucIdx < CFG_NUM_OF_STA_RECORD; ucIdx++) {
+        prStaRec = cnmGetStaRecByIndex(prAdapter, ucIdx);
+        if(prStaRec) {
+            prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, prStaRec->ucBssIndex);
+
+            if(!prBssInfo) {
+                continue;
+            }
+            
+            for(eAci = 0; eAci < WMM_AC_INDEX_NUM; eAci++) {
+                arLLStats[eAci].u4TxMsdu += 
+                    prStaRec->arLinkStatistics[eAci].u4TxMsdu;
+                arLLStats[eAci].u4RxMsdu += 
+                    prStaRec->arLinkStatistics[eAci].u4RxMsdu;  
+                arLLStats[eAci].u4TxDropMsdu += 
+                    prStaRec->arLinkStatistics[eAci].u4TxDropMsdu;  
+                arLLStats[eAci].u4TxFailMsdu += 
+                    prStaRec->arLinkStatistics[eAci].u4TxFailMsdu;
+                arLLStats[eAci].u4TxRetryMsdu += 
+                    prStaRec->arLinkStatistics[eAci].u4TxRetryMsdu; 
+            }
+        }
+    }
+#endif
 
     //<2>Dump BSS statistics
     for(eAci = 0; eAci < WMM_AC_INDEX_NUM; eAci++) { 
-        DBGLOG(SW4, INFO, ("BSS[%u] link statistics of AC[%u]: Tx[%u] Rx[%u] TxDrop[%u] TxFail[%u] TxRetry[%u]\n",
-            prBssInfo->ucBssIndex,
-            eAci,
-            prBssInfo->arLinkStatistics[eAci].u4TxMsdu,
-            prBssInfo->arLinkStatistics[eAci].u4RxMsdu,
-            prBssInfo->arLinkStatistics[eAci].u4TxDropMsdu,
-            prBssInfo->arLinkStatistics[eAci].u4TxFailMsdu,
-            prBssInfo->arLinkStatistics[eAci].u4TxRetryMsdu)
-            );
+        DBGLOG(SW4, INFO, ("LLS BSS[%u] AC[%u]: T[%u] R[%u] T_D[%u] T_F[%u]\n",
+            prBssInfo->ucBssIndex, eAci, arLLStats[eAci].u4TxMsdu,
+            arLLStats[eAci].u4RxMsdu, arLLStats[eAci].u4TxDropMsdu,
+            arLLStats[eAci].u4TxFailMsdu));
     }
 }
 
+VOID
+wlanDumpAllBssStatistics(IN P_ADAPTER_T prAdapter)
+{
+    P_BSS_INFO_T prBssInfo;
+	//ENUM_WMM_ACI_T eAci;
+    UINT_32 ucIdx;    
+
+    //wlanUpdateAllBssStatistics(prAdapter);
 
+    for(ucIdx = 0; ucIdx < BSS_INFO_NUM; ucIdx++) {
+    	prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, ucIdx);
+    	if (!IS_BSS_ACTIVE(prBssInfo)) {
+    		DBGLOG(SW4, TRACE, ("Invalid BssInfo index[%u], skip dump!\n", ucIdx));
+    		continue;
+    	}
+
+        wlanDumpBssStatistics(prAdapter, ucIdx);
+    }
+}
 
 WLAN_STATUS 
 wlanoidQueryStaStatistics(IN P_ADAPTER_T prAdapter,
@@ -6478,6 +6582,13 @@ VOID wlanInitFeatureOption(IN P_ADAPTER_T prAdapter)
     prQM->u4QueLenMovingAverage = (UINT_32)wlanCfgGetUint32(prAdapter, "QueLenMovingAvg", QM_QUE_LEN_MOVING_AVE_FACTOR);
     prQM->u4ExtraReservedTcResource = (UINT_32)wlanCfgGetUint32(prAdapter, "TcExtraRsv", QM_EXTRA_RESERVED_RESOURCE_WHEN_BUSY);
 
+    /* Stats log */
+    prWifiVar->u4StatsLogTimeout = (UINT_32)wlanCfgGetUint32(prAdapter, "StatsLogTO", WLAN_TX_STATS_LOG_TIMEOUT);
+    prWifiVar->u4StatsLogDuration = (UINT_32)wlanCfgGetUint32(prAdapter, "StatsLogDur", WLAN_TX_STATS_LOG_DURATION);
+
+    prWifiVar->ucDhcpTxDone = (UINT_8)wlanCfgGetUint32(prAdapter, "DhcpTxDone", 0);
+    prWifiVar->ucArpTxDone = (UINT_8)wlanCfgGetUint32(prAdapter, "ArpTxDone", 0);
+
 }
 
 VOID
@@ -6655,7 +6766,11 @@ wlanCfgSetCountryCode(
         (((UINT_16) aucValue[0]) << 8) | ((UINT_16) aucValue[1]) ;
 
         prAdapter->prDomainInfo = NULL; /* Force to re-search country code */
-        rlmDomainSendCmd(prAdapter, TRUE);    	
+        rlmDomainSendCmd(prAdapter, TRUE);
+
+        /* Update supported channel list for WLAN & P2P interface (wiphy->bands) */
+        wlanUpdateChannelTable(prAdapter->prGlueInfo);
+        p2pUpdateChannelTableByDomain(prAdapter->prGlueInfo);
     }
 }
 
@@ -7610,6 +7725,8 @@ wlanUpdateTxStatistics(
     P_STA_RECORD_T prStaRec;
     P_BSS_INFO_T prBssInfo;
     ENUM_WMM_ACI_T eAci = WMM_AC_BE_INDEX;
+    P_QUE_MGT_T prQM = &prAdapter->rQM;
+    OS_SYSTIME rCurTime;
 
     eAci = aucTid2ACI[prMsduInfo->ucUserPriority];
 
@@ -7634,6 +7751,21 @@ wlanUpdateTxStatistics(
         }
     }
 
+    /* Trigger FW stats log every 20s */
+    rCurTime = (OS_SYSTIME)kalGetTimeTick();
+
+    DBGLOG(INIT, TRACE, ("CUR[%u] LAST[%u] TO[%u]\n", rCurTime, 
+        prQM->rLastTxPktDumpTime, CHECK_FOR_TIMEOUT(rCurTime, 
+        prQM->rLastTxPktDumpTime, MSEC_TO_SYSTIME(prAdapter->rWifiVar.u4StatsLogTimeout))));
+
+    if(CHECK_FOR_TIMEOUT(rCurTime, prQM->rLastTxPktDumpTime, 
+        MSEC_TO_SYSTIME(prAdapter->rWifiVar.u4StatsLogTimeout))) {
+        
+        wlanTriggerStatsLog(prAdapter, prAdapter->rWifiVar.u4StatsLogDuration);
+        wlanDumpAllBssStatistics(prAdapter);
+
+        prQM->rLastTxPktDumpTime = rCurTime;
+    }
 }
 
 
@@ -7654,6 +7786,46 @@ wlanUpdateRxStatistics(
     }
 }
 
+WLAN_STATUS
+wlanTriggerStatsLog(
+    IN P_ADAPTER_T prAdapter,
+    IN UINT_32 u4DurationInMs
+    )
+{
+    CMD_STATS_LOG_T rStatsLogCmd;
+    WLAN_STATUS rResult;
+
+    kalMemZero(&rStatsLogCmd, sizeof(CMD_STATS_LOG_T));
+
+    rStatsLogCmd.u4DurationInMs = u4DurationInMs;
+
+	rResult = wlanSendSetQueryCmd(prAdapter, CMD_ID_STATS_LOG, TRUE, FALSE, 
+                FALSE, nicCmdEventSetCommon, nicOidCmdTimeoutCommon,
+				sizeof(CMD_STATS_LOG_T), (PUINT_8)&rStatsLogCmd, NULL, 0);
+
+    return rResult;
+}
+
+WLAN_STATUS
+wlanDhcpTxDone(IN P_ADAPTER_T prAdapter, IN P_MSDU_INFO_T prMsduInfo, 
+    IN ENUM_TX_RESULT_CODE_T rTxDoneStatus)
+{
+    DBGLOG(SW4, INFO, ("DHCP PKT[0x%p] WIDX:PID[%u:%u] Status[%u]\n", 
+        prMsduInfo->prPacket, prMsduInfo->ucWlanIndex, prMsduInfo->ucPID, 
+        rTxDoneStatus));
 
+    return WLAN_STATUS_SUCCESS;
+}
+
+WLAN_STATUS
+wlanArpTxDone(IN P_ADAPTER_T prAdapter, IN P_MSDU_INFO_T prMsduInfo, 
+    IN ENUM_TX_RESULT_CODE_T rTxDoneStatus)
+{
+    DBGLOG(SW4, INFO, ("ARP PKT[0x%p] WIDX:PID[%u:%u] Status[%u]\n", 
+        prMsduInfo->prPacket, prMsduInfo->ucWlanIndex, prMsduInfo->ucPID, 
+        rTxDoneStatus));
+
+    return WLAN_STATUS_SUCCESS;
+}
 
 
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/common/wlan_oid.c b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/common/wlan_oid.c
index 6c40647..b99f652 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/common/wlan_oid.c
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/common/wlan_oid.c
@@ -2254,6 +2254,197 @@ wlanoidSetSsid(IN P_ADAPTER_T prAdapter,
 
 }				/* end of wlanoidSetSsid() */
 
+/*----------------------------------------------------------------------------*/
+/*!
+* \brief This routine will initiate the join procedure to attempt
+*        to associate with the new BSS, base on given SSID, BSSID, and freqency.
+*	If the target connecting BSS is in the same ESS as current connected BSS, roaming
+*	will be performed.
+*
+* \param[in] prAdapter Pointer to the Adapter structure.
+* \param[in] pvSetBuffer Pointer to the buffer that holds the data to be set.
+* \param[in] u4SetBufferLen The length of the set buffer.
+* \param[out] pu4SetInfoLen If the call is successful, returns the number of
+*                           bytes read from the set buffer. If the call failed
+*                           due to invalid length of the set buffer, returns
+*                           the amount of storage needed.
+*
+* \retval WLAN_STATUS_SUCCESS
+* \retval WLAN_STATUS_INVALID_DATA
+* \retval WLAN_STATUS_ADAPTER_NOT_READY
+* \retval WLAN_STATUS_INVALID_LENGTH
+*/
+/*----------------------------------------------------------------------------*/
+WLAN_STATUS
+wlanoidSetConnect(
+    IN  P_ADAPTER_T       prAdapter,
+    IN  PVOID             pvSetBuffer,
+    IN  UINT_32           u4SetBufferLen,
+    OUT PUINT_32          pu4SetInfoLen
+    )
+{
+	P_GLUE_INFO_T prGlueInfo;
+    P_PARAM_CONNECT_T pParamConn;
+	P_CONNECTION_SETTINGS_T prConnSettings;
+    UINT_32 i;
+    INT_32 i4Idx = -1, i4MaxRSSI = INT_MIN;
+    P_MSG_AIS_ABORT_T prAisAbortMsg;
+    BOOLEAN fgIsValidSsid = TRUE;
+	BOOLEAN fgEqualSsid = FALSE;
+	BOOLEAN fgEqualBssid = FALSE;
+	const UINT_8 aucZeroMacAddr[] = NULL_MAC_ADDR;
+
+    ASSERT(prAdapter);
+    ASSERT(pu4SetInfoLen);
+
+    /* MSDN:
+     * Powering on the radio if the radio is powered off through a setting of OID_802_11_DISASSOCIATE
+     */
+    if(prAdapter->fgIsRadioOff == TRUE) {
+        prAdapter->fgIsRadioOff = FALSE;
+    }
+
+    if(u4SetBufferLen != sizeof(PARAM_CONNECT_T)) {
+        return WLAN_STATUS_INVALID_LENGTH;
+    }
+    else if (prAdapter->rAcpiState == ACPI_STATE_D3) {
+        DBGLOG(REQ, WARN, ("Fail in set ssid! (Adapter not ready). ACPI=D%d, Radio=%d\n",
+                    prAdapter->rAcpiState, prAdapter->fgIsRadioOff));
+        return WLAN_STATUS_ADAPTER_NOT_READY;
+    }
+	prAisAbortMsg = (P_MSG_AIS_ABORT_T)cnmMemAlloc(prAdapter, RAM_TYPE_MSG, sizeof(MSG_AIS_ABORT_T));
+	if (!prAisAbortMsg) {
+		ASSERT(0);
+		return WLAN_STATUS_FAILURE;
+	}
+	prAisAbortMsg->rMsgHdr.eMsgId = MID_OID_AIS_FSM_JOIN_REQ;
+
+    pParamConn = (P_PARAM_CONNECT_T) pvSetBuffer;
+	prConnSettings = &prAdapter->rWifiVar.rConnSettings;
+
+    if (pParamConn->u4SsidLen > 32) {
+        return WLAN_STATUS_INVALID_LENGTH;
+    } else if (!pParamConn->pucBssid && !pParamConn->pucSsid)
+    	return WLAN_STATUS_INVALID_LENGTH;
+
+    prGlueInfo = prAdapter->prGlueInfo;
+	kalMemZero(prConnSettings->aucSSID, sizeof(prConnSettings->aucSSID));
+	kalMemZero(prConnSettings->aucBSSID, sizeof(prConnSettings->aucBSSID));
+	prConnSettings->eConnectionPolicy = CONNECT_BY_SSID_ANY;
+	prConnSettings->fgIsConnByBssidIssued = FALSE;
+	
+	if (pParamConn->pucSsid) {
+		prConnSettings->eConnectionPolicy = CONNECT_BY_SSID_BEST_RSSI;
+	    COPY_SSID(prConnSettings->aucSSID,
+				prConnSettings->ucSSIDLen,
+				pParamConn->pucSsid,
+	            (UINT_8)pParamConn->u4SsidLen);
+		if (EQUAL_SSID(prAdapter->rWlanInfo.rCurrBssId.rSsid.aucSsid,
+						prAdapter->rWlanInfo.rCurrBssId.rSsid.u4SsidLen,
+						pParamConn->pucSsid,
+						pParamConn->u4SsidLen))
+			fgEqualSsid = TRUE;
+	}
+	if (pParamConn->pucBssid) {
+		if (!EQUAL_MAC_ADDR(aucZeroMacAddr, pParamConn->pucBssid) &&
+				IS_UCAST_MAC_ADDR(pParamConn->pucBssid)) {
+			prConnSettings->eConnectionPolicy = CONNECT_BY_BSSID;
+			prConnSettings->fgIsConnByBssidIssued = TRUE;
+			COPY_MAC_ADDR(prConnSettings->aucBSSID, pParamConn->pucBssid);
+			if (EQUAL_MAC_ADDR(prAdapter->rWlanInfo.rCurrBssId.arMacAddress,
+										pParamConn->pucBssid))
+				fgEqualBssid = TRUE;
+		} else {
+			DBGLOG(INIT, INFO, ("wrong bssid "MACSTR"to connect\n", MAC2STR(pParamConn->pucBssid)));
+		}
+	} else
+		DBGLOG(INIT, INFO, ("No Bssid set\n"));
+	prConnSettings->u4FreqInKHz = pParamConn->u4CenterFreq;
+
+    // prepare for CMD_BUILD_CONNECTION & CMD_GET_CONNECTION_STATUS
+    // re-association check
+    if(kalGetMediaStateIndicated(prGlueInfo) == PARAM_MEDIA_STATE_CONNECTED) {
+        if(fgEqualSsid) {
+			prAisAbortMsg->ucReasonOfDisconnect = DISCONNECT_REASON_CODE_REASSOCIATION;
+            if (fgEqualBssid) {
+				kalSetMediaStateIndicated(prGlueInfo, PARAM_MEDIA_STATE_TO_BE_INDICATED);
+            }
+        }
+        else {
+			DBGLOG(INIT, INFO, ("DisBySsid\n"));
+            kalIndicateStatusAndComplete(prGlueInfo,
+                    WLAN_STATUS_MEDIA_DISCONNECT,
+                    NULL,
+                    0);
+			prAisAbortMsg->ucReasonOfDisconnect = DISCONNECT_REASON_CODE_NEW_CONNECTION;
+        }
+    } else
+    	prAisAbortMsg->ucReasonOfDisconnect = DISCONNECT_REASON_CODE_NEW_CONNECTION;
+#if 0
+    // check if any scanned result matchs with the SSID
+    for(i = 0 ; i < prAdapter->rWlanInfo.u4ScanResultNum ; i++) {
+        PUINT_8 aucSsid = prAdapter->rWlanInfo.arScanResult[i].rSsid.aucSsid;
+        UINT_8 ucSsidLength = (UINT_8) prAdapter->rWlanInfo.arScanResult[i].rSsid.u4SsidLen;
+        INT_32 i4RSSI = prAdapter->rWlanInfo.arScanResult[i].rRssi;
+
+        if(EQUAL_SSID(aucSsid, ucSsidLength, pParamConn->pucSsid, pParamConn->u4SsidLen) &&
+                i4RSSI >= i4MaxRSSI) {
+            i4Idx = (INT_32)i;
+            i4MaxRSSI = i4RSSI;
+        }
+		if(EQUAL_MAC_ADDR(prAdapter->rWlanInfo.arScanResult[i].arMacAddress, pAddr)) {
+            i4Idx = (INT_32)i;
+            break;
+        }
+    }
+#endif
+    /* prepare message to AIS */
+    if (prConnSettings->eOPMode == NET_TYPE_IBSS
+            || prConnSettings->eOPMode == NET_TYPE_DEDICATED_IBSS) {
+        /* IBSS */ /* beacon period */
+        prConnSettings->u2BeaconPeriod    = prAdapter->rWlanInfo.u2BeaconPeriod;
+        prConnSettings->u2AtimWindow      = prAdapter->rWlanInfo.u2AtimWindow;
+    }
+
+    if (prAdapter->rWifiVar.fgSupportWZCDisassociation) {
+        if (pParamConn->u4SsidLen == ELEM_MAX_LEN_SSID) {
+            fgIsValidSsid = FALSE;
+
+            for (i = 0; i < ELEM_MAX_LEN_SSID; i++) {
+                if ( !((0 < pParamConn->pucSsid[i]) && (pParamConn->pucSsid[i] <= 0x1F)) ) {
+                    fgIsValidSsid = TRUE;
+                    break;
+                }
+            }
+        }
+    }
+
+    /* Set Connection Request Issued Flag */
+    if (fgIsValidSsid) {
+        prConnSettings->fgIsConnReqIssued = TRUE;
+    }
+    else {
+        prConnSettings->fgIsConnReqIssued = FALSE;
+    }
+	
+    if (fgEqualSsid || fgEqualBssid) {
+        prAisAbortMsg->fgDelayIndication = TRUE;
+    }
+    else {
+        /* Update the information to CONNECTION_SETTINGS_T */
+        prAisAbortMsg->fgDelayIndication = FALSE;
+    }
+
+    mboxSendMsg(prAdapter,
+            MBOX_ID_0,
+            (P_MSG_HDR_T) prAisAbortMsg,
+            MSG_SEND_METHOD_BUF);
+
+	DBGLOG(INIT, INFO, ("ssid %s, bssid "MACSTR", conn policy %d, disc reason %d\n",
+			prConnSettings->aucSSID, MAC2STR(prConnSettings->aucBSSID),
+			prConnSettings->eConnectionPolicy, prAisAbortMsg->ucReasonOfDisconnect));
+    return WLAN_STATUS_SUCCESS;
+}/* end of wlanoidSetConnect */
 
 /*----------------------------------------------------------------------------*/
 /*!
@@ -7632,7 +7823,7 @@ wlanoidSetDisassociate(IN P_ADAPTER_T prAdapter,
 	/* indicate for disconnection */
 	if (kalGetMediaStateIndicated(prAdapter->prGlueInfo) == PARAM_MEDIA_STATE_CONNECTED) {
 		kalIndicateStatusAndComplete(prAdapter->prGlueInfo,
-					     WLAN_STATUS_MEDIA_DISCONNECT, NULL, 0);
+					     WLAN_STATUS_MEDIA_DISCONNECT_LOCALLY, NULL, 0);
 	}
 #if !defined(LINUX)
 	prAdapter->fgIsRadioOff = TRUE;
@@ -10326,6 +10517,10 @@ wlanoidSetCountryCode(IN P_ADAPTER_T prAdapter,
 	prAdapter->prDomainInfo = NULL;	/* Force to re-search country code */
 	rlmDomainSendCmd(prAdapter, TRUE);
 
+    /* Update supported channel list for WLAN & P2P interface (wiphy->bands) */
+    wlanUpdateChannelTable(prAdapter->prGlueInfo);
+    p2pUpdateChannelTableByDomain(prAdapter->prGlueInfo);
+
 	return WLAN_STATUS_SUCCESS;
 }
 
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/common/wlan_p2p.c b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/common/wlan_p2p.c
index 28c8a35..49a297a 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/common/wlan_p2p.c
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/common/wlan_p2p.c
@@ -12,6 +12,10 @@
 /*
 ** $Log: wlan_p2p.c $
 **
+** 04 07 2015 eason.tsai
+** [ALPS02012000] [MT6795][L-MR1][NFC][Beam Plus][Blocking]The picture will not transfer.
+** 4-way handshake with  key stuck in 2/4 recieve
+**
 ** 03 07 2014 eason.tsai
 ** [ALPS01070904] [Need Patch] [Volunteer Patch][MT6630][Driver]MT6630 Wi-Fi Patch
 ** fix ap mode crash by hotspot only set_beacon without chenge_interface
@@ -645,7 +649,9 @@ wlanoidSetRemoveP2PKey(IN P_ADAPTER_T prAdapter,
 	/* Clean up the Tx key flag */
 	prStaRec = cnmGetStaRecByAddress(prAdapter, prRemovedKey->ucBssIdx, prRemovedKey->arBSSID);
 
-	if (prRemovedKey->u4KeyIndex & IS_UNICAST_KEY) {
+
+	/*mark for MR1 to avoid remove-key, but remove the wlan_tbl0 at the same time*/
+	if (1/*prRemovedKey->u4KeyIndex & IS_UNICAST_KEY */) {
 		if (prStaRec) {
 			rCmdKey.ucKeyType = 1;
 			rCmdKey.ucWlanIndex = prStaRec->ucWlanIndex;
@@ -669,7 +675,8 @@ wlanoidSetRemoveP2PKey(IN P_ADAPTER_T prAdapter,
 		}
 	}
 
-	secPrivacyFreeForEntry(prAdapter, rCmdKey.ucWlanIndex);
+	/*mark for MR1 to avoid remove-key, but remove the wlan_tbl0 at the same time*/
+	//secPrivacyFreeForEntry(prAdapter, rCmdKey.ucWlanIndex);
 
 	return wlanoidSendSetQueryP2PCmd(prAdapter,
 					 CMD_ID_ADD_REMOVE_KEY,
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/mgmt/rlm_domain.h b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/mgmt/rlm_domain.h
index 9157eac..ada2467 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/mgmt/rlm_domain.h
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/mgmt/rlm_domain.h
@@ -338,14 +338,8 @@
 #define MIB_REG_DOMAIN_JAPAN            0x40	/* MPHPT (Japan) */
 #define MIB_REG_DOMAIN_OTHER            0x00	/* other */
 
-#if CFG_SUPPORT_PWR_LIMIT_COUNTRY
 
 
-#define POWER_LIMIT_TABLE_NULL 			0xFFFF
-#define MAX_TX_POWER     				63
-#define MIN_TX_POWER     				-64
-#define MAX_CMD_SUPPORT_CHANNEL_NUM  	64
-
 /*2.4G*/
 #define BAND_2G4_LOWER_BOUND 1   
 #define BAND_2G4_UPPER_BOUND 14
@@ -359,6 +353,14 @@
 #define UNII3_LOWER_BOUND    149  
 #define UNII3_UPPER_BOUND    173 
 
+
+#if CFG_SUPPORT_PWR_LIMIT_COUNTRY
+
+#define POWER_LIMIT_TABLE_NULL 			0xFFFF
+#define MAX_TX_POWER     				63
+#define MIN_TX_POWER     				-64
+#define MAX_CMD_SUPPORT_CHANNEL_NUM  	64
+
 #endif
 
 /*******************************************************************************
@@ -377,6 +379,8 @@ typedef enum _ENUM_POWER_LIMIT_T {
 	PWR_LIMIT_NUM
 } ENUM_POWER_LIMIT_T, *P_ENUM_POWER_LIMIT_T;
 
+#endif
+
 typedef enum _ENUM_POWER_LIMIT_SUBBAND_T {
 	POWER_LIMIT_2G4         = 0,
 	POWER_LIMIT_UNII1       = 1,
@@ -386,7 +390,6 @@ typedef enum _ENUM_POWER_LIMIT_SUBBAND_T {
 	POWER_LIMIT_SUBAND_NUM
 } ENUM_POWER_LIMIT_SUBBAND_T, *P_ENUM_POWER_LIMIT_SUBBAND_T;
 
-#endif
 
 
 /* Define channel offset in unit of 5MHz bandwidth */
@@ -579,6 +582,13 @@ typedef struct _SUBBAND_CHANNEL_T {
 *                                 M A C R O S
 ********************************************************************************
 */
+#define CAL_CH_OFFSET_80M(_PRIMARY_CH, _CENTRAL_CH) \
+			(((_PRIMARY_CH - _CENTRAL_CH ) + 6) >> 2)
+			
+#define CAL_CH_OFFSET_160M(_PRIMARY_CH, _CENTRAL_CH) \
+			(((_PRIMARY_CH - _CENTRAL_CH ) + 14) >> 2)
+
+
 
 /*******************************************************************************
 *                   F U N C T I O N   D E C L A R A T I O N S
@@ -601,6 +611,14 @@ BOOLEAN rlmDomainIsLegalChannel(P_ADAPTER_T prAdapter, ENUM_BAND_T eBand, UINT_8
 
 UINT_32 rlmDomainSupOperatingClassIeFill(PUINT_8 pBuf);
 
+BOOLEAN rlmDomainCheckChannelEntryValid(P_ADAPTER_T prAdapter, UINT_8 ucCentralCh);
+
+UINT_8 rlmDomainGetCenterChannel(ENUM_BAND_T eBand, UINT_8 ucPriChannel, ENUM_CHNL_EXT_T eExtend);
+
+BOOLEAN rlmDomainIsValidRfSetting (P_ADAPTER_T prAdapter, ENUM_BAND_T eBand, 
+	UINT_8 ucPriChannel, ENUM_CHNL_EXT_T eExtend, 
+	ENUM_CHANNEL_WIDTH_T eChannelWidth, UINT_8 ucChannelS1, UINT_8 ucChannelS2);
+ 
 #if CFG_SUPPORT_PWR_LIMIT_COUNTRY
 
 BOOLEAN
@@ -609,12 +627,6 @@ rlmDomainCheckPowerLimitValid (
 	COUNTRY_POWER_LIMIT_TABLE_CONFIGURATION         rPowerLimitTableConfiguration,      
 	UINT_8          								ucPwrLimitNum
     );
-BOOLEAN
-rlmDomainCheckChannelEntryValid(
-    P_ADAPTER_T     prAdapter,
-    UINT_8          ucCentralCh
-    );
-
 
 VOID
 rlmDomainCheckCountryPowerLimitTable (
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic/adapter.h b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic/adapter.h
index 3af86f6..d515958 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic/adapter.h
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic/adapter.h
@@ -1382,6 +1382,12 @@ typedef struct _WIFI_VAR_T {
 
     UINT_8                 ucCmdRsvResource;
     UINT_32                u4MgmtQueueDelayTimeout;
+
+    UINT_32                u4StatsLogTimeout;
+    UINT_32                u4StatsLogDuration;
+    UINT_8                 ucDhcpTxDone;
+    UINT_8                 ucArpTxDone;
+    
 } WIFI_VAR_T, *P_WIFI_VAR_T;/* end of _WIFI_VAR_T */
 
 /* cnm_timer module */
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic/cmd_buf.h b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic/cmd_buf.h
index d1c0323..fc235a6 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic/cmd_buf.h
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic/cmd_buf.h
@@ -93,7 +93,8 @@ struct _CMD_INFO_T {
 
 	UINT_16 u2InfoBufLen;	/* This is actual CMD buffer length */
 	PUINT_8 pucInfoBuffer;	/* May pointer to structure in prAdapter */
-	P_NATIVE_PACKET prPacket;	/* only valid when it's a security frame */
+	P_MSDU_INFO_T prMsduInfo; /* only valid when it's a security/MGMT frame */
+	P_NATIVE_PACKET prPacket; /* only valid when it's a security frame */
 
 	UINT_8 ucBssIndex;
 	UINT_8 ucStaRecIndex;	/* only valid when it's a security frame */
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic/mac.h b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic/mac.h
index 151d82b..f0b7f9a 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic/mac.h
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic/mac.h
@@ -177,6 +177,7 @@
 #define MAC_ADDR_LOCAL_ADMIN                    BIT(1)
 
 #define ETH_P_IPV4                              0x0800
+#define ETH_P_ARP                               0x0806
 #define ETH_P_IPX                               0x8137	/* Novell IPX */
 #define ETH_P_AARP                              0x80F3	/* AppleTalk Address Resolution Protocol (AARP) */
 #define ETH_P_IPV6                              0x86DD
@@ -242,10 +243,17 @@
 
 #define TCP_HDR_TCP_CSUM_OFFSET                 16
 
+#define UDP_HDR_LEN                             8
+
 #define UDP_HDR_SRC_PORT_OFFSET                 0
 #define UDP_HDR_DST_PORT_OFFSET                 2
 #define UDP_HDR_UDP_CSUM_OFFSET                 6
 
+#define IP_PORT_BOOTP_SERVER                    67
+#define IP_PORT_BOOTP_CLIENT                    68
+
+#define DHCP_MAGIC_NUMBER                       0x63825363
+
 #define ARP_OPERATION_OFFSET                    6
 #define ARP_SNEDER_MAC_OFFSET                   8
 #define ARP_SENDER_IP_OFFSET                    14
@@ -1442,6 +1450,23 @@ typedef struct _ETH_FRAME_T {
 	UINT_8 aucData[1];
 } __KAL_ATTRIB_PACKED__ ETH_FRAME_T, *P_ETH_FRAME_T;
 
+typedef struct _BOOTP_PROTOCOL_T {
+    UINT_8 ucOperation;
+    UINT_8 ucHdrType;
+    UINT_8 ucHdrLen;
+    UINT_8 ucHops;
+    UINT_32 u4TransId;
+    UINT_16 u2Seconds;
+    UINT_16 u2Flags;
+    UINT_32 u4CIAddr;
+    UINT_32 u4YIAddr;
+    UINT_32 u4SIAddr;
+    UINT_32 u4GIAddr;
+    UINT_8 aucCHAddr[16];
+    UINT_8 aucServerName[64];
+    UINT_8 aucFileName[128];
+    UINT_8 aucOptions[0];
+} __KAL_ATTRIB_PACKED__ BOOTP_PROTOCOL_T, *P_BOOTP_PROTOCOL_T;
 
 /* IEEE 802.11 WLAN Frame Structure */
 /* WLAN MAC Header (without Address 4 and QoS Control fields) */
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic/nic_tx.h b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic/nic_tx.h
index d7f986b..6c904bb 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic/nic_tx.h
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic/nic_tx.h
@@ -1004,7 +1004,7 @@ struct _MSDU_INFO_T {
 
 #if CFG_SUPPORT_MULTITHREAD
     /* Compose TxDesc in tx_thread and place here */
-    UINT_8                      ucTxDescBuffer[NIC_TX_DESC_AND_PADDING_LENGTH];
+    UINT_8                      aucTxDescBuffer[NIC_TX_DESC_AND_PADDING_LENGTH];
 #endif
 };
 
@@ -1633,6 +1633,8 @@ nicTxPrintMetRTP (
     IN BOOLEAN         bFreeSkb
     );
 
+VOID nicTxProcessTxDoneEvent(IN P_ADAPTER_T prAdapter, 
+    IN P_WIFI_EVENT_T prEvent);
 
 /*******************************************************************************
 *                              F U N C T I O N S
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic/que_mgt.h b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic/que_mgt.h
index d1d7dac..57ffd42 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic/que_mgt.h
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic/que_mgt.h
@@ -621,6 +621,8 @@ typedef struct _QUE_MGT_T {	/* Queue Management Control Info */
 #endif
 
     UINT_32 u4MaxForwardBufferCount;
+
+    OS_SYSTIME rLastTxPktDumpTime;
 } QUE_MGT_T, *P_QUE_MGT_T;
 
 
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic/wlan_def.h b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic/wlan_def.h
index f7c1166..e81185d 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic/wlan_def.h
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic/wlan_def.h
@@ -1059,6 +1059,14 @@ typedef struct _P2P_DEVICE_DESC_T {
 					((UINT_32)__cp[2] << 16) | ((UINT_32)__cp[3] << 24); \
 	}
 
+#define WLAN_GET_FIELD_BE32(_memAddr_p, _value_p) \
+	{ \
+		PUINT_8 __cp = (PUINT_8)(_memAddr_p); \
+		*(PUINT_32)(_value_p) = ((UINT_32)__cp[0] << 24) | \
+		    ((UINT_32)__cp[1] << 16) | ((UINT_32)__cp[2] << 8) | \
+		    ((UINT_32)__cp[3]); \
+	}
+
 #define WLAN_GET_FIELD_64(_memAddr_p, _value_p) \
 	{ \
 		PUINT_8 __cp = (PUINT_8)(_memAddr_p); \
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic_cmd_event.h b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic_cmd_event.h
index 067110f..c8e1b99 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic_cmd_event.h
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/nic_cmd_event.h
@@ -140,7 +140,8 @@ typedef enum _ENUM_CMD_ID_T {
     CMD_ID_SEC_CHECK,                   /* 0xc5 (Set / Query) */
     CMD_ID_DUMP_MEM,                    /* 0xc6 (Query) */
     CMD_ID_RESOURCE_CONFIG,             /* 0xc7 (Set / Query) */	
-    CMD_ID_CHIP_CONFIG          = 0xCA, /* 0xca (Set / Query) */    
+    CMD_ID_CHIP_CONFIG          = 0xCA, /* 0xca (Set / Query) */
+    CMD_ID_STATS_LOG            = 0xCB, /* 0xcb (Set) */
     CMD_ID_SET_RDD_CH           = 0xE1,
     CMD_ID_SET_BWCS             = 0xF1,
     CMD_ID_SET_OSC              = 0xF2,
@@ -757,8 +758,10 @@ typedef struct _EVENT_TX_DONE_T {
     UINT_8      ucStatus;
     UINT_16     u2SequenceNumber;
     UINT_8      ucWlanIndex;
-    UINT_8      aucReserved1[3];
-    UINT_32     au4Reserved2;
+    UINT_8      ucTxCount;
+    UINT_16     u2TxRate;
+    UINT_8      ucFlag;
+    UINT_8      au4Reserved2[3];
     UINT_32     au4Reserved3;
 } EVENT_TX_DONE_T, *P_EVENT_TX_DONE_T;
 
@@ -1498,6 +1501,11 @@ typedef struct _CMD_MONITOR_SET_INFO_T {
 } CMD_MONITOR_SET_INFO_T, *P_CMD_MONITOR_SET_INFO_T;
 #endif
 
+typedef struct _CMD_STATS_LOG_T {
+    UINT_32         u4DurationInMs;
+    UINT_8          aucReserved[32];
+} CMD_STATS_LOG_T, *P_CMD_STATS_LOG_T;
+
 /*******************************************************************************
 *                            P U B L I C   D A T A
 ********************************************************************************
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/typedef.h b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/typedef.h
index 141de80..9e2e1f5 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/typedef.h
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/typedef.h
@@ -40,6 +40,7 @@
 
 #define WLAN_STATUS_MEDIA_CONNECT               ((WLAN_STATUS) 0x4001000BL)
 #define WLAN_STATUS_MEDIA_DISCONNECT            ((WLAN_STATUS) 0x4001000CL)
+#define WLAN_STATUS_MEDIA_DISCONNECT_LOCALLY	((WLAN_STATUS) 0x4001000DL)
 #define WLAN_STATUS_MEDIA_SPECIFIC_INDICATION   ((WLAN_STATUS) 0x40010012L)
 
 #define WLAN_STATUS_SCAN_COMPLETE               ((WLAN_STATUS) 0x60010001L)
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/wlan_lib.h b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/wlan_lib.h
index 7e3ea33..fde562d 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/wlan_lib.h
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/wlan_lib.h
@@ -465,6 +465,9 @@
 
 #define WLAN_TX_THREAD_TASK_PRIORITY        0	/* If not setting the priority, 0 is the default */
 #define WLAN_TX_THREAD_TASK_NICE            (-10)	/* If not setting the nice, -10 is the default */
+
+#define WLAN_TX_STATS_LOG_TIMEOUT                   30000
+#define WLAN_TX_STATS_LOG_DURATION                  1500
 /*******************************************************************************
 *                             D A T A   T Y P E S
 ********************************************************************************
@@ -835,6 +838,7 @@ typedef struct _NET_INTERFACE_INFO_T {
 	PVOID pvNetInterface;
 } NET_INTERFACE_INFO_T, *P_NET_INTERFACE_INFO_T;
 
+#if 0
 typedef struct _SEC_FRAME_INFO_T {
 	BOOLEAN fgIsProtected;
 #if CFG_SUPPORT_MULTITHREAD
@@ -842,6 +846,7 @@ typedef struct _SEC_FRAME_INFO_T {
 	UINT_8 ucTxDescBuffer[DWORD_TO_BYTE(7)];
 #endif
 } SEC_FRAME_INFO_T, *P_SEC_FRAME_INFO_T;
+#endif
 
 typedef enum _ENUM_TX_RESULT_CODE_T {
 	TX_RESULT_SUCCESS = 0,
@@ -929,10 +934,16 @@ typedef struct _TX_PACKET_INFO {
     UINT_8 ucPriorityParam;
     UINT_32 u4PacketLen;
     UINT_8 aucEthDestAddr[MAC_ADDR_LEN];
+    UINT_16 u2Flag;
+
+#if 0
     BOOLEAN fgIs1X;
     BOOLEAN fgIsPAL;
     BOOLEAN fgIs802_3;
     BOOLEAN fgIsVlanExists;
+    BOOLEAN fgIsDhcp;
+    BOOLEAN fgIsArp;
+#endif
 } TX_PACKET_INFO, *P_TX_PACKET_INFO;
 
 typedef enum _ENUM_TX_PROFILING_TAG_T {
@@ -1331,3 +1342,12 @@ wlanUpdateRxStatistics(
     IN P_SW_RFB_T prSwRfb
     );
 
+WLAN_STATUS wlanTriggerStatsLog(IN P_ADAPTER_T prAdapter, 
+    IN UINT_32 u4DurationInMs);
+
+WLAN_STATUS wlanDhcpTxDone(IN P_ADAPTER_T prAdapter, 
+    IN P_MSDU_INFO_T prMsduInfo, IN ENUM_TX_RESULT_CODE_T rTxDoneStatus);
+
+WLAN_STATUS wlanArpTxDone(IN P_ADAPTER_T prAdapter, 
+    IN P_MSDU_INFO_T prMsduInfo, IN ENUM_TX_RESULT_CODE_T rTxDoneStatus);
+
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/wlan_oid.h b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/wlan_oid.h
index 7af72ab..690b2e4 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/wlan_oid.h
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/include/wlan_oid.h
@@ -405,6 +405,13 @@ typedef struct _PARAM_SSID_T {
 	UINT_8 aucSsid[PARAM_MAX_LEN_SSID];
 } PARAM_SSID_T, *P_PARAM_SSID_T;
 
+typedef struct _PARAM_CONNECT_T {
+	UINT_32  u4SsidLen;      /*!< SSID length in bytes. Zero length is broadcast(any) SSID */
+	UINT_8   *pucSsid;
+	UINT_8	 *pucBssid;
+	UINT_32  u4CenterFreq;
+} PARAM_CONNECT_T, *P_PARAM_CONNECT_T;
+
 /* This is enum defined for user to select an AdHoc Mode */
 typedef enum _ENUM_PARAM_AD_HOC_MODE_T {
 	AD_HOC_MODE_11B = 0,	/*!< Create 11b IBSS if we support 802.11abg/802.11bg. */
@@ -1183,6 +1190,10 @@ wlanoidSetBssid(IN P_ADAPTER_T prAdapter,
 		IN PVOID pvSetBuffer, IN UINT_32 u4SetBufferLen, OUT PUINT_32 pu4SetInfoLen);
 
 WLAN_STATUS
+wlanoidSetConnect(IN  P_ADAPTER_T prAdapter,
+		IN  PVOID pvSetBuffer, IN  UINT_32 u4SetBufferLen, OUT PUINT_32 pu4SetInfoLen );
+
+WLAN_STATUS
 wlanoidSetSsid(IN P_ADAPTER_T prAdapter,
 	       IN PVOID pvSetBuffer, IN UINT_32 u4SetBufferLen, OUT PUINT_32 pu4SetInfoLen);
 
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/aaa_fsm.c b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/aaa_fsm.c
index 70739e7..8c2c109 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/aaa_fsm.c
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/aaa_fsm.c
@@ -775,6 +775,11 @@ aaaFsmRunEventTxDone(IN P_ADAPTER_T prAdapter,
 
 	prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, prStaRec->ucBssIndex);
 
+    /* Trigger statistics log if Auth/Assoc Tx failed */
+    if(rTxDoneStatus != TX_RESULT_SUCCESS) {
+        wlanTriggerStatsLog(prAdapter, prAdapter->rWifiVar.u4StatsLogDuration);
+    }
+
 	switch (prStaRec->eAuthAssocState) {
 	case AAA_STATE_SEND_AUTH2:
 		{
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/ais_fsm.c b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/ais_fsm.c
index 0fb52fa..db8f132 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/ais_fsm.c
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/ais_fsm.c
@@ -1110,7 +1110,7 @@
 #define AIS_ROAMING_CONNECTION_TRIAL_LIMIT  2
 #define AIS_JOIN_TIMEOUT                    15
 
-#define CTIA_MAGIC_SSID                     "ctia_test_only_*#*#3646633#*#*"
+#define CTIA_MAGIC_SSID                     "no_use_ctia_ssid"//"ctia_test_only_*#*#3646633#*#*"
 #define CTIA_MAGIC_SSID_LEN                 30
 
 #define AIS_FSM_STATE_SEARCH_ACTION_PHASE_0	0
@@ -2008,7 +2008,7 @@ VOID aisFsmSteps(IN P_ADAPTER_T prAdapter, ENUM_AIS_STATE_T eNextState)
 #if CFG_SUPPORT_PNO
                                 prAisBssInfo->fgIsNetRequestInActive = TRUE;
                                 if(prAisBssInfo->fgIsPNOEnable){
-                                    DBGLOG(BSS, INFO, ("[wlan index][Network]=%d fgIsPNOEnable && OP_MODE_INFRASTRUCTURE, KEEP ACTIVE \n", prAisBssInfo->ucBssIndex, 1));
+                                    DBGLOG(BSS, INFO, ("[wlan index][Network]=%d fgIsPNOEnable && OP_MODE_INFRASTRUCTURE, KEEP ACTIVE \n", prAisBssInfo->ucBssIndex));
                                 }
                                 else
 #endif                                           
@@ -3090,7 +3090,9 @@ aisFsmJoinCompleteAction(IN struct _ADAPTER_T *prAdapter, IN struct _MSG_HDR_T *
 			}
 
 #if CFG_SUPPORT_ROAMING
-			roamingFsmRunEventStart(prAdapter);
+			/* if bssid is given, it means we no need fw roaming */
+			if (prAdapter->rWifiVar.rConnSettings.eConnectionPolicy != CONNECT_BY_BSSID)
+				roamingFsmRunEventStart(prAdapter);
 #endif				/* CFG_SUPPORT_ROAMING */
 
 			/* 4 <1.7> Set the Next State of AIS FSM */
@@ -4950,12 +4952,13 @@ aisUpdateBssInfoForRoamingAP(IN P_ADAPTER_T prAdapter,
 		/* cnmStaRecChangeState(prAdapter, prAisBssInfo->prStaRecOfAP, STA_STATE_1); */
 		cnmStaRecFree(prAdapter, prAisBssInfo->prStaRecOfAP);
 	}
-	/* 4 <1.3> Activate current AP's STA_RECORD_T in Driver. */
-	cnmStaRecChangeState(prAdapter, prStaRec, STA_STATE_3);
 
 	/* 4 <1.4> Update BSS_INFO_T */
 	aisUpdateBssInfoForJOIN(prAdapter, prStaRec, prAssocRspSwRfb);
 
+	/* 4 <1.3> Activate current AP's STA_RECORD_T in Driver. */
+	cnmStaRecChangeState(prAdapter, prStaRec, STA_STATE_3);
+
 	/* 4 <1.6> Indicate Connected Event to Host immediately. */
 	/* Require BSSID, Association ID, Beacon Interval.. from AIS_BSS_INFO_T */
 	aisIndicationOfMediaStateToHost(prAdapter, PARAM_MEDIA_STATE_CONNECTED, FALSE);
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/cnm_mem.c b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/cnm_mem.c
index bab2b23..0c91ab9 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/cnm_mem.c
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/cnm_mem.c
@@ -581,14 +581,20 @@ P_MSDU_INFO_T cnmPktAlloc(P_ADAPTER_T prAdapter, UINT_32 u4Length)
     KAL_RELEASE_SPIN_LOCK(prAdapter, SPIN_LOCK_TX_MSDU_INFO_LIST);
 
     if (prMsduInfo) {
-        prMsduInfo->prPacket = cnmMemAlloc(prAdapter, RAM_TYPE_BUF, u4Length);
-        prMsduInfo->eSrc = TX_PACKET_MGMT;
-
-        if (prMsduInfo->prPacket == NULL) {
-            KAL_ACQUIRE_SPIN_LOCK(prAdapter, SPIN_LOCK_TX_MSDU_INFO_LIST);
-            QUEUE_INSERT_TAIL(prQueList, &prMsduInfo->rQueEntry);
-            KAL_RELEASE_SPIN_LOCK(prAdapter, SPIN_LOCK_TX_MSDU_INFO_LIST);
-            prMsduInfo = NULL;
+        if(u4Length) {
+            prMsduInfo->prPacket = 
+                cnmMemAlloc(prAdapter, RAM_TYPE_BUF, u4Length);
+            prMsduInfo->eSrc = TX_PACKET_MGMT;
+
+            if (prMsduInfo->prPacket == NULL) {
+                KAL_ACQUIRE_SPIN_LOCK(prAdapter, SPIN_LOCK_TX_MSDU_INFO_LIST);
+                QUEUE_INSERT_TAIL(prQueList, &prMsduInfo->rQueEntry);
+                KAL_RELEASE_SPIN_LOCK(prAdapter, SPIN_LOCK_TX_MSDU_INFO_LIST);
+                prMsduInfo = NULL;
+            }
+        } 
+        else {
+            prMsduInfo->prPacket = NULL;
         }
     }
 #if DBG
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/p2p_func.c b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/p2p_func.c
index 0157fd1..d8fd837 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/p2p_func.c
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/p2p_func.c
@@ -539,7 +539,9 @@ p2pFuncTxMgmtFrame(IN P_ADAPTER_T prAdapter,
 
     			break;
             }
-			prMgmtTxMsdu =
+			prMgmtTxMsdu->ucStaRecIndex = 
+                           (prStaRec != NULL)?(prStaRec->ucIndex) : (STA_REC_INDEX_NOT_FOUND);
+                        prMgmtTxMsdu =
 			    p2pFuncProcessP2pProbeRsp(prAdapter, ucBssIndex, prMgmtTxMsdu);
 			ucRetryLimit = 2;
 			break;
@@ -2954,6 +2956,7 @@ p2pFuncProcessP2pProbeRsp(IN P_ADAPTER_T prAdapter,
 		bssBuildBeaconProbeRespFrameCommonIEs(prRetMsduInfo,
 						      prP2pBssInfo, prProbeRspFrame->aucDestAddr);
 
+                prRetMsduInfo->ucStaRecIndex = prMgmtTxMsdu->ucStaRecIndex;
 
 		for (u4Idx = 0; u4Idx < u4IeArraySize; u4Idx++) {
 			if (txProbeRspIETable[u4Idx].pfnAppendIE) {
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/p2p_scan.c b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/p2p_scan.c
index beee862..c87f4e8 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/p2p_scan.c
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/p2p_scan.c
@@ -71,6 +71,7 @@ scanP2pProcessBeaconAndProbeResp(IN P_ADAPTER_T prAdapter,
 				 IN P_BSS_DESC_T prBssDesc,
 				 IN P_WLAN_BEACON_FRAME_T prWlanBeaconFrame)
 {
+	BOOLEAN fgIsSkipThisBeacon = FALSE;
 	if (prBssDesc->fgIsP2PPresent) {
 		if ((prBssDesc->fgIsConnected) &&	/* P2P GC connected. */
 		    ((prWlanBeaconFrame->u2FrameCtrl & MASK_FRAME_TYPE) == MAC_FRAME_BEACON)	/* TX Beacon */
@@ -95,13 +96,14 @@ scanP2pProcessBeaconAndProbeResp(IN P_ADAPTER_T prAdapter,
 				       prBssDesc->aucSSID, prBssDesc->ucSSIDLen)))) {
 					continue;
 				}
-
 				if ((prP2pBssInfo->eCurrentOPMode == OP_MODE_INFRASTRUCTURE) &&	/* P2P GC */
-				    (prP2pBssInfo->eConnectionState == PARAM_MEDIA_STATE_CONNECTED) &&	/* Connected */
-				    (!prP2pBssInfo->ucDTIMPeriod)) {	/* First Time. */
-					prP2pBssInfo->ucDTIMPeriod = prBssDesc->ucDTIMPeriod;
-					nicPmIndicateBssConnected(prAdapter,
-								  prP2pBssInfo->ucBssIndex);
+				    (prP2pBssInfo->eConnectionState == PARAM_MEDIA_STATE_CONNECTED)){	/* Connected */
+					fgIsSkipThisBeacon = TRUE;
+					if ((!prP2pBssInfo->ucDTIMPeriod)) {	/* First Time. */
+						prP2pBssInfo->ucDTIMPeriod = prBssDesc->ucDTIMPeriod;
+						nicPmIndicateBssConnected(prAdapter,
+							prP2pBssInfo->ucBssIndex);
+					}
 				}
 
 			}
@@ -115,16 +117,17 @@ scanP2pProcessBeaconAndProbeResp(IN P_ADAPTER_T prAdapter,
 
 			if (((prWlanBeaconFrame->u2FrameCtrl & MASK_FRAME_TYPE) !=
 			     MAC_FRAME_PROBE_RSP)) {
-				/* Only report Probe Response frame to supplicant. */
+				/* Only report Probe Response frame to supplicant except passive scan. */
 				/* Probe response collect much more information. */
-				break;
+				if (fgIsSkipThisBeacon)
+					break;
 			}
 
 			rChannelInfo.ucChannelNum = prBssDesc->ucChannelNum;
 			rChannelInfo.eBand = prBssDesc->eBand;
 			prBssDesc->fgIsP2PReport = TRUE;
 
-			DBGLOG(P2P, INFO,
+			DBGLOG(P2P, STATE,
 			       ("indicate %s [%d]\n", prBssDesc->aucSSID, prBssDesc->ucChannelNum));
 
 			kalP2PIndicateBssInfo(prAdapter->prGlueInfo,
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/rlm.c b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/rlm.c
index 4c0d663..8a67601 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/rlm.c
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/rlm.c
@@ -1784,7 +1784,24 @@ rlmRecIeInfoForClient(P_ADAPTER_T prAdapter,
 		DBGLOG(RLM, INFO, ("Ch : DFS has Appeared\n"));
 	}
 #endif
+	if(!rlmDomainIsValidRfSetting(prAdapter, prBssInfo->eBand, 
+		prBssInfo->ucPrimaryChannel, prBssInfo->eBssSCO, 
+		prBssInfo->ucVhtChannelWidth, prBssInfo->ucVhtChannelFrequencyS1,
+		prBssInfo->ucVhtChannelFrequencyS2)) {
+	
+        /*Dump IE Inforamtion*/
+        DBGLOG(RLM, WARN, ("rlmRecIeInfoForClient IE Information\n"));
+        DBGLOG(RLM, WARN, ("IE Length = %d\n", u2IELength));
+        DBGLOG_MEM8(RLM, WARN, pucIE, u2IELength);
 
+        /*Error Handling for Non-predicted IE - Fixed to set 20MHz*/		 
+        prBssInfo->ucVhtChannelWidth = CW_20_40MHZ; 
+        prBssInfo->ucVhtChannelFrequencyS1 = 0;
+        prBssInfo->ucVhtChannelFrequencyS2 = 0;
+        prBssInfo->eBssSCO = CHNL_EXT_SCN;
+        prBssInfo->ucHtOpInfo1 &=
+			~(HT_OP_INFO1_SCO | HT_OP_INFO1_STA_CHNL_WIDTH);
+	}
 
 #if CFG_SUPPORT_QUIET && 0
 	if (!fgHasQuietIE) {
@@ -2151,9 +2168,17 @@ rlmProcessAssocRsp(P_ADAPTER_T prAdapter, P_SW_RFB_T prSwRfb, PUINT_8 pucIE, UIN
 	    ((prBssInfo->u2CapInfo & CAP_INFO_SHORT_SLOT_TIME)
 	     || (prBssInfo->eBand != BAND_2G4)) ? TRUE : FALSE;
 	ucPriChannel = rlmRecIeInfoForClient(prAdapter, prBssInfo, pucIE, u2IELength);
+	
+	if (prBssInfo->ucPrimaryChannel != ucPriChannel) {
+		DBGLOG(RLM, INFO,
+		("Use RF pri channel[%u].Pri channel in HT OP IE is :[%u]\n", prBssInfo->ucPrimaryChannel, ucPriChannel));
+	}
+    /*Avoid wrong primary channel info in HT operation IE info when accept association response*/
+#if 0
 	if (ucPriChannel > 0) {
 		prBssInfo->ucPrimaryChannel = ucPriChannel;
 	}
+#endif
 
 	if (!RLM_NET_IS_11N(prBssInfo) || !(prStaRec->u2HtCapInfo & HT_CAP_INFO_SUP_CHNL_WIDTH)) {
 		prBssInfo->fg40mBwAllowed = FALSE;
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/rlm_domain.c b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/rlm_domain.c
index 5769de1..049f0fa 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/rlm_domain.c
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/rlm_domain.c
@@ -603,7 +603,7 @@ COUNTRY_CH_SET_T arCountryChSets[] = {
 #include "rlm_txpwr_init.h"
 
 
-#if CFG_SUPPORT_PWR_LIMIT_COUNTRY 
+
 
 SUBBAND_CHANNEL_T g_rRlmSubBand[] = {
 
@@ -615,7 +615,7 @@ SUBBAND_CHANNEL_T g_rRlmSubBand[] = {
 	
 };
 
-#endif
+
 
 /*******************************************************************************
 *                           P R I V A T E   D A T A
@@ -1017,6 +1017,215 @@ UINT_32 rlmDomainSupOperatingClassIeFill(PUINT_8 pBuf)
 
 	return u4IeLen;
 }
+/*----------------------------------------------------------------------------*/
+/*!
+* @brief
+*
+* @param[in]
+*
+* @return (fgValid) : 0 -> inValid, 1 -> Valid
+*/
+/*----------------------------------------------------------------------------*/
+BOOLEAN
+rlmDomainCheckChannelEntryValid(
+    P_ADAPTER_T     prAdapter,
+    UINT_8          ucCentralCh
+    )
+{
+    BOOLEAN         fgValid = FALSE;
+    UINT_8          ucTemp = 0;
+    UINT_8          i;
+	/*Check Power limit table channel efficient or not*/
+
+	for (i = POWER_LIMIT_2G4; i < POWER_LIMIT_SUBAND_NUM; i++) {
+		if ((ucCentralCh >= g_rRlmSubBand[i].ucStartCh) && (ucCentralCh <= g_rRlmSubBand[i].ucEndCh)) {
+        	ucTemp = (ucCentralCh - g_rRlmSubBand[i].ucStartCh) % g_rRlmSubBand[i].ucInterval ;
+		}
+	}
+
+
+#if 0
+    /*2.4G, ex 1, 2, 3*/
+	if (ucCentralCh >= BAND_2G4_LOWER_BOUND && ucCentralCh <= BAND_2G4_UPPER_BOUND) {
+		ucTemp = 0; 
+	}
+	/*FCC- Spec : Band UNII-1, ex 36, 38, 40....*/
+	else if (ucCentralCh >= UNII1_LOWER_BOUND && ucCentralCh <= UNII1_UPPER_BOUND) {
+		ucTemp = (ucCentralCh - UNII1_LOWER_BOUND) % 2;
+	}
+	/*FCC- Spec : Band UNII-2A, ex 52, 54, 56....*/
+	else if (ucCentralCh >= UNII2A_LOWER_BOUND && ucCentralCh <= UNII2A_UPPER_BOUND) {
+		ucTemp = (ucCentralCh - UNII2A_LOWER_BOUND) % 2;
+	}
+	/*FCC- Spec : Band UNII-2C, ex 100, 102, 104....*/
+	else if (ucCentralCh >= UNII2C_LOWER_BOUND && ucCentralCh <= UNII2C_UPPER_BOUND) {
+		ucTemp = (ucCentralCh - UNII2C_LOWER_BOUND) % 2;
+	}
+	/*FCC- Spec : Band UNII-3, ex 149, 151, 153...*/
+	else if (ucCentralCh >= UNII3_LOWER_BOUND && ucCentralCh <= UNII3_UPPER_BOUND) {
+		ucTemp = (ucCentralCh - UNII3_LOWER_BOUND) % 2; 
+	}
+
+#endif
+	if (ucTemp == 0) {
+		fgValid = TRUE;
+	}
+	return fgValid;
+ 
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+* \brief
+*
+* \param[in]
+*
+* \return 
+*/
+/*----------------------------------------------------------------------------*/
+UINT_8
+rlmDomainGetCenterChannel (
+    ENUM_BAND_T         eBand,
+    UINT_8              ucPriChannel,
+    ENUM_CHNL_EXT_T     eExtend
+    )
+{
+    UINT_8      ucCenterChannel;
+
+    if (eExtend == CHNL_EXT_SCA) {
+ 
+        ucCenterChannel = ucPriChannel + 2;
+    }
+    else if (eExtend == CHNL_EXT_SCB) {
+  
+        ucCenterChannel = ucPriChannel - 2;
+    }
+    else {
+ 
+        ucCenterChannel = ucPriChannel;
+    }
+
+    return ucCenterChannel;
+}
+ 
+/*----------------------------------------------------------------------------*/
+/*!
+* \brief
+*
+* \param[in]
+*
+* \return 
+*/
+/*----------------------------------------------------------------------------*/
+BOOLEAN
+rlmDomainIsValidRfSetting (
+	P_ADAPTER_T 	     prAdapter,
+    ENUM_BAND_T          eBand,
+    UINT_8               ucPriChannel,
+    ENUM_CHNL_EXT_T      eExtend,
+    ENUM_CHANNEL_WIDTH_T eChannelWidth,
+    UINT_8               ucChannelS1,
+    UINT_8               ucChannelS2
+    )
+{
+	UINT_8  ucCenterChannel;
+	UINT_8  ucUpperChannel;
+	UINT_8  ucLowerChannel;
+	BOOLEAN fgValidChannel = TRUE;
+	BOOLEAN fgUpperChannel = TRUE;
+	BOOLEAN fgLowerChannel = TRUE;
+	BOOLEAN fgValidBW      = TRUE;
+	BOOLEAN fgValidRfSetting = TRUE;
+	UINT_32 u4PrimaryOffset;
+	
+	/*DBG msg for Channel InValid*/
+	if(eChannelWidth == CW_20_40MHZ) {
+		
+		ucCenterChannel = rlmDomainGetCenterChannel(eBand, ucPriChannel, eExtend);
+
+		/* Check Central Channel Valid or Not*/
+		fgValidChannel = rlmDomainCheckChannelEntryValid(prAdapter, ucCenterChannel);
+		if(fgValidChannel == FALSE) {
+			DBGLOG(RLM, WARN, ("Rf: CentralCh=%d\n", ucCenterChannel));
+		}
+
+		/* Check Upper Channel and Lower Channel*/
+		switch(eExtend) {
+			case CHNL_EXT_SCA:
+				ucUpperChannel = ucPriChannel + 4;
+				ucLowerChannel = ucPriChannel;
+				break;
+			case CHNL_EXT_SCB:
+				ucUpperChannel = ucPriChannel;
+				ucLowerChannel = ucPriChannel - 4;
+				break;
+			default:
+				ucUpperChannel = ucPriChannel;
+				ucLowerChannel = ucPriChannel;
+				break;
+		}
+		
+		fgUpperChannel = rlmDomainCheckChannelEntryValid(prAdapter, ucUpperChannel);
+		if(fgUpperChannel == FALSE) {
+			DBGLOG(RLM, WARN, ("Rf: UpperCh=%d\n", ucUpperChannel));
+		}
+		
+		fgLowerChannel = rlmDomainCheckChannelEntryValid(prAdapter, ucLowerChannel);
+		if(fgLowerChannel == FALSE) {
+			DBGLOG(RLM, WARN, ("Rf: LowerCh=%d\n", ucLowerChannel));
+		}
+
+	}
+	else if(eChannelWidth == CW_80MHZ){
+		ucCenterChannel = ucChannelS1;
+
+		/* Check Central Channel Valid or Not*/
+		fgValidChannel = rlmDomainCheckChannelEntryValid(prAdapter, ucCenterChannel);
+		if(fgValidChannel == FALSE) {
+			DBGLOG(RLM, WARN, ("Rf: CentralCh=%d\n", ucCenterChannel));
+		}
+	}
+	else if(eChannelWidth == CW_160MHZ){
+		ucCenterChannel = ucChannelS2;
+		
+		/* Check Central Channel Valid or Not*/
+		/*TODo*/
+	}
+
+    /* Check BW Setting Correct or Not*/
+	if(eBand == BAND_2G4) {
+		if(eChannelWidth != CW_20_40MHZ) {
+			fgValidBW = FALSE;
+			DBGLOG(RLM, WARN, ("Rf: B=%d, W=%d\n", eBand, eChannelWidth));
+		}
+	}
+	else {
+		if(eChannelWidth == CW_80MHZ) {
+			u4PrimaryOffset = CAL_CH_OFFSET_80M(ucPriChannel, ucCenterChannel);
+			if(u4PrimaryOffset > 4) {
+				fgValidBW = FALSE;
+				DBGLOG(RLM, WARN, ("Rf: PriOffSet=%d, W=%d\n", 
+				u4PrimaryOffset, eChannelWidth));
+			}
+		} 
+		else if (eChannelWidth == CW_160MHZ) {
+			u4PrimaryOffset = CAL_CH_OFFSET_160M(ucPriChannel, ucCenterChannel);
+			if(u4PrimaryOffset > 8) {
+				fgValidBW = FALSE;
+				DBGLOG(RLM, WARN, ("Rf: PriOffSet=%d, W=%d\n", 
+				u4PrimaryOffset, eChannelWidth));
+			}
+		}
+	}
+
+	if((fgValidBW == FALSE) || (fgValidChannel == FALSE) || (fgUpperChannel == FALSE) || (fgLowerChannel == FALSE)) {
+		fgValidRfSetting = FALSE;
+	}
+
+	return fgValidRfSetting;
+			
+}
+
 
 #if CFG_SUPPORT_PWR_LIMIT_COUNTRY
 
@@ -1190,63 +1399,6 @@ rlmDomainPwrLimitDefaultTableDecision(
 *
 * @param[in]
 *
-* @return (fgValid) : 0 -> inValid, 1 -> Valid
-*/
-/*----------------------------------------------------------------------------*/
-BOOLEAN
-rlmDomainCheckChannelEntryValid(
-    P_ADAPTER_T     prAdapter,
-    UINT_8          ucCentralCh
-    )
-{
-    BOOLEAN         fgValid = FALSE;
-	UINT_8          ucTemp = 0;
-    UINT_8          i;
-	/*Check Power limit table channel efficient or not*/
-
-	for (i = POWER_LIMIT_2G4; i < POWER_LIMIT_SUBAND_NUM; i++) {
-		if ((ucCentralCh >= g_rRlmSubBand[i].ucStartCh) && (ucCentralCh <= g_rRlmSubBand[i].ucEndCh)) {
-        	ucTemp = (ucCentralCh - g_rRlmSubBand[i].ucStartCh) % g_rRlmSubBand[i].ucInterval ;
-		}
-	}
-
-
-#if 0
-    /*2.4G, ex 1, 2, 3*/
-	if (ucCentralCh >= BAND_2G4_LOWER_BOUND && ucCentralCh <= BAND_2G4_UPPER_BOUND) {
-		ucTemp = 0; 
-	}
-	/*FCC- Spec : Band UNII-1, ex 36, 38, 40....*/
-	else if (ucCentralCh >= UNII1_LOWER_BOUND && ucCentralCh <= UNII1_UPPER_BOUND) {
-		ucTemp = (ucCentralCh - UNII1_LOWER_BOUND) % 2;
-	}
-	/*FCC- Spec : Band UNII-2A, ex 52, 54, 56....*/
-	else if (ucCentralCh >= UNII2A_LOWER_BOUND && ucCentralCh <= UNII2A_UPPER_BOUND) {
-		ucTemp = (ucCentralCh - UNII2A_LOWER_BOUND) % 2;
-	}
-	/*FCC- Spec : Band UNII-2C, ex 100, 102, 104....*/
-	else if (ucCentralCh >= UNII2C_LOWER_BOUND && ucCentralCh <= UNII2C_UPPER_BOUND) {
-		ucTemp = (ucCentralCh - UNII2C_LOWER_BOUND) % 2;
-	}
-	/*FCC- Spec : Band UNII-3, ex 149, 151, 153...*/
-	else if (ucCentralCh >= UNII3_LOWER_BOUND && ucCentralCh <= UNII3_UPPER_BOUND) {
-		ucTemp = (ucCentralCh - UNII3_LOWER_BOUND) % 2; 
-	}
-
-#endif
-	if (ucTemp == 0) {
-		fgValid = TRUE;
-	}
-
-	return fgValid;
- 
-}
-/*----------------------------------------------------------------------------*/
-/*!
-* @brief
-*
-* @param[in]
-*
 * @return (none) 
 */
 /*----------------------------------------------------------------------------*/
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/saa_fsm.c b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/saa_fsm.c
index 06f3618..88e08c3 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/saa_fsm.c
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/saa_fsm.c
@@ -824,6 +824,11 @@ saaFsmRunEventTxDone(IN P_ADAPTER_T prAdapter,
 
 	DBGLOG(SAA, LOUD, ("EVENT-TX DONE: Current Time = %d\n", kalGetTimeTick()));
 
+    /* Trigger statistics log if Auth/Assoc Tx failed */
+    if(rTxDoneStatus != TX_RESULT_SUCCESS) {
+        wlanTriggerStatsLog(prAdapter, prAdapter->rWifiVar.u4StatsLogDuration);
+    }
+
 	eNextState = prStaRec->eAuthAssocState;
 
 	switch (prStaRec->eAuthAssocState) {
@@ -952,6 +957,9 @@ VOID saaFsmRunEventTxReqTimeOut(IN P_ADAPTER_T prAdapter, IN ULONG plParamPtr)
 
 	DBGLOG(SAA, LOUD, ("EVENT-TIMER: TX REQ TIMEOUT, Current Time = %d\n", kalGetTimeTick()));
 
+    /* Trigger statistics log if Auth/Assoc Tx timeout */
+    wlanTriggerStatsLog(prAdapter, prAdapter->rWifiVar.u4StatsLogDuration);
+
 	switch (prStaRec->eAuthAssocState) {
 	case SAA_STATE_SEND_AUTH1:
 	case SAA_STATE_SEND_AUTH3:
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/scan.c b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/scan.c
index 71a41ff..78ec754 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/scan.c
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/mgmt/scan.c
@@ -814,7 +814,6 @@ VOID scnFreeAllPendingScanRquests (IN P_ADAPTER_T prAdapter)
     P_SCAN_INFO_T prScanInfo;
     P_MSG_HDR_T prMsgHdr;
     P_MSG_SCN_SCAN_REQ prScanReqMsg;
-    P_MSG_SCN_SCAN_REQ_V2 prScanReqV2Msg;
 
 
     prScanInfo = &(prAdapter->rWifiVar.rScanInfo);
@@ -2079,9 +2078,23 @@ P_BSS_DESC_T scanAddToBssDesc(IN P_ADAPTER_T prAdapter, IN P_SW_RFB_T prSwRfb)
 			}
 		}
 	}
+	
+	/* 4 <5> Check IE information corret or not */
+	if (!rlmDomainIsValidRfSetting(prAdapter, prBssDesc->eBand, prBssDesc->ucChannelNum, prBssDesc->eSco, 
+		prBssDesc->eChannelWidth, prBssDesc->ucCenterFreqS1, prBssDesc->ucCenterFreqS2)) {
+		/*Dump IE Inforamtion*/
+		DBGLOG(RLM, WARN, ("ScanAddToBssDesc IE Information\n"));
+		DBGLOG(RLM, WARN, ("IE Length = %d\n", u2IELength));
+		DBGLOG_MEM8(RLM, WARN, pucIE, u2IELength);
+	
+		/*Error Handling for Non-predicted IE - Fixed to set 20MHz*/		 
+		prBssDesc->eChannelWidth = CW_20_40MHZ; 
+		prBssDesc->ucCenterFreqS1 = 0;
+		prBssDesc->ucCenterFreqS2 = 0;
+		prBssDesc->eSco = CHNL_EXT_SCN;
+	}
 
-
-	/* 4 <5> PHY type setting */
+	/* 4 <6> PHY type setting */
 	prBssDesc->ucPhyTypeSet = 0;
 
 	if (BAND_2G4 == prBssDesc->eBand) {
@@ -2126,7 +2139,7 @@ P_BSS_DESC_T scanAddToBssDesc(IN P_ADAPTER_T prAdapter, IN P_SW_RFB_T prSwRfb)
 	}
 
 
-	/* 4 <6> Update BSS_DESC_T's Last Update TimeStamp. */
+	/* 4 <7> Update BSS_DESC_T's Last Update TimeStamp. */
 	GET_CURRENT_SYSTIME(&prBssDesc->rUpdateTime);
 
 	return prBssDesc;
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/nic/cmd_buf.c b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/nic/cmd_buf.c
index df1ab98..3ab52db 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/nic/cmd_buf.c
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/nic/cmd_buf.c
@@ -142,7 +142,6 @@ P_CMD_INFO_T cmdBufAllocateCmdInfo(IN P_ADAPTER_T prAdapter, IN UINT_32 u4Length
 
 	DEBUGFUNC("cmdBufAllocateCmdInfo");
 
-
 	ASSERT(prAdapter);
 
 	KAL_ACQUIRE_SPIN_LOCK(prAdapter, SPIN_LOCK_CMD_RESOURCE);
@@ -151,30 +150,34 @@ P_CMD_INFO_T cmdBufAllocateCmdInfo(IN P_ADAPTER_T prAdapter, IN UINT_32 u4Length
 
 	if (prCmdInfo) {
 		/* Setup initial value in CMD_INFO_T */
-		/* Start address of allocated memory */
-		prCmdInfo->pucInfoBuffer = cnmMemAlloc(prAdapter, RAM_TYPE_BUF, u4Length);
-
-		if (prCmdInfo->pucInfoBuffer == NULL) {
-			KAL_ACQUIRE_SPIN_LOCK(prAdapter, SPIN_LOCK_CMD_RESOURCE);
-			QUEUE_INSERT_TAIL(&prAdapter->rFreeCmdList, &prCmdInfo->rQueEntry);
-			KAL_RELEASE_SPIN_LOCK(prAdapter, SPIN_LOCK_CMD_RESOURCE);
-
-			prCmdInfo = NULL;
-		} else {
-			prCmdInfo->u2InfoBufLen = 0;
-			prCmdInfo->fgIsOid = FALSE;
-			prCmdInfo->fgDriverDomainMCR = FALSE;
-		}
+		prCmdInfo->u2InfoBufLen = 0;
+		prCmdInfo->fgIsOid = FALSE;
+		prCmdInfo->fgDriverDomainMCR = FALSE;        
+
+        if(u4Length) {
+    		/* Start address of allocated memory */
+    		prCmdInfo->pucInfoBuffer = 
+    		    cnmMemAlloc(prAdapter, RAM_TYPE_BUF, u4Length);
+
+    		if (prCmdInfo->pucInfoBuffer == NULL) {
+    			KAL_ACQUIRE_SPIN_LOCK(prAdapter, SPIN_LOCK_CMD_RESOURCE);
+    			QUEUE_INSERT_TAIL(&prAdapter->rFreeCmdList, &prCmdInfo->rQueEntry);
+    			KAL_RELEASE_SPIN_LOCK(prAdapter, SPIN_LOCK_CMD_RESOURCE);
+
+    			prCmdInfo = NULL;
+    		}
+        }
+        else {
+            prCmdInfo->pucInfoBuffer = NULL;
+        }
 	}
 
 	if (prCmdInfo) {
-		DBGLOG(MEM, INFO,
-		       ("CMD[0x%p] allocated! LEN[%04u], Rest[%u]\n", prCmdInfo, u4Length,
-			prAdapter->rFreeCmdList.u4NumElem));
+		DBGLOG(MEM, INFO, ("CMD[0x%p] allocated! LEN[%04u], Rest[%u]\n", 
+            prCmdInfo, u4Length, prAdapter->rFreeCmdList.u4NumElem));
 	} else {
-		DBGLOG(MEM, INFO,
-		       ("CMD allocation failed! LEN[%04u], Rest[%u]\n", u4Length,
-			prAdapter->rFreeCmdList.u4NumElem));
+		DBGLOG(MEM, INFO, ("CMD allocation failed! LEN[%04u], Rest[%u]\n", 
+            u4Length, prAdapter->rFreeCmdList.u4NumElem));
 	}
 
 	return prCmdInfo;
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/nic/nic_cmd_event.c b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/nic/nic_cmd_event.c
index 41799cf..1ab7048 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/nic/nic_cmd_event.c
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/nic/nic_cmd_event.c
@@ -681,11 +681,7 @@ nicCmdEventQueryLinkSpeed(IN P_ADAPTER_T prAdapter,
 		prGlueInfo = prAdapter->prGlueInfo;
 		pu4LinkSpeed = (PUINT_32) (prCmdInfo->pvInformationBuffer);
 
-		if (prLinkQuality->u2LinkSpeed == 0) {
-			*pu4LinkSpeed = 10000;	/* 10K * 100bps = 1Mbps */
-		} else {
-			*pu4LinkSpeed = prLinkQuality->u2LinkSpeed * 5000;
-		}
+        *pu4LinkSpeed = prLinkQuality->u2LinkSpeed * 5000;
 
 		u4QueryInfoLen = sizeof(UINT_32);
 
@@ -1836,14 +1832,16 @@ nicCmdEventQueryStaStatistics(IN P_ADAPTER_T prAdapter,
 
 			prStaRec = cnmGetStaRecByIndex(prAdapter, prEvent->ucStaRecIdx);
 
-			/*link layer statistics*/
-			for(eAci = 0; eAci < WMM_AC_INDEX_NUM; eAci++) {
-				prStaStatistics->arLinkStatistics[eAci].u4TxFailMsdu = prEvent->arLinkStatistics[eAci].u4TxFailMsdu;
-				prStaStatistics->arLinkStatistics[eAci].u4TxRetryMsdu = prEvent->arLinkStatistics[eAci].u4TxRetryMsdu;  
+            if(prStaRec) {
+            	/*link layer statistics*/
+            	for(eAci = 0; eAci < WMM_AC_INDEX_NUM; eAci++) {
+            		prStaStatistics->arLinkStatistics[eAci].u4TxFailMsdu = prEvent->arLinkStatistics[eAci].u4TxFailMsdu;
+            		prStaStatistics->arLinkStatistics[eAci].u4TxRetryMsdu = prEvent->arLinkStatistics[eAci].u4TxRetryMsdu;  
 
-				/*for dump bss statistics*/
-				prStaRec->arLinkStatistics[eAci].u4TxFailMsdu = prEvent->arLinkStatistics[eAci].u4TxFailMsdu;
-				prStaRec->arLinkStatistics[eAci].u4TxRetryMsdu = prEvent->arLinkStatistics[eAci].u4TxRetryMsdu;                  
+            		/*for dump bss statistics*/
+            		prStaRec->arLinkStatistics[eAci].u4TxFailMsdu = prEvent->arLinkStatistics[eAci].u4TxFailMsdu;
+            		prStaRec->arLinkStatistics[eAci].u4TxRetryMsdu = prEvent->arLinkStatistics[eAci].u4TxRetryMsdu;                  
+            	}
 			}
 
 			if (prEvent->u4TxCount) {
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/nic/nic_rx.c b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/nic/nic_rx.c
index 29a0e3c..959b0d6 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/nic/nic_rx.c
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/nic/nic_rx.c
@@ -1926,9 +1926,7 @@ VOID nicRxProcessForwardPkt(IN P_ADAPTER_T prAdapter, IN P_SW_RFB_T prSwRfb)
     prTxCtrl = &prAdapter->rTxCtrl;
     prRxCtrl = &prAdapter->rRxCtrl;
 
-    KAL_ACQUIRE_SPIN_LOCK(prAdapter, SPIN_LOCK_TX_MSDU_INFO_LIST);
-    QUEUE_REMOVE_HEAD(&prTxCtrl->rFreeMsduInfoList, prMsduInfo, P_MSDU_INFO_T);
-    KAL_RELEASE_SPIN_LOCK(prAdapter, SPIN_LOCK_TX_MSDU_INFO_LIST);
+    prMsduInfo = cnmPktAlloc(prAdapter, 0);
 
 	if (prMsduInfo &&
        kalProcessRxPacket(prAdapter->prGlueInfo,
@@ -1939,13 +1937,12 @@ VOID nicRxProcessForwardPkt(IN P_ADAPTER_T prAdapter, IN P_SW_RFB_T prSwRfb)
 			       CFG_RX_RETAINED_PKT_THRESHOLD ? TRUE : FALSE,
                 prSwRfb->aeCSUM) == WLAN_STATUS_SUCCESS) {
 
-        prMsduInfo->eSrc = TX_PACKET_FORWARDING;
-
 		/* parsing forward frame */
 		wlanProcessTxFrame(prAdapter, (P_NATIVE_PACKET) (prSwRfb->pvPacket));
 		/* pack into MSDU_INFO_T */
 		nicTxFillMsduInfo(prAdapter, prMsduInfo, (P_NATIVE_PACKET) (prSwRfb->pvPacket));
 
+        prMsduInfo->eSrc = TX_PACKET_FORWARDING;
         prMsduInfo->ucBssIndex = secGetBssIdxByWlanIdx(prAdapter, prSwRfb->ucWlanIdx);
 
 		/* release RX buffer (to rIndicatedRfbList) */
@@ -2503,7 +2500,7 @@ VOID nicRxProcessDataPacket(IN P_ADAPTER_T prAdapter, IN OUT P_SW_RFB_T prSwRfb)
 VOID nicRxProcessEventPacket(IN P_ADAPTER_T prAdapter, IN OUT P_SW_RFB_T prSwRfb)
 {
     P_CMD_INFO_T prCmdInfo;
-    P_MSDU_INFO_T prMsduInfo;
+    //P_MSDU_INFO_T prMsduInfo;
     P_WIFI_EVENT_T prEvent;
     P_GLUE_INFO_T prGlueInfo;
     BOOLEAN fgIsNewVersion;
@@ -2866,6 +2863,9 @@ VOID nicRxProcessEventPacket(IN P_ADAPTER_T prAdapter, IN OUT P_SW_RFB_T prSwRfb
         break;
 
     case EVENT_ID_TX_DONE:
+#if 1
+        nicTxProcessTxDoneEvent(prAdapter, prEvent);
+#else
         {
             P_EVENT_TX_DONE_T prTxDone;
 			prTxDone = (P_EVENT_TX_DONE_T) (prEvent->aucBuffer);
@@ -2889,12 +2889,17 @@ VOID nicRxProcessEventPacket(IN P_ADAPTER_T prAdapter, IN OUT P_SW_RFB_T prSwRfb
 
 			if (prMsduInfo) {
 				prMsduInfo->pfTxDoneHandler(prAdapter, prMsduInfo,
-							    (ENUM_TX_RESULT_CODE_T) (prTxDone->
-										     ucStatus));
-
-                cnmMgtPktFree(prAdapter, prMsduInfo);
+							    (ENUM_TX_RESULT_CODE_T)(prTxDone->ucStatus));
+                
+                if(prMsduInfo->eSrc == TX_PACKET_MGMT) {
+                    cnmMgtPktFree(prAdapter, prMsduInfo);
+                }
+                else {
+                    nicTxReturnMsduInfo(prAdapter, prMsduInfo);
+                }
             }
         }
+#endif
         break;
 
     case EVENT_ID_SLEEPY_INFO:
@@ -3269,7 +3274,7 @@ VOID nicRxProcessEventPacket(IN P_ADAPTER_T prAdapter, IN OUT P_SW_RFB_T prSwRfb
             u2MsgSize = prEventDebugMsg->u2MsgSize;
             pucMsg = prEventDebugMsg->aucMsg;
 
-			DBGLOG(SW4, INFO, ("DEBUG_MSG Id %u Type %u Fg 0x%x Val 0x%x Size %u\n",
+			DBGLOG(SW4, TRACE, ("DEBUG_MSG Id %u Type %u Fg 0x%x Val 0x%x Size %u\n",
 					   u2DebugMsgId, ucMsgType, ucFlags, u4Value, u2MsgSize));
 
 			if (u2MsgSize <= DEBUG_MSG_SIZE_MAX) {
@@ -3281,26 +3286,10 @@ VOID nicRxProcessEventPacket(IN P_ADAPTER_T prAdapter, IN OUT P_SW_RFB_T prSwRfb
                     pucMsg[u2MsgSize] = '\0';
                     DBGLOG(SW4, INFO, ("%s\n", pucMsg));
 				} else if (ucMsgType == DEBUG_MSG_TYPE_MEM32) {
-
-#if CFG_SUPPORT_XLOG
-					/* dumpMemory32(ANDROID_LOG_INFO, pucMsg, u2MsgSize); */
-#else
-					/* dumpMemory32(pucMsg, u2MsgSize); */
-#endif
 					DBGLOG_MEM32(SW4, INFO, pucMsg, u2MsgSize);
 				} else if (prEventDebugMsg->ucMsgType == DEBUG_MSG_TYPE_MEM8) {
-#if CFG_SUPPORT_XLOG
-/* dumpMemory8(ANDROID_LOG_INFO, pucMsg, u2MsgSize); */
-#else
-					/* dumpMemory8(pucMsg, u2MsgSize); */
-#endif
 					DBGLOG_MEM8(SW4, INFO, pucMsg, u2MsgSize);
 				} else {
-#if CFG_SUPPORT_XLOG
-					/* dumpMemory32(ANDROID_LOG_INFO, pucMsg, u2MsgSize); */
-#else
-					/* dumpMemory32(pucMsg, u2MsgSize); */
-#endif
 					DBGLOG_MEM32(SW4, INFO, pucMsg, u2MsgSize);
                 }
             } /* DEBUG_MSG_SIZE_MAX */
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/nic/nic_tx.c b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/nic/nic_tx.c
index 56c6533..3b4d054 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/nic/nic_tx.c
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/nic/nic_tx.c
@@ -1402,9 +1402,8 @@ UINT_8 nicTxGetCmdResourceType(IN P_CMD_INFO_T prCmdInfo)
             break;
             
         case COMMAND_TYPE_MANAGEMENT_FRAME:
-		ucTC =
-		    nicTxGetFrameResourceType(FRAME_TYPE_MMPDU,
-					      (P_MSDU_INFO_T) prCmdInfo->prPacket);
+		    ucTC = nicTxGetFrameResourceType(FRAME_TYPE_MMPDU, 
+                        prCmdInfo->prMsduInfo);
             break;
 
         default:
@@ -1553,7 +1552,7 @@ WLAN_STATUS nicTxMsduInfoListMthread(IN P_ADAPTER_T prAdapter, IN P_MSDU_INFO_T
             break;
         }
 
-        nicTxFillDesc(prAdapter, prMsduInfo, prMsduInfo->ucTxDescBuffer, NULL);
+        nicTxFillDesc(prAdapter, prMsduInfo, prMsduInfo->aucTxDescBuffer, NULL);
 
         prMsduInfo = prNextMsduInfo;
     }
@@ -1598,14 +1597,13 @@ UINT_32 nicTxMsduQueueMthread(IN P_ADAPTER_T prAdapter)
     u4TxLoopCount = prAdapter->rWifiVar.u4HifTxloopCount;
 
     while(u4TxLoopCount--) {
-
         while(QUEUE_IS_NOT_EMPTY((&(prAdapter->rTxP0Queue)))) {
-    KAL_ACQUIRE_SPIN_LOCK(prAdapter, SPIN_LOCK_TX_PORT_QUE);
-    QUEUE_MOVE_ALL((prDataPort0), (&(prAdapter->rTxP0Queue)));
-    KAL_RELEASE_SPIN_LOCK(prAdapter, SPIN_LOCK_TX_PORT_QUE);
+            KAL_ACQUIRE_SPIN_LOCK(prAdapter, SPIN_LOCK_TX_PORT_QUE);
+            QUEUE_MOVE_ALL((prDataPort0), (&(prAdapter->rTxP0Queue)));
+            KAL_RELEASE_SPIN_LOCK(prAdapter, SPIN_LOCK_TX_PORT_QUE);
 
-        nicTxMsduQueue(prAdapter, 0, prDataPort0);
-    }
+            nicTxMsduQueue(prAdapter, 0, prDataPort0);
+        }
 
         while(QUEUE_IS_NOT_EMPTY((&(prAdapter->rTxP1Queue)))) {
             KAL_ACQUIRE_SPIN_LOCK(prAdapter, SPIN_LOCK_TX_PORT_QUE);
@@ -1613,7 +1611,7 @@ UINT_32 nicTxMsduQueueMthread(IN P_ADAPTER_T prAdapter)
             KAL_RELEASE_SPIN_LOCK(prAdapter, SPIN_LOCK_TX_PORT_QUE);
 
             nicTxMsduQueue(prAdapter, 1, prDataPort0);
-    }
+        }
     }
     
     return WLAN_STATUS_SUCCESS;
@@ -1633,9 +1631,9 @@ UINT_32 nicTxMsduQueueMthread(IN P_ADAPTER_T prAdapter)
 */
 /*----------------------------------------------------------------------------*/
 VOID
-nicTxComposeDesc(IN P_ADAPTER_T prAdapter,
-    IN P_MSDU_INFO_T        prMsduInfo,
-		 IN UINT_8 ucTxDescLength, IN BOOLEAN fgIsTemplate, OUT PUINT_8 prTxDescBuffer)
+nicTxComposeDesc(IN P_ADAPTER_T prAdapter, IN P_MSDU_INFO_T prMsduInfo,
+    IN UINT_8 ucTxDescLength, IN BOOLEAN fgIsTemplate, 
+    OUT PUINT_8 prTxDescBuffer)
 {
     P_HW_MAC_TX_DESC_T prTxDesc;
     P_STA_RECORD_T prStaRec;
@@ -1787,36 +1785,37 @@ nicTxComposeDesc(IN P_ADAPTER_T prAdapter,
 
 VOID
 nicTxComposeSecurityFrameDesc(IN P_ADAPTER_T prAdapter,
-    IN P_CMD_INFO_T         prCmdInfo,
-			      OUT PUINT_8 prTxDescBuffer, OUT PUINT_8 pucTxDescLength)
+    IN P_CMD_INFO_T prCmdInfo, OUT PUINT_8 prTxDescBuffer, 
+    OUT PUINT_8 pucTxDescLength)
 {
-	P_HW_MAC_TX_DESC_T prTxDesc = (P_HW_MAC_TX_DESC_T) prTxDescBuffer;
+	P_HW_MAC_TX_DESC_T prTxDesc = (P_HW_MAC_TX_DESC_T)prTxDescBuffer;
 	UINT_8 ucTxDescAndPaddingLength =
 	    NIC_TX_DESC_LONG_FORMAT_LENGTH + NIC_TX_DESC_PADDING_LENGTH;
-    P_STA_RECORD_T prStaRec = cnmGetStaRecByIndex(prAdapter, prCmdInfo->ucStaRecIndex);
+    //P_STA_RECORD_T prStaRec = cnmGetStaRecByIndex(prAdapter, prCmdInfo->ucStaRecIndex);
     P_BSS_INFO_T prBssInfo;
     UINT_8 ucTid = 0;
     UINT_8 ucTempTC = TC4_INDEX;
-    P_SEC_FRAME_INFO_T prSecFrameInfo;
     P_NATIVE_PACKET prNativePacket;
     UINT_8 ucEtherTypeOffsetInWord;
+    P_MSDU_INFO_T prMsduInfo;
 
-	prSecFrameInfo = (P_SEC_FRAME_INFO_T) prCmdInfo->pucInfoBuffer;
-
-    prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, prCmdInfo->ucBssIndex);            
-    prNativePacket = prCmdInfo->prPacket;
+    prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, prCmdInfo->ucBssIndex);
+    prMsduInfo = prCmdInfo->prMsduInfo;
+    prNativePacket = prMsduInfo->prPacket;
 
     ASSERT(prNativePacket);
 
     kalMemZero(prTxDesc, ucTxDescAndPaddingLength);
 
 	/* WLAN index */
-	if (prStaRec) {
-		/* UC to a connected peer */
-        HAL_MAC_TX_DESC_SET_WLAN_INDEX(prTxDesc, prStaRec->ucWlanIndex);        
-        /* Redirect Security frame to TID0 */
-		/* ucTempTC = arNetwork2TcResource[prStaRec->ucBssIndex][aucTid2ACI[ucTid]]; */
-    }
+	prMsduInfo->ucWlanIndex = nicTxGetWlanIdx(prAdapter, prMsduInfo->ucBssIndex, 
+	    prMsduInfo->ucStaRecIndex);
+
+	/* UC to a connected peer */
+    HAL_MAC_TX_DESC_SET_WLAN_INDEX(prTxDesc, prMsduInfo->ucWlanIndex);
+    /* Redirect Security frame to TID0 */
+	/* ucTempTC = arNetwork2TcResource[prStaRec->ucBssIndex][aucTid2ACI[ucTid]]; */
+        
 	/* Tx byte count */
 	HAL_MAC_TX_DESC_SET_TX_BYTE_COUNT(prTxDesc,
 					  ucTxDescAndPaddingLength + prCmdInfo->u2InfoBufLen);
@@ -1830,17 +1829,16 @@ nicTxComposeSecurityFrameDesc(IN P_ADAPTER_T prAdapter,
     HAL_MAC_TX_DESC_SET_PORT_INDEX(prTxDesc, arTcResourceControl[ucTempTC].ucDestPortIndex);
     HAL_MAC_TX_DESC_SET_QUEUE_INDEX(prTxDesc, arTcResourceControl[ucTempTC].ucDestQueueIndex);
 
-	/* Protection bit */
-	if (prSecFrameInfo->fgIsProtected) {
-        HAL_MAC_TX_DESC_SET_PROTECTION(prTxDesc);
-    }
 	/* Header format */
     HAL_MAC_TX_DESC_SET_HEADER_FORMAT(prTxDesc, HEADER_FORMAT_NON_802_11);
 
 	/* Long Format */
     HAL_MAC_TX_DESC_SET_LONG_FORMAT(prTxDesc);
 
-	if (!GLUE_GET_PKT_IS_802_3(prNativePacket)) {
+	/* Update Packet option */
+    nicTxFillDescByPktOption(prMsduInfo, prTxDesc);
+
+	if (!GLUE_TEST_PKT_FLAG(prNativePacket, ENUM_PKT_802_3)) {
 		/* Set EthernetII */
         HAL_MAC_TX_DESC_SET_ETHERNET_II(prTxDesc);
     }
@@ -1852,12 +1850,11 @@ nicTxComposeSecurityFrameDesc(IN P_ADAPTER_T prAdapter,
 
 	/* Remaining TX time */
 	HAL_MAC_TX_DESC_SET_REMAINING_LIFE_TIME_IN_MS(prTxDesc,
-						      arTcTrafficSettings[ucTempTC].
-						      u4RemainingTxTime);
+	    arTcTrafficSettings[ucTempTC].u4RemainingTxTime);
 
 	/* Tx count limit */
 	HAL_MAC_TX_DESC_SET_REMAINING_TX_COUNT(prTxDesc,
-					       arTcTrafficSettings[ucTempTC].ucTxCountLimit);
+		arTcTrafficSettings[ucTempTC].ucTxCountLimit);
 
     /* Set lowest BSS basic rate */
     HAL_MAC_TX_DESC_SET_FR_RATE(prTxDesc, prBssInfo->u2HwDefaultFixedRateCode);
@@ -1867,11 +1864,33 @@ nicTxComposeSecurityFrameDesc(IN P_ADAPTER_T prAdapter,
 	/* Own MAC */
     HAL_MAC_TX_DESC_SET_OWN_MAC_INDEX(prTxDesc, prBssInfo->ucOwnMacIndex); 
 
+	/* PID */
+	if (prMsduInfo->pfTxDoneHandler) {
+        prMsduInfo->ucPID = nicTxAssignPID(prAdapter, prMsduInfo->ucWlanIndex);
+        HAL_MAC_TX_DESC_SET_PID(prTxDesc, prMsduInfo->ucPID);
+        HAL_MAC_TX_DESC_SET_TXS_TO_MCU(prTxDesc);
+    }
+
 	if (pucTxDescLength) {
         *pucTxDescLength = ucTxDescAndPaddingLength;
     }
 }
 
+BOOLEAN
+nicTxIsTXDTemplateAllowd(IN P_ADAPTER_T prAdapter, 
+    IN P_MSDU_INFO_T prMsduInfo, IN P_STA_RECORD_T prStaRec){
+
+    if(prMsduInfo->fgIsTXDTemplateValid && (prMsduInfo->ucControlFlag == 0) 
+        && prStaRec && !prMsduInfo->pfTxDoneHandler) {
+
+        return TRUE;
+    }
+    else {
+        return FALSE;
+    }
+}
+
+
 /*----------------------------------------------------------------------------*/
 /*!
 * @brief In this function, we'll compose the Tx descriptor of the MSDU.
@@ -1901,7 +1920,7 @@ nicTxFillDesc(IN P_ADAPTER_T prAdapter,
 *------------------------------------------------------------------------------
 */
     /* Get TXD from pre-allocated template */
-	if (prMsduInfo->fgIsTXDTemplateValid && (prMsduInfo->ucControlFlag == 0) && prStaRec) {
+	if (nicTxIsTXDTemplateAllowd(prAdapter, prMsduInfo, prStaRec)) {
         prTxDescTemplate = prStaRec->aprTxDescTemplate[prMsduInfo->ucUserPriority];
     
 		if (HAL_MAC_TX_DESC_IS_LONG_FORMAT(prTxDescTemplate)) {
@@ -1964,19 +1983,18 @@ nicTxFillDesc(IN P_ADAPTER_T prAdapter,
 }
 
 VOID
-nicTxCopyDesc(IN P_ADAPTER_T prAdapter,
-    IN P_HW_MAC_TX_DESC_T   prTarTxDesc,
-	      IN P_HW_MAC_TX_DESC_T prSrcTxDesc, OUT PUINT_8 pucTxDescLength)
+nicTxCopyDesc(IN P_ADAPTER_T prAdapter, IN PUINT_8 pucTarTxDesc, 
+    IN PUINT_8 pucSrcTxDesc, OUT PUINT_8 pucTxDescLength)
 {
     UINT_8 ucTxDescLength;
 
-	if (HAL_MAC_TX_DESC_IS_LONG_FORMAT((P_HW_MAC_TX_DESC_T) prSrcTxDesc)) {
+	if (HAL_MAC_TX_DESC_IS_LONG_FORMAT((P_HW_MAC_TX_DESC_T)pucSrcTxDesc)) {
         ucTxDescLength = NIC_TX_DESC_LONG_FORMAT_LENGTH;
 	} else {
         ucTxDescLength = NIC_TX_DESC_SHORT_FORMAT_LENGTH;
     }
     
-    kalMemCopy(prTarTxDesc, prSrcTxDesc, ucTxDescLength);
+    kalMemCopy(pucTarTxDesc, pucSrcTxDesc, ucTxDescLength);
 
 	if (pucTxDescLength) {
         *pucTxDescLength = ucTxDescLength;
@@ -1999,31 +2017,24 @@ WLAN_STATUS nicTxGenerateDescTemplate(IN P_ADAPTER_T prAdapter, IN P_STA_RECORD_
     UINT_8  ucTc;
     UINT_8  ucTxDescSize;
     P_HW_MAC_TX_DESC_T  prTxDesc;
-    P_TX_CTRL_T prTxCtrl;
     P_MSDU_INFO_T prMsduInfo;
     WLAN_STATUS rStatus = WLAN_STATUS_SUCCESS;
 
-    KAL_SPIN_LOCK_DECLARATION();
-
-    ASSERT(prAdapter);    
+    ASSERT(prAdapter);
 
     /* Free previous template, first */
 	/* nicTxFreeDescTemplate(prAdapter, prStaRec); */
 	for (ucTid = 0; ucTid < TX_DESC_TID_NUM; ucTid++) {
         prStaRec->aprTxDescTemplate[ucTid] = NULL;
-    }    
-
-    prTxCtrl = &prAdapter->rTxCtrl;
+    }
 
-    KAL_ACQUIRE_SPIN_LOCK(prAdapter, SPIN_LOCK_TX_MSDU_INFO_LIST);
-    QUEUE_REMOVE_HEAD(&prTxCtrl->rFreeMsduInfoList, prMsduInfo, P_MSDU_INFO_T);
-    KAL_RELEASE_SPIN_LOCK(prAdapter, SPIN_LOCK_TX_MSDU_INFO_LIST);
+    prMsduInfo = cnmPktAlloc(prAdapter, 0);
 
 	if (!prMsduInfo) {
         return WLAN_STATUS_RESOURCES;
     }
 
-    /* Fill up MsduInfo template */   
+    /* Fill up MsduInfo template */
     prMsduInfo->eSrc = TX_PACKET_OS;
     prMsduInfo->fgIs802_11 = FALSE;
     prMsduInfo->fgIs802_1x = FALSE;
@@ -2225,10 +2236,8 @@ WLAN_STATUS nicTxMsduQueue(IN P_ADAPTER_T prAdapter, UINT_8 ucPortIdx, P_QUE_T p
             ASSERT(prNativePacket);
             
 #if CFG_SUPPORT_MULTITHREAD
-            nicTxCopyDesc(prAdapter, 
-				      (P_HW_MAC_TX_DESC_T) (pucOutputBuf + u4TotalLength),
-				      (P_HW_MAC_TX_DESC_T) prMsduInfo->ucTxDescBuffer,
-                &ucTxDescSize);
+            nicTxCopyDesc(prAdapter, (pucOutputBuf + u4TotalLength),
+				prMsduInfo->aucTxDescBuffer, &ucTxDescSize);
 #else
 			nicTxFillDesc(prAdapter, prMsduInfo, (pucOutputBuf + u4TotalLength),
 				      &ucTxDescSize);
@@ -2257,32 +2266,35 @@ WLAN_STATUS nicTxMsduQueue(IN P_ADAPTER_T prAdapter, UINT_8 ucPortIdx, P_QUE_T p
             /* Free MSDU_INFO */
             if (prMsduInfo->eSrc == TX_PACKET_MGMT) {
                 GLUE_DEC_REF_CNT(prTxCtrl->i4TxMgmtPendingNum);
+			} 
+            else if (prMsduInfo->eSrc == TX_PACKET_OS) {
+                wlanTxProfilingTagMsdu(prAdapter, prMsduInfo, 
+                    TX_PROF_TAG_DRV_TX_DONE);
+                kalSendComplete(prAdapter->prGlueInfo, prNativePacket, 
+                    WLAN_STATUS_SUCCESS);
+			} 
+            else if (prMsduInfo->eSrc == TX_PACKET_FORWARDING) {
+                GLUE_DEC_REF_CNT(prTxCtrl->i4PendingFwdFrameCount);
+            }
 
-                if (prMsduInfo->pfTxDoneHandler == NULL) {
+            if (prMsduInfo->pfTxDoneHandler) {
+                KAL_SPIN_LOCK_DECLARATION();
+    			DBGLOG(REQ, INFO, ("Wait WIDX:PID[%u:%u] SEQ[%u]\n",
+                    prMsduInfo->ucWlanIndex, prMsduInfo->ucPID,
+                    prMsduInfo->ucTxSeqNum));
+                
+                KAL_ACQUIRE_SPIN_LOCK(prAdapter, SPIN_LOCK_TXING_MGMT_LIST);
+    			QUEUE_INSERT_TAIL(&(prTxCtrl->rTxMgmtTxingQueue),
+    					  (P_QUE_ENTRY_T) prMsduInfo);
+                KAL_RELEASE_SPIN_LOCK(prAdapter, SPIN_LOCK_TXING_MGMT_LIST);
+            }
+            else {
+                if(prMsduInfo->eSrc == TX_PACKET_MGMT) {
                     cnmMgtPktFree(prAdapter, prMsduInfo);
-				} else {
-                    KAL_SPIN_LOCK_DECLARATION();
-					DBGLOG(REQ, INFO, ("Wait WIDX:PID[%u:%u] SEQ[%u]\n",
-                        prMsduInfo->ucWlanIndex, 
-                        prMsduInfo->ucPID,
-                        prMsduInfo->ucTxSeqNum));
-                    KAL_ACQUIRE_SPIN_LOCK(prAdapter, SPIN_LOCK_TXING_MGMT_LIST);
-					QUEUE_INSERT_TAIL(&(prTxCtrl->rTxMgmtTxingQueue),
-							  (P_QUE_ENTRY_T) prMsduInfo);
-                    KAL_RELEASE_SPIN_LOCK(prAdapter, SPIN_LOCK_TXING_MGMT_LIST);
                 }
-			} else {
-                /* only free MSDU when it is not a MGMT frame */
-				QUEUE_INSERT_TAIL(prFreeQueue, (P_QUE_ENTRY_T) prMsduInfo);
-
-                if (prMsduInfo->eSrc == TX_PACKET_OS) {
-                    wlanTxProfilingTagMsdu(prAdapter, prMsduInfo, TX_PROF_TAG_DRV_TX_DONE);
-                    kalSendComplete(prAdapter->prGlueInfo,
-							prNativePacket, WLAN_STATUS_SUCCESS);
-
-                    
-				} else if (prMsduInfo->eSrc == TX_PACKET_FORWARDING) {
-                    GLUE_DEC_REF_CNT(prTxCtrl->i4PendingFwdFrameCount);
+                else {
+                    /* only free MSDU when it is not a MGMT frame */
+    				QUEUE_INSERT_TAIL(prFreeQueue, (P_QUE_ENTRY_T) prMsduInfo);
                 }
             }
 
@@ -2350,7 +2362,7 @@ WLAN_STATUS nicTxMsduQueue(IN P_ADAPTER_T prAdapter, UINT_8 ucPortIdx, P_QUE_T p
 #endif
 		nicTxReturnMsduInfo(prAdapter, (P_MSDU_INFO_T) QUEUE_GET_HEAD(&rFreeQueue));
 
-            }
+    }
       
     return WLAN_STATUS_SUCCESS;
 }
@@ -2386,40 +2398,54 @@ WLAN_STATUS nicTxCmd(IN P_ADAPTER_T prAdapter, IN P_CMD_INFO_T prCmdInfo, IN UIN
     pucOutputBuf = prTxCtrl->pucTxCoalescingBufPtr;
 
 	if (prCmdInfo->eCmdType == COMMAND_TYPE_SECURITY_FRAME) {
+        prMsduInfo = prCmdInfo->prMsduInfo;
+        
 #if CFG_SUPPORT_MULTITHREAD
-        nicTxCopyDesc(prAdapter, 
-			      (P_HW_MAC_TX_DESC_T) &pucOutputBuf[0],
-			      (P_HW_MAC_TX_DESC_T) ((P_SEC_FRAME_INFO_T) prCmdInfo->pucInfoBuffer)->
-			      ucTxDescBuffer, &ucTxDescLength);
+        nicTxCopyDesc(prAdapter, &pucOutputBuf[0], prMsduInfo->aucTxDescBuffer, 
+            &ucTxDescLength);
 #else
 		nicTxComposeSecurityFrameDesc(prAdapter, prCmdInfo, &pucOutputBuf[0],
             &ucTxDescLength);
 #endif
 
-        prNativePacket = prCmdInfo->prPacket;
+        prNativePacket = prMsduInfo->prPacket;
 		u2OverallBufferLength =
 		    TFCB_FRAME_PAD_TO_DW((prCmdInfo->u2InfoBufLen + ucTxDescLength));
 
-		/* <3> Copy Frame Body Copy */
+		/* <3> Copy Frame Body */
 		kalCopyFrame(prAdapter->prGlueInfo, prNativePacket, pucOutputBuf + ucTxDescLength);
 
-        DBGLOG(INIT, INFO, ("TX SEC Frame: BSS[%u] STA_REC[%u] WLAN_IDX[%u] LEN[%u]\n", 
-            prCmdInfo->ucBssIndex,
-            prCmdInfo->ucStaRecIndex,
-				    HAL_MAC_TX_DESC_GET_WLAN_INDEX((P_HW_MAC_TX_DESC_T) &
-								   pucOutputBuf[0]),
-            ucTxDescLength + prCmdInfo->u2InfoBufLen));
+        DBGLOG(INIT, INFO, ("TX SEC Frame: BSS[%u] WIDX:PID[%u:%u] STA[%u]"
+            " LEN[%u] ENC[%u] RSP[%u]\n", prCmdInfo->ucBssIndex, 
+			HAL_MAC_TX_DESC_GET_WLAN_INDEX((P_HW_MAC_TX_DESC_T)&pucOutputBuf[0]),
+            prMsduInfo->ucPID, prCmdInfo->ucStaRecIndex, 
+            ucTxDescLength + prCmdInfo->u2InfoBufLen,
+            HAL_MAC_TX_DESC_IS_PROTECTION((P_HW_MAC_TX_DESC_T)&pucOutputBuf[0]), 
+            prMsduInfo->pfTxDoneHandler ? TRUE : FALSE));
+
+        prMsduInfo->prPacket = NULL;
+
+        if (prMsduInfo->pfTxDoneHandler) {
+			/* DBGLOG(INIT, TRACE,("Wait Cmd TxSeqNum:%d\n", prMsduInfo->ucTxSeqNum)); */
+            KAL_ACQUIRE_SPIN_LOCK(prAdapter, SPIN_LOCK_TXING_MGMT_LIST);
+			QUEUE_INSERT_TAIL(&(prTxCtrl->rTxMgmtTxingQueue),
+					  (P_QUE_ENTRY_T) prMsduInfo);
+            KAL_RELEASE_SPIN_LOCK(prAdapter, SPIN_LOCK_TXING_MGMT_LIST);
+		} else {
+		    /* Only return MSDU_INFO */
+		    /* NativePacket will be freed at SEC frame CMD callback */
+		    nicTxReturnMsduInfo(prAdapter, prMsduInfo);
+        }
         
 	} else if (prCmdInfo->eCmdType == COMMAND_TYPE_MANAGEMENT_FRAME) {
-		prMsduInfo = (P_MSDU_INFO_T) prCmdInfo->prPacket;
+		prMsduInfo = prCmdInfo->prMsduInfo;
 
         ASSERT(prMsduInfo->fgIs802_11 == TRUE);
         ASSERT(prMsduInfo->eSrc == TX_PACKET_MGMT);     
 
 #if CFG_SUPPORT_MULTITHREAD
-        nicTxCopyDesc(prAdapter, 
-			      (P_HW_MAC_TX_DESC_T) &pucOutputBuf[0],
-			      (P_HW_MAC_TX_DESC_T) prMsduInfo->ucTxDescBuffer, &ucTxDescLength);
+        nicTxCopyDesc(prAdapter, &pucOutputBuf[0], prMsduInfo->aucTxDescBuffer, 
+            &ucTxDescLength);
 #else
         nicTxFillDesc(prAdapter, prMsduInfo, &pucOutputBuf[0], &ucTxDescLength);
 #endif
@@ -2469,9 +2495,8 @@ WLAN_STATUS nicTxCmd(IN P_ADAPTER_T prAdapter, IN P_CMD_INFO_T prCmdInfo, IN UIN
         ASSERT(u2OverallBufferLength <= prAdapter->u4CoalescingBufCachedSize);
         
         DBGLOG(INIT, INFO, ("TX CMD: ID[0x%02X] SEQ[%u] SET[%u] LEN[%u]\n", 
-            prWifiCmd->ucCID,
-            prWifiCmd->ucSeqNum,
-				    prWifiCmd->ucSetQuery, u2OverallBufferLength));
+            prWifiCmd->ucCID, prWifiCmd->ucSeqNum, prWifiCmd->ucSetQuery, 
+            u2OverallBufferLength));
     }
 
 	/* <4> Write frame to data port */
@@ -2524,7 +2549,8 @@ VOID nicTxRelease(IN P_ADAPTER_T prAdapter, IN BOOLEAN fgProcTxDoneHandler)
 							    TX_RESULT_DROPPED_IN_DRIVER);
             }
 
-            cnmMgtPktFree(prAdapter, prMsduInfo);
+            nicTxFreeMsduInfoPacket(prAdapter, prMsduInfo);
+            nicTxReturnMsduInfo(prAdapter, prMsduInfo);
 		} else {
             break;
         }
@@ -2640,19 +2666,26 @@ VOID nicTxFreeMsduInfoPacket(IN P_ADAPTER_T prAdapter, IN P_MSDU_INFO_T prMsduIn
         prNativePacket = prMsduInfo->prPacket;
 
 		if (prMsduInfo->eSrc == TX_PACKET_OS) {
-			kalSendComplete(prAdapter->prGlueInfo, prNativePacket, WLAN_STATUS_FAILURE);
-			wlanUpdateTxStatistics(prAdapter, prMsduInfo, TRUE); /*get per-AC Tx drop packets*/
+            if(prNativePacket) {
+			    kalSendComplete(prAdapter->prGlueInfo, prNativePacket, 
+                    WLAN_STATUS_FAILURE);
+            }
+            /*get per-AC Tx drop packets*/
+			wlanUpdateTxStatistics(prAdapter, prMsduInfo, TRUE); 
 		} else if (prMsduInfo->eSrc == TX_PACKET_MGMT) {
             if (prMsduInfo->pfTxDoneHandler) {
 				prMsduInfo->pfTxDoneHandler(prAdapter, prMsduInfo,
 							    TX_RESULT_DROPPED_IN_DRIVER);
             }
-            cnmMemFree(prAdapter, prNativePacket);
+            if(prNativePacket) {
+                cnmMemFree(prAdapter, prNativePacket);
+            }
 		} else if (prMsduInfo->eSrc == TX_PACKET_FORWARDING) {
             GLUE_DEC_REF_CNT(prTxCtrl->i4PendingFwdFrameCount);
         }
 
-		prMsduInfo = (P_MSDU_INFO_T) QUEUE_GET_NEXT_ENTRY((P_QUE_ENTRY_T) prMsduInfo);
+		prMsduInfo = 
+            (P_MSDU_INFO_T)QUEUE_GET_NEXT_ENTRY((P_QUE_ENTRY_T) prMsduInfo);
     }
 
     return;
@@ -2725,33 +2758,45 @@ nicTxFillMsduInfo(IN P_ADAPTER_T prAdapter,
 		  IN P_MSDU_INFO_T prMsduInfo, IN P_NATIVE_PACKET prPacket)
 {
     P_GLUE_INFO_T   prGlueInfo;
-    UINT_8          aucEthDestAddr[PARAM_MAC_ADDR_LEN];
 
     ASSERT(prAdapter);
 
+    kalMemZero(prMsduInfo, sizeof(MSDU_INFO_T));
+
     prGlueInfo = prAdapter->prGlueInfo;
     ASSERT(prGlueInfo); 
 	
-    kalGetEthDestAddr(prAdapter->prGlueInfo, prPacket, aucEthDestAddr);    
+    kalGetEthDestAddr(prAdapter->prGlueInfo, prPacket, 
+        prMsduInfo->aucEthDestAddr);
 
     prMsduInfo->prPacket = prPacket;
-    prMsduInfo->fgIs802_1x = GLUE_GET_PKT_IS_1X(prPacket);
-    prMsduInfo->fgIs802_11 = FALSE;
-    prMsduInfo->fgIs802_3 = GLUE_GET_PKT_IS_802_3(prPacket);
-    prMsduInfo->fgIsVlanExists = GLUE_GET_PKT_IS_VLAN_EXIST(prPacket);
     prMsduInfo->ucBssIndex = GLUE_GET_PKT_BSS_IDX(prPacket);
     prMsduInfo->ucUserPriority = GLUE_GET_PKT_TID(prPacket);
     prMsduInfo->ucMacHeaderLength = GLUE_GET_PKT_HEADER_LEN(prPacket);
 	prMsduInfo->u2FrameLength = (UINT_16) GLUE_GET_PKT_FRAME_LEN(prPacket);
     prMsduInfo->ucPageCount = nicTxGetPageCount(prMsduInfo->u2FrameLength, FALSE);
-    prMsduInfo->pfTxDoneHandler = NULL;
-    prMsduInfo->ucPID = NIC_TX_DESC_PID_RESERVED;
-    
-    COPY_MAC_ADDR(prMsduInfo->aucEthDestAddr, aucEthDestAddr);
 
-    /* Reset to default value */
-    prMsduInfo->fgIsTXDTemplateValid = FALSE;
-    prMsduInfo->ucPacketType = TX_PACKET_TYPE_DATA;
+    if(GLUE_IS_PKT_FLAG_SET(prPacket)) {
+        prMsduInfo->fgIs802_1x = GLUE_TEST_PKT_FLAG(prPacket, ENUM_PKT_1X);
+        prMsduInfo->fgIs802_3 = GLUE_TEST_PKT_FLAG(prPacket, ENUM_PKT_802_3);
+        prMsduInfo->fgIsVlanExists = GLUE_TEST_PKT_FLAG(prPacket, ENUM_PKT_VLAN_EXIST);
+        
+        if(GLUE_TEST_PKT_FLAG(prPacket, ENUM_PKT_DHCP) && 
+            prAdapter->rWifiVar.ucDhcpTxDone) {
+            prMsduInfo->pfTxDoneHandler = wlanDhcpTxDone;
+        }
+        else if(GLUE_TEST_PKT_FLAG(prPacket, ENUM_PKT_ARP) && 
+            prAdapter->rWifiVar.ucArpTxDone){
+            prMsduInfo->pfTxDoneHandler = wlanArpTxDone;
+        }        
+    }
+
+    /* Reset to default value by memory zero */
+    //prMsduInfo->ucPID = NIC_TX_DESC_PID_RESERVED;
+    //prMsduInfo->ucRateMode = MSDU_RATE_MODE_AUTO;
+    //prMsduInfo->fgIsTXDTemplateValid = FALSE;
+    //prMsduInfo->ucPacketType = TX_PACKET_TYPE_DATA;
+	//prMsduInfo->fgIs802_11 = FALSE;
   
     return TRUE;
 }
@@ -3029,13 +3074,60 @@ BOOLEAN nicTxProcessMngPacket(IN P_ADAPTER_T prAdapter, IN P_MSDU_INFO_T prMsduI
 		nicTxSetPktFixedRateOption(prMsduInfo, u2RateCode, FIX_BW_NO_FIXED, FALSE, FALSE);
     }   
 #if CFG_SUPPORT_MULTITHREAD
-    nicTxFillDesc(prAdapter, prMsduInfo, prMsduInfo->ucTxDescBuffer, NULL);
+    nicTxFillDesc(prAdapter, prMsduInfo, prMsduInfo->aucTxDescBuffer, NULL);
 #endif
 
     return TRUE;
 }
 
 
+VOID nicTxProcessTxDoneEvent(IN P_ADAPTER_T prAdapter, 
+    IN P_WIFI_EVENT_T prEvent)
+{
+    P_EVENT_TX_DONE_T prTxDone;
+    P_MSDU_INFO_T prMsduInfo;
+    
+	prTxDone = (P_EVENT_TX_DONE_T)(prEvent->aucBuffer);
+
+    if(prTxDone->ucFlag & BIT(0)) {
+        /* Tx Done with advanced info */
+        DBGLOG(INIT, INFO,("EVENT_ID_TX_DONE WIDX:PID[%u:%u] Status[%u] SN[%u]"
+            " CNT[%u] RATE[0x%04x]\n",
+            prTxDone->ucWlanIndex, prTxDone->ucPacketSeq, prTxDone->ucStatus, 
+            prTxDone->u2SequenceNumber, prTxDone->ucTxCount, prTxDone->u2TxRate));
+    }
+    else {
+        DBGLOG(INIT, INFO,("EVENT_ID_TX_DONE WIDX:PID[%u:%u] Status[%u] SN[%u]\n",
+            prTxDone->ucWlanIndex, prTxDone->ucPacketSeq, prTxDone->ucStatus, 
+            prTxDone->u2SequenceNumber));
+    }
+
+    /* call related TX Done Handler */
+	prMsduInfo = nicGetPendingTxMsduInfo(prAdapter, prTxDone->ucWlanIndex, 
+	                prTxDone->ucPacketSeq);
+
+#if CFG_SUPPORT_802_11V_TIMING_MEASUREMENT
+    DBGLOG(INIT, TRACE, ("EVENT_ID_TX_DONE u4TimeStamp = %x u2AirDelay = %x\n",
+        prTxDone->au4Reserved1, prTxDone->au4Reserved2));
+
+    wnmReportTimingMeas(prAdapter, prMsduInfo->ucStaRecIndex,
+			    prTxDone->au4Reserved1,
+			    prTxDone->au4Reserved1 + prTxDone->au4Reserved2);
+#endif
+
+	if (prMsduInfo) {
+		prMsduInfo->pfTxDoneHandler(prAdapter, prMsduInfo,
+					    (ENUM_TX_RESULT_CODE_T)(prTxDone->ucStatus));
+        
+        if(prMsduInfo->eSrc == TX_PACKET_MGMT) {
+            cnmMgtPktFree(prAdapter, prMsduInfo);
+        }
+        else {
+            nicTxReturnMsduInfo(prAdapter, prMsduInfo);
+        }
+    }
+}
+
 /*----------------------------------------------------------------------------*/
 /*!
 * \brief this function enqueues MSDU_INFO_T into queue management,
@@ -3155,7 +3247,7 @@ WLAN_STATUS nicTxEnqueueMsdu(IN P_ADAPTER_T prAdapter, IN P_MSDU_INFO_T prMsduIn
                     prCmdInfo->eCmdType = COMMAND_TYPE_MANAGEMENT_FRAME;
                     prCmdInfo->u2InfoBufLen = prMsduInfoHead->u2FrameLength;
                     prCmdInfo->pucInfoBuffer = NULL;
-					prCmdInfo->prPacket = (P_NATIVE_PACKET) prMsduInfoHead;
+					prCmdInfo->prMsduInfo = prMsduInfoHead;
                     prCmdInfo->ucStaRecIndex = prMsduInfoHead->ucStaRecIndex;
                     prCmdInfo->ucBssIndex = prMsduInfoHead->ucBssIndex;
                     prCmdInfo->pfCmdDoneHandler = NULL;
@@ -3329,12 +3421,10 @@ UINT_8 nicTxGetCmdPageCount(IN P_CMD_INFO_T prCmdInfo)
 }
 
 VOID 
-nicTxSetMngPacket(P_ADAPTER_T prAdapter,
-    P_MSDU_INFO_T           prMsduInfo,
-    UINT_8                  ucBssIndex,
-    UINT_8                  ucStaRecIndex,
-    UINT_8                  ucMacHeaderLength,
-		  UINT_16 u2FrameLength, PFN_TX_DONE_HANDLER pfTxDoneHandler, UINT_8 ucRateMode)
+nicTxSetMngPacket(P_ADAPTER_T prAdapter, P_MSDU_INFO_T prMsduInfo,
+    UINT_8 ucBssIndex, UINT_8 ucStaRecIndex, UINT_8 ucMacHeaderLength,
+    UINT_16 u2FrameLength, PFN_TX_DONE_HANDLER pfTxDoneHandler, 
+    UINT_8 ucRateMode)
 {
     ASSERT(prMsduInfo);
 
@@ -3359,16 +3449,11 @@ nicTxSetMngPacket(P_ADAPTER_T prAdapter,
 }
 
 VOID
-nicTxSetDataPacket(P_ADAPTER_T prAdapter,
-    P_MSDU_INFO_T           prMsduInfo,
-    UINT_8                  ucBssIndex, 
-    UINT_8                  ucStaRecIndex,
-    UINT_8                  ucMacHeaderLength,
-    UINT_16                 u2FrameLength,
-    PFN_TX_DONE_HANDLER     pfTxDoneHandler,
-    UINT_8                  ucRateMode,
-    ENUM_TX_PACKET_SRC_T    eSrc,    
-		   UINT_8 ucTID, BOOLEAN fgIs802_11Frame, BOOLEAN fgIs1xFrame)
+nicTxSetDataPacket(P_ADAPTER_T prAdapter, P_MSDU_INFO_T prMsduInfo,
+    UINT_8 ucBssIndex, UINT_8 ucStaRecIndex, UINT_8 ucMacHeaderLength,
+    UINT_16 u2FrameLength, PFN_TX_DONE_HANDLER pfTxDoneHandler,
+    UINT_8 ucRateMode, ENUM_TX_PACKET_SRC_T eSrc, UINT_8 ucTID, 
+    BOOLEAN fgIs802_11Frame, BOOLEAN fgIs1xFrame)
 {
     ASSERT(prMsduInfo);
 
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/nic/que_mgt.c b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/nic/que_mgt.c
index b829d43..2d33c42 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/nic/que_mgt.c
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/nic/que_mgt.c
@@ -902,6 +902,8 @@ VOID qmInit(IN P_ADAPTER_T prAdapter)
 
     prQM->u4TxAllowedStaCount = 0;
 
+    prQM->rLastTxPktDumpTime = (OS_SYSTIME)kalGetTimeTick();
+
 }
 
 #if QM_TEST_MODE
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/os/linux/gl_bow.c b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/os/linux/gl_bow.c
index 3f067dc..0df8ac4 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/os/linux/gl_bow.c
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/os/linux/gl_bow.c
@@ -1235,7 +1235,7 @@ static int bowHardStartXmit(IN struct sk_buff *prSkb, IN struct net_device *prDe
 	}
 
 	if (fgIs1x) {
-		GLUE_SET_PKT_FLAG_1X(prSkb);
+        GLUE_SET_PKT_FLAG(prSkb, ENUM_PKT_1X);
 	}
 
 	if (kalHardStartXmit(prSkb, prDev, prGlueInfo, ucBssIndex) == WLAN_STATUS_SUCCESS) {
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/os/linux/gl_cfg80211.c b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/os/linux/gl_cfg80211.c
index 88060de..89569e8 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/os/linux/gl_cfg80211.c
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/os/linux/gl_cfg80211.c
@@ -487,35 +487,63 @@ mtk_cfg80211_get_station(struct wiphy *wiphy,
 			MAC2STR(mac), MAC2STR(arBssid)));
 		return -ENOENT;
 	}
-
-	/* 2. fill TX rate */
-	rStatus = kalIoctl(prGlueInfo,
-			   wlanoidQueryLinkSpeed,
-			   &u4Rate, sizeof(u4Rate), TRUE, FALSE, FALSE, &u4BufLen);
-
-	if (rStatus != WLAN_STATUS_SUCCESS) {
-		DBGLOG(REQ, WARN, ("unable to retrieve link speed\n"));
-	} else {
-		sinfo->filled |= STATION_INFO_TX_BITRATE;
-		sinfo->txrate.legacy = u4Rate / 1000;	/* convert from 100bps to 100kbps */
-	}
-
-	if (prGlueInfo->eParamMediaStateIndicated != PARAM_MEDIA_STATE_CONNECTED) {
-		/* not connected */
-		DBGLOG(REQ, WARN, ("not yet connected\n"));
-	} else {
-		/* 3. fill RSSI */
-		rStatus = kalIoctl(prGlueInfo,
-				   wlanoidQueryRssi,
-				   &i4Rssi, sizeof(i4Rssi), TRUE, FALSE, FALSE, &u4BufLen);
-
-		if (rStatus != WLAN_STATUS_SUCCESS) {
-			DBGLOG(REQ, WARN, ("unable to retrieve link speed\n"));
-		} else {
-			sinfo->filled |= STATION_INFO_SIGNAL;
-			sinfo->signal = i4Rssi;	/* dBm */
-		}
-	}
+	
+    /* 2. fill TX rate */
+    if(prGlueInfo->eParamMediaStateIndicated != PARAM_MEDIA_STATE_CONNECTED) {
+        /* not connected */
+        DBGLOG(REQ, WARN, ("not yet connected\n"));
+    }
+    else {
+        rStatus = kalIoctl(prGlueInfo,
+            wlanoidQueryLinkSpeed,
+            &u4Rate,
+            sizeof(u4Rate),
+            TRUE,
+            FALSE,
+            FALSE,
+            &u4BufLen);
+
+        sinfo->filled |= STATION_INFO_TX_BITRATE;
+
+        if ((rStatus != WLAN_STATUS_SUCCESS) || (u4Rate == 0)) {
+            //DBGLOG(REQ, WARN, ("unable to retrieve link speed\n"));
+            DBGLOG(REQ, WARN, ("last link speed\n"));
+            sinfo->txrate.legacy = prGlueInfo->u4LinkSpeedCache;
+        }
+        else {
+            //sinfo->filled |= STATION_INFO_TX_BITRATE;
+            sinfo->txrate.legacy = u4Rate / 1000; /* convert from 100bps to 100kbps */
+            prGlueInfo->u4LinkSpeedCache = u4Rate / 1000;
+            
+        }
+    }
+    
+    /* 3. fill RSSI */
+    if(prGlueInfo->eParamMediaStateIndicated != PARAM_MEDIA_STATE_CONNECTED) {
+        /* not connected */
+        DBGLOG(REQ, WARN, ("not yet connected\n"));
+    }
+    else {
+        rStatus = kalIoctl(prGlueInfo,
+                wlanoidQueryRssi,
+                &i4Rssi,
+                sizeof(i4Rssi),
+                TRUE,
+                FALSE,
+                FALSE,
+                &u4BufLen);
+                
+        sinfo->filled |= STATION_INFO_SIGNAL;
+        
+        if ((rStatus != WLAN_STATUS_SUCCESS) || (i4Rssi == PARAM_WHQL_RSSI_MIN_DBM) || (i4Rssi == PARAM_WHQL_RSSI_MAX_DBM)) {
+            DBGLOG(REQ, WARN, ("last rssi\n"));
+            sinfo->signal = prGlueInfo->i4RssiCache;
+        }
+        else {
+                sinfo->signal = i4Rssi; /* dBm */
+                prGlueInfo->i4RssiCache = i4Rssi;       
+        }
+    }
 
 	/* Get statistics from net_dev */
 	prDevStats = (struct net_device_stats *)kalGetStats(ndev);
@@ -741,7 +769,7 @@ mtk_cfg80211_connect(struct wiphy *wiphy,
 	ENUM_PARAM_ENCRYPTION_STATUS_T eEncStatus;
 	ENUM_PARAM_AUTH_MODE_T eAuthMode;
 	UINT_32 cipher;
-	PARAM_SSID_T rNewSsid;
+	PARAM_CONNECT_T rNewSsid;
 	BOOLEAN fgCarryWPSIE = FALSE;
 	ENUM_PARAM_OP_MODE_T eOpMode;
 	UINT_32 i, u4AkmSuite = 0;
@@ -1068,30 +1096,17 @@ mtk_cfg80211_connect(struct wiphy *wiphy,
 		}
 	}
 
-	if (sme->ssid_len > 0) {
-		/* connect by SSID */
-		COPY_SSID(rNewSsid.aucSsid, rNewSsid.u4SsidLen, sme->ssid, sme->ssid_len);
-
-		rStatus = kalIoctl(prGlueInfo,
-				   wlanoidSetSsid,
-				   (PVOID) & rNewSsid,
-				   sizeof(PARAM_SSID_T), FALSE, FALSE, TRUE, &u4BufLen);
-
-		if (rStatus != WLAN_STATUS_SUCCESS) {
-			DBGLOG(REQ, WARN, ("set SSID:%lx\n", rStatus));
-			return -EINVAL;
-		}
-	} else {
-		/* connect by BSSID */
-		rStatus = kalIoctl(prGlueInfo,
-				   wlanoidSetBssid,
-				   (PVOID) sme->bssid, MAC_ADDR_LEN, FALSE, FALSE, TRUE, &u4BufLen);
+	rNewSsid.u4CenterFreq = sme->channel ? sme->channel->center_freq:0;
+	rNewSsid.pucBssid = sme->bssid;
+	rNewSsid.pucSsid = sme->ssid;
+	rNewSsid.u4SsidLen = sme->ssid_len;
+	rStatus = kalIoctl(prGlueInfo, wlanoidSetConnect,  (PVOID) &rNewSsid, sizeof(PARAM_CONNECT_T),
+	       				 FALSE, FALSE, TRUE, &u4BufLen);
 
-		if (rStatus != WLAN_STATUS_SUCCESS) {
-			DBGLOG(REQ, WARN, ("set BSSID:%lx\n", rStatus));
-			return -EINVAL;
-		}
-	}
+    if (rStatus != WLAN_STATUS_SUCCESS) {
+        DBGLOG(REQ, WARN, ("set SSID:%x\n", rStatus));
+        return -EINVAL;
+    }
 #if 0
 	if (sme->bssid != NULL && 1 /* prGlueInfo->fgIsBSSIDSet */) {
 		/* connect by BSSID */
@@ -2812,7 +2827,7 @@ mtk_cfg80211_testmode_get_lte_channel(IN struct wiphy *wiphy,
 #define CHN_DIRTY_WEIGHT_UPPERBOUND 4
 
 
-	BOOLEAN fgIsReady = FALSE, fgIsFistRecord = TRUE;
+	BOOLEAN fgIsReady = FALSE;
 	BOOLEAN fgIsPureAP;
 
 
@@ -2947,13 +2962,17 @@ mtk_cfg80211_testmode_get_lte_channel(IN struct wiphy *wiphy,
 		}
 
 		fgIsReady = prGlueInfo->prAdapter->rWifiVar.rChnLoadInfo.fgDataReadyBit;
-		PreferChannels[0].u2APNum = 0xFFFF;
-		PreferChannels[1].u2APNum = 0xFFFF;
+		PreferChannels[0].ucChannel = 0;  	// default channel : ch1 
+		PreferChannels[1].ucChannel = 0;  	// default channel : ch1 
+		PreferChannels[0].u2APNum = 0xFFFF; // default channel score  : 0xFFFF
+		PreferChannels[1].u2APNum = 0xFFFF; // default channel score  : 0xFFFF
 
 		/* (u4TempSafeChannelBitmask & BIT(1) == 1) -> 2G Ch1 is valid */
-		if (u4TempSafeChannelBitmask == 0)
+		if (u4TempSafeChannelBitmask == 0) {
+			DBGLOG(P2P, WARN, ("  Can't get any safe channel from fw!?\n"));
 			u4TempSafeChannelBitmask = BITS(1, (ucMax_24G_Chn_List));
-		DBGLOG(P2P, INFO, ("   u4TempSafeChannelBitmask=%08x\n", u4TempSafeChannelBitmask));
+		}
+		DBGLOG(P2P, INFO, ("   SafeChannelBitmask=%08x\n", u4TempSafeChannelBitmask));
 
 		ucChValidCnt = 0;
 		for (ucIdx = ucDefaultIdx; ucIdx < ucMax_24G_Chn_List; ucIdx++) {
@@ -2966,8 +2985,7 @@ mtk_cfg80211_testmode_get_lte_channel(IN struct wiphy *wiphy,
 				PreferChannels[0].ucChannel = ucIdx;
 				PreferChannels[0].u2APNum = ar2_4G_ChannelLoadingWeightScore[ucIdx].u2APNum;
 			} else {
-				if ((PreferChannels[1].u2APNum >= ar2_4G_ChannelLoadingWeightScore[ucIdx].u2APNum) || (fgIsFistRecord == 1)) {
-					fgIsFistRecord = FALSE;
+				if (PreferChannels[1].u2APNum >= ar2_4G_ChannelLoadingWeightScore[ucIdx].u2APNum) {
 					PreferChannels[1].ucChannel = ucIdx;
 					PreferChannels[1].u2APNum = ar2_4G_ChannelLoadingWeightScore[ucIdx].u2APNum;
 				}
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/os/linux/gl_kal.c b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/os/linux/gl_kal.c
index 84aa616..6705e13 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/os/linux/gl_kal.c
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/os/linux/gl_kal.c
@@ -1887,16 +1887,7 @@ kalIndicateStatusAndComplete(IN P_GLUE_INFO_T prGlueInfo,
 
 
 			/* CFG80211 Indication */
-			if (eStatus == WLAN_STATUS_MEDIA_CONNECT
-			    && prGlueInfo->prDevHandler->ieee80211_ptr->sme_state ==
-			    CFG80211_SME_CONNECTING) {
-				cfg80211_connect_result(prGlueInfo->prDevHandler, arBssid,
-							prGlueInfo->aucReqIe,
-							prGlueInfo->u4ReqIeLength,
-							prGlueInfo->aucRspIe,
-							prGlueInfo->u4RspIeLength,
-							WLAN_STATUS_SUCCESS, GFP_KERNEL);
-			} else if (eStatus == WLAN_STATUS_ROAM_OUT_FIND_BEST
+			if (eStatus == WLAN_STATUS_ROAM_OUT_FIND_BEST
 				   && prGlueInfo->prDevHandler->ieee80211_ptr->sme_state ==
 				   CFG80211_SME_CONNECTED) {
 				struct ieee80211_channel *prChannel = NULL;
@@ -1926,12 +1917,21 @@ kalIndicateStatusAndComplete(IN P_GLUE_INFO_T prGlueInfo,
 						prGlueInfo->u4ReqIeLength,
 						prGlueInfo->aucRspIe,
 						prGlueInfo->u4RspIeLength, GFP_KERNEL);
-			}
+			}else if  ( prGlueInfo->prDevHandler->ieee80211_ptr->sme_state ==
+			    CFG80211_SME_CONNECTING) {
+				cfg80211_connect_result(prGlueInfo->prDevHandler, arBssid,
+							prGlueInfo->aucReqIe,
+							prGlueInfo->u4ReqIeLength,
+							prGlueInfo->aucRspIe,
+							prGlueInfo->u4RspIeLength,
+							WLAN_STATUS_SUCCESS, GFP_KERNEL);
+			} 
 		}
 
 		break;
 
 	case WLAN_STATUS_MEDIA_DISCONNECT:
+	case WLAN_STATUS_MEDIA_DISCONNECT_LOCALLY:
 		/* indicate disassoc event */
 		wext_indicate_wext_event(prGlueInfo, SIOCGIWAP, NULL, 0);
 		/* For CR 90 and CR99, While supplicant do reassociate, driver will do netif_carrier_off first,
@@ -1950,7 +1950,7 @@ kalIndicateStatusAndComplete(IN P_GLUE_INFO_T prGlueInfo,
 
 		if (prGlueInfo->fgIsRegistered == TRUE
 		    && prGlueInfo->prDevHandler->ieee80211_ptr->sme_state ==
-		    CFG80211_SME_CONNECTED) {
+		    CFG80211_SME_CONNECTED && eStatus == WLAN_STATUS_MEDIA_DISCONNECT) {
 			P_BSS_INFO_T prBssInfo = prGlueInfo->prAdapter->prAisBssInfo;
 			UINT_16 u2DeauthReason = 0;
 
@@ -2513,6 +2513,72 @@ UINT_32 kalReadExtCfg(IN P_GLUE_INFO_T prGlueInfo)
 }
 #endif
 
+BOOLEAN
+kalIPv4FrameClassifier(IN P_GLUE_INFO_T prGlueInfo, 
+    IN P_NATIVE_PACKET prPacket, IN PUINT_8 pucIpHdr, 
+    OUT P_TX_PACKET_INFO prTxPktInfo)
+{
+	UINT_8 ucIpVersion;
+    //UINT_16 u2IpId;
+
+	/* IPv4 version check */
+	ucIpVersion = (pucIpHdr[0] & IP_VERSION_MASK) >> IP_VERSION_OFFSET;
+	if (ucIpVersion != IP_VERSION_4) {
+		DBGLOG(INIT, WARN, ("Invalid IPv4 packet version: %u\n", 
+            ucIpVersion));
+		return FALSE;
+	}
+    
+    //WLAN_GET_FIELD_16(&pucIpHdr[IPV4_HDR_IP_IDENTIFICATION_OFFSET], &u2IpId); 
+
+    if(pucIpHdr[IPV4_HDR_IP_PROTOCOL_OFFSET] == IP_PROTOCOL_UDP) {
+        PUINT_8 pucUdpHdr = &pucIpHdr[IPV4_HDR_LEN];
+        UINT_16 u2DstPort;
+        //UINT_16 u2SrcPort;
+
+        //DBGLOG_MEM8(INIT, INFO, pucUdpHdr, 256);
+
+        /* Get UDP DST port */
+        WLAN_GET_FIELD_BE16(&pucUdpHdr[UDP_HDR_DST_PORT_OFFSET], &u2DstPort);
+
+        //DBGLOG(INIT, INFO, ("UDP DST[%u]\n", u2DstPort));        
+
+        /* Get UDP SRC port */
+        //WLAN_GET_FIELD_BE16(&pucUdpHdr[UDP_HDR_SRC_PORT_OFFSET], &u2SrcPort);
+
+        /* BOOTP/DHCP protocol */
+        if((u2DstPort == IP_PORT_BOOTP_SERVER) || 
+            (u2DstPort == IP_PORT_BOOTP_CLIENT)) {
+
+            P_BOOTP_PROTOCOL_T prBootp = 
+                (P_BOOTP_PROTOCOL_T)&pucUdpHdr[UDP_HDR_LEN];
+
+            UINT_32 u4DhcpMagicCode;
+
+            WLAN_GET_FIELD_BE32(&prBootp->aucOptions[0], &u4DhcpMagicCode);
+#if 0
+            DBGLOG(INIT, INFO, ("DHCP MGC[0x%08x] XID[%u] OPT[%u] TYPE[%u]\n",
+                    u4DhcpMagicCode, prBootp->u4TransId, prBootp->aucOptions[4], 
+                    prBootp->aucOptions[6]));
+#endif
+            if(u4DhcpMagicCode == DHCP_MAGIC_NUMBER) {
+                UINT_32 u4Xid;
+
+                WLAN_GET_FIELD_BE32(&prBootp->u4TransId, &u4Xid);
+                
+                DBGLOG(SW4, INFO, ("DHCP PKT[0x%p] XID[0x%08x] OPT[%u] TYPE[%u]\n", 
+                    prPacket, u4Xid, prBootp->aucOptions[4], prBootp->aucOptions[6]));
+
+                prTxPktInfo->u2Flag |= BIT(ENUM_PKT_DHCP);
+            }
+        }
+    }
+
+
+    return TRUE;
+}
+
+
 /*----------------------------------------------------------------------------*/
 /*!
 * @brief This inline function is to extract some packet information, including
@@ -2555,7 +2621,7 @@ kalQoSFrameClassifierAndPacketInfo(IN P_GLUE_INFO_T prGlueInfo,
 
 	/* 4 <1> Skip 802.1Q header (VLAN Tagging) */
 	if (u2EtherTypeLen == ETH_P_VLAN) {
-		prTxPktInfo->fgIsVlanExists = TRUE;
+		prTxPktInfo->u2Flag |= BIT(ENUM_PKT_VLAN_EXIST);
 		ucEthTypeLenOffset += ETH_802_1Q_HEADER_LEN;
 		WLAN_GET_FIELD_BE16(&aucLookAheadBuf[ucEthTypeLenOffset], &u2EtherTypeLen);
 	}
@@ -2565,43 +2631,20 @@ kalQoSFrameClassifierAndPacketInfo(IN P_GLUE_INFO_T prGlueInfo,
 	/* 4 <3> Handle ethernet format */
 	switch (u2EtherTypeLen) {
 
-#if 0
 		/* IPv4 */
-	case ETH_P_IPV4:
-
-        /* Skip IPV4 parsing if no profiling requirment */
-        if(!kalTxProfilingIsEnabled(prGlueInfo, prPacket)) {
-            break;
-        }
-        
-		{
-			PUINT_8 pucIpHdr = pucNextProtocol;
-			UINT_8 ucIpVersion;
-			UINT_8 ucIpTos;
-
-			/* IPv4 header length check */
-			if (u4PacketLen < (ucEthTypeLenOffset + ETHER_TYPE_LEN + IPV4_HDR_LEN)) {
-				DBGLOG(INIT, WARN,
-				       ("Invalid IPv4 packet length: %lu\n", u4PacketLen));
-				return FALSE;
-			}
-
-			/* IPv4 version check */
-			ucIpVersion = (pucIpHdr[0] & IP_VERSION_MASK) >> IP_VERSION_OFFSET;
-			if (ucIpVersion != IP_VERSION_4) {
-				DBGLOG(INIT, WARN,
-				       ("Invalid IPv4 packet version: %u\n", ucIpVersion));
-				return FALSE;
-			}
-			/* Get the DSCP value from the header of IP packet. */
-			ucIpTos = *(pucIpHdr + IPV4_HDR_TOS_OFFSET);
-			ucUserPriority =
-			    ((ucIpTos & IPV4_HDR_TOS_PREC_MASK) >> IPV4_HDR_TOS_PREC_OFFSET);
-			/* TODO(Kevin): Add TSPEC classifier here */
-                     
+	case ETH_P_IPV4:        
+		/* IPv4 header length check */
+		if (u4PacketLen < (ucEthTypeLenOffset + ETHER_TYPE_LEN + IPV4_HDR_LEN)) {
+			DBGLOG(INIT, WARN, ("Invalid IPv4 packet length: %lu\n", 
+                u4PacketLen));
+			break;
 		}
+
+        kalIPv4FrameClassifier(prGlueInfo, prPacket, pucNextProtocol, 
+            prTxPktInfo);
 		break;
 
+#if 0
 		/* IPv6 */
 	case ETH_P_IPV6:
 		{
@@ -2630,18 +2673,33 @@ kalQoSFrameClassifierAndPacketInfo(IN P_GLUE_INFO_T prGlueInfo,
 		break;
 #endif
 
+    case ETH_P_ARP:
+        {
+            UINT_16 u2ArpOp;
+
+            WLAN_GET_FIELD_BE16(&pucNextProtocol[ARP_OPERATION_OFFSET], &u2ArpOp);
+            
+            DBGLOG(SW4, INFO, ("ARP %s PKT[0x%p] TAR MAC/IP["MACSTR"]/["IPV4STR"]\n", 
+                u2ArpOp == ARP_OPERATION_REQUEST?"REQ":"RSP", 
+                prPacket, MAC2STR(&pucNextProtocol[ARP_TARGET_MAC_OFFSET]),
+                IPV4TOSTR(&pucNextProtocol[ARP_TARGET_IP_OFFSET])));
+
+            prTxPktInfo->u2Flag |= BIT(ENUM_PKT_ARP);
+        }
+        break;
+        
 	case ETH_P_1X:
 	case ETH_P_PRE_1X:
 #if CFG_SUPPORT_WAPI
 	case ETH_WPI_1X:
 #endif
-		prTxPktInfo->fgIs1X = TRUE;
+		prTxPktInfo->u2Flag |= BIT(ENUM_PKT_1X);
 		break;
 
 	default:
 		/* 4 <4> Handle 802.3 format if LEN <= 1500 */
 		if (u2EtherTypeLen <= ETH_802_3_MAX_LEN) {
-			prTxPktInfo->fgIs802_3 = TRUE;
+			prTxPktInfo->u2Flag |= BIT(ENUM_PKT_802_3);
 		}
 		break;
 	}
@@ -3124,7 +3182,7 @@ kalProcessTxPacket(
     }
 
     /* Handle security frame */
-    if(GLUE_GET_PKT_IS_1X(prSkb)) {
+    if(GLUE_TEST_PKT_FLAG(prSkb, ENUM_PKT_1X)) {
         if(wlanProcessSecurityFrame(prGlueInfo->prAdapter, (P_NATIVE_PACKET)prSkb)) {
             u4Status = WLAN_STATUS_SUCCESS;
             GLUE_INC_REF_CNT(prGlueInfo->i4TxPendingSecurityFrameNum);
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/os/linux/include/gl_kal.h b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/os/linux/include/gl_kal.h
index 4414c38..b2241f9 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/os/linux/include/gl_kal.h
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/os/linux/include/gl_kal.h
@@ -604,11 +604,6 @@
 #include "nic/bow.h"
 #endif
 
-#if CFG_SUPPORT_XLOG
-#include "linux/xlog.h"
-#endif
-
-
 #include "linux/kallsyms.h"
 #include <linux/ftrace_event.h>
 
@@ -1173,52 +1168,34 @@ typedef struct _MONITOR_RADIOTAP_T {
 #define kalGetTimeTick()                            jiffies_to_msecs(jiffies)
 
 #define kalPrint                                    printk
+#define WLAN_TAG                                    "[wlan]"
 
-#if CFG_SUPPORT_XLOG
-#define XLOG_TAG   "wlan"
+#if 1
+#define kalPrintTag(_Fmt...)        kalPrint(WLAN_TAG _Fmt)
+#define kalDbgLog(_DbgClass, _Fmt)  kalPrintTag _Fmt 
+#else
 
-#define XLogErrorFunc(_Fmt...)                     xlog_printk(ANDROID_LOG_ERROR, XLOG_TAG, _Fmt)
-#define XLogWarnFunc(_Fmt...)                      xlog_printk(ANDROID_LOG_WARN, XLOG_TAG, _Fmt)
-#define XLogInfoFunc(_Fmt...)                      xlog_printk(ANDROID_LOG_DEBUG, XLOG_TAG, _Fmt)
-#define XLogDebugFunc(_Fmt...)                     xlog_printk(ANDROID_LOG_DEBUG, XLOG_TAG, _Fmt)
-#define XLogVerboseFunc(_Fmt...)                   xlog_printk(ANDROID_LOG_VERBOSE, XLOG_TAG, _Fmt)
+#define kalPrintErr(_Fmt...)                    kalPrint(KERN_ERR WLAN_TAG _Fmt)
+#define kalPrintWarn(_Fmt...)                   kalPrint(KERN_WARNING WLAN_TAG _Fmt)
+#define kalPrintInfo(_Fmt...)                   kalPrint(KERN_INFO WLAN_TAG _Fmt)
+#define kalPrintDebug(_Fmt...)                  kalPrint(KERN_INFO WLAN_TAG _Fmt)
 
 #define kalDbgLog(_DbgClass, _Fmt) \
 { \
     if (_DbgClass & DBG_CLASS_ERROR) { \
-        XLogErrorFunc _Fmt; \
-    } \
-    else if (_DbgClass & DBG_CLASS_WARN) { \
-        XLogWarnFunc _Fmt; \
-    } \
-    else if (_DbgClass & (DBG_CLASS_STATE | DBG_CLASS_EVENT | DBG_CLASS_INFO)) { \
-        XLogInfoFunc _Fmt; \
-    } \
-    else if (_DbgClass & (DBG_CLASS_TRACE | DBG_CLASS_LOUD)) { \
-        XLogDebugFunc _Fmt; \
-    } \
-    else if (_DbgClass & DBG_CLASS_TEMP) { \
-        XLogVerboseFunc _Fmt; \
-    } \
-}    
-#else
-
-#define kalDbgLog(_DbgClass, (_Fmt)) \
-{ \
-    if (_DbgClass & DBG_CLASS_ERROR) { \
-        kalPrint(KERN_ERR _Fmt); \
+        kalPrintErr _Fmt; \
     } \
     else if (_DbgClass & DBG_CLASS_WARN) { \
-        kalPrint(KERN_WARNING _Fmt); \
+        kalPrintWarn _Fmt; \
     } \
     else if (_DbgClass & (DBG_CLASS_EVENT | DBG_CLASS_INFO)) { \
-        kalPrint(KERN_INFO _Fmt); \
+        kalPrintInfo _Fmt; \
     } \
     else if (_DbgClass & (DBG_CLASS_STATE | DBG_CLASS_TRACE | DBG_CLASS_LOUD)) { \
-        kalPrint(KERN_DEBUG _Fmt); \
+        kalPrintDebug _Fmt; \
     } \
     else if (_DbgClass & DBG_CLASS_TEMP) { \
-        kalPrint(KERN_ERR _Fmt); \
+        kalPrintErr _Fmt; \
     } \
 }   
 #endif
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/os/linux/include/gl_os.h b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/os/linux/include/gl_os.h
index 5ae5cea..354fc06 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/os/linux/include/gl_os.h
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/os/linux/include/gl_os.h
@@ -739,6 +739,17 @@ typedef enum _ENUM_NET_REG_STATE_T {
 } ENUM_NET_REG_STATE_T;
 #endif
 
+typedef enum _ENUM_PKT_FLAG_T {
+    ENUM_PKT_802_11,        /* 802.11 or non-802.11 */
+    ENUM_PKT_802_3,         /* 802.3 or ethernetII */
+    ENUM_PKT_1X,            /* 1x frame or not */
+    ENUM_PKT_PROTECTED_1X,  /* prtected 1x frame */
+    ENUM_PKT_VLAN_EXIST,    /* VLAN tag exist */
+    ENUM_PKT_DHCP,          /* DHCP frame */
+    ENUM_PKT_ARP,           /* ARP */
+    ENUM_PKT_FLAG_NUM
+} ENUM_PKT_FLAG_T;
+
 typedef struct _GL_IO_REQ_T {
     QUE_ENTRY_T             rQueEntry;
 	/* wait_queue_head_t       cmdwait_q; */
@@ -990,6 +1001,9 @@ struct _GLUE_INFO_T {
     struct net_device *prMonDevHandler;
 	struct work_struct monWork;
 #endif
+
+    INT_32                  i4RssiCache;
+    UINT_32                 u4LinkSpeedCache;
 };
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
@@ -1094,6 +1108,7 @@ typedef struct _NETDEV_PRIVATE_GLUE_INFO {
 typedef struct _PACKET_PRIVATE_DATA {
     QUE_ENTRY_T rQueEntry;
     UINT_16 u2Flag;
+    UINT_8 ucTid;
     UINT_8 ucBssIdx;
 
     UINT_8 ucHeaderLen;
@@ -1161,43 +1176,20 @@ typedef struct _PACKET_PRIVATE_DATA {
 #define GLUE_GET_PKT_DESCRIPTOR(_prQueueEntry)  \
 	    ((P_NATIVE_PACKET) (((ULONG)_prQueueEntry) - offsetof(struct sk_buff, cb[0])))
 
-#define GLUE_SET_PKT_TID(_p, _tid) { \
-        (GLUE_GET_PKT_PRIVATE_DATA(_p)->u2Flag &= ~(BITS(0, 2))); \
-	    (GLUE_GET_PKT_PRIVATE_DATA(_p)->u2Flag |= (UINT_8)((_tid) & (BITS(0, 2)))); \
-    }
+#define GLUE_SET_PKT_TID(_p, _tid) \
+	    (GLUE_GET_PKT_PRIVATE_DATA(_p)->ucTid = (UINT_8)(_tid))
 
 #define GLUE_GET_PKT_TID(_p) \
-	    (GLUE_GET_PKT_PRIVATE_DATA(_p)->u2Flag & BITS(0, 2))
-
-#define GLUE_SET_PKT_FLAG_VLAN_EXIST(_p)  \
-	    (GLUE_GET_PKT_PRIVATE_DATA(_p)->u2Flag |= BIT(3))
-
-#define GLUE_GET_PKT_IS_VLAN_EXIST(_p) \
-	    (GLUE_GET_PKT_PRIVATE_DATA(_p)->u2Flag & BIT(3))
-
-#define GLUE_SET_PKT_FLAG_802_3(_p)  \
-	    (GLUE_GET_PKT_PRIVATE_DATA(_p)->u2Flag |= BIT(4))
-
-#define GLUE_GET_PKT_IS_802_3(_p) \
-	    (GLUE_GET_PKT_PRIVATE_DATA(_p)->u2Flag & BIT(4))
+	    (GLUE_GET_PKT_PRIVATE_DATA(_p)->ucTid)
 
-#define GLUE_SET_PKT_FLAG_1X(_p) \
-	    (GLUE_GET_PKT_PRIVATE_DATA(_p)->u2Flag |= BIT(5))
+#define GLUE_SET_PKT_FLAG(_p, _flag) \
+        (GLUE_GET_PKT_PRIVATE_DATA(_p)->u2Flag |= BIT(_flag))
 
-#define  GLUE_GET_PKT_IS_1X(_p) \
-	    (GLUE_GET_PKT_PRIVATE_DATA(_p)->u2Flag & BIT(5))
+#define GLUE_TEST_PKT_FLAG(_p, _flag) \
+        (GLUE_GET_PKT_PRIVATE_DATA(_p)->u2Flag & BIT(_flag))
 
-#define GLUE_SET_PKT_FLAG_802_11(_p) \
-	    (GLUE_GET_PKT_PRIVATE_DATA(_p)->u2Flag |= BIT(6))
-
-#define  GLUE_GET_PKT_IS_802_11(_p)        \
-	    (GLUE_GET_PKT_PRIVATE_DATA(_p)->u2Flag & BIT(6))
-
-#define GLUE_SET_PKT_FLAG_PROTECTED_1X(_p) \
-	    (GLUE_GET_PKT_PRIVATE_DATA(_p)->u2Flag |= BIT(7))
-
-#define GLUE_GET_PKT_IS_PROTECTED_1X(_p) \
-	    (GLUE_GET_PKT_PRIVATE_DATA(_p)->u2Flag & BIT(7))
+#define GLUE_IS_PKT_FLAG_SET(_p) \
+        (GLUE_GET_PKT_PRIVATE_DATA(_p)->u2Flag)
 
 #define GLUE_SET_PKT_BSS_IDX(_p, _ucBssIndex) \
 	    (GLUE_GET_PKT_PRIVATE_DATA(_p)->ucBssIdx = (UINT_8)(_ucBssIndex))
@@ -1333,6 +1325,8 @@ VOID kalMetTagPacket(IN P_GLUE_INFO_T prGlueInfo,
     IN P_NATIVE_PACKET prPacket, IN ENUM_TX_PROFILING_TAG_T eTag);
 
 VOID kalMetInit(IN P_GLUE_INFO_T prGlueInfo);
-#endif    
+#endif
+
+VOID wlanUpdateChannelTable(P_GLUE_INFO_T prGlueInfo);
 
 #endif /* _GL_OS_H */
diff --git a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/os/linux/include/gl_p2p_os.h b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/os/linux/include/gl_p2p_os.h
index 805632b..370f730 100644
--- a/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/os/linux/include/gl_p2p_os.h
+++ b/drivers/misc/mediatek/connectivity/combo/drv_wlan/mt6630/wlan/os/linux/include/gl_p2p_os.h
@@ -263,4 +263,6 @@ BOOLEAN p2PFreeInfo(P_GLUE_INFO_T prGlueInfo);
 
 VOID p2pSetSuspendMode(P_GLUE_INFO_T prGlueInfo, BOOLEAN fgEnable);
 
+VOID p2pUpdateChannelTableByDomain(P_GLUE_INFO_T prGlueInfo);
+
 #endif
diff --git a/drivers/misc/mediatek/connectivity/conn_soc/common/core/include/btm_core.h b/drivers/misc/mediatek/connectivity/conn_soc/common/core/include/btm_core.h
index d9dbbdc..51ecb0e 100644
--- a/drivers/misc/mediatek/connectivity/conn_soc/common/core/include/btm_core.h
+++ b/drivers/misc/mediatek/connectivity/conn_soc/common/core/include/btm_core.h
@@ -127,6 +127,7 @@ INT32 stp_notify_btm_poll_cpupcr_ctrl(UINT32 en);
 INT32 stp_btm_notify_wmt_trace_wq(MTKSTP_BTM_T *stp_btm);
 INT32 stp_notify_btm_do_fw_assert_via_emi(MTKSTP_BTM_T *stp_btm);
 INT32 stp_notify_btm_handle_wmt_lte_coex(MTKSTP_BTM_T *stp_btm);
+INT32 wcn_psm_flag_trigger_collect_ftrace(void);
 
 MTKSTP_BTM_T *stp_btm_init(void);
 
diff --git a/drivers/misc/mediatek/connectivity/conn_soc/common/core/psm_core.c b/drivers/misc/mediatek/connectivity/conn_soc/common/core/psm_core.c
index 06c4f54..e29197b 100644
--- a/drivers/misc/mediatek/connectivity/conn_soc/common/core/psm_core.c
+++ b/drivers/misc/mediatek/connectivity/conn_soc/common/core/psm_core.c
@@ -1067,6 +1067,7 @@ static inline INT32 _stp_psm_wait_wmt_event_wq(MTKSTP_PSM_T *stp_psm){
         {
             STP_PSM_ERR_FUNC("flag = %ld<== Abnormal flag be set!!\n\r", stp_psm->flag.data);
             STP_PSM_ERR_FUNC("state = %d, flag = %ld\n", stp_psm->work_state, stp_psm->flag.data);
+            wcn_psm_flag_trigger_collect_ftrace();	/* trigger collect SYS_FTRACE */
 			_stp_psm_dbg_out_printk(g_stp_psm_dbg);
         }
         retval = STP_PSM_OPERATION_SUCCESS;
@@ -1492,7 +1493,7 @@ static inline INT32  _stp_psm_do_wakeup(MTKSTP_PSM_T *stp_psm)
         RB_GET(&stp_psm->rActiveOpQ, pOp);
 		if (NULL != pOp && !RB_FULL(pOpQ))
 		{
-            STP_PSM_DBG_FUNC("opid = %d\n", pOp->op.opId);
+            STP_PSM_INFO_FUNC("opid = %d\n", pOp->op.opId);
     	    RB_PUT(pOpQ, pOp);
 		}
 		else
diff --git a/drivers/misc/mediatek/connectivity/conn_soc/common/core/stp_core.c b/drivers/misc/mediatek/connectivity/conn_soc/common/core/stp_core.c
index e2eccae..74b83d1 100644
--- a/drivers/misc/mediatek/connectivity/conn_soc/common/core/stp_core.c
+++ b/drivers/misc/mediatek/connectivity/conn_soc/common/core/stp_core.c
@@ -2755,9 +2755,7 @@ INT32 mtk_wcn_stp_send_data(const PUINT8 buffer, const UINT32 length, const UINT
 	{
 	     //if(stp_is_apply_powersaving())
 	     {
-	        if(stp_is_privileges_cmd(buffer, length , type))
-	        {
-	            STP_DBG_FUNC("send privileges cmd\n");
+	         if(type == WMT_TASK_INDX){
 	            goto DONT_MONITOR;
 	        }
 	        //If now chip is awake, to restart monitor!
@@ -2963,7 +2961,7 @@ INT32 mtk_wcn_stp_send_data(const PUINT8 buffer, const UINT32 length, const UINT
     {
 	    //if(stp_is_apply_powersaving()) 
 	   {
-		    if((MTK_WCN_BOOL_FALSE == stp_is_privileges_cmd(buffer, length , type))) 
+		    if(type != WMT_TASK_INDX)
 		    {
 			
 		    	/*-----------------------------STP_PSM_UnLock----------------------------------------*/
diff --git a/drivers/misc/mediatek/connectivity/conn_soc/common/linux/pri/stp_dbg.c b/drivers/misc/mediatek/connectivity/conn_soc/common/linux/pri/stp_dbg.c
index 13492ea..e2f02b0 100644
--- a/drivers/misc/mediatek/connectivity/conn_soc/common/linux/pri/stp_dbg.c
+++ b/drivers/misc/mediatek/connectivity/conn_soc/common/linux/pri/stp_dbg.c
@@ -409,7 +409,22 @@ INT32 wcn_core_dump_reset(P_WCN_CORE_DUMP_T dmp, UINT32 timeout)
 
     return 0;
 }
+/* wcn_psm_flag_trigger_collect_ftrace - wmtd timeout ,this func can collect SYS_FTRACE
+ *
+ * Retunr 0 if success
+ */
+#define PSM_ABNORMAL_FLAG_INFO_HEAD "Abnormal PSM flag be set ,just collect SYS_FTRACE to DB"
+INT32 wcn_psm_flag_trigger_collect_ftrace(void)
+{
+	PUINT8 pbuf;
+	INT32 len;
 
+	pbuf = "Abnormal PSM flag be set";
+	len = osal_strlen("Abnormal PSM flag be set");
+	osal_strcpy(&g_core_dump->info[0], PSM_ABNORMAL_FLAG_INFO_HEAD);
+	aed_combo_exception(NULL, 0, (const int *)pbuf, len, (const char *)g_core_dump->info);
+	return 0;
+}
 /* wcn_core_dump_timeout - wait for FW assert info timeout ,this func can collect SYS_FTRACE
  *
  * Retunr 0 if success
diff --git a/drivers/misc/mediatek/connectivity/conn_soc/common/linux/pub/stp_chrdev_bt.c b/drivers/misc/mediatek/connectivity/conn_soc/common/linux/pub/stp_chrdev_bt.c
index 098b245..9a41ad8 100644
--- a/drivers/misc/mediatek/connectivity/conn_soc/common/linux/pub/stp_chrdev_bt.c
+++ b/drivers/misc/mediatek/connectivity/conn_soc/common/linux/pub/stp_chrdev_bt.c
@@ -33,8 +33,6 @@
 
 MODULE_LICENSE("Dual BSD/GPL");
 
-#define BT_DRIVER_NAME "mtk_stp_BT_chrdev"
-#define BT_DEV_MAJOR 192 // never used number
 
 #define PFX                         "[MTK-BT] "
 #define BT_LOG_DBG                  3
@@ -42,15 +40,6 @@ MODULE_LICENSE("Dual BSD/GPL");
 #define BT_LOG_WARN                 1
 #define BT_LOG_ERR                  0
 
-#define COMBO_IOC_BT_HWVER           6
-
-#define COMBO_IOC_MAGIC        0xb0
-#define COMBO_IOCTL_FW_ASSERT  _IOWR(COMBO_IOC_MAGIC, 0, void*)
-#if WMT_CREATE_NODE_DYNAMIC
-struct class * bt_class = NULL;
-struct device * bt_dev = NULL;
-#endif
-
 static unsigned int gDbgLevel = BT_LOG_INFO;
 
 #define BT_DBG_FUNC(fmt, arg...)    if(gDbgLevel >= BT_LOG_DBG){ printk(PFX "%s: "  fmt, __FUNCTION__ ,##arg);}
@@ -60,9 +49,30 @@ static unsigned int gDbgLevel = BT_LOG_INFO;
 #define BT_TRC_FUNC(f)              if(gDbgLevel >= BT_LOG_DBG){printk(PFX "<%s> <%d>\n", __FUNCTION__, __LINE__);}
 
 #define VERSION "1.0"
+#define BT_DRIVER_NAME "mtk_stp_BT_chrdev"
+#define BT_DEV_MAJOR 192 // never used number
 #define BT_NVRAM_CUSTOM_NAME "/data/BT_Addr"
 
-static int BT_devs = 1;        /* device count */
+#if 0
+#define COMBO_IOC_MAGIC        0xb0
+#define COMBO_IOCTL_FW_ASSERT  _IOWR(COMBO_IOC_MAGIC, 0, void*)
+#define COMBO_IOCTL_BT_IC_HW_VER  _IOWR(COMBO_IOC_MAGIC, 1, int)
+#define COMBO_IOCTL_BT_IC_FW_VER  _IOWR(COMBO_IOC_MAGIC, 2, int)
+#define COMBO_IOC_BT_HWVER           6
+#else
+#define COMBO_IOCTL_FW_ASSERT        2
+#define COMBO_IOCTL_BT_IC_HW_VER     3
+#define COMBO_IOCTL_BT_IC_FW_VER     4
+#define COMBO_IOC_BT_HWVER           5
+#define COMBO_IOC_BT_SET_PSM         6
+#endif
+
+#if WMT_CREATE_NODE_DYNAMIC
+struct class * bt_class = NULL;
+struct device * bt_dev = NULL;
+#endif
+
+static int BT_devs = 1;                   /* device count */
 static int BT_major = BT_DEV_MAJOR;       /* dynamic allocation */
 module_param(BT_major, uint, 0);
 static struct cdev BT_cdev;
@@ -383,19 +393,29 @@ long BT_unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
                 BT_INFO_FUNC("BT Set fw assert OK\n");
                 retval = 0;
             } else {
-                BT_INFO_FUNC("BT Set fw assert Failed\n");
+                BT_ERR_FUNC("BT Set fw assert Failed\n");
                 retval = (-1000);
             }
             break;
         default:
             retval = -EFAULT;
-            BT_DBG_FUNC("BT_ioctl(): unknown cmd (%d)\n", cmd);
+            BT_ERR_FUNC("unknown cmd (%d)\n", cmd);
             break;
     }
 
     return retval;
 }
 
+long BT_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	long ret;
+
+	BT_INFO_FUNC("cmd[0x%x]\n", cmd);
+	ret = BT_unlocked_ioctl(filp, cmd, arg);
+	
+	return ret;
+}
+
 static int BT_open(struct inode *inode, struct file *file)
 {
     BT_INFO_FUNC("%s: major %d minor %d (pid %d)\n", __func__,
@@ -407,7 +427,7 @@ static int BT_open(struct inode *inode, struct file *file)
 #if 1 /* GeorgeKuo: turn on function before check stp ready */
      /* turn on BT */
     if (MTK_WCN_BOOL_FALSE == mtk_wcn_wmt_func_on(WMTDRV_TYPE_BT)) {
-        BT_WARN_FUNC("WMT turn on BT fail!\n");
+        BT_ERR_FUNC("WMT turn on BT fail!\n");
         return -ENODEV;
     }else{
         retflag = 0;
@@ -485,6 +505,7 @@ struct file_operations BT_fops = {
     .write = BT_write,
 //    .ioctl = BT_ioctl,
     .unlocked_ioctl = BT_unlocked_ioctl,
+    .compat_ioctl = BT_compat_ioctl,
     .poll = BT_poll
 };
 
diff --git a/drivers/misc/mediatek/connectivity/conn_soc/common/linux/pub/wmt_chrdev_wifi.c b/drivers/misc/mediatek/connectivity/conn_soc/common/linux/pub/wmt_chrdev_wifi.c
index 0a138e6..77c251f 100644
--- a/drivers/misc/mediatek/connectivity/conn_soc/common/linux/pub/wmt_chrdev_wifi.c
+++ b/drivers/misc/mediatek/connectivity/conn_soc/common/linux/pub/wmt_chrdev_wifi.c
@@ -373,6 +373,7 @@ ssize_t WIFI_write(struct file *filp, const char __user *buf, size_t count, loff
 
             if (MTK_WCN_BOOL_FALSE == mtk_wcn_wmt_func_off(WMTDRV_TYPE_WIFI)) {
                 WIFI_ERR_FUNC("WMT turn off WIFI fail!\n");
+                powered = 2;
             }
             else {
                 WIFI_INFO_FUNC("WMT turn off WIFI OK!\n");
@@ -390,6 +391,11 @@ ssize_t WIFI_write(struct file *filp, const char __user *buf, size_t count, loff
                 WIFI_INFO_FUNC("WIFI is already power on!\n");
                 retval = count;
                 goto done;
+            } else if (powered == 2) {
+            	/* workaround for wifi turn off fail. otherwise, 
+            	   will KE in register_netdevice with wrong dev->state */
+                WIFI_ERR_FUNC("WIFI turn off fail last time, can't turn on again!\n");
+                goto done;
             }
 
             if (MTK_WCN_BOOL_FALSE == mtk_wcn_wmt_func_on(WMTDRV_TYPE_WIFI)) {
@@ -477,6 +483,13 @@ ssize_t WIFI_write(struct file *filp, const char __user *buf, size_t count, loff
             }
         }
         else if (local[0] == 'S' || local[0] == 'P' || local[0] == 'A') {
+            if (powered == 2) {
+                /* workaround for wifi turn off fail. otherwise, 
+                   will KE in register_netdevice with wrong dev->state */
+                WIFI_ERR_FUNC("WIFI turn off fail last time, can't turn on again!\n");
+                goto done;
+            }
+
             if (powered == 0) {
                 /* If WIFI is off, turn on WIFI first */
                 if (MTK_WCN_BOOL_FALSE == mtk_wcn_wmt_func_on(WMTDRV_TYPE_WIFI)) {
diff --git a/drivers/misc/mediatek/connectivity/conn_soc/drv_wlan/mt_wifi/wlan/common/wlan_lib.c b/drivers/misc/mediatek/connectivity/conn_soc/drv_wlan/mt_wifi/wlan/common/wlan_lib.c
index fb9224f..6fc7e3c 100644
--- a/drivers/misc/mediatek/connectivity/conn_soc/drv_wlan/mt_wifi/wlan/common/wlan_lib.c
+++ b/drivers/misc/mediatek/connectivity/conn_soc/drv_wlan/mt_wifi/wlan/common/wlan_lib.c
@@ -1242,19 +1242,10 @@ wlanAdapterStart (
     UINT_32 u4SetInfoLen;
 #endif
 
-	enum Adapter_Start_Fail_Reason {
-		ALLOC_ADAPTER_MEM_FAIL,
-		DRIVER_OWN_FAIL,
-		INIT_ADAPTER_FAIL,
-		RAM_CODE_DOWNLOAD_FAIL,
-		WAIT_FIRMWARE_READY_FAIL,
-		FAIL_REASON_MAX
-	} eFailReason;
     ASSERT(prAdapter);
 
     DEBUGFUNC("wlanAdapterStart");
 
-	eFailReason = FAIL_REASON_MAX;
     //4 <0> Reset variables in ADAPTER_T
     prAdapter->fgIsFwOwn = TRUE;
     prAdapter->fgIsEnterD3ReqIssued = FALSE;
@@ -1271,7 +1262,6 @@ wlanAdapterStart (
         if ( (u4Status = nicAllocateAdapterMemory(prAdapter)) != WLAN_STATUS_SUCCESS ) {
             DBGLOG(INIT, ERROR, ("nicAllocateAdapterMemory Error!\n"));
             u4Status = WLAN_STATUS_FAILURE;
-			eFailReason = ALLOC_ADAPTER_MEM_FAIL;
             break;
         }
 
@@ -1288,7 +1278,6 @@ wlanAdapterStart (
         if(prAdapter->fgIsFwOwn == TRUE) {
             DBGLOG(INIT, ERROR, ("nicpmSetDriverOwn() failed!\n"));
             u4Status = WLAN_STATUS_FAILURE;
-			eFailReason = DRIVER_OWN_FAIL;
             break;
         }
 
@@ -1296,7 +1285,6 @@ wlanAdapterStart (
         if ( (u4Status = nicInitializeAdapter(prAdapter)) != WLAN_STATUS_SUCCESS ) {
             DBGLOG(INIT, ERROR, ("nicInitializeAdapter failed!\n"));
             u4Status = WLAN_STATUS_FAILURE;
-			eFailReason = INIT_ADAPTER_FAIL;
             break;
         }
 #endif
@@ -1412,7 +1400,6 @@ wlanAdapterStart (
         #endif
 
             if(u4Status != WLAN_STATUS_SUCCESS) {
-				eFailReason = RAM_CODE_DOWNLOAD_FAIL;
                 break;
             }
 
@@ -1428,7 +1415,6 @@ wlanAdapterStart (
         else {
             DBGLOG(INIT, ERROR, ("No Firmware found!\n"));
             u4Status = WLAN_STATUS_FAILURE;
-			eFailReason = RAM_CODE_DOWNLOAD_FAIL;
             break;
         }
 
@@ -1616,7 +1602,6 @@ wlanAdapterStart (
             else if(kalIsCardRemoved(prAdapter->prGlueInfo) == TRUE
                     || fgIsBusAccessFailed == TRUE) {
                 u4Status = WLAN_STATUS_FAILURE;
-				eFailReason = WAIT_FIRMWARE_READY_FAIL;
                 break;
             }
             else if(i >= CFG_RESPONSE_POLLING_TIMEOUT) {
@@ -1626,7 +1611,6 @@ wlanAdapterStart (
                 DBGLOG(INIT, ERROR, ("Waiting for Ready bit: Timeout, ID=%u\n",
                         (u4MailBox0 & 0x0000FFFF)));
                 u4Status = WLAN_STATUS_FAILURE;
-				eFailReason = WAIT_FIRMWARE_READY_FAIL;
                 break;
             }
             else {
@@ -1697,7 +1681,6 @@ wlanAdapterStart (
         RECLAIM_POWER_CONTROL_TO_PM(prAdapter, FALSE);
 
         if(u4Status != WLAN_STATUS_SUCCESS) {
-			eFailReason = WAIT_FIRMWARE_READY_FAIL;
             break;
         }
 
@@ -1879,26 +1862,8 @@ wlanAdapterStart (
     }
     else {
         // release allocated memory
-		switch (eFailReason)
-		{
-		case WAIT_FIRMWARE_READY_FAIL:
-		case RAM_CODE_DOWNLOAD_FAIL:
-			DBGLOG(INIT, ERROR, ("Wait firmware ready fail or ram code download fail, FailReason: %d\n",
-					eFailReason));
-			KAL_WAKE_LOCK_DESTROY(prAdapter, &prAdapter->rTxThreadWakeLock);
-			nicRxUninitialize(prAdapter);
-			nicTxRelease(prAdapter);
-			/* System Service Uninitialization */
-		    nicUninitSystemService(prAdapter);
-		case INIT_ADAPTER_FAIL:
-		case DRIVER_OWN_FAIL:
-			nicReleaseAdapterMemory(prAdapter);
-		case ALLOC_ADAPTER_MEM_FAIL:
-			break;
-		default:
-			break;
-		}
-	}
+        nicReleaseAdapterMemory(prAdapter);
+    }
 
     return u4Status;
 } /* wlanAdapterStart */
@@ -4571,7 +4536,7 @@ wlanQueryPermanentAddress(
 
     // header checking ..
     prHifRxHdr = (P_HIF_RX_HEADER_T)aucBuffer;
-	if ((prHifRxHdr->u2PacketType & HIF_RX_HDR_PACKET_TYPE_MASK) != HIF_RX_PKT_TYPE_EVENT) {
+    if(prHifRxHdr->u2PacketType != HIF_RX_PKT_TYPE_EVENT) {
         return WLAN_STATUS_FAILURE;
     }
 
@@ -4661,7 +4626,7 @@ wlanQueryNicCapability(
 
     // header checking ..
     prHifRxHdr = (P_HIF_RX_HEADER_T)aucBuffer;
-	if ((prHifRxHdr->u2PacketType & HIF_RX_HDR_PACKET_TYPE_MASK) != HIF_RX_PKT_TYPE_EVENT) {
+    if(prHifRxHdr->u2PacketType != HIF_RX_PKT_TYPE_EVENT) {
         return WLAN_STATUS_FAILURE;
     }
 
@@ -5000,7 +4965,7 @@ wlanQueryPdMcr(
 
     // header checking ..
     prHifRxHdr = (P_HIF_RX_HEADER_T)aucBuffer;
-	if ((prHifRxHdr->u2PacketType & HIF_RX_HDR_PACKET_TYPE_MASK) != HIF_RX_PKT_TYPE_EVENT) {
+    if(prHifRxHdr->u2PacketType != HIF_RX_PKT_TYPE_EVENT) {
         return WLAN_STATUS_FAILURE;
     }
 
diff --git a/drivers/misc/mediatek/connectivity/conn_soc/drv_wlan/mt_wifi/wlan/mgmt/p2p_func.c b/drivers/misc/mediatek/connectivity/conn_soc/drv_wlan/mt_wifi/wlan/mgmt/p2p_func.c
index aa1cebd..4144987 100644
--- a/drivers/misc/mediatek/connectivity/conn_soc/drv_wlan/mt_wifi/wlan/mgmt/p2p_func.c
+++ b/drivers/misc/mediatek/connectivity/conn_soc/drv_wlan/mt_wifi/wlan/mgmt/p2p_func.c
@@ -1162,7 +1162,11 @@ p2pFuncTxMgmtFrame (
 
         switch (prWlanHdr->u2FrameCtrl & MASK_FRAME_TYPE) {
         case MAC_FRAME_PROBE_RSP:
+
 			DBGLOG(P2P, TRACE, ("p2pFuncTxMgmtFrame:  TX MAC_FRAME_PROBE_RSP\n"));
+
+            prMgmtTxMsdu->ucStaRecIndex = (prStaRec != NULL)? (prStaRec->ucIndex):(STA_REC_INDEX_NOT_FOUND);
+	    
             prMgmtTxMsdu = p2pFuncProcessP2pProbeRsp(prAdapter, prMgmtTxMsdu);
             break;
         default:
@@ -3018,6 +3022,8 @@ p2pFuncProcessP2pProbeRsp (
                                                 prProbeRspFrame->aucDestAddr);
 
 
+	prRetMsduInfo->ucStaRecIndex = prMgmtTxMsdu->ucStaRecIndex;
+
         for (u4Idx = 0; u4Idx < u4IeArraySize; u4Idx++) {
             if (txProbeRspIETable[u4Idx].pfnAppendIE) {
                 txProbeRspIETable[u4Idx].pfnAppendIE(prAdapter, prRetMsduInfo);
diff --git a/drivers/misc/mediatek/connectivity/conn_soc/drv_wlan/mt_wifi/wlan/os/linux/gl_init.c b/drivers/misc/mediatek/connectivity/conn_soc/drv_wlan/mt_wifi/wlan/os/linux/gl_init.c
index a5149c3..bd33087 100644
--- a/drivers/misc/mediatek/connectivity/conn_soc/drv_wlan/mt_wifi/wlan/os/linux/gl_init.c
+++ b/drivers/misc/mediatek/connectivity/conn_soc/drv_wlan/mt_wifi/wlan/os/linux/gl_init.c
@@ -3015,17 +3015,8 @@ wlanProbe(
     P_ADAPTER_T prAdapter = NULL;
     INT_32 i4Status = 0;
     BOOLEAN bRet = FALSE;
-	enum probe_fail_reason {
-		BUS_INIT_FAIL,
-		NET_CREATE_FAIL,
-		BUS_SET_IRQ_FAIL,
-		ADAPTER_START_FAIL,
-		NET_REGISTER_FAIL,
-		PROC_INIT_FAIL,
-		FAIL_REASON_NUM
-	} eFailReason;
-
-	eFailReason = FAIL_REASON_NUM;
+
+
     do {
         //4 <1> Initialize the IO port of the interface
         /*  GeorgeKuo: pData has different meaning for _HIF_XXX:
@@ -3040,7 +3031,6 @@ wlanProbe(
         if (FALSE == bRet) {
             DBGLOG(INIT, ERROR, (KERN_ALERT "wlanProbe: glBusInit() fail\n"));
             i4Status = -EIO;
-			eFailReason = BUS_INIT_FAIL;
             break;
         }
 
@@ -3048,7 +3038,6 @@ wlanProbe(
         if ((prWdev = wlanNetCreate(pvData)) == NULL) {
             DBGLOG(INIT, ERROR, ("wlanProbe: No memory for dev and its private\n"));
             i4Status = -ENOMEM;
-			eFailReason = NET_CREATE_FAIL;
             break;
         }
 
@@ -3076,7 +3065,6 @@ wlanProbe(
 
         if (i4Status != WLAN_STATUS_SUCCESS) {
             DBGLOG(INIT, ERROR, ("wlanProbe: Set IRQ error\n"));
-			eFailReason = BUS_SET_IRQ_FAIL;
             break;
         }
 
@@ -3178,7 +3166,6 @@ bailout:
                 HifRegDump(prGlueInfo->prAdapter);
 //                if (prGlueInfo->rHifInfo.DmaOps->DmaRegDump != NULL)
 //                    prGlueInfo->rHifInfo.DmaOps->DmaRegDump(&prGlueInfo->rHifInfo);
-				eFailReason = ADAPTER_START_FAIL;
                 break;
             }
         }
@@ -3194,7 +3181,6 @@ bailout:
 
         if (wlanAdapterStart(prAdapter, prRegInfo, NULL, 0) != WLAN_STATUS_SUCCESS) {
             i4Status = -EIO;
-			eFailReason = ADAPTER_START_FAIL;
             break;
         }
 #endif
@@ -3233,11 +3219,6 @@ bailout:
             }
 #endif /* CFG_SUPPORT_ROAMING_ENC */
 
-#if CFG_SUPPORT_BCN_TUNE
-            /* adjust beacon timeout detection related parameters */
-            rlmBcnEnhanceConfig(prGlueInfo->prAdapter);
-#endif /* CFG_SUPPORT_TXR_ENC */
-
         /* set MAC address */
         {
             WLAN_STATUS rStatus = WLAN_STATUS_FAILURE;
@@ -3298,7 +3279,6 @@ bailout:
         if ((i4DevIdx = wlanNetRegister(prWdev)) < 0){
             i4Status = -ENXIO;
             DBGLOG(INIT, ERROR, ("wlanProbe: Cannot register the net_device context to the kernel\n"));
-			eFailReason = NET_REGISTER_FAIL;
             break;
         }
 		
@@ -3308,7 +3288,6 @@ bailout:
         DBGLOG(INIT, TRACE, ("init procfs...\n"));
         if ( (i4Status = procInitProcfs(prDev, NIC_DEVICE_ID_LOW)) < 0) {
             DBGLOG(INIT, ERROR, ("wlanProbe: init procfs failed\n"));
-			eFailReason = PROC_INIT_FAIL;
             break;
         }
 #endif /* WLAN_INCLUDE_PROC */
@@ -3339,30 +3318,10 @@ bailout:
     while (FALSE);
 
     if (i4Status != WLAN_STATUS_SUCCESS)
-	{
-		switch (eFailReason)
-		{
-		case PROC_INIT_FAIL:
-			wlanNetUnregister(prWdev);
-		case NET_REGISTER_FAIL:
-			set_bit(GLUE_FLAG_HALT_BIT, &prGlueInfo->ulFlag);
-			/* wake up main thread */
-		    wake_up_interruptible(&prGlueInfo->waitq);
-			/* wait main thread stops */
-		    wait_for_completion_interruptible(&prGlueInfo->rHaltComp);
-        	KAL_WAKE_LOCK_DESTROY(prGlueInfo->prAdapter, &prGlueInfo->rAhbIsrWakeLock);
-			wlanAdapterStop(prAdapter);
-		case ADAPTER_START_FAIL:
-        	if (prWdev != NULL)
-            	glBusFreeIrq(prWdev->netdev, *((P_GLUE_INFO_T *) netdev_priv(prWdev->netdev)));
-		case BUS_SET_IRQ_FAIL:
-			KAL_WAKE_LOCK_DESTROY(prAdapter, &prGlueInfo->rAhbIsrWakeLock);
-			wlanNetDestroy(prWdev);
-		case NET_CREATE_FAIL:
-		case BUS_INIT_FAIL:
-		default:
-			break;
-		}
+    {
+        KAL_WAKE_LOCK_DESTROY(prGlueInfo->prAdapter, &prGlueInfo->rAhbIsrWakeLock);
+        if (prWdev != NULL)
+            glBusFreeIrq(prWdev->netdev, *((P_GLUE_INFO_T *) netdev_priv(prWdev->netdev)));
     }
 
 #if CFG_ENABLE_WIFI_DIRECT
@@ -3379,28 +3338,14 @@ bailout:
         kalIndicateAgpsNotify(prAdapter, AGPS_EVENT_WLAN_ON, NULL, 0);
 #endif
 #if (CFG_SUPPORT_MET_PROFILING == 1)
-	{
-		int iMetInitRet = WLAN_STATUS_FAILURE;
-		if (i4Status == WLAN_STATUS_SUCCESS)
-		{
-    		DBGLOG(INIT, TRACE, ("init MET procfs...\n"));
-			iMetInitRet = kalMetInitProcfs(prGlueInfo);
-    		if (iMetInitRet < 0)
-			{
-        		DBGLOG(INIT, ERROR, ("wlanProbe: init MET procfs failed\n"));
-			}
-    	}
-	}
+    DBGLOG(INIT, TRACE, ("init MET procfs...\n"));
+    printk("MET_PROF: MET PROCFS init....\n");
+    if ( (i4Status = kalMetInitProcfs(prGlueInfo)) < 0) {
+        DBGLOG(INIT, ERROR, ("wlanProbe: init MET procfs failed\n"));
+    }
 #endif
-	if (i4Status == WLAN_STATUS_SUCCESS) {
-		/* probe ok */
-		DBGLOG(INIT, TRACE, ("wlanProbe ok\n"));
-	} else {
-		/* probe failed */
-		DBGLOG(INIT, ERROR, ("wlanProbe failed\n"));
-	}
-
-	return i4Status;
+    DBGLOG(INIT, TRACE, ("wlanProbe ok\n"));
+    return i4Status;
 } /* end of wlanProbe() */
 
 
diff --git a/drivers/misc/mediatek/dispsys/mt6752/Makefile b/drivers/misc/mediatek/dispsys/mt6752/Makefile
index 37eaa30..e8eb155 100644
--- a/drivers/misc/mediatek/dispsys/mt6752/Makefile
+++ b/drivers/misc/mediatek/dispsys/mt6752/Makefile
@@ -11,7 +11,7 @@ ifeq ($(CONFIG_TRUSTONIC_TEE_SUPPORT),y)
 ccflags-y += \
 	 -I$(srctree)/drivers/misc/mediatek/gud/$(MTK_PLATFORM)/gud/MobiCoreKernelApi/public \
 	 -I$(srctree)/drivers/misc/mediatek/gud/$(MTK_PLATFORM)/gud/MobiCoreKernelApi/include \
-	 -I$(srctree)/../vendor/trustonic/platform/$(MTK_PLATFORM)/trustlets/tplay/Tltplay/public
+	 -I$(srctree)/drivers/misc/mediatek/mach/$(MTK_PLATFORM)/include/trustzone/tplay/Tltplay
 
 endif
 endif
diff --git a/drivers/misc/mediatek/dispsys/mt6752/ddp_dsi.c b/drivers/misc/mediatek/dispsys/mt6752/ddp_dsi.c
index cf8869f..957ee4b 100644
--- a/drivers/misc/mediatek/dispsys/mt6752/ddp_dsi.c
+++ b/drivers/misc/mediatek/dispsys/mt6752/ddp_dsi.c
@@ -23,13 +23,13 @@
 #include <cust_gpio_usage.h>
 #include "ddp_mmp.h"
 
-typedef enum
+/*typedef enum
 {
     PM_DSI0 = 0,
     PM_DSI1 = 1,
     PM_DSI_DUAL = 2,
     PM_DSI_MAX	= 0XFF,	
-} DSI_INDEX;
+} DSI_INDEX;*/
 
 //static unsigned int _dsi_reg_update_wq_flag = 0;
 static DECLARE_WAIT_QUEUE_HEAD(_dsi_reg_update_wq);
diff --git a/drivers/misc/mediatek/eccci/ccci_core.c b/drivers/misc/mediatek/eccci/ccci_core.c
index 5b7dfe4..02eeeac 100644
--- a/drivers/misc/mediatek/eccci/ccci_core.c
+++ b/drivers/misc/mediatek/eccci/ccci_core.c
@@ -369,8 +369,11 @@ int exec_ccci_kern_func_by_md_id(int md_id, unsigned int id, char *buf, unsigned
 		 */
 		if(md->md_state != READY)
 			ret = 1;
-		else
+		else {
 			ret = ccci_send_msg_to_md(md, CCCI_SYSTEM_TX, MD_PAUSE_LTE, *((int *)buf), 1);
+			if (ret == -CCCI_ERR_MD_NOT_READY || ret == -CCCI_ERR_HIF_NOT_POWER_ON)
+				ret = 1;
+		}
 		break;
    	case ID_STORE_SIM_SWITCH_MODE:
         {
diff --git a/drivers/misc/mediatek/eccci/ccci_core.h b/drivers/misc/mediatek/eccci/ccci_core.h
index 64d3320..89b816e 100644
--- a/drivers/misc/mediatek/eccci/ccci_core.h
+++ b/drivers/misc/mediatek/eccci/ccci_core.h
@@ -542,13 +542,7 @@ static inline int ccci_port_recv_skb(struct ccci_modem *md, struct sk_buff *skb)
 			seq_num = ccci_h->seq_num;
 			assert_bit = ccci_h->assert_bit;
 #endif
-            if(port->ops->recv_skb){
 			ret = port->ops->recv_skb(port, skb);
-            }else{
-                CCCI_ERR_MSG(md->index, CORE, "port->ops->recv_skb is null\n");
-                ret == -CCCI_ERR_CHANNEL_NUM_MIS_MATCH;
-                goto err_exit;
-            }
 #ifdef FEATURE_SEQ_CHECK_EN
 			if(ret>=0 || ret==-CCCI_ERR_DROP_PACKET) {
 				if(assert_bit && ((seq_num - md->seq_nums[IN][channel]) & 0x7FFF) != 1) {
@@ -611,14 +605,7 @@ static inline int ccci_port_recv_request(struct ccci_modem *md, struct ccci_requ
 			seq_num = ccci_h->seq_num;
 			assert_bit = ccci_h->assert_bit;
 #endif
-            if(port->ops->recv_request){
 			ret = port->ops->recv_request(port, req);
-            }else{
-                CCCI_ERR_MSG(md->index, CORE, "port->ops->recv_request is null\n");
-                ret == -CCCI_ERR_CHANNEL_NUM_MIS_MATCH;
-                goto err_exit;
-            }
-
 #ifdef FEATURE_SEQ_CHECK_EN
 			if(ret>=0 || ret==-CCCI_ERR_DROP_PACKET) {
 				if(assert_bit && ((seq_num - md->seq_nums[IN][channel]) & 0x7FFF) != 1) {
diff --git a/drivers/misc/mediatek/eccci/modem_ccif.c b/drivers/misc/mediatek/eccci/modem_ccif.c
index 4e99345..ca6fa2a 100644
--- a/drivers/misc/mediatek/eccci/modem_ccif.c
+++ b/drivers/misc/mediatek/eccci/modem_ccif.c
@@ -49,7 +49,7 @@
 #define NET_RX_QUEUE_MASK 0x38
 #define NAPI_QUEUE_MASK NET_RX_QUEUE_MASK // Rx, only Rx-exclusive port can enable NAPI
 
-#define IS_PASS_SKB(md,qno) ((md->md_state!=EXCEPTION || md->ex_stage!=EX_INIT_DONE) &&((1<<qno) & NET_RX_QUEUE_MASK)) 
+#define IS_PASS_SKB(md,qno) (md->md_state!=EXCEPTION &&((1<<qno) & NET_RX_QUEUE_MASK)) 
 
 #define RX_BUGDET 16
 
diff --git a/drivers/misc/mediatek/eccci/modem_cldma.c b/drivers/misc/mediatek/eccci/modem_cldma.c
index 1ebe78e..e78dbf9 100644
--- a/drivers/misc/mediatek/eccci/modem_cldma.c
+++ b/drivers/misc/mediatek/eccci/modem_cldma.c
@@ -95,7 +95,7 @@ static const unsigned char high_priority_queue_mask =  0x00;
 
 #define TAG "mcd"
 
-#define IS_PASS_SKB(md,qno) ((md->md_state!=EXCEPTION || md->ex_stage!=EX_INIT_DONE) &&((1<<qno) & NET_RX_QUEUE_MASK)) 
+#define IS_PASS_SKB(md,qno) (md->md_state!=EXCEPTION &&((1<<qno) & NET_RX_QUEUE_MASK)) 
 /*
  * do NOT add any static data, data should be in modem's instance
  */
@@ -294,7 +294,7 @@ static int cldma_rx_collect(struct md_cd_queue *queue, int budget, int blocking,
 
     struct ccci_request *req;
     struct cldma_rgpd *rgpd;
-	struct ccci_request *new_req = NULL;
+    struct ccci_request *new_req;
     struct ccci_header ccci_h;
     struct sk_buff *skb;
 #ifdef CLDMA_TRACE
@@ -305,7 +305,7 @@ static int cldma_rx_collect(struct md_cd_queue *queue, int budget, int blocking,
     unsigned long long total_handle_time=0;
 #endif
     int ret=0, count=0,qno=queue->index;
-	unsigned long long skb_bytes = 0;
+    unsigned long long skb_bytes;
     *result = UNDER_BUDGET;
     *rxbytes =0;
 
@@ -553,6 +553,7 @@ static int cldma_tx_collect(struct md_cd_queue *queue, int budget, int blocking,
     struct ccci_modem *md = queue->modem;
     struct md_cd_ctrl *md_ctrl = (struct md_cd_ctrl *)md->private_data;
     unsigned long flags;
+
     struct ccci_request *req;
     struct cldma_tgpd *tgpd;
     struct ccci_header *ccci_h;
@@ -950,7 +951,7 @@ static irqreturn_t cldma_isr(int irq, void *data)
 static void cldma_irq_work(struct work_struct *work)
 {
 	struct md_cd_ctrl *md_ctrl = container_of(work, struct md_cd_ctrl, cldma_irq_work);
-	struct ccci_modem *md = md_ctrl->modem;
+	struct ccci_modem *md = md_ctrl->txq[0].modem;
     cldma_irq_work_cb(md);
 }
 
@@ -1092,28 +1093,11 @@ static inline void cldma_stop_for_ee(struct ccci_modem *md)
 static inline void cldma_reset(struct ccci_modem *md)
 {
     struct md_cd_ctrl *md_ctrl = (struct md_cd_ctrl *)md->private_data;
-	volatile unsigned int SO_CFG;
     
     CCCI_INF_MSG(md->index, TAG, "%s from %ps\n", __FUNCTION__, __builtin_return_address(0));
     cldma_stop(md);
-    // enable OUT DMA
-    cldma_write32(md_ctrl->cldma_ap_ao_base, CLDMA_AP_SO_CFG, cldma_read32(md_ctrl->cldma_ap_ao_base, CLDMA_AP_SO_CFG)|0x01);
-	SO_CFG = cldma_read32(md_ctrl->cldma_ap_ao_base, CLDMA_AP_SO_CFG);
-	if (SO_CFG & 0x1 == 0)  // write function didn't work
-	{
-		CCCI_ERR_MSG(md->index, TAG, "Enable AP OUTCLDMA failed. Register can't be wrote. SO_CFG=0x%x\n", SO_CFG);
-		cldma_dump_register(md);
-		cldma_write32(md_ctrl->cldma_ap_ao_base, CLDMA_AP_SO_CFG, cldma_read32(md_ctrl->cldma_ap_ao_base, CLDMA_AP_SO_CFG)|0x01);
-	}
-    // wait RGPD write transaction repsonse
-    cldma_write32(md_ctrl->cldma_ap_ao_base, CLDMA_AP_SO_CFG, cldma_read32(md_ctrl->cldma_ap_ao_base, CLDMA_AP_SO_CFG) | 0x4);
-	SO_CFG = cldma_read32(md_ctrl->cldma_ap_ao_base, CLDMA_AP_SO_CFG);
-	if (SO_CFG & 0x1 == 0)  // write function didn't work
-	{
-		CCCI_ERR_MSG(md->index, TAG, "Enable AP OUTCLDMA failed. Register can't be wrote. SO_CFG=0x%x\n", SO_CFG);
-		cldma_dump_register(md);
-		cldma_write32(md_ctrl->cldma_ap_ao_base, CLDMA_AP_SO_CFG, cldma_read32(md_ctrl->cldma_ap_ao_base, CLDMA_AP_SO_CFG)|0x05);
-	}
+    // enable OUT DMA & wait RGPD write transaction repsonse
+    cldma_write32(md_ctrl->cldma_ap_ao_base, CLDMA_AP_SO_CFG, cldma_read32(md_ctrl->cldma_ap_ao_base, CLDMA_AP_SO_CFG) | 0x5);
     // enable SPLIT_EN
     cldma_write32(md_ctrl->cldma_ap_ao_base, CLDMA_AP_BUS_CFG, cldma_read32(md_ctrl->cldma_ap_ao_base, CLDMA_AP_BUS_CFG)|0x02);
     // set high priority queue
@@ -1311,17 +1295,25 @@ static int md_cd_start_queue(struct ccci_modem *md, unsigned char qno, DIRECTION
 static void md_cd_wdt_work(struct work_struct *work)
 {
     struct md_cd_ctrl *md_ctrl = container_of(work, struct md_cd_ctrl, wdt_work);
-	struct ccci_modem *md = md_ctrl->modem;
-	int ret = 0;
+    struct ccci_modem *md = md_ctrl->txq[0].modem;
+    int ret = 0;
+#ifdef  ENABLE_CLDMA_AP_SIDE    
     // 1. dump RGU reg
-	CCCI_INF_MSG(md->index, TAG, "Dump MD RGU registers\n");
+    CCCI_INF_MSG(0, TAG, "Dump MD RGU registers\n");
     md_cd_lock_modem_clock_src(1);
-	ccci_mem_dump(md->index, md_ctrl->md_rgu_base, 0x30);
+    ccci_mem_dump(0, md_ctrl->md_rgu_base, 0x30);
     md_cd_lock_modem_clock_src(0);
-	if(md->md_state == INVALID) {
-		CCCI_ERR_MSG(md->index, TAG, "md_cd_wdt_work: md_state is INVALID\n");
-		return;
-	}
+#else
+    CCCI_INF_MSG(md->index, TAG, "Dump MD RGU registers\n");
+    md_cd_lock_modem_clock_src(1);
+    ccci_mem_dump(md->index, md_ctrl->md_rgu_base, 0x30);
+    md_cd_lock_modem_clock_src(0);
+#endif
+
+#ifdef CONFIG_ARCH_MT6753
+	CCCI_INF_MSG(0, TAG, "tmp return for D3 bringup!\n");
+	return;
+#endif
     // 2. wakelock
     wake_lock_timeout(&md_ctrl->trm_wake_lock, 10*HZ);
 
@@ -1458,7 +1450,7 @@ static void md_cd_exception(struct ccci_modem *md, HIF_EX_STAGE stage)
 static void md_cd_ccif_delayed_work(struct work_struct *work)
 {
     struct md_cd_ctrl *md_ctrl = container_of(to_delayed_work(work), struct md_cd_ctrl, ccif_delayed_work);
-	struct ccci_modem *md = md_ctrl->modem;
+    struct ccci_modem *md = md_ctrl->txq[0].modem;
     int i;
 
 #if defined (CONFIG_MTK_AEE_FEATURE)
@@ -1485,7 +1477,7 @@ static void md_cd_ccif_delayed_work(struct work_struct *work)
 static void md_cd_ccif_work(struct work_struct *work)
 {
     struct md_cd_ctrl *md_ctrl = container_of(work, struct md_cd_ctrl, ccif_work);
-	struct ccci_modem *md = md_ctrl->modem;
+    struct ccci_modem *md = md_ctrl->txq[0].modem;
     // seems sometime MD send D2H_EXCEPTION_INIT_DONE and D2H_EXCEPTION_CLEARQ_DONE together
     if(md_ctrl->channel_id & (1<<D2H_EXCEPTION_INIT))
         md_cd_exception(md, HIF_EX_INIT);
@@ -1959,20 +1951,13 @@ static int md_cd_write_room(struct ccci_modem *md, unsigned char qno)
     return md_ctrl->txq[qno].free_slot;
 }
 
-/*
-*[IMPORTANT NOTES]
-* For improve network performance, network port will pass skb directly by req args
-* So we should check current port no whethe is network queue by IS_PASS_SKB(md,qno),
-* if yes,  skb=(struct sk_buff *)req;
-* else req is struct ccci_request *
-*/
 static int md_cd_send_request(struct ccci_modem *md, unsigned char qno, struct ccci_request* req)
 {
     struct md_cd_ctrl *md_ctrl = (struct md_cd_ctrl *)md->private_data;
     struct md_cd_queue *queue;
     struct ccci_request *tx_req;
     struct cldma_tgpd *tgpd;
-    int ret=0;
+    int ret;
     int blocking;
     struct ccci_header *ccci_h;
     struct sk_buff *skb;
@@ -2847,10 +2832,10 @@ static int ccci_modem_probe(struct platform_device *plat_dev)
     // init modem structure
     md->ops = &md_cd_ops;
     CCCI_INF_MSG(md_id, TAG, "md_cldma_probe:md=%p,md->private_data=%p\n",md,md->private_data);
+    md_ctrl = (struct md_cd_ctrl *)md->private_data;
 
     // init modem private data
     md_ctrl = (struct md_cd_ctrl *)md->private_data;
-	md_ctrl->modem = md;
     md_ctrl->hw_info = md_hw;
     md_ctrl->txq_active = 0;
     md_ctrl->rxq_active = 0;
diff --git a/drivers/misc/mediatek/eccci/modem_cldma.h b/drivers/misc/mediatek/eccci/modem_cldma.h
index 1f5dce5..e139f2e 100644
--- a/drivers/misc/mediatek/eccci/modem_cldma.h
+++ b/drivers/misc/mediatek/eccci/modem_cldma.h
@@ -43,7 +43,6 @@ struct md_cd_queue {
 };
 
 struct md_cd_ctrl {
-	struct ccci_modem * modem;
 	// hardcode, max queue number should be synced with struct ccci_port@ccci_core.h
 	struct md_cd_queue txq[CLDMA_TXQ_NUM];
 	struct md_cd_queue rxq[CLDMA_RXQ_NUM];
diff --git a/drivers/misc/mediatek/etm/mt6752/etmv4/etm_register_v4.h b/drivers/misc/mediatek/etm/mt6752/etmv4/etm_register_v4.h
index ae64ae2..48fb9b3 100644
--- a/drivers/misc/mediatek/etm/mt6752/etmv4/etm_register_v4.h
+++ b/drivers/misc/mediatek/etm/mt6752/etmv4/etm_register_v4.h
@@ -466,5 +466,8 @@
 
 /** bits mask which indicates the current effective value of programming bit */
 #define ETMSR_PROGRAM	(1<<1)
-
+/*ETM Use this register to know if ETM is permitted to run.*/
+#define DBGAUTHSTATUS_EL1 0xFB8
+#define NSNID_SHIFT 2
+#define SNID_SHIFT 6
 #endif
diff --git a/drivers/misc/mediatek/etm/mt6752/etmv4/etm_v4.c b/drivers/misc/mediatek/etm/mt6752/etmv4/etm_v4.c
index 27df71c..74241bc 100644
--- a/drivers/misc/mediatek/etm/mt6752/etmv4/etm_v4.c
+++ b/drivers/misc/mediatek/etm/mt6752/etmv4/etm_v4.c
@@ -30,7 +30,7 @@
 #define CS_TP_PORTSIZE 16
 /* T32 is 0x2001, we can apply 0x1 is fine */
 #define CS_FORMATMODE 0x11	/* Enable Continuous formatter and FLUSHIN */
-//#define ETM_DEBUG 0
+//#define ETM_DEBUG 1
 //#define ETM_INIT_SAMPLE_CODE 1
 
 #ifdef ETM_DEBUG
@@ -81,6 +81,12 @@ struct etm_trace_context_t
 	struct mutex mutex;
 };
 
+static int restart_trace(struct notifier_block *nfb, unsigned long action, void *hcpu);
+
+static struct notifier_block __cpuinitdata pftracer_notifier = {
+        .notifier_call = restart_trace,
+};
+
 static struct etm_trace_context_t tracer;
 
 DEFINE_PER_CPU(int, trace_pwr_down);
@@ -1791,11 +1797,9 @@ static void remove_files(void)
 
 static int etm_probe(struct platform_device *pdev)
 {
-	int ret = 0, i;
-
+    int ret = 0, i;
     ETM_PRINT("[ETM LOG] etm_probe\n");
-
-	mutex_lock(&tracer.mutex);
+    mutex_lock(&tracer.mutex);
 
     of_property_read_u32(pdev->dev.of_node, "num", &tracer.nr_etm_regs);
 
@@ -1815,6 +1819,7 @@ static int etm_probe(struct platform_device *pdev)
         ETM_PRINT("[ETM LOG]etm %d @ 0x%p\n", i+1, tracer.etm_regs[i]);
     }
 
+
     tracer.etm_info = kmalloc(sizeof(struct etm_info) * tracer.nr_etm_regs, GFP_KERNEL);
 	if (!tracer.etm_info) {
 		pr_err("[ETM LOG] Failed to allocate ETM info array\n");
@@ -1822,6 +1827,9 @@ static int etm_probe(struct platform_device *pdev)
 		goto out;
 	}
 
+
+
+
     for(i = 0; i < tracer.nr_etm_regs; i++) {
         memset(&(tracer.etm_info[i]), 0, sizeof(struct etm_info));
         tracer.etm_info[i].enable = 1;
@@ -1984,7 +1992,7 @@ int etb_probe(struct platform_device *pdev)
 	tracer.state = TRACE_STATE_STOP;
 
 	mutex_unlock(&tracer.mutex);
-        ETM_PRINT("[ETM LOG][ETM LOG] ETBCTL &0x%lx=0x%x\n",(vmalloc_to_pfn(tracer.etb_regs)<<12)+ETBCTL,cs_cpu_read(tracer.etb_regs+ETBCTL,0x0));
+        ETM_PRINT("[ETM LOG] ETBCTL &0x%lx=0x%x\n",(vmalloc_to_pfn(tracer.etb_regs)<<12)+ETBCTL,cs_cpu_read(tracer.etb_regs+ETBCTL,0x0));
         ETM_PRINT("[ETM LOG][ETM LOG] %s Done\n",__func__);
 	return 0;
 }
@@ -2080,16 +2088,50 @@ restart_trace(struct notifier_block *nfb, unsigned long action, void *hcpu)
 	return NOTIFY_OK;
 }
 
-static struct notifier_block __cpuinitdata pftracer_notifier = {
-	.notifier_call = restart_trace,
+
+
+static unsigned int check_if_non_invasive_debug_enable(void){
+	unsigned int auth_status = 0;
+	unsigned int etm_enable = 0;
+#ifdef CONFIG_ARM64
+	asm volatile("MRS %0,DBGAUTHSTATUS_EL1" : "=r" (auth_status));
+	etm_enable = (auth_status >> NSNID_SHIFT) & 0x1;
+#else
+
+/*
+* Since we can't read SCR register in non-secure mode, we can't get info about
+* which mode we are in.
+* Thus, We use these config to identify if this is ATF or TEE Project.
+* If, it is ATF/TEE Proejct kernel is run in non-secure mode, else it is run in secure mode.
+*/
+
+
+#if  defined(CONFIG_ARM_PSCI) || defined(CONFIG_MTK_PSCI)
+        asm volatile("MRC p14,0,%0,c7,c14,6" : "=r" (auth_status));
+	etm_enable = (auth_status >> NSNID_SHIFT) & 0x1;
+#else
+        asm volatile("MRC p14,0,%0,c7,c14,6" : "=r" (auth_status));
+	etm_enable = (auth_status >> SNID_SHIFT) & 0x1;
+#endif
+#endif
+	pr_notice("[ETM LOG] Authencation Interface, status 0x%x, etm_enable 0x%x\n",auth_status,etm_enable);
+	return etm_enable;
 };
 
+
+
 /**
  * driver initialization entry point
  */
 static int __init etm_init(void)
 {
 	int i, err;
+
+        if(!check_if_non_invasive_debug_enable()){
+            pr_notice("[ETM LOG] ETM DEBUG is not permitted by authentication interface of this chip\n");	
+	    return -EPERM;
+	}
+	
 	memset(&tracer, 0,sizeof(struct etm_trace_context_t));
 	mutex_init(&tracer.mutex);
 	tracer.trace_range_start = TRACE_RANGE_START;
diff --git a/drivers/misc/mediatek/fmradio/core/fm_main.c b/drivers/misc/mediatek/fmradio/core/fm_main.c
index 11233c0..38d318f 100644
--- a/drivers/misc/mediatek/fmradio/core/fm_main.c
+++ b/drivers/misc/mediatek/fmradio/core/fm_main.c
@@ -173,21 +173,21 @@ fm_s32 fm_set_stat(struct fm *fmp, int which, bool stat)
 		ret = -1;
 		WCN_DBG(FM_ERR | MAIN, "fm set stat error, object=%d, stat=%d\n", which, stat);
 	}
-	
+
     FM_UNLOCK(fm_ops_lock);
 	return ret;
 }
 
 fm_s32 fm_get_stat(struct fm *fmp, int which, bool *stat)
-{	
+{
     fm_s32 ret = 0;
     FMR_ASSERT(fmp);
-    FMR_ASSERT(stat);	
+    FMR_ASSERT(stat);
     if (FM_LOCK(fm_ops_lock)) return (-FM_ELOCK);
 
 	if(which < (sizeof(g_fm_stat)/sizeof(g_fm_stat[0])))
 	{
-		*stat = g_fm_stat[which];		
+		*stat = g_fm_stat[which];
         WCN_DBG(FM_DBG | MAIN, "fm get stat object=%d, stat=%d\n", which, *stat);
 	}
 	else
@@ -195,8 +195,8 @@ fm_s32 fm_get_stat(struct fm *fmp, int which, bool *stat)
 		ret = -1;
 		WCN_DBG(FM_ERR | MAIN, "fm get stat error, object=%d\n", which);
 	}
-	
-    FM_UNLOCK(fm_ops_lock);	
+
+    FM_UNLOCK(fm_ops_lock);
 	return ret;
 }
 
@@ -538,7 +538,7 @@ fm_s32 fm_powerup_tx(struct fm *fm, struct fm_tune_parm *parm)
 	if (ret) {
 		parm->err = FM_FAILED;
 		fm_pwr_state_set(fm, FM_PWR_OFF);
-		WCN_DBG(FM_ERR | MAIN,"FM pwr up Tx fail!\n"); 
+		WCN_DBG(FM_ERR | MAIN,"FM pwr up Tx fail!\n");
 	} else {
 		parm->err = FM_SUCCESS;
 	}
@@ -692,7 +692,7 @@ fm_s32 fm_seek(struct fm *fm, struct fm_seek_parm *parm)
 	} else if (parm->band == FM_BAND_SPECIAL) {
 		fm->min_freq = FM_RX_BAND_FREQ_L;
 		fm->max_freq = FM_RX_BAND_FREQ_H;
-	} 
+	}
 #else
 	if (parm->band == FM_BAND_UE) {
 		fm->min_freq = FM_UE_FREQ_MIN * 10;
@@ -703,7 +703,7 @@ fm_s32 fm_seek(struct fm *fm, struct fm_seek_parm *parm)
 	} else if (parm->band == FM_BAND_SPECIAL) {
 		fm->min_freq = FM_RX_BAND_FREQ_L * 10;
 		fm->max_freq = FM_RX_BAND_FREQ_H * 10;
-	} 
+	}
 #endif
 	else {
 		WCN_DBG(FM_ALT | MAIN, "band:%d out of range\n", parm->band);
@@ -805,7 +805,7 @@ fm_s32 fm_tx_scan(struct fm *fm, struct fm_tx_scan_parm *parm)
 	} else if (parm->band == FM_BAND_SPECIAL) {
 		fm->min_freq = FM_FREQ_MIN * 10;
 		fm->max_freq = FM_FREQ_MAX * 10;
-	}	
+	}
 #else
 	if (parm->band == FM_BAND_UE) {
 		fm->min_freq = FM_UE_FREQ_MIN;
@@ -816,7 +816,7 @@ fm_s32 fm_tx_scan(struct fm *fm, struct fm_tx_scan_parm *parm)
 	} else if (parm->band == FM_BAND_SPECIAL) {
  		fm->min_freq = FM_FREQ_MIN;
 		fm->max_freq = FM_FREQ_MAX;
-	} 	
+	}
 #endif
 	else {
 		WCN_DBG(FM_ERR | MAIN, "band:%d out of range\n", parm->band);
@@ -892,7 +892,7 @@ fm_s32 fm_scan(struct fm *fm, struct fm_scan_parm *parm)
 		} else if (parm->band == FM_BAND_SPECIAL) {
 			fm->min_freq = FM_FREQ_MIN * 10;
 			fm->max_freq = FM_FREQ_MAX * 10;
-		}	
+		}
 #else
 	if (parm->band == FM_BAND_UE) {
 		fm->min_freq = FM_UE_FREQ_MIN;
@@ -903,7 +903,7 @@ fm_s32 fm_scan(struct fm *fm, struct fm_scan_parm *parm)
 	} else if (parm->band == FM_BAND_SPECIAL) {
 		fm->min_freq = FM_RX_BAND_FREQ_L;
 		fm->max_freq = FM_RX_BAND_FREQ_H;
-	} 
+	}
 #endif
 	else {
 		WCN_DBG(FM_ALT | MAIN, "band:%d out of range\n", parm->band);
@@ -1869,7 +1869,14 @@ fm_s32 fm_i2s_set(struct fm *fm, fm_s32 onoff, fm_s32 mode, fm_s32 sample)
 	if (FM_LOCK(fm_ops_lock))
 		return (-FM_ELOCK);
 
-	ret = fm_low_ops.bi.i2s_set(onoff, mode, sample);
+	if((FM_PWR_RX_ON == fm_pwr_state_get(fm)) || (FM_PWR_TX_ON == fm_pwr_state_get(fm))) {
+		ret = fm_low_ops.bi.i2s_set(onoff, mode, sample);
+	     	if (ret)
+	     		WCN_DBG(FM_ALT | MAIN, "i2s_set Failed\n");
+	     	else
+	     		WCN_DBG(FM_DBG | MAIN, "i2s_set OK!\n");
+	} else
+		WCN_DBG(FM_ALT | MAIN, "FM power off, not support i2s setting\n");
 
 	FM_UNLOCK(fm_ops_lock);
 	return ret;
@@ -1933,7 +1940,7 @@ fm_s32 fm_tune(struct fm *fm, struct fm_tune_parm *parm)
 	if (ret) {
 		WCN_DBG(FM_ALT | MAIN, "FM ramp down failed\n");
 		goto out;
-	}		
+	}
 
 	if (fm_cur_freq_get() != parm->freq) {
 		fm_memset(fm->pstRDSData, 0, sizeof(rds_t));
@@ -2473,7 +2480,7 @@ void fm_subsys_reset_work_func(unsigned long data)
 			goto out;
 		}
 	}
-	
+
 	/* prepare to reset */
 
 	/* wait 3s */
diff --git a/drivers/misc/mediatek/gud/mt6752/gud/MobiCoreKernelApi/clientlib.c b/drivers/misc/mediatek/gud/mt6752/gud/MobiCoreKernelApi/clientlib.c
index 5713380..a951e69 100644
--- a/drivers/misc/mediatek/gud/mt6752/gud/MobiCoreKernelApi/clientlib.c
+++ b/drivers/misc/mediatek/gud/mt6752/gud/MobiCoreKernelApi/clientlib.c
@@ -342,14 +342,17 @@ enum mc_result mc_open_session(struct mc_session_handle *session,
 		}
 
 		/* Read command response */
+		struct mc_drv_rsp_open_session_t rsp_open_session;
+		memset(&rsp_open_session, 0, sizeof(rsp_open_session));
 
-		/* read header first */
-		struct mc_drv_response_header_t rsp_header;
-		memset(&rsp_header, 0, sizeof(rsp_header));
+		/* read whole response, to prevent being interrupted
+			between header and payload */
 		len = connection_read_datablock(dev_con,
-						&rsp_header,
-						sizeof(rsp_header));
-		if (len != sizeof(rsp_header)) {
+						&rsp_open_session,
+						sizeof(rsp_open_session));
+
+		/* header processing */
+		if (len < sizeof(rsp_open_session.header)) {
 			MCDRV_DBG_ERROR(mc_kapi,
 					"CMD_OPEN_SESSION readResp failed %d",
 					len);
@@ -357,11 +360,11 @@ enum mc_result mc_open_session(struct mc_session_handle *session,
 			break;
 		}
 
-		if (rsp_header.response_id != MC_DRV_RSP_OK) {
+		if (rsp_open_session.header.response_id != MC_DRV_RSP_OK) {
 			MCDRV_DBG_ERROR(mc_kapi,
 					"CMD_OPEN_SESSION failed, respId=%d",
-					rsp_header.response_id);
-			switch (rsp_header.response_id) {
+					rsp_open_session.header.response_id);
+			switch (rsp_open_session.header.response_id) {
 			case MC_DRV_RSP_TRUSTLET_NOT_FOUND:
 				mc_result = MC_DRV_ERR_INVALID_DEVICE_FILE;
 				break;
@@ -375,16 +378,9 @@ enum mc_result mc_open_session(struct mc_session_handle *session,
 			break;
 		}
 
-		/* read payload */
-		struct mc_drv_rsp_open_session_payload_t
-					rsp_open_session_payload;
-		memset(&rsp_open_session_payload, 0,
-		       sizeof(rsp_open_session_payload));
-		len = connection_read_datablock(
-					dev_con,
-					&rsp_open_session_payload,
-					sizeof(rsp_open_session_payload));
-		if (len != sizeof(rsp_open_session_payload)) {
+		/* payload */
+		len -= sizeof(rsp_open_session.header);
+		if (len != sizeof(rsp_open_session.payload)) {
 			MCDRV_DBG_ERROR(mc_kapi,
 					"CMD_OPEN_SESSION readPayload fail %d",
 					len);
@@ -393,7 +389,7 @@ enum mc_result mc_open_session(struct mc_session_handle *session,
 		}
 
 		/* Register session with handle */
-		session->session_id = rsp_open_session_payload.session_id;
+		session->session_id = rsp_open_session.payload.session_id;
 
 		/* Set up second channel for notifications */
 		struct connection *session_connection = connection_new();
@@ -420,8 +416,8 @@ enum mc_result mc_open_session(struct mc_session_handle *session,
 			{
 				session->device_id,
 				session->session_id,
-				rsp_open_session_payload.device_session_id,
-				rsp_open_session_payload.session_magic
+				rsp_open_session.payload.device_session_id,
+				rsp_open_session.payload.session_magic
 			}
 		};
 		connection_write_data(session_connection,
@@ -429,6 +425,7 @@ enum mc_result mc_open_session(struct mc_session_handle *session,
 				      sizeof(cmd_nqconnect));
 
 		/* Read command response, header first */
+		struct mc_drv_response_header_t rsp_header;
 		len = connection_read_datablock(session_connection,
 						&rsp_header,
 						sizeof(rsp_header));
diff --git a/drivers/misc/mediatek/gud/mt6752/gud/MobiCoreKernelApi/main.c b/drivers/misc/mediatek/gud/mt6752/gud/MobiCoreKernelApi/main.c
index 4fedb73..5695b36 100644
--- a/drivers/misc/mediatek/gud/mt6752/gud/MobiCoreKernelApi/main.c
+++ b/drivers/misc/mediatek/gud/mt6752/gud/MobiCoreKernelApi/main.c
@@ -32,6 +32,7 @@ struct mc_kernelapi_ctx {
 	struct sock *sk;
 	struct list_head peers;
 	atomic_t counter;
+	struct mutex peers_lock; /* peers lock */
 };
 
 struct mc_kernelapi_ctx *mod_ctx;
@@ -56,23 +57,33 @@ unsigned int mcapi_unique_id(void)
 
 static struct connection *mcapi_find_connection(uint32_t seq)
 {
-	struct connection *tmp;
+	struct connection *tmp, *conn = NULL;
 	struct list_head *pos;
 
+	mutex_lock(&(mod_ctx->peers_lock));
+
 	/* Get session for session_id */
 	list_for_each(pos, &mod_ctx->peers) {
 		tmp = list_entry(pos, struct connection, list);
-		if (tmp->sequence_magic == seq)
-			return tmp;
+		if (tmp->sequence_magic == seq) {
+			conn = tmp;
+			break;
+		}
 	}
 
-	return NULL;
+	mutex_unlock(&(mod_ctx->peers_lock));
+
+	return conn;
 }
 
 void mcapi_insert_connection(struct connection *connection)
 {
+	mutex_lock(&(mod_ctx->peers_lock));
+
 	list_add_tail(&(connection->list), &(mod_ctx->peers));
 	connection->socket_descriptor = mod_ctx->sk;
+
+	mutex_unlock(&(mod_ctx->peers_lock));
 }
 
 void mcapi_remove_connection(uint32_t seq)
@@ -80,6 +91,8 @@ void mcapi_remove_connection(uint32_t seq)
 	struct connection *tmp;
 	struct list_head *pos, *q;
 
+	mutex_lock(&(mod_ctx->peers_lock));
+
 	/*
 	 * Delete all session objects. Usually this should not be needed as
 	 * closeDevice() requires that all sessions have been closed before.
@@ -91,6 +104,8 @@ void mcapi_remove_connection(uint32_t seq)
 			break;
 		}
 	}
+
+	mutex_unlock(&(mod_ctx->peers_lock));
 }
 
 static int mcapi_process(struct sk_buff *skb, struct nlmsghdr *nlh)
@@ -174,6 +189,9 @@ static int __init mcapi_init(void)
 	}
 
 	INIT_LIST_HEAD(&mod_ctx->peers);
+
+	mutex_init(&mod_ctx->peers_lock);
+
 	return 0;
 }
 
diff --git a/drivers/misc/mediatek/gyroscope/lsm6ds3gy/lsm6ds3_gy.c b/drivers/misc/mediatek/gyroscope/lsm6ds3gy/lsm6ds3_gy.c
index ed5637b..f57e886 100644
--- a/drivers/misc/mediatek/gyroscope/lsm6ds3gy/lsm6ds3_gy.c
+++ b/drivers/misc/mediatek/gyroscope/lsm6ds3gy/lsm6ds3_gy.c
@@ -1,5 +1,4 @@
-/* ST LSM6DS3 Accelerometer and Gyroscope sensor driver 
- *
+/* ST LSM6DS3 Accelerometer and Gyroscope sensor driver
  *
  *
  * This software is licensed under the terms of the GNU General Public
diff --git a/drivers/misc/mediatek/gyroscope/lsm6ds3gy/lsm6ds3_gy.h b/drivers/misc/mediatek/gyroscope/lsm6ds3gy/lsm6ds3_gy.h
index 6f55122..6c08f35 100644
--- a/drivers/misc/mediatek/gyroscope/lsm6ds3gy/lsm6ds3_gy.h
+++ b/drivers/misc/mediatek/gyroscope/lsm6ds3gy/lsm6ds3_gy.h
@@ -1,5 +1,4 @@
 /* lsm6ds3.h
- *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
diff --git a/drivers/misc/mediatek/hdmi/Sii8348/hdmi_drv.c b/drivers/misc/mediatek/hdmi/Sii8348/hdmi_drv.c
index 0dd7f21..3b11af5 100644
--- a/drivers/misc/mediatek/hdmi/Sii8348/hdmi_drv.c
+++ b/drivers/misc/mediatek/hdmi/Sii8348/hdmi_drv.c
@@ -111,8 +111,11 @@ static char* cable_type_print(unsigned short type)
 	}	
 }
 
-static HDMI_CABLE_TYPE MHL_Connect_type = MHL_CABLE;
-static bool HDCP_Supported_Info = false;
+HDMI_CABLE_TYPE MHL_Connect_type = MHL_CABLE;
+static unsigned int HDCP_Supported_Info = 0;
+bool MHL_3D_Support = false;
+int MHL_3D_format=0x00;
+
 static void hdmi_drv_get_params(HDMI_PARAMS *params)
 {
 	memset(params, 0, sizeof(HDMI_PARAMS));
@@ -139,8 +142,13 @@ static void hdmi_drv_get_params(HDMI_PARAMS *params)
     params->scaling_factor 				= 0;
     params->cabletype 					= MHL_Connect_type;
 	params->HDCPSupported 				= HDCP_Supported_Info;
+#ifdef CONFIG_MTK_HDMI_3D_SUPPORT	
+    if(MHL_Connect_type== MHL_3D_GLASSES)    
+        params->cabletype 				= MHL_CABLE;
 
-    HDMI_LOG("type %s\n", cable_type_print(params->cabletype));
+	params->is_3d_support 				= MHL_3D_Support;
+#endif
+    HDMI_LOG("type %s-%d hdcp %d-%d\n", cable_type_print(params->cabletype), MHL_Connect_type, params->HDCPSupported, HDCP_Supported_Info);
 	return ;
 }
 
@@ -175,7 +183,13 @@ static int hdmi_drv_audio_enable(bool enable)
 static int hdmi_drv_enter(void)  {return 0;}
 static int hdmi_drv_exit(void)  {return 0;}
 
+#ifdef CONFIG_MTK_HDMI_3D_SUPPORT
+extern void si_mhl_tx_drv_video_3d_update(struct mhl_dev_context *dev_context, int video_3d);
+extern void si_mhl_tx_drv_video_3d(struct mhl_dev_context *dev_context, int video_3d);
+static int hdmi_drv_video_config(HDMI_VIDEO_RESOLUTION vformat, HDMI_VIDEO_INPUT_FORMAT vin, int vout)
+#else
 static int hdmi_drv_video_config(HDMI_VIDEO_RESOLUTION vformat, HDMI_VIDEO_INPUT_FORMAT vin, HDMI_VIDEO_OUTPUT_FORMAT vout)
+#endif
 {
 	if(vformat == HDMI_VIDEO_720x480p_60Hz)
 	{
@@ -201,9 +215,31 @@ static int hdmi_drv_video_config(HDMI_VIDEO_RESOLUTION vformat, HDMI_VIDEO_INPUT
 	{
 		HDMI_LOG("%s, video format not support now\n", __func__);
 	}
-	
+
+#ifdef CONFIG_MTK_HDMI_3D_SUPPORT
+	if(vout & HDMI_VOUT_FORMAT_3D_SBS)
+        MHL_3D_format=VIDEO_3D_SS;
+	else if(vout & HDMI_VOUT_FORMAT_3D_TAB)
+	    MHL_3D_format=VIDEO_3D_TB;
+    else
+	    MHL_3D_format = VIDEO_3D_NONE;
+	    
+	if(si_dev_context)
+	{	    
+        HDMI_LOG("video format  -- %d, 0x%x, %d\n", MHL_3D_Support, vout, MHL_3D_format);
+		if(vformat < HDMI_VIDEO_RESOLUTION_NUM)
+		{
+		    ///if(MHL_3D_Support && (MHL_3D_format > 0))
+		    si_mhl_tx_drv_video_3d(si_dev_context, MHL_3D_format);			
+            si_mhl_tx_set_path_en_I(si_dev_context);
+		}
+		else
+		    si_mhl_tx_drv_video_3d_update(si_dev_context, MHL_3D_format);
+ 	}
+ #else
     if(si_dev_context)
     	si_mhl_tx_set_path_en_I(si_dev_context);
+ #endif
     return 0;
 }
 
@@ -331,7 +367,11 @@ void hdmi_drv_power_off(void)
 
 }
 
-
+void switch_mhl_to_d3(void)
+{    
+    if(si_dev_context)
+        ForceSwitchToD3(si_dev_context);
+}
 static unsigned int pal_resulution = 0;
 void update_av_info_edid(bool audio_video, unsigned int param1, unsigned int param2)
 {
@@ -617,7 +657,12 @@ void Notify_AP_MHL_TX_Event(unsigned int event, unsigned int event_param, void *
 			break;
 		case MHL_TX_EVENT_DEV_CAP_UPDATE:
 		{
-			MHL_Connect_type = MHL_SMB_CABLE;			
+#ifdef CONFIG_MTK_HDMI_3D_SUPPORT		
+		    if(event_param == 0xBA)
+                MHL_Connect_type = MHL_3D_GLASSES;	
+		    else		    
+#endif		    
+    			MHL_Connect_type = MHL_SMB_CABLE;			
 		}
 			break;
 		case MHL_TX_EVENT_EDID_UPDATE:
@@ -627,9 +672,10 @@ void Notify_AP_MHL_TX_Event(unsigned int event, unsigned int event_param, void *
 			break;
 		case MHL_TX_EVENT_EDID_DONE:
 		{
-#ifdef HDCP_ENABLE
-			HDCP_Supported_Info = true;
-#endif
+///#ifdef HDCP_ENABLE
+            if(chip_device_id == 0x8346)
+			    HDCP_Supported_Info = 140; ///HDCP 1.4
+///#endif
 			sii_mhl_connected = MHL_TX_EVENT_CALLBACK;
 			hdmi_invoke_cable_callbacks(HDMI_STATE_ACTIVE);
 			SMB_Init();
diff --git a/drivers/misc/mediatek/hdmi/Sii8348/mhl_supp.c b/drivers/misc/mediatek/hdmi/Sii8348/mhl_supp.c
index 170ede1..efe430e 100644
--- a/drivers/misc/mediatek/hdmi/Sii8348/mhl_supp.c
+++ b/drivers/misc/mediatek/hdmi/Sii8348/mhl_supp.c
@@ -1004,10 +1004,14 @@ void si_mhl_tx_msc_command_done(struct mhl_dev_context *dev_context, uint8_t dat
 		 */           
         if(0x0F == req->reg)
         {
-            if(data1 == 0xB9)
+#ifdef CONFIG_MTK_HDMI_3D_SUPPORT        
+            if((data1 == 0xB9) || (data1 == 0xBA))
+#else
+            if(data1 == 0xB9) 
+#endif
             {
             	//SMB
-            	mhl_event_notify(dev_context, MHL_TX_EVENT_DEV_CAP_UPDATE, NULL, NULL);
+            	mhl_event_notify(dev_context, MHL_TX_EVENT_DEV_CAP_UPDATE, data1, NULL);
             }
 			
         }
@@ -1244,15 +1248,19 @@ void si_mhl_tx_process_write_burst_data(struct mhl_dev_context *dev_context)
 
 		switch(burst_id) {
 		case burst_id_3D_VIC:
+#ifndef CONFIG_MTK_HDMI_3D_SUPPORT
 			si_mhl_tx_process_3d_vic_burst(
 					dev_context->edid_parser_context,
 					&dev_context->incoming_scratch_pad.videoFormatData);
+#endif					
 			break;
 
 		case burst_id_3D_DTD:
+#ifndef CONFIG_MTK_HDMI_3D_SUPPORT
 			si_mhl_tx_process_3d_dtd_burst(
 					dev_context->edid_parser_context,
 					&dev_context->incoming_scratch_pad.videoFormatData);
+#endif					
 			break;
 
 		case LOCAL_ADOPTER_ID:
diff --git a/drivers/misc/mediatek/hdmi/Sii8348/platform.c b/drivers/misc/mediatek/hdmi/Sii8348/platform.c
index 1b4c928..1b75976 100644
--- a/drivers/misc/mediatek/hdmi/Sii8348/platform.c
+++ b/drivers/misc/mediatek/hdmi/Sii8348/platform.c
@@ -514,31 +514,54 @@ static inline int platform_write_i2c_block(struct i2c_adapter *i2c_bus
 }
 
 /***************************End*******************************/
-
+///#define ENABLE_MHL_VBUS_POWER_OUT
+#ifdef ENABLE_MHL_VBUS_POWER_OUT
+extern void mtk_disable_pmic_otg_mode(void);
+extern void mtk_enable_pmic_otg_mode(void);
+bool VBUS_state = false;
+#include <mach/battery_meter.h>
+#endif
 void mhl_tx_vbus_control(enum vbus_power_state power_state)
 {
-    return ;
-    
-	struct mhl_dev_context *dev_context;
-	dev_context = i2c_get_clientdata(device_addresses[0].client);	// TODO: FD, TBC, it seems the 'client' is always 'NULL', is it right here???
+
+#ifdef ENABLE_MHL_VBUS_POWER_OUT
+	///struct mhl_dev_context *dev_context;
+	///dev_context = i2c_get_clientdata(device_addresses[0].client);	// TODO: FD, TBC, it seems the 'client' is always 'NULL', is it right here
+	printk("%s: mhl_tx_vbus_control3 %d-%d received!\n", __func__, VBUS_state, power_state);
+    if(VBUS_state == power_state)
+        return;
+        
+    VBUS_state = power_state;
 
 	switch (power_state) {
 	case VBUS_OFF:
 		//set_pin(dev_context,TX2MHLRX_PWR_M,1);
 		//set_pin(dev_context,LED_SRC_VBUS_ON,GPIO_LED_OFF);
+		mtk_disable_pmic_otg_mode();
 		break;
 
 	case VBUS_ON:
 		//set_pin(dev_context,TX2MHLRX_PWR_M,0);
 		//set_pin(dev_context,LED_SRC_VBUS_ON,GPIO_LED_ON);
+		printk(	"%s:  power chg %d received!\n",
+				__func__, battery_meter_get_charger_voltage());
+		if(battery_meter_get_charger_voltage() > 4000)
+		    VBUS_state = VBUS_OFF;
+		else
+    		mtk_enable_pmic_otg_mode();
+		printk(	"%s:  power chg %d received!\n",
+				__func__, battery_meter_get_charger_voltage());
 		break;
 
 	default:
-		dev_err(dev_context->mhl_dev,
-				"%s: Invalid power state %d received!\n",
+		printk(	"%s: Invalid power state %d received!\n",
 				__func__, power_state);
 		break;
-	}
+	}        
+#else
+	printk(	"%s: do not support power out %d received!\n",
+				__func__, power_state);
+#endif	
 }
 
 /******************************Debug Start*****************************/
@@ -879,6 +902,9 @@ int32_t sii_8348_tx_init()
 {
 	int32_t ret = 0;
 
+#ifdef ENABLE_MHL_VBUS_POWER_OUT	
+    VBUS_state = false;
+#endif
 	ret = mhl_tx_init(&drv_info, mClient);
 	printk("sii_8348_init, mClient is %p\n", mClient);
 	
diff --git a/drivers/misc/mediatek/hdmi/Sii8348/si_8348_drv.c b/drivers/misc/mediatek/hdmi/Sii8348/si_8348_drv.c
index e3108e3..6c0aac5 100644
--- a/drivers/misc/mediatek/hdmi/Sii8348/si_8348_drv.c
+++ b/drivers/misc/mediatek/hdmi/Sii8348/si_8348_drv.c
@@ -581,94 +581,7 @@ static uint8_t calculate_avi_info_frame_checksum(hw_avi_payload_t *payload)
 	checksum = 0x82 + 0x02 + 0x0D;	/* these are set by the hardware */
 	return calculate_generic_checksum(payload->ifData, checksum, SIZE_AVI_INFOFRAME);
 }
-#if 0
-#define SIZE_AUDIO_IF					14
-static uint8_t calculate_audio_if_checksum(uint8_t *audio_if)
-{
-	uint8_t checksum = 0;
-
-	return calculate_generic_checksum(audio_if, checksum, SIZE_AUDIO_IF);
-}
-
-#define SIZE_AVIF					9
-static uint8_t calculate_avif_checksum(uint8_t *avif)
-{
-	uint8_t checksum = 0;
-
-	return calculate_generic_checksum(avif, checksum, SIZE_AVIF);
-}
-#define SIZE_VSIF					8
-static uint8_t calculate_vsif_checksum(uint8_t *vsif)
-{
-	uint8_t checksum = 0;
-
-	return calculate_generic_checksum(vsif, checksum, SIZE_VSIF);
-}
-
-static int is_valid_avi_info_frame(struct mhl_dev_context *dev_context, avi_info_frame_t *avif)
-{
-	uint8_t	checksum;
-
-	checksum = calculate_generic_checksum((uint8_t *)avif, 0, sizeof(*avif));
-	if (0 != checksum) {
-		MHL_TX_DBG_ERR(dev_context, "AVI info frame checksum is: 0x%02x should be 0\n", checksum);
-		return 0;
-
-	} else if (0x82 != avif->header.type_code) {
-		MHL_TX_DBG_ERR(dev_context, "Invalid AVI type code: 0x%02x\n", avif->header.type_code);
-		return 0;
-
-	} else if (0x02 != avif->header.version_number) {
-		MHL_TX_DBG_ERR(dev_context, "Invalid AVI version: 0x%02x\n", avif->header.version_number);
-		return 0;
-
-	} else if (0x0D != avif->header.length) {
-		return 0;
-
-	} else {
-		return 1;
-	}
-}
-
-static int is_valid_vsif(struct mhl_dev_context *dev_context, vendor_specific_info_frame_t *vsif)
-{
-	uint8_t	checksum;
 
-	/*
-		Calculate the checksum assuming that the payload includes the checksum
-	*/
-	checksum = calculate_generic_checksum((uint8_t *)vsif, 0,
-			sizeof(vsif->header) + vsif->header.length );
-	if (0 != checksum) {
-		MHL_TX_DBG_WARN(dev_context, "VSIF info frame checksum is: 0x%02x should be 0\n", checksum);
-		/*
-			Try again, assuming that the header includes the checksum.
-		*/
-		checksum = calculate_generic_checksum((uint8_t *)vsif, 0,
-			sizeof(vsif->header) + vsif->header.length
-			+ sizeof(vsif->payLoad.checksum));
-		if (0 != checksum){
-			MHL_TX_DBG_ERR(dev_context, "VSIF info frame checksum "
-					"(adjusted for checksum itself) is: 0x%02x "
-						   "should be 0\n", checksum);
-			return 0;
-		}
-	} 
-	if (0x81 != vsif->header.type_code) {
-		MHL_TX_DBG_ERR(dev_context, "Invalid VSIF type code: 0x%02x\n",
-					   vsif->header.type_code);
-		return 0;
-
-	} else if (0x01 != vsif->header.version_number) {
-		MHL_TX_DBG_ERR(dev_context, "Invalid VSIF version: 0x%02x\n",
-					   vsif->header.version_number);
-		return 0;
-
-	} else {
-		return 1;
-	}
-}
-#endif
 static	void	print_vic_modes(struct drv_hw_context *hw_context,uint8_t vic)
 {
 	int	i;
@@ -764,7 +677,8 @@ static int set_hdmi_params(struct mhl_dev_context *dev_context)
 	 */
 	threeDPixelClockRatio = 1;
 	si_mhl_tx_drv_get_incoming_horizontal_total(hw_context);
-#if 0
+
+#ifdef CONFIG_MTK_HDMI_3D_SUPPORT
 	if (hw_context->valid_vsif && hw_context->valid_3d)
 	{
 		MHL_TX_DBG_WARN(, "valid HDMI VSIF\n");
@@ -774,22 +688,13 @@ static int set_hdmi_params(struct mhl_dev_context *dev_context)
 			MHL_TX_DBG_ERR(,"AVI VIC is zero!!!\n");
 			return false;
 		}
-		// TODO: FD, MUST, check this to support 3D properly
-		/*
-		if (hvf3DFormatIndicationPresent == hw_context->current_vs_info_frame.
-				payLoad.pb4.HDMI_Video_Format) {
-
-			MHL_TX_DBG_INFO(dev_context,"VSIF indicates 3D\n");
-			if (tdsFramePacking == hw_context->current_vs_info_frame.
-					payLoad.pb5.ThreeDStructure.threeDStructure) {
-
-				MHL_TX_DBG_INFO(dev_context, "mhl_tx: tdsFramePacking\n");
-				threeDPixelClockRatio = 2;
-			}
+		if ( 1 == hw_context->valid_3d_fs )
+		{
+			MHL_TX_DBG_INFO(dev_context, "3D Pixel Clock Ratio: Frame Packing\n");
+			threeDPixelClockRatio = 2;
 		}
-		*/
 	}
-	#endif
+#endif
 	#if 0
 	else
 	{ 	/* no VSIF */
@@ -979,65 +884,7 @@ static int set_hdmi_params(struct mhl_dev_context *dev_context)
 	return true;
 }
 
-/*
-	process_info_frame_change
-		called by the MHL Tx driver when a
-        new AVI info frame is received from upstream
-		OR
-		called by customer's SOC video driver when a mode change is desired.
-*/
-/*
-void process_info_frame_change(struct drv_hw_context *hw_context
-		, vendor_specific_info_frame_t *vsif
-		, avi_info_frame_t *avif)
-{
-	bool mode_change = false;
-	struct mhl_dev_context	*dev_context;
-
-	dev_context = container_of((void *)hw_context, struct mhl_dev_context, drv_context);
 
-	if (NULL != vsif) {
-		if(is_valid_vsif(dev_context, vsif)) {			// TODO: FD, TBI, any need to do the check? may remove it later
-			memcpy( (void *)&(hw_context->current_vs_info_frame), (void *)vsif, sizeof(vendor_specific_info_frame_t));
-			hw_context->valid_vsif = 1;
-			mode_change = true;
-		}
-		else
-		{
-			MHL_TX_DBG_INFO(hw_context, "It's NOT a valid VSIF!\n");
-			hw_context->valid_vsif = 0;
-		}
-	}
-	if (NULL != avif) {
-		if(is_valid_avi_info_frame(dev_context, avif)) {	// TODO: FD, TBI, any need to do the check? may remove it later
-			memcpy( (void *)&(hw_context->current_avi_info_frame), (void *)avif, sizeof(avi_info_frame_t));
-			hw_context->valid_avif = 1;
-			mode_change = true;
-		}
-		else
-		{
-			MHL_TX_DBG_INFO(hw_context, "It's NOT a valid AVIF!\n");
-			hw_context->valid_avif = 0;
-		}
-	}
-
-	// No need to check Audio IF
-
-	// Save the changes only, no need to proceed if EDID is not yet parsed
-	if ( false == dev_context->edid_parse_done )
-	{
-		return;
-	}
-
-	if (mode_change) {
-		// TODO: FD, TBI, any appoach to check source stability in Drake? If any, "do_the_check"
-		//	if ( do_the_check() )
-		{
-			start_video(hw_context,dev_context->edid_parser_context);
-		}
-	}
-}
-*/
 #define dump_edid_fifo(hw_context, block_number) /* do nothing */
 
 int si_mhl_tx_drv_set_upstream_edid(struct drv_hw_context *hw_context, uint8_t *edid, uint16_t length)
@@ -1807,7 +1654,9 @@ static void unmute_video(struct drv_hw_context *hw_context)
 		/*
 		 * Send VSIF out
 		 */
+#ifndef CONFIG_MTK_HDMI_3D_SUPPORT		 
 		if ( 1 == hw_context->valid_vsif && 1 == hw_context->valid_3d )
+#endif		
 		{
 			MHL_TX_DBG_INFO(hw_context, "Send VSIF out...\n");
 			mhl_tx_write_reg(hw_context, REG_TPI_INFO_FSEL, BIT_TPI_INFO_EN | BIT_TPI_INFO_RPT | BIT_TPI_INFO_SEL_3D_VSIF);	// Send 3D VSIF repeatly
@@ -2910,6 +2759,10 @@ void	ForceSwitchToD3( struct mhl_dev_context *dev_context)
     */
     //mhl_tx_modify_reg((struct drv_hw_context *)(&dev_context->drv_context), REG_DPD,
     //                             BIT_MASTER_POWER_CTRL,  0x00);
+    mhl_tx_modify_reg((struct drv_hw_context *)(&dev_context->drv_context), REG_DISC_CTRL1, BIT_DISC_CTRL1_STROBE_OFF, 0);
+    mhl_tx_modify_reg((struct drv_hw_context *)(&dev_context->drv_context), REG_DPD, BIT_MASTER_POWER_CTRL, 0);
+
+    MHL_TX_DBG_INFO((struct drv_hw_context *)(&dev_context->drv_context), "!!!!!!!!!!!. ForceSwitchToD3 to D3 0x%x\n", mhl_tx_read_reg((struct drv_hw_context *)(&dev_context->drv_context), REG_INTR4));
 	return;
 }
 
@@ -3009,6 +2862,9 @@ static int int_4_isr(struct drv_hw_context *hw_context, uint8_t int_4_status)
 					0x80, 0x80);
 		if(0x02 == (mhl_tx_read_reg(hw_context, REG_DISC_STAT2) & 0x03)) {
 			MHL_TX_DBG_INFO(hw_context, "Cable impedance = 1k (MHL Device)\n");
+			/* Call platform function to turn the VBUS on for unpowered dongle */
+			mhl_tx_vbus_control(VBUS_ON);
+			msleep(100);
 			mhl_tx_write_reg(hw_context, REG_DISC_CTRL1, 0x27);
 			/*************************************************************/
 			
@@ -3036,9 +2892,7 @@ static int int_4_isr(struct drv_hw_context *hw_context, uint8_t int_4_status)
 					| BIT_DC9_DISC_PULSE_PROCEED
 					);
 
-			/* Call platform function to turn the VBUS on for unpowered dongle */
-			mhl_tx_vbus_control(VBUS_ON);
-			msleep(100);
+			
 		}
 		/* enable remaining discovery interrupts */
 		enable_intr(hw_context, INTR_DISC,
@@ -3323,7 +3177,9 @@ int si_mhl_tx_chip_initialize(struct drv_hw_context *hw_context)
 		hw_context->valid_vsif = 0;
 		//hw_context->valid_avif = 0;
 		hw_context->valid_3d = 0;
-
+#ifdef CONFIG_MTK_HDMI_3D_SUPPORT		
+		hw_context->valid_3d_fs = 0;
+#endif
 		//hw_context->current_audio_configure = 0;
 		//memset( hw_context->current_audio_info_frame, 0, AUDIO_IF_SIZE );
 		memset(&hw_context->current_vs_info_frame, 0, sizeof(hw_context->current_vs_info_frame));
@@ -3425,3 +3281,266 @@ void siHdmiTx_AudioSel (int AduioMode)
 	siHdmiTx.AudioI2SFormat		= (MCLK256FS << 4) |SCK_SAMPLE_RISING_EDGE |0x00; //last num 0x00-->0x02
 	*/
 }
+
+#ifdef CONFIG_MTK_HDMI_3D_SUPPORT
+#define SIZE_VSIF					8
+static uint8_t calculate_vsif_checksum(uint8_t *vsif)
+{
+	uint8_t checksum = 0;
+
+	return calculate_generic_checksum(vsif, checksum, SIZE_VSIF);
+}
+
+static int is_valid_vsif(struct mhl_dev_context *dev_context, vendor_specific_info_frame_t *vsif)
+{
+	uint8_t	checksum;
+
+	/*
+		Calculate the checksum assuming that the payload includes the checksum
+	*/
+	checksum = calculate_generic_checksum((uint8_t *)vsif, 0,
+			sizeof(vsif->header) + vsif->header.length );
+	if (0 != checksum) {
+		MHL_TX_DBG_WARN(dev_context, "VSIF info frame checksum is: 0x%02x should be 0\n", checksum);
+		/*
+			Try again, assuming that the header includes the checksum.
+		*/
+		checksum = calculate_generic_checksum((uint8_t *)vsif, 0,
+			sizeof(vsif->header) + vsif->header.length
+			+ sizeof(vsif->payLoad.checksum));
+		if (0 != checksum){
+			MHL_TX_DBG_ERR(dev_context, "VSIF info frame checksum "
+					"(adjusted for checksum itself) is: 0x%02x "
+						   "should be 0\n", checksum);
+			return 0;
+		}
+	} 
+	if (0x81 != vsif->header.type_code) {
+		MHL_TX_DBG_ERR(dev_context, "Invalid VSIF type code: 0x%02x\n",
+					   vsif->header.type_code);
+		return 0;
+
+	} else if (0x01 != vsif->header.version_number) {
+		MHL_TX_DBG_ERR(dev_context, "Invalid VSIF version: 0x%02x\n",
+					   vsif->header.version_number);
+		return 0;
+
+	} else {
+		return 1;
+	}
+}
+
+/*
+	process_info_frame_change
+		called by the MHL Tx driver when a
+        new AVI info frame is received from upstream
+		OR
+		called by customer's SOC video driver when a mode change is desired.
+*/
+
+void process_info_frame_change(struct drv_hw_context *hw_context
+		, vendor_specific_info_frame_t *vsif
+		, avi_info_frame_t *avif)
+{
+	bool mode_change = false;
+	struct mhl_dev_context	*dev_context;
+
+	dev_context = container_of((void *)hw_context, struct mhl_dev_context, drv_context);
+
+	if (NULL != vsif) {
+		if(is_valid_vsif(dev_context, vsif)) {
+		    MHL_TX_DBG_INFO(hw_context, "refresh VISF!!!!!!!\n");
+			memcpy( (void *)&(hw_context->current_vs_info_frame), (void *)vsif, sizeof(vendor_specific_info_frame_t));
+			hw_context->valid_vsif = 1;
+			mode_change = true;
+		}
+		else
+		{
+			MHL_TX_DBG_INFO(hw_context, "It's NOT a valid VSIF!\n");
+			hw_context->valid_vsif = 0;
+		}
+	}
+	/*if (NULL != avif) {
+		if(is_valid_avi_info_frame(dev_context, avif)) {
+			memcpy( (void *)&(hw_context->current_avi_info_frame), (void *)avif, sizeof(avi_info_frame_t));
+			hw_context->valid_avif = 1;
+			mode_change = true;
+		}
+		else
+		{
+			MHL_TX_DBG_INFO(hw_context, "It's NOT a valid AVIF!\n");
+			hw_context->valid_avif = 0;
+		}
+	}
+
+	// No need to check Audio IF
+
+	// Save the changes only, no need to proceed if EDID is not yet parsed
+	if ( false == dev_context->edid_parse_done )
+	{
+		return;
+	}
+
+	if (mode_change) {
+		start_video(hw_context,dev_context->edid_parser_context);
+	}*/
+}
+static void fill_vsif(struct drv_hw_context *hw_context, uint8_t *p_vsif, int video_3d)
+{
+//	uint8_t video_3d_structure = 0;			// per HDMI
+	uint8_t mhl_3d_fmt_type = 0;
+	uint8_t mhl_vid_fmt = 0;
+
+	MHL_TX_DBG_INFO(hw_context, "Fill VSIF, video_3d:%02X ...\n", video_3d);
+
+	if ( VIDEO_3D_NONE == video_3d )
+	{
+		MHL_TX_DBG_INFO(hw_context, "Input Video 3D Update: NO 3D\n");
+		mhl_vid_fmt = 0x00;
+		hw_context->valid_3d = 0;
+		hw_context->valid_3d_fs = 0;
+	}
+	else if ( VIDEO_3D_FS == video_3d )
+	{
+		MHL_TX_DBG_INFO(hw_context, "Input Video 3D Update: 3D - Frame Sequential\n");
+//		video_3d_structure = 0x00;		// per HDMI
+		mhl_vid_fmt = 0x01;
+		mhl_3d_fmt_type = 0x00;
+		hw_context->valid_3d = 1;
+		hw_context->valid_3d_fs = 1;
+	}
+	else if ( VIDEO_3D_TB == video_3d )
+	{
+		MHL_TX_DBG_INFO(hw_context, "Input Video 3D Update: 3D - Top Bottom\n");
+//		video_3d_structure = 0x06;		// per HDMI
+		mhl_vid_fmt = 0x01;
+		mhl_3d_fmt_type = 0x01;
+		hw_context->valid_3d = 1;
+		hw_context->valid_3d_fs = 0;
+	}
+	else if ( VIDEO_3D_SS == video_3d )
+	{
+		MHL_TX_DBG_INFO(hw_context, "Input Video 3D Update: 3D - Side by side\n");
+//		video_3d_structure = 0x08;		// per HDMI
+		mhl_vid_fmt = 0x01;
+		mhl_3d_fmt_type = 0x02;
+		hw_context->valid_3d = 1;
+		hw_context->valid_3d_fs = 0;
+	}
+
+	// Fill VSIF
+
+	p_vsif[0] = 0x81;	// VSIF header
+	p_vsif[1] = 0x01;	// Version
+	p_vsif[2] = 0x04;	// Length
+
+	p_vsif[3] = 0x00;	// Initial checksum
+
+	// Per MHL, begin
+	// Should use this for MHL
+	p_vsif[4] = 0x1D;	// 0x7CA61D in Little Endian
+	p_vsif[5] = 0xA6;
+	p_vsif[6] = 0x7C;
+	p_vsif[7] = mhl_3d_fmt_type << 2 | mhl_vid_fmt;
+	// Per MHL, end
+
+	p_vsif[3] = calculate_vsif_checksum(p_vsif);	// Checksum
+
+	// In case there is a need to use HDMI VSIF
+	// Per HDMI, begin
+	/*
+	   p_vsif[2] = 0x07;	// Length
+
+	// For compatibility with 'bad' MHL sinks, which accept HDMI IEEE OUI instead of MHL IEEE OUI
+	   p_vsif[4] = 0x03;	// 0x000C03 in Little Endian
+	   p_vsif[5] = 0x0C;
+	   p_vsif[6] = 0x00;
+
+	   p_vsif[7] = 0x40;	// 0x010-00000 -- 3D format indication present
+	   p_vsif[8] = video_3d_structure << 4;	// 3D structure & 3D_Meta_present=0
+	   p_vsif[9] = 0x00;
+	   p_vsif[10] = 0x00;
+	 */
+	// Per HDMI, end
+}
+
+//void si_mhl_tx_drv_video_3d_update(struct drv_hw_context *hw_context, int video, int video_3d)
+void si_mhl_tx_drv_video_3d(struct mhl_dev_context *dev_context, int video_3d)
+{
+	vendor_specific_info_frame_t vsif;
+
+    MHL_TX_DBG_INFO((struct drv_hw_context *) (&dev_context->drv_context), "Input Timing Update: video 3D configuration changed %d\n", video_3d);
+
+	memset( &vsif, 0, sizeof(vendor_specific_info_frame_t) );
+
+	fill_vsif( (struct drv_hw_context *) (&dev_context->drv_context), (uint8_t *)(&vsif), video_3d );	// Fill VISF
+
+	// Process VSIF only
+	process_info_frame_change((struct drv_hw_context *) (&dev_context->drv_context),&vsif,NULL);
+
+	//fill_video_lcd( hw_context, video, video_3d );
+
+	//set_pin(hw_context, VID_CTRL_ACK, 1);  // tell to allow further VID_CTRL_INT
+}
+
+#if 0
+struct timer_list restart_timer;
+struct drv_hw_context *temp_hw_context = NULL;
+void __restart_timer_isr(unsigned long n)
+{
+    unmute_video(temp_hw_context);
+    del_timer(&restart_timer);
+}
+#endif
+
+extern HDMI_CABLE_TYPE MHL_Connect_type;
+extern HDMI_STATE hdmi_drv_get_state(void);
+void si_mhl_tx_drv_video_3d_update(struct mhl_dev_context *dev_context, int video_3d)
+{
+	vendor_specific_info_frame_t vsif;	
+    struct drv_hw_context *hw_context = (struct drv_hw_context *)&dev_context->drv_context;
+    
+
+    MHL_TX_DBG_INFO((struct drv_hw_context *) (&dev_context->drv_context), "Input Timing Update to: video 3D configuration changed-%d, cable type: %d\n", video_3d, MHL_Connect_type);
+    if(MHL_Connect_type != MHL_3D_GLASSES)
+        stop_video(hw_context);
+    
+	memset( &vsif, 0, sizeof(vendor_specific_info_frame_t) );
+
+	fill_vsif( (struct drv_hw_context *) (&dev_context->drv_context), (uint8_t *)(&vsif), video_3d );	// Fill VISF
+
+	// Process VSIF only
+	process_info_frame_change((struct drv_hw_context *) (&dev_context->drv_context),&vsif,NULL);
+
+	/*
+		 * Send VSIF out
+		 */
+		///if ( 1 == hw_context->valid_vsif && 1 == hw_context->valid_3d )
+		{
+			MHL_TX_DBG_INFO((struct drv_hw_context *) (&dev_context->drv_context), "Send VSIF out...\n");
+			mhl_tx_write_reg((struct drv_hw_context *) (&dev_context->drv_context), REG_TPI_INFO_FSEL, BIT_TPI_INFO_EN | BIT_TPI_INFO_RPT | BIT_TPI_INFO_SEL_3D_VSIF);	// Send 3D VSIF repeatly
+			///DumpIncomingInfoFrame(&((struct drv_hw_context *) (&dev_context->drv_context)->current_vs_info_frame),sizeof((struct drv_hw_context *) (&dev_context->drv_context)->current_vs_info_frame));
+			///mhl_tx_write_reg_block((struct drv_hw_context *) (&dev_context->drv_context), REG_TPI_INFO_BYTE00, 8, (u8 *)(&((struct drv_hw_context *) (&dev_context->drv_context)->current_vs_info_frame)) );	// only 8 bytes are valid for MHL VSIF
+            DumpIncomingInfoFrame(&(hw_context->current_vs_info_frame),sizeof(hw_context->current_vs_info_frame));
+			mhl_tx_write_reg_block((struct drv_hw_context *) (&dev_context->drv_context), REG_TPI_INFO_BYTE00, 8, (u8 *)(&(hw_context->current_vs_info_frame)) );	// only 8 bytes are valid for MHL VSIF
+			mhl_tx_write_reg((struct drv_hw_context *) (&dev_context->drv_context), REG_TPI_INFO_BYTE30, 0x00);// Trigger the infoframe sending
+		}
+
+#if 0    
+    restart_timer.expires = jiffies + msecs_to_jiffies(500);
+    restart_timer.function = __restart_timer_isr;
+    init_timer(&restart_timer);
+    add_timer(&restart_timer);
+#else
+    if(MHL_Connect_type != MHL_3D_GLASSES)
+    {
+        msleep(120);
+        if(hdmi_drv_get_state()==HDMI_STATE_ACTIVE)
+            unmute_video(hw_context);
+    }  
+    
+    MHL_TX_DBG_INFO((struct drv_hw_context *) (&dev_context->drv_context), "Input Timing Update to: video 3D configuration changed done\n");
+#endif
+}
+#endif
+
diff --git a/drivers/misc/mediatek/hdmi/Sii8348/si_8348_drv.h b/drivers/misc/mediatek/hdmi/Sii8348/si_8348_drv.h
index 842af47..5bd2886 100644
--- a/drivers/misc/mediatek/hdmi/Sii8348/si_8348_drv.h
+++ b/drivers/misc/mediatek/hdmi/Sii8348/si_8348_drv.h
@@ -42,7 +42,9 @@ struct drv_hw_context {
 	uint8_t		valid_vsif;
 	//uint8_t		valid_avif;
 	uint8_t		valid_3d;
-
+#ifdef CONFIG_MTK_HDMI_3D_SUPPORT	
+	uint8_t		valid_3d_fs;
+#endif
 	struct workqueue_struct 	*demo_loop_wq;
 	struct delayed_work 		demo_loop_work;
 
diff --git a/drivers/misc/mediatek/hdmi/Sii8348/si_mhl2_edid_3d.c b/drivers/misc/mediatek/hdmi/Sii8348/si_mhl2_edid_3d.c
index 7754080..fcec352 100644
--- a/drivers/misc/mediatek/hdmi/Sii8348/si_mhl2_edid_3d.c
+++ b/drivers/misc/mediatek/hdmi/Sii8348/si_mhl2_edid_3d.c
@@ -387,84 +387,43 @@ PMHL2_video_descriptor_t pMHL2_video_descriptor = p_MHL2_video_descriptor_parm;
 
 	return ret_val;
 }
-#ifdef PRUNE_EDID
+
+#ifdef CONFIG_MTK_HDMI_3D_SUPPORT
 void si_mhl_tx_prune_dtd_list(edid_3d_data_p mhl_edid_3d_data,
 							  P_18_byte_descriptor_u p_desc,uint8_t limit)
 {
 	uint8_t i;
 	uint8_t number_that_we_pruned = 0;
-	#define DTD_Demoresolution
-	#ifdef DTD_Demoresolution
-	const uint8_t DemodetailTiming [18]={0x01,  0x1D,  0x00,  0x72,  0x51, 0xD0,  0x1E,  0x20,  0x6E,  0x28,  0x55,  0x00,  0xC4,  0x8E,  0x21,  0x00,  0x00,  0x1E};
-	//extern void *memcpy(void *dest, const void *src,  uint8_t n);
-	#endif
-
 	MHL_TX_EDID_INFO(mhl_edid_3d_data->dev_context,"limit: %d\n",(uint16_t)limit);
-	MHL_TX_EDID_INFO(mhl_edid_3d_data->dev_context," si_peer_supports_packed_pixel(mhl_edid_3d_data->dev_context) :0x%02x\n",   (uint16_t) si_peer_supports_packed_pixel(mhl_edid_3d_data->dev_context) );
-	  if (limit&&(! si_peer_supports_packed_pixel(mhl_edid_3d_data->dev_context) ))
-    {
-        for (i = 0 ; i < limit -1 ; ++i)
-        {
-        	TX_PRUNE_PRINT(("limit4444: %d,i=%d,(p_desc->dtd.pixel_clock_high):0x%02x, si_peer_supports_packed_pixel(mhl_edid_3d_data->dev_context) :0x%02x\n",
-        		(uint16_t)limit,i,(uint16_t)(p_desc->dtd.pixel_clock_high),(uint16_t) si_peer_supports_packed_pixel(mhl_edid_3d_data->dev_context) ));
-		//DumpEdidBlock(pEdidBlock0,sizeof(*pEdidBlock0));
-
-		if ((0 != p_desc->dtd.pixel_clock_low) || (0 != p_desc->dtd.pixel_clock_high))
-	            {
-	                if ((0 == p_desc->dtd.horz_active_7_0)&&(0 == p_desc->dtd.horz_active_blanking_high.horz_blanking_11_8))
-	                {
-	                P_18_byte_descriptor_u pHolder=p_desc,pNextDesc = p_desc+1;
-	                uint8_t j;
-	                    number_that_we_pruned++;
-	                    for (j = i+1; j < limit ; ++j)
-	                    {TX_PRUNE_PRINT(("limit555555: %d, i=%d, j=%d\n",(uint16_t)limit,i,j));
-	                        // move the rest of the entries one by one
-	                        *p_desc++ = *pNextDesc++;
-	                    }
-	                    // re-consider the new occupant of the i'th entry on the next iteration
-	                    //i--;
-	                    p_desc=pHolder;
-	                }
-	            }
-			if ((p_desc->dtd.pixel_clock_high>0x20)&&(! si_peer_supports_packed_pixel(mhl_edid_3d_data->dev_context) ))
-				#ifndef DTD_Demoresolution
-				{
-					P_18_byte_descriptor_u pNextDesc = p_desc+1;//pHolder=p_desc,
+	if (limit) {
+		for (i = 0 ; i < limit -1 ; ++i) {
+			if ((0 != p_desc->dtd.pixel_clock_low) || (0 != p_desc->dtd.pixel_clock_high)) {
+				if ((0 == p_desc->dtd.horz_active_7_0)&&(0 == p_desc->dtd.horz_active_blanking_high.horz_active_11_8)) {
+					P_18_byte_descriptor_u p_holder=p_desc,p_next_desc = p_desc+1;
 					uint8_t j;
 					number_that_we_pruned++;
-					for (j = i+1; j < limit ; ++j)
-					{
-						//TX_PRUNE_PRINT(("limit6666666: %d,*p_desc:0x%02x\n",(uint16_t)limit,*p_desc));
-						// move the rest of the entries one by one
-						*p_desc++ = *pNextDesc++;
+					for (j = i+1; j < limit ; ++j) {
+						/* move the rest of the entries one by one */
+						*p_desc++ = *p_next_desc++;
 					}
-					// re-consider the new occupant of the i'th entry on the next iteration
+					/* re-consider the new occupant of the i'th entry on the next iteration */
 					i--;
-					//p_desc=pHolder;
-               		 }
-				#else
-				{
-					//TX_PRUNE_PRINT(("limit6666666: %d,*p_desc:0x%02x\n",(uint16_t)limit,*p_desc));
-				        memcpy(p_desc, &DemodetailTiming[0],18);				   
+					p_desc=p_holder;
 				}
-				#endif
-	
-        }
-        TX_PRUNE_PRINT(("limit2: %d\n",(uint16_t)limit));
-        // at this point "i" holds the value of mhlTxConfig.svdDataBlockLength-1
-        //  and p_desc points to the last entry in the list
-        for (;number_that_we_pruned >0;--number_that_we_pruned,--p_desc)
-        {
-        uint8_t *pu8Temp = (uint8_t *)p_desc;
-        uint8_t size;
+			}
+		}
+		/* at this point "i" holds the value of mhl_edid_3d_data->svddata_block_length-1 
+			and p_desc points to the last entry in the list 
+		*/
+		for (;number_that_we_pruned >0;--number_that_we_pruned,--p_desc) {
+			uint8_t *pu8_temp = (uint8_t *)p_desc;
+			uint8_t size;
 
-            for (size = sizeof(*p_desc); size > 0; --size)
-            {TX_PRUNE_PRINT(("*pu8Temp: %d\n",(uint16_t)*pu8Temp));
-                *pu8Temp++ = 0;
+			for (size = sizeof(*p_desc); size > 0; --size) {
+				*pu8_temp-- = 0;
 			}
-        }
-        TX_PRUNE_PRINT(("limit3: %d\n",(uint16_t)limit));
-    }
+		}
+	}
 }
 #endif
 
@@ -758,7 +717,7 @@ static uint8_t si_mhl_tx_parse_861_long_descriptors(edid_3d_data_p mhl_edid_3d_d
 
 }
 
-#ifdef PRUNE_EDID
+#ifdef CONFIG_MTK_HDMI_3D_SUPPORT
 static void si_mhl_tx_prune_edid(edid_3d_data_p mhl_edid_3d_data)
 {
 	PEDID_block0_t p_EDID_block_0 = (PEDID_block0_t)&mhl_edid_3d_data->EDID_block_data[0];
@@ -1192,14 +1151,14 @@ static void si_mhl_tx_prune_edid(edid_3d_data_p mhl_edid_3d_data)
 
 
 	/*
-		TODO: adjust all pointers into the EDID along the way of pruning the contents, instead of re-parsing here
+		can be optimized: adjust all pointers into the EDID along the way of pruning the contents, instead of re-parsing here
 	*/
 #ifndef EDID_PASSTHROUGH //(
     if (0 == si_mhl_tx_drv_set_upstream_edid(mhl_edid_3d_data->drv_context,mhl_edid_3d_data->EDID_block_data,2*EDID_BLOCK_SIZE))
 #endif //)
 	{
 		SET_3D_FLAG(mhl_edid_3d_data,FLAGS_EDID_READ_DONE)
-		si_mhl_tx_drv_enable_video_path(mhl_edid_3d_data->drv_context);	// TODO: FD, TBI, debug?
+		si_mhl_tx_drv_enable_video_path(mhl_edid_3d_data->drv_context);
 	}
 }
 #endif
@@ -1496,14 +1455,15 @@ static void si_mhl_tx_display_timing_enumeration_end(edid_3d_data_p mhl_edid_3d_
 	/* notify the app (board specific) layer */
 	display_timing_enumeration_end(mhl_edid_3d_data);
 	SET_3D_FLAG(mhl_edid_3d_data,FLAGS_BURST_3D_DONE);
-	#ifdef PRUNE_EDID
+#ifdef CONFIG_MTK_HDMI_3D_SUPPORT
 	si_mhl_tx_prune_edid(mhl_edid_3d_data);
-	#else
+#else
 	SET_3D_FLAG(mhl_edid_3d_data,FLAGS_EDID_READ_DONE)
 	si_mhl_tx_drv_enable_video_path(mhl_edid_3d_data->drv_context);	// //TODO: FD, TBI, debug?
-	#endif
+#endif
 }
 
+
 static void CheckForAll3DBurstDone(edid_3d_data_p mhl_edid_3d_data)
 {
 	if (TEST_3D_FLAG(mhl_edid_3d_data,FLAGS_BURST_3D_VIC_DONE)){
@@ -2091,7 +2051,7 @@ void SiiMhlTxMakeItDVI(edid_3d_data_p mhl_edid_3d_data,PEDID_block0_t p_EDID_blo
 			,"EDID: second block now all 0xFF\n");
 }
 
-#if 0
+#ifdef CONFIG_MTK_HDMI_3D_SUPPORT
 static void SiiMhlTx3dReqForNonTranscodeMode( edid_3d_data_p mhl_edid_3d_data )
 {
 	MHL_TX_EDID_INFO(mhl_edid_3d_data->dev_context,
@@ -2125,13 +2085,8 @@ static void SiiMhlTx3dReqForNonTranscodeMode( edid_3d_data_p mhl_edid_3d_data )
 
 			// EDID read need to be done in SW TPI mode, as it is done now, switch back to default TPI mode: HW TPI mode
 			si_mhl_tx_drv_set_hw_tpi_mode( mhl_edid_3d_data->drv_context, true );
-			#ifdef PRUNE_EDID
-			si_mhl_tx_prune_edid(mhl_edid_3d_data);
-			#else
-			SET_3D_FLAG(mhl_edid_3d_data,FLAGS_EDID_READ_DONE)
-			si_mhl_tx_drv_enable_video_path(mhl_edid_3d_data->drv_context);	// //TODO: FD, TBI, debug?
-			#endif
 
+			si_mhl_tx_prune_edid(mhl_edid_3d_data);
 		}
 	} else {
 #ifndef EDID_PASSTHROUGH //(
@@ -2142,7 +2097,7 @@ static void SiiMhlTx3dReqForNonTranscodeMode( edid_3d_data_p mhl_edid_3d_data )
 			si_mhl_tx_drv_set_hw_tpi_mode( mhl_edid_3d_data->drv_context, true );
 
 			SET_3D_FLAG(mhl_edid_3d_data, FLAGS_EDID_READ_DONE);
-			si_mhl_tx_drv_enable_video_path(mhl_edid_3d_data->drv_context);	// TODO: FD, TBI, debug?
+			si_mhl_tx_drv_enable_video_path(mhl_edid_3d_data->drv_context);
 		}
 	}
 }
@@ -2492,7 +2447,10 @@ uint8_t i;
                     {
                     P_vsdb_t p_vsdb = (P_vsdb_t) p_data_u.puc_data_block;
                     uint8_t *puc_next_db = ((uint8_t *)&p_vsdb->header) + sizeof(p_vsdb->header) + data_block_length;
-
+#ifdef CONFIG_MTK_HDMI_3D_SUPPORT                    
+                    extern bool MHL_3D_Support;
+                    MHL_3D_Support = false;
+#endif                       
 		    // TODO: FD, TBI, any chance of MHL OUI here? 0x030C00 is HDMI OUI
 		    if (   (p_vsdb->IEEE_OUI[0] == 0x03)
 				    && (p_vsdb->IEEE_OUI[1] == 0x0C)
@@ -2522,8 +2480,14 @@ uint8_t i;
 				    mhl_edid_3d_data->parse_data._3D_supported = false;
 			    } else if (mhl_edid_3d_data->parse_data.p_byte_13_through_byte_15->byte13._3D_present) {
 				    mhl_edid_3d_data->parse_data._3D_supported = true;
+#ifdef CONFIG_MTK_HDMI_3D_SUPPORT				    
+				    MHL_3D_Support= true;
+#endif				    
 			    } else {
 				    mhl_edid_3d_data->parse_data._3D_supported = false;
+#ifdef CONFIG_MTK_HDMI_3D_SUPPORT				    
+				    MHL_3D_Support= false;
+#endif				    
 			    }
 
 			    MHL_TX_EDID_INFO(mhl_edid_3d_data->dev_context,
@@ -2652,11 +2616,13 @@ void si_mhl_tx_handle_atomic_hw_edid_read_complete(edid_3d_data_p mhl_edid_3d_da
 	p_EDID_block_0->checksum = 0;
 	p_EDID_block_0->checksum = calculate_generic_checksum((uint8_t *)p_EDID_block_0,0,sizeof(*p_EDID_block_0));
 
-	//SiiMhlTx3dReqForNonTranscodeMode(mhl_edid_3d_data);
+#ifdef CONFIG_MTK_HDMI_3D_SUPPORT
+	SiiMhlTx3dReqForNonTranscodeMode(mhl_edid_3d_data);
+#endif	
 }
 
 /*
-		EXPORTED FUNCTIONS
+		EXPORTED FUNCTIONS 
 */
 
 void si_mhl_tx_initiate_edid_sequence(void *context)
diff --git a/drivers/misc/mediatek/hdmi/Sii8348/si_mhl_tx_hw_drv_api.h b/drivers/misc/mediatek/hdmi/Sii8348/si_mhl_tx_hw_drv_api.h
index 2ce5912..a6f2048 100644
--- a/drivers/misc/mediatek/hdmi/Sii8348/si_mhl_tx_hw_drv_api.h
+++ b/drivers/misc/mediatek/hdmi/Sii8348/si_mhl_tx_hw_drv_api.h
@@ -77,6 +77,11 @@ void si_mhl_tx_drv_video_update(struct drv_hw_context *hw_context, int video, in
 void si_mhl_tx_drv_video_3d_update(struct drv_hw_context *hw_context, int video, int video_3d);
 void si_mhl_tx_drv_video_all_update(struct drv_hw_context *hw_context, int video, int video_3d);
 */
+#ifdef CONFIG_MTK_HDMI_3D_SUPPORT
+void si_mhl_tx_drv_video_3d_update(struct mhl_dev_context *dev_context, int video_3d);
+void si_mhl_tx_drv_video_3d(struct mhl_dev_context *dev_context, int video_3d);
+#endif
+
 #ifdef	NEVER
 typedef enum
 {
diff --git a/drivers/misc/mediatek/hdmi/inc/hdmi_drv.h b/drivers/misc/mediatek/hdmi/inc/hdmi_drv.h
index 6154218..e38f936 100644
--- a/drivers/misc/mediatek/hdmi/inc/hdmi_drv.h
+++ b/drivers/misc/mediatek/hdmi/inc/hdmi_drv.h
@@ -76,6 +76,10 @@ typedef enum {
 	HDMI_VOUT_FORMAT_RGB888,
 	HDMI_VOUT_FORMAT_YUV422,
 	HDMI_VOUT_FORMAT_YUV444,
+
+	HDMI_VOUT_FORMAT_2D     = 1<<16,
+	HDMI_VOUT_FORMAT_3D_SBS = 1<<17,
+	HDMI_VOUT_FORMAT_3D_TAB = 1<<18,
 } HDMI_VIDEO_OUTPUT_FORMAT;
 
 //Must align to MHL Tx chip driver define
@@ -111,9 +115,17 @@ typedef enum {
 	HDMI_CABLE,
 	MHL_CABLE,
 	MHL_SMB_CABLE,
-	MHL_2_CABLE		/* /MHL 2.0 */
+	MHL_2_CABLE,		/* /MHL 2.0 */
+	MHL_3D_GLASSES
 } HDMI_CABLE_TYPE;
 
+typedef enum {
+	HDMI_2D,
+	HDMI_3D_SBS,
+	HDMI_3D_TAB,
+	HDMI_3D_FP		
+} HDMI_3D_FORMAT_ENUM;
+
 typedef struct {
 	unsigned int width;
 	unsigned int height;
@@ -150,7 +162,10 @@ typedef struct {
 	unsigned int scaling_factor;	/* determine the scaling of output screen size, valid value 0~10 */
 	/* 0 means no scaling, 5 means scaling to 95%, 10 means 90% */
 	HDMI_CABLE_TYPE cabletype;
-	bool HDCPSupported;
+	unsigned int HDCPSupported;
+#ifdef CONFIG_MTK_HDMI_3D_SUPPORT	
+	int is_3d_support;
+#endif	
 } HDMI_PARAMS;
 
 typedef enum {
@@ -256,7 +271,11 @@ typedef struct {
 	void (*suspend) (void);
 	void (*resume) (void);
 	int  (*audio_config)(HDMI_AUDIO_FORMAT aformat, int bitWidth);
+#ifdef CONFIG_MTK_HDMI_3D_SUPPORT	
+	int  (*video_config)(HDMI_VIDEO_RESOLUTION vformat, HDMI_VIDEO_INPUT_FORMAT vin, int vou);
+#else
 	int  (*video_config)(HDMI_VIDEO_RESOLUTION vformat, HDMI_VIDEO_INPUT_FORMAT vin, HDMI_VIDEO_OUTPUT_FORMAT vou);
+#endif
 	int (*video_enable) (bool enable);
 	int (*audio_enable) (bool enable);
 	int (*irq_enable) (bool enable);
diff --git a/drivers/misc/mediatek/hwmon/batchsen/batch.c b/drivers/misc/mediatek/hwmon/batchsen/batch.c
index 601a889..7c22463 100644
--- a/drivers/misc/mediatek/hwmon/batchsen/batch.c
+++ b/drivers/misc/mediatek/hwmon/batchsen/batch.c
@@ -70,7 +70,7 @@ static int batch_update_polling_rate(void)
 	int mindelay =0;
 	
 	//mindelay = obj->dev_list.data_dev[0].delay;
-	for(idx = 0; idx < MAX_ANDROID_SENSOR_NUM; idx++)//choose first MAX_ANDROID_SENSOR_NUM sensors for different sensor type 
+	for(idx = 0; idx < ID_SENSOR_MAX_HANDLE; idx++)//choose first ID_SENSOR_MAX_HANDLE sensors for different sensor type 
 	{
 		if((obj->active_sensor & (0x01<< idx)) && (0 != obj->dev_list.data_dev[idx].maxBatchReportLatencyMs))
 		{
@@ -97,25 +97,25 @@ static int get_fifo_data(struct batch_context *obj)
     time.tv_nsec = 0;
     get_monotonic_boottime(&time);
     nt = time.tv_sec*1000000000LL+time.tv_nsec;
-    for(i=0;i<=MAX_ANDROID_SENSOR_NUM;i++)
+    for(i=0;i<=ID_SENSOR_MAX_HANDLE;i++)
     {
         obj->timestamp_info[i].num = 1;
         obj->timestamp_info[i].end_t = nt;
     }
     
 	BATCH_LOG("fwq!! get_fifo_data +++++++++	!\n");
-	if((obj->dev_list.ctl_dev[MAX_ANDROID_SENSOR_NUM].flush != NULL) 
-		&& (obj->dev_list.data_dev[MAX_ANDROID_SENSOR_NUM].get_data != NULL)
-		&& (obj->dev_list.data_dev[MAX_ANDROID_SENSOR_NUM].get_fifo_status)!=NULL)
+	if((obj->dev_list.ctl_dev[ID_SENSOR_MAX_HANDLE].flush != NULL) 
+		&& (obj->dev_list.data_dev[ID_SENSOR_MAX_HANDLE].get_data != NULL)
+		&& (obj->dev_list.data_dev[ID_SENSOR_MAX_HANDLE].get_fifo_status)!=NULL)
 	{
 		mutex_lock(&batch_data_mutex);
-		err = obj->dev_list.data_dev[MAX_ANDROID_SENSOR_NUM].get_fifo_status(&fifo_len,&fifo_status,0, obj->timestamp_info);
+		err = obj->dev_list.data_dev[ID_SENSOR_MAX_HANDLE].get_fifo_status(&fifo_len,&fifo_status,0, obj->timestamp_info);
 		if(-1 == fifo_len)
 		{
 				//we use fifo_status
 				if(1 == fifo_status)
 				{
-					err = obj->dev_list.data_dev[MAX_ANDROID_SENSOR_NUM].get_data(0, &sensor_data);
+					err = obj->dev_list.data_dev[ID_SENSOR_MAX_HANDLE].get_data(0, &sensor_data);
 					if(err)
 					{
 						BATCH_LOG("batch get fifoA data error\n");
@@ -136,7 +136,7 @@ static int get_fifo_data(struct batch_context *obj)
 		mutex_unlock(&batch_data_mutex);
 	}
 		
-	for(idx = 0; idx < MAX_ANDROID_SENSOR_NUM; idx++)
+	for(idx = 0; idx < ID_SENSOR_MAX_HANDLE; idx++)
 	{
 			//BATCH_LOG("get data from sensor (%d) !\n", idx);
 		if((obj->dev_list.ctl_dev[idx].flush == NULL) || (obj->dev_list.data_dev[idx].get_data == NULL))
@@ -219,11 +219,11 @@ static void report_data_once(int handle)
     
 	obj->flush_result = 0;
 	//BATCH_LOG("fwq ++++++++++++++++++\n" );
-	//BATCH_LOG("fwq batch mode  (%x,%x)) !!!!\n",obj->dev_list.ctl_dev[MAX_ANDROID_SENSOR_NUM].flush,
-//		obj->dev_list.data_dev[MAX_ANDROID_SENSOR_NUM].get_data);
-	if((obj->dev_list.ctl_dev[MAX_ANDROID_SENSOR_NUM].flush != NULL) && (obj->dev_list.data_dev[MAX_ANDROID_SENSOR_NUM].get_data != NULL))
+	//BATCH_LOG("fwq batch mode  (%x,%x)) !!!!\n",obj->dev_list.ctl_dev[ID_SENSOR_MAX_HANDLE].flush,
+//		obj->dev_list.data_dev[ID_SENSOR_MAX_HANDLE].get_data);
+	if((obj->dev_list.ctl_dev[ID_SENSOR_MAX_HANDLE].flush != NULL) && (obj->dev_list.data_dev[ID_SENSOR_MAX_HANDLE].get_data != NULL))
 	{
-		obj->flush_result = obj->dev_list.ctl_dev[MAX_ANDROID_SENSOR_NUM].flush(handle);
+		obj->flush_result = obj->dev_list.ctl_dev[ID_SENSOR_MAX_HANDLE].flush(handle);
 		get_fifo_data(obj);
 		report_batch_finish(obj->idev, handle);		
 	}
@@ -294,7 +294,7 @@ static ssize_t batch_store_active(struct device* dev, struct device_attribute *a
         cxt->batch_result = -1;
         return count;
     }
-    else if (MAX_ANDROID_SENSOR_NUM <= handle)
+    else if (ID_SENSOR_MAX_HANDLE <= handle)
     {
         cxt->batch_result = 0;
         return count;
@@ -342,9 +342,9 @@ static ssize_t batch_store_active(struct device* dev, struct device_attribute *a
             mutex_unlock(&batch_hw_mutex);
             return count;
         }
-    }else if(cxt->dev_list.ctl_dev[MAX_ANDROID_SENSOR_NUM].enable_hw_batch != NULL){
-        //BATCH_LOG("cxt->dev_list.ctl_dev[%d].enable_hw_batch, %d, %d, %d\n",MAX_ANDROID_SENSOR_NUM,en,cxt->dev_list.data_dev[handle].samplingPeriodMs, cxt->dev_list.data_dev[handle].maxBatchReportLatencyMs);
-        res = cxt->dev_list.ctl_dev[MAX_ANDROID_SENSOR_NUM].enable_hw_batch(handle, en,cxt->dev_list.data_dev[handle].flags|cxt->force_wake_upon_fifo_full,(long long)cxt->dev_list.data_dev[handle].samplingPeriodMs*1000000,(long long)cxt->dev_list.data_dev[handle].maxBatchReportLatencyMs*1000000);
+    }else if(cxt->dev_list.ctl_dev[ID_SENSOR_MAX_HANDLE].enable_hw_batch != NULL){
+        //BATCH_LOG("cxt->dev_list.ctl_dev[%d].enable_hw_batch, %d, %d, %d\n",ID_SENSOR_MAX_HANDLE,en,cxt->dev_list.data_dev[handle].samplingPeriodMs, cxt->dev_list.data_dev[handle].maxBatchReportLatencyMs);
+        res = cxt->dev_list.ctl_dev[ID_SENSOR_MAX_HANDLE].enable_hw_batch(handle, en,cxt->dev_list.data_dev[handle].flags|cxt->force_wake_upon_fifo_full,(long long)cxt->dev_list.data_dev[handle].samplingPeriodMs*1000000,(long long)cxt->dev_list.data_dev[handle].maxBatchReportLatencyMs*1000000);
         if(res < 0)
         {
             cxt->batch_result = -1;
@@ -429,7 +429,7 @@ static ssize_t batch_store_batch(struct device* dev, struct device_attribute *at
         cxt->batch_result = -1;
         return count;
     }
-    else if (MAX_ANDROID_SENSOR_NUM <= handle)
+    else if (ID_SENSOR_MAX_HANDLE <= handle)
     {
         cxt->batch_result = 0;
         return count;
@@ -449,7 +449,7 @@ static ssize_t batch_store_batch(struct device* dev, struct device_attribute *at
         return count;
     }    
 
-	if((cxt->dev_list.ctl_dev[MAX_ANDROID_SENSOR_NUM].enable_hw_batch == NULL)&&(cxt->dev_list.ctl_dev[handle].enable_hw_batch == NULL)){
+	if((cxt->dev_list.ctl_dev[ID_SENSOR_MAX_HANDLE].enable_hw_batch == NULL)&&(cxt->dev_list.ctl_dev[handle].enable_hw_batch == NULL)){
 		cxt->batch_result = -1;
 		return count;
 	}
@@ -507,8 +507,8 @@ static ssize_t batch_store_batch(struct device* dev, struct device_attribute *at
             mutex_unlock(&batch_hw_mutex);
             return count;
         }
-    }else if(cxt->dev_list.ctl_dev[MAX_ANDROID_SENSOR_NUM].enable_hw_batch != NULL){
-        res = cxt->dev_list.ctl_dev[MAX_ANDROID_SENSOR_NUM].enable_hw_batch(handle, en,flags|cxt->force_wake_upon_fifo_full,(long long)samplingPeriodNs*1000000,(long long)maxBatchReportLatencyNs*1000000);
+    }else if(cxt->dev_list.ctl_dev[ID_SENSOR_MAX_HANDLE].enable_hw_batch != NULL){
+        res = cxt->dev_list.ctl_dev[ID_SENSOR_MAX_HANDLE].enable_hw_batch(handle, en,flags|cxt->force_wake_upon_fifo_full,(long long)samplingPeriodNs*1000000,(long long)maxBatchReportLatencyNs*1000000);
         if(res < 0)
         {
             cxt->batch_result = -1;
@@ -565,6 +565,12 @@ static ssize_t batch_store_flush(struct device* dev, struct device_attribute *at
         	return count;
     	}
 
+	if (handle < 0 || ID_SENSOR_MAX_HANDLE < handle) {
+		BATCH_ERR("invalid handle : %d\n", handle);
+		cxt->flush_result = -1;
+		return count;
+	}
+
 	report_data_once(handle);//handle need to use of this function 
 	
 	BATCH_LOG(" flush_store_delay sucess------\n");
@@ -636,7 +642,7 @@ static long batch_unlocked_ioctl(struct file *fp, unsigned int cmd, unsigned lon
 
             for (i=0;i<batch_context_obj->numOfDataLeft&&i<batch_sensors_data.numOfDataReturn;i++)
             {
-                err = batch_context_obj->dev_list.data_dev[MAX_ANDROID_SENSOR_NUM].get_data(0, &batch_sensors_data.data[i]);
+                err = batch_context_obj->dev_list.data_dev[ID_SENSOR_MAX_HANDLE].get_data(0, &batch_sensors_data.data[i]);
                 if (err)
                 {
                     BATCH_ERR("BATCH_IO_GET_SENSORS_DATA err = %d\n", err);
@@ -801,7 +807,7 @@ int batch_register_data_path(int handle, struct batch_data_path *data)
 		BATCH_ERR("data pointer is null!\n");
 		return -1;
 		}
-	if(handle >= 0 && handle <=(MAX_ANDROID_SENSOR_NUM)){
+	if(handle >= 0 && handle <=(ID_SENSOR_MAX_HANDLE)){
 		cxt ->dev_list.data_dev[handle].get_data = data->get_data;
 		cxt ->dev_list.data_dev[handle].flags = data->flags;
 		cxt ->dev_list.data_dev[handle].get_fifo_status= data->get_fifo_status;
@@ -819,7 +825,7 @@ int batch_register_control_path(int handle, struct batch_control_path *ctl)
 		BATCH_ERR("ctl pointer is null!\n");
 		return -1;
 		}
-	if(handle >= 0 && handle <=(MAX_ANDROID_SENSOR_NUM)){
+	if(handle >= 0 && handle <=(ID_SENSOR_MAX_HANDLE)){
 		cxt ->dev_list.ctl_dev[handle].enable_hw_batch = ctl->enable_hw_batch;
 		cxt ->dev_list.ctl_dev[handle].flush= ctl->flush;
 		return 0;	
@@ -841,7 +847,7 @@ int batch_register_support_info(int handle, int support,int div, int timestamp_s
 			return -1;
 		}
 	}
-	if(handle >= 0 && handle <=(MAX_ANDROID_SENSOR_NUM)){
+	if(handle >= 0 && handle <=(ID_SENSOR_MAX_HANDLE)){
 		cxt ->dev_list.data_dev[handle].is_batch_supported = support;
 		cxt ->dev_list.data_dev[handle].div = div;
 		cxt ->dev_list.data_dev[handle].is_timestamp_supported = timestamp_supported;
@@ -1120,7 +1126,7 @@ static int batch_suspend(struct platform_device *dev, pm_message_t state)
 
     mutex_lock(&batch_hw_mutex);
     cxt->force_wake_upon_fifo_full = 0;
-    for (handle=0;handle<=MAX_ANDROID_SENSOR_NUM;handle++)
+    for (handle=0;handle<=ID_SENSOR_MAX_HANDLE;handle++)
     {
         if (cxt->dev_list.data_dev[handle].is_batch_supported)
         {
@@ -1132,8 +1138,8 @@ static int batch_suspend(struct platform_device *dev, pm_message_t state)
                 if(res < 0)
                 {
                 }
-            }else if(cxt->dev_list.ctl_dev[MAX_ANDROID_SENSOR_NUM].enable_hw_batch != NULL){
-                res = cxt->dev_list.ctl_dev[MAX_ANDROID_SENSOR_NUM].enable_hw_batch(handle, en,cxt->dev_list.data_dev[handle].flags|cxt->force_wake_upon_fifo_full,
+            }else if(cxt->dev_list.ctl_dev[ID_SENSOR_MAX_HANDLE].enable_hw_batch != NULL){
+                res = cxt->dev_list.ctl_dev[ID_SENSOR_MAX_HANDLE].enable_hw_batch(handle, en,cxt->dev_list.data_dev[handle].flags|cxt->force_wake_upon_fifo_full,
                     (long long)cxt->dev_list.data_dev[handle].samplingPeriodMs*1000000, (long long)cxt->dev_list.data_dev[handle].maxBatchReportLatencyMs*1000000);
                 if(res < 0)
                 {
@@ -1160,7 +1166,7 @@ static int batch_resume(struct platform_device *dev)
 
     mutex_lock(&batch_hw_mutex);
     cxt->force_wake_upon_fifo_full = SENSORS_BATCH_WAKE_UPON_FIFO_FULL;
-    for (handle=0;handle<=MAX_ANDROID_SENSOR_NUM;handle++)
+    for (handle=0;handle<=ID_SENSOR_MAX_HANDLE;handle++)
     {
         if (cxt->dev_list.data_dev[handle].is_batch_supported)
         {
@@ -1172,8 +1178,8 @@ static int batch_resume(struct platform_device *dev)
                 if(res < 0)
                 {
                 }
-            }else if(cxt->dev_list.ctl_dev[MAX_ANDROID_SENSOR_NUM].enable_hw_batch != NULL){
-                res = cxt->dev_list.ctl_dev[MAX_ANDROID_SENSOR_NUM].enable_hw_batch(handle, en,cxt->dev_list.data_dev[handle].flags|cxt->force_wake_upon_fifo_full,
+            }else if(cxt->dev_list.ctl_dev[ID_SENSOR_MAX_HANDLE].enable_hw_batch != NULL){
+                res = cxt->dev_list.ctl_dev[ID_SENSOR_MAX_HANDLE].enable_hw_batch(handle, en,cxt->dev_list.data_dev[handle].flags|cxt->force_wake_upon_fifo_full,
                     (long long)cxt->dev_list.data_dev[handle].samplingPeriodMs*1000000, (long long)cxt->dev_list.data_dev[handle].maxBatchReportLatencyMs*1000000);
                 if(res < 0)
                 {
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6752/kd_sensorlist.h b/drivers/misc/mediatek/imgsensor/src/mt6752/kd_sensorlist.h
index 9104153..3a9ed90 100644
--- a/drivers/misc/mediatek/imgsensor/src/mt6752/kd_sensorlist.h
+++ b/drivers/misc/mediatek/imgsensor/src/mt6752/kd_sensorlist.h
@@ -122,14 +122,6 @@ UINT32 T8EV5_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 //! 2. This file should be the same as mediatek\custom\common\hal\imgsensor\src\sensorlist.cpp
 ACDK_KD_SENSOR_INIT_FUNCTION_STRUCT kdSensorList[MAX_NUM_OF_SUPPORT_SENSOR+1] =
 {
-#if 1// tangqingcai
-#if defined(OV13850_MIPI_RAW)
-    {OV13850_SENSOR_ID, SENSOR_DRVNAME_OV13850_MIPI_RAW, OV13850_MIPI_RAW_SensorInit}, 
-#endif
-#if defined(OV5670_MIPI_RAW)
-    {OV5670MIPI_SENSOR_ID, SENSOR_DRVNAME_OV5670_MIPI_RAW, OV5670_MIPI_RAW_SensorInit}, 
-#endif 
-#else // tangqingcai
 /*IMX*/
 #if defined(IMX220_MIPI_RAW)
     {IMX220_SENSOR_ID, SENSOR_DRVNAME_IMX220_MIPI_RAW, IMX220_MIPI_RAW_SensorInit},
@@ -441,7 +433,7 @@ ACDK_KD_SENSOR_INIT_FUNCTION_STRUCT kdSensorList[MAX_NUM_OF_SUPPORT_SENSOR+1] =
 #if defined(T8EV5_YUV)
     {T8EV5_SENSOR_ID, SENSOR_DRVNAME_T8EV5_YUV, T8EV5_YUV_SensorInit},
 #endif
-#endif // tangqingcai
+
 /*  ADD sensor driver before this line */
     {0,{0},NULL}, //end of list
 };
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6752/ov13850_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6752/ov13850_mipi_raw/Makefile
index 563d7a8..50b8b5a 100644
--- a/drivers/misc/mediatek/imgsensor/src/mt6752/ov13850_mipi_raw/Makefile
+++ b/drivers/misc/mediatek/imgsensor/src/mt6752/ov13850_mipi_raw/Makefile
@@ -1,6 +1,4 @@
 include $(srctree)/drivers/misc/mediatek/Makefile.custom
 
-#obj-y += ov13850_otp_cal.o
 obj-y += ov13850mipiraw_Sensor.o
 
- 
\ No newline at end of file
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6752/ov13850_mipi_raw/ov13850mipiraw_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6752/ov13850_mipi_raw/ov13850mipiraw_Sensor.c
index 0c19ed6..b176583 100644
--- a/drivers/misc/mediatek/imgsensor/src/mt6752/ov13850_mipi_raw/ov13850mipiraw_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6752/ov13850_mipi_raw/ov13850mipiraw_Sensor.c
@@ -47,15 +47,15 @@
 /****************************   Modify end    *******************************************/
 
 #if DBG
-#define LOG_DBG(format, args...)    xlog_printk(ANDROID_LOG_DEBUG   , PFX, "[%s] " format, __FUNCTION__, ##args)
-#define LOG_INF(format, args...)    xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
-#define LOG_WRN(format, args...)    xlog_printk(ANDROID_LOG_WARN, PFX, "[%s] " format, __FUNCTION__, ##args)
-#define LOG_ERR(format, args...)    xlog_printk(ANDROID_LOG_ERROR   , PFX, "[%s] " format, __FUNCTION__, ##args)
+#define LOG_DBG(format, args...)    pr_debug( PFX "[%s] " format, __FUNCTION__, ##args)
+#define LOG_INF(format, args...)    pr_info( PFX "[%s] " format, __FUNCTION__, ##args)
+#define LOG_WRN(format, args...)    pr_warn( PFX "[%s] " format, __FUNCTION__, ##args)
+#define LOG_ERR(format, args...)    pr_err( PFX "[%s] " format, __FUNCTION__, ##args)
 #else
 #define LOG_DBG(format, args...) 
 #define LOG_INF(format, args...)
-#define LOG_WRN(format, args...)    xlog_printk(ANDROID_LOG_WARN, PFX, "[%s] " format, __FUNCTION__, ##args)
-#define LOG_ERR(format, args...)    xlog_printk(ANDROID_LOG_ERROR   , PFX, "[%s] " format, __FUNCTION__, ##args)
+#define LOG_WRN(format, args...)    pr_warn( PFX "[%s] " format, __FUNCTION__, ##args)
+#define LOG_ERR(format, args...)    pr_err( PFX "[%s] " format, __FUNCTION__, ##args)
 
 #endif
 static DEFINE_SPINLOCK(imgsensor_drv_lock);
@@ -64,12 +64,12 @@ static DEFINE_SPINLOCK(imgsensor_drv_lock);
 
 int ov13850_chip_ver = OV13850_R2A;
 //sensor otp
-extern void otp_cali(unsigned char writeid);
+//extern void otp_cali(unsigned char writeid);
 
 static imgsensor_info_struct imgsensor_info = {
     .sensor_id = OV13850_SENSOR_ID,        //record sensor id defined in Kd_imgsensor.h
 
-    .checksum_value = 0xa261a12b,//0xf86cfdf4,        //checksum value for Camera Auto Test
+    .checksum_value = 0xbde6b5f8,//0xf86cfdf4,        //checksum value for Camera Auto Test
 
     .pre = {
         .pclk = 240000000,                //record different mode's pclk
@@ -212,7 +212,231 @@ static kal_uint16 read_cmos_sensor(kal_uint32 addr)
 static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
 {
     char pu_send_cmd[3] = {(char)(addr >> 8), (char)(addr & 0xFF), (char)(para & 0xFF)};
-    iWriteRegI2C(pu_send_cmd, 3, imgsensor.i2c_write_id);		
+    iWriteRegI2C(pu_send_cmd, 3, imgsensor.i2c_write_id);
+}
+static kal_uint16 OV13850_read_cmos_sensor(kal_uint32 addr)
+{
+	kal_uint16 get_byte=0;
+
+	char pu_send_cmd[2] = {(char)(addr >> 8), (char)(addr & 0xFF) };
+	iReadRegI2C(pu_send_cmd, 2, (u8*)&get_byte, 1, imgsensor.i2c_write_id);
+
+	return get_byte;
+}
+
+static void OV13850_write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
+{
+	char pu_send_cmd[3] = {(char)(addr >> 8), (char)(addr & 0xFF), (char)(para & 0xFF)};
+	iWriteRegI2C(pu_send_cmd, 3, imgsensor.i2c_write_id);
+}
+
+//int ReadSensorReg(u16 i2cId, u16 addr, u8 * puBuff);
+
+kal_uint16 OV13850_EEProm_read(kal_uint32 addr)
+
+{
+       kal_uint16 get_byte=0;
+
+	char pu_send_cmd[2] = {(char)(addr >> 8), (char)(addr & 0xFF) };
+	iReadRegI2C(pu_send_cmd, 2, (u8*)&get_byte, 1, 0xb0);  //0xb0 is driver ic id
+	
+	return get_byte;
+}
+
+void OV13850_ApplyAWB(kal_uint16 rg,kal_uint16 bg,kal_uint16 RG_Ratio_Typical,kal_uint16 BG_Ratio_Typical)
+
+{
+	kal_uint16 nR_G_gain,nB_G_gain,nG_G_gain;
+	kal_uint16 nBase_gain;
+	kal_uint16 R_gain,B_gain,G_gain;
+	USHORT temp1,temp2,temp3,temp4,temp5,temp6;//shenan
+	
+	nR_G_gain=(RG_Ratio_Typical*1000)/rg;
+	nB_G_gain=(BG_Ratio_Typical*1000)/bg;
+	nG_G_gain=1000;
+	
+	if(nR_G_gain<1000 || nB_G_gain<1000)
+	{
+		if(nR_G_gain < nB_G_gain)
+			nBase_gain=nR_G_gain;
+		else
+			nBase_gain=nB_G_gain;
+	}
+	else
+	{
+		nBase_gain=nG_G_gain;
+	}
+	
+	R_gain=0x400*nR_G_gain/(nBase_gain);
+	B_gain=0x400*nB_G_gain/(nBase_gain);
+	G_gain=0x400*nG_G_gain/(nBase_gain);
+	
+	if(R_gain>0x400)
+	{
+		OV13850_write_cmos_sensor(0x5056,R_gain>>8);
+		OV13850_write_cmos_sensor(0x5057,R_gain&0x00ff);
+	}
+	if(G_gain>0x400)
+	{
+		OV13850_write_cmos_sensor(0x5058,G_gain>>8);
+		OV13850_write_cmos_sensor(0x5059,G_gain&0x00ff);
+	}
+	if(B_gain>0x400)
+	{
+		OV13850_write_cmos_sensor(0x505A,B_gain>>8);
+		OV13850_write_cmos_sensor(0x505B,B_gain&0x00ff);
+	}
+	//shenan,
+	temp1=OV13850_read_cmos_sensor(0x5056);
+	temp2=OV13850_read_cmos_sensor(0x5057);
+	temp3=OV13850_read_cmos_sensor(0x5058);
+	temp4=OV13850_read_cmos_sensor(0x5059);
+	temp5=OV13850_read_cmos_sensor(0x505A);
+	temp6=OV13850_read_cmos_sensor(0x505B);
+	
+	LOG_INF("OTP AWB info From Sensor 0x5056: 0x%x\n",temp1);
+	LOG_INF("OTP AWB info From Sensor 0x5057: 0x%x\n",temp2);
+	LOG_INF("OTP AWB info From Sensor 0x5058: 0x%x\n",temp3);
+	LOG_INF("OTP AWB info From Sensor 0x5059: 0x%x\n",temp4);
+	LOG_INF("OTP AWB info From Sensor 0x505a: 0x%x\n",temp5);
+	LOG_INF("OTP AWB info From Sensor 0x505b: 0x%x\n",temp6);
+	//shenan
+}
+
+kal_uint16 OV13850_checkOTP()
+{
+     kal_uint16 otp_flag;
+     kal_uint16 * otp_info_data = (kal_uint16 *)kmalloc(sizeof(kal_uint16)*32,GFP_KERNEL);
+     USHORT * otp_wb_data = (USHORT * )kmalloc(sizeof(USHORT)*64,GFP_KERNEL);
+     USHORT * otp_lsc_data= (USHORT *)kmalloc(sizeof(USHORT)*360,GFP_KERNEL);
+     USHORT flag,temp;
+     kal_uint16 i,sum;
+     kal_uint16 rg,bg,RG_Ratio_Typical,BG_Ratio_Typical;
+
+     //check EEProm flag
+      otp_flag = OV13850_EEProm_read(0x0400);
+      mdelay(10);
+
+      LOG_INF("otpdebug:otp_flag = %x", otp_flag);
+	  
+    if(otp_flag&0x01==1)
+    {
+     	LOG_INF("OV13850 EEProm read success");
+    }
+   else
+    {
+     	LOG_INF("OV13850 EEProm read wrong");
+	return;
+    }
+
+     //read basic info from EEProm
+      for(i=0x0401;i<=0x0412;i++)
+      {
+       otp_info_data[i-0x0401] = OV13850_EEProm_read(i);
+      }
+      
+      mdelay(10);
+
+	USHORT module_id = otp_info_data[0];
+	USHORT sensor_versoin = otp_info_data[1];
+	USHORT otp_calibration_version = otp_info_data[2];
+	USHORT dll_version = otp_info_data[3];
+	USHORT production_year = otp_info_data[4];
+	USHORT production_month = otp_info_data[5];
+	USHORT production_day = otp_info_data[6];
+	USHORT sensor_id = otp_info_data[7];
+	USHORT lens_id = otp_info_data[8];
+	USHORT vcm_id = otp_info_data[9];
+	USHORT driver_ic_id = otp_info_data[10];
+	USHORT IR_BG_id = otp_info_data[11];
+	USHORT color_temperature_id = otp_info_data[12];
+	USHORT AF_FF_flag = otp_info_data[13];
+	USHORT light_source_flag = otp_info_data[14]; 
+
+	LOG_INF("otpdebug:module_id = %x",module_id);
+	LOG_INF("otpdebug:dll_version = %x",dll_version);
+     
+	//if(module_id != 0x07 || dll_version != 0x03)
+	//{
+       //  LOG_INF("otpdebug:The module is not made by ofilm or Dll version is wrong");
+	//  return;
+	//}
+       //read LSC data from EEProm
+       for(i=0x042f;i<=0x0596;i++)
+       {
+       	  otp_lsc_data[i-0x042f] = OV13850_EEProm_read(i);
+	  LOG_INF("OTP LSC info From Epprom 0x%x: 0x%x\n",i,otp_lsc_data[i-0x042f]); //shenan
+       }
+       
+	 mdelay(10);
+
+	 //update LSC data from EEProm
+	  i = 0;
+	  temp = 0;
+	  temp=OV13850_read_cmos_sensor(0x5000);
+	  temp =temp | 0x01;
+	  OV13850_write_cmos_sensor(0x5000,temp);
+
+	  for(i=0;i<360;i++)
+	   {
+	   	OV13850_write_cmos_sensor(0x5200+i,otp_lsc_data[i]);
+		LOG_INF("OTP LSC info From Sensor 0x%x: 0x%x\n",0x5200+i,OV13850_read_cmos_sensor(0x5200+i)); //shenan
+	   }
+	
+	//read wb data from EEProm 
+	for(i=0x0413;i<=0x042e;i++)
+	{
+	  otp_wb_data[i-0x0413] = OV13850_EEProm_read(i);
+	  LOG_INF("OTP AWB info From Epprom 0x%x: 0x%x\n",i,otp_wb_data[i-0x0413]); //shenan
+	}
+	
+       mdelay(10);
+	
+	rg = (otp_wb_data[0]<<2) + ((otp_wb_data[1]>>6)&0x03);
+	bg = (otp_wb_data[2]<<2) + ((otp_wb_data[3]>>6)&0x03);
+	RG_Ratio_Typical = (otp_wb_data[6]<<2) + ((otp_wb_data[7]>>6)&0x03);
+	BG_Ratio_Typical = (otp_wb_data[8]<<2) + ((otp_wb_data[9]>>6)&0x03);
+
+	LOG_INF("otpdebug:rg = %x\n",rg);
+	LOG_INF("otpdebug:bg = %x\n",bg);
+	LOG_INF("otpdebug:RG_Ratio_Typical = %x\n",RG_Ratio_Typical);
+	LOG_INF("otpdebug:BG_Ratio_Typical = %x\n",BG_Ratio_Typical);
+	
+       //update wb data from EEProm
+        if((rg != 0) && (bg != 0) && (RG_Ratio_Typical != 0) && (BG_Ratio_Typical != 0))
+      {
+	OV13850_ApplyAWB(rg,bg,RG_Ratio_Typical,BG_Ratio_Typical);
+	}
+	
+	//EEProm checksum
+	sum = 0;
+	kal_uint16 TotalCheckSumValue =0;
+	USHORT * BufferCheckSum= (USHORT *)kmalloc(sizeof(USHORT)*420,GFP_KERNEL);
+
+	for(i=0x0401;i<=0x059e;i++)
+	{
+		BufferCheckSum[i-0x0401]=OV13850_EEProm_read(i);
+	}
+	
+	mdelay(10);
+   
+	for(i=0x0401;i<=0x059d;i++)
+	{
+	   sum+= BufferCheckSum[i-0x0401];
+	}
+	mdelay(10);
+	TotalCheckSumValue = (sum%0xff + 1);
+	mdelay(10);
+	if(BufferCheckSum[413]==TotalCheckSumValue)
+	{
+		LOG_INF("OV13850 EEProm read data success");
+	}
+	else
+	{
+	    LOG_INF("OV13850 EEProm read data failed");		
+	}
+	
+	
 }
 
 static void set_dummy()
@@ -303,11 +527,8 @@ static void set_shutter(kal_uint16 shutter)
     spin_unlock(&imgsensor_drv_lock);
     shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
     shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
-    // Framelength should be an even number
-    shutter = (shutter >> 1) << 1;
-    imgsensor.frame_length = (imgsensor.frame_length >> 1) << 1;
 
-	if (imgsensor.autoflicker_en) {
+    if (imgsensor.autoflicker_en) {
         realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
         if(realtime_fps >= 297 && realtime_fps <= 305)
             set_max_framerate(296,0);
@@ -635,7 +856,7 @@ static void sensor_init(void)
 		write_cmos_sensor(0x3609, 0x40);
 		write_cmos_sensor(0x360a, 0x30);
 		write_cmos_sensor(0x360b, 0x91);
-		write_cmos_sensor(0x360c, 0x49);
+		write_cmos_sensor(0x360c, 0x09);//shenan
 		write_cmos_sensor(0x360f, 0x02);
 		write_cmos_sensor(0x3611, 0x10);
 		write_cmos_sensor(0x3612, 0x27);
@@ -672,7 +893,7 @@ static void sensor_init(void)
 		write_cmos_sensor(0x3710, 0x28);
 		write_cmos_sensor(0x3716, 0x03);
 		write_cmos_sensor(0x3718, 0x10);
-		write_cmos_sensor(0x3719, 0x08);
+		write_cmos_sensor(0x3719, 0x0c);  //shenan
 		write_cmos_sensor(0x371a, 0x08);
 		write_cmos_sensor(0x371c, 0xfc);
 		write_cmos_sensor(0x3748, 0x00);
@@ -766,7 +987,7 @@ static void sensor_init(void)
 		write_cmos_sensor(0x4d05, 0x65);
 		write_cmos_sensor(0x4d0b, 0x00);
 		write_cmos_sensor(0x5000, 0x0e);//0e
-		write_cmos_sensor(0x5001, 0x01);
+		write_cmos_sensor(0x5001, 0x03); //shenan,01
 		write_cmos_sensor(0x5002, 0x07);
 		write_cmos_sensor(0x5013, 0x40);
 		write_cmos_sensor(0x501c, 0x00);
@@ -796,6 +1017,11 @@ static void sensor_init(void)
 		write_cmos_sensor(0x5b09, 0x02);
 		write_cmos_sensor(0x5e00, 0x00);
 		write_cmos_sensor(0x5e10, 0x1c);		
+		write_cmos_sensor(0x5368, 0x70); //max gain  //shenan
+		write_cmos_sensor(0x5369, 0x40); //min gain
+		write_cmos_sensor(0x536a, 0x40); //max Q
+		write_cmos_sensor(0x536b, 0x08); //min Q
+		write_cmos_sensor(0x536c, 0x32); //enable min Q bit 2
 		if (ov13850_chip_ver == OV13850_R1A)
 		{
 			write_cmos_sensor(0x351b, 0x00);
@@ -857,6 +1083,7 @@ static void sensor_init(void)
 static void preview_setting(void)
 {
     write_cmos_sensor(0x0100, 0x00);//
+    mdelay(50);
 		write_cmos_sensor(0x0300, 0x01);
 		write_cmos_sensor(0x0302, 0x28);
 		write_cmos_sensor(0x0303, 0x00);
@@ -910,7 +1137,7 @@ static void preview_setting(void)
 		write_cmos_sensor(0x5401, 0x61);
 		write_cmos_sensor(0x5405, 0x40);
 		write_cmos_sensor(0x0100, 0x01);//
-		mdelay(10);	
+		mdelay(15);
 }    /*    preview_setting  */
 
 int capture_first_flag = 0;
@@ -933,10 +1160,11 @@ if (capture_first_flag == 0)
 
     if (currefps == 240) { //24fps for PIP
         //@@full_132PCLK_24.75
+                write_cmos_sensor(0x0100, 0x00);//
       		write_cmos_sensor(0x0300, 0x00);//
-			write_cmos_sensor(0x0302, 0x28);//0x32
+			write_cmos_sensor(0x0302, 0x28);//
 			write_cmos_sensor(0x0303, 0x00);//
-			write_cmos_sensor(0x3612, 0x33);//0x07
+			write_cmos_sensor(0x3612, 0x33);//
 			write_cmos_sensor(0x3501, 0xc0);//   
 			write_cmos_sensor(0x3702, 0x40);// ;add for VGA differences
 			write_cmos_sensor(0x370a, 0x24);//
@@ -982,15 +1210,16 @@ if (capture_first_flag == 0)
 			write_cmos_sensor(0x4501, 0x38);//
 			write_cmos_sensor(0x4601, 0x04);//
 			write_cmos_sensor(0x4603, 0x00);//
-			write_cmos_sensor(0x4837, 0x11);//0x0d
+			write_cmos_sensor(0x4837, 0x11);//
 			write_cmos_sensor(0x5401, 0x71);//
 			write_cmos_sensor(0x5405, 0x80);//
 			write_cmos_sensor(0x0100, 0x01);//
 
     } else {   //30fps            //30fps for Normal capture & ZSD
  
-
-     		write_cmos_sensor(0x0300, 0x00);//
+      write_cmos_sensor(0x0100, 0x00);//
+      mdelay(50);
+      		write_cmos_sensor(0x0300, 0x00);//
 			write_cmos_sensor(0x0302, 0x32);//
 			write_cmos_sensor(0x0303, 0x00);//
 			write_cmos_sensor(0x3612, 0x07);//
@@ -1131,11 +1360,25 @@ static void hs_video_setting()
 		write_cmos_sensor(0x0302, 0x28);
 		write_cmos_sensor(0x0303, 0x00);
 		write_cmos_sensor(0x3612, 0x27);
+		write_cmos_sensor(0x3614, 0x28); //neil add 20150113
 		write_cmos_sensor(0x3501, 0x20);
 		write_cmos_sensor(0x3702, 0x5a);
 		write_cmos_sensor(0x370a, 0xa9);
-		write_cmos_sensor(0x372a, 0x00);
+		write_cmos_sensor(0x3718, 0x1c);//add new20140801
+                write_cmos_sensor(0x371b, 0x00); // neil add 20150113
+                write_cmos_sensor(0x3748, 0x00); // neil add 20150113
+                write_cmos_sensor(0x3730, 0x00); // neil add 20150113
+                write_cmos_sensor(0x3731, 0x00); // neil add 20150113
+                write_cmos_sensor(0x3732, 0x00); // neil add 20150113
+                write_cmos_sensor(0x3733, 0x00); // neil add 20150113
+		write_cmos_sensor(0x372a, 0x00); // neil add 20150113
+                write_cmos_sensor(0x3749, 0x00); // neil add 20150113
+                write_cmos_sensor(0x3738, 0x00); // neil add 20150113
+                write_cmos_sensor(0x3739, 0x00); // neil add 20150113
+                write_cmos_sensor(0x373a, 0x00); // neil add 20150113
+                write_cmos_sensor(0x373b, 0x00); // neil add 20150113
 		write_cmos_sensor(0x372f, 0x88);
+		write_cmos_sensor(0x3780, 0x10); //neil add 20150108
 		write_cmos_sensor(0x3801, 0x00);
 		write_cmos_sensor(0x3802, 0x01);
 		write_cmos_sensor(0x3803, 0x78);
@@ -1256,7 +1499,21 @@ static void slim_video_setting()
 		write_cmos_sensor(0x3614, 0x28);
 		write_cmos_sensor(0x370a, 0x27);
 		write_cmos_sensor(0x372a, 0x00);
-		write_cmos_sensor(0x372f, 0x90);
+		write_cmos_sensor(0x3718, 0x1c);//add new20140801
+                write_cmos_sensor(0x371b, 0x00); // neil add 20150113
+                write_cmos_sensor(0x3748, 0x00); // neil add 20150113
+                write_cmos_sensor(0x3730, 0x00); // neil add 20150113
+                write_cmos_sensor(0x3731, 0x00); // neil add 20150113
+                write_cmos_sensor(0x3732, 0x00); // neil add 20150113
+                write_cmos_sensor(0x3733, 0x00); // neil add 20150113
+		write_cmos_sensor(0x372a, 0x00); // neil add 20150113
+                write_cmos_sensor(0x3749, 0x00); // neil add 20150113
+                write_cmos_sensor(0x3738, 0x00); // neil add 20150113
+                write_cmos_sensor(0x3739, 0x00); // neil add 20150113
+                write_cmos_sensor(0x373a, 0x00); // neil add 20150113
+                write_cmos_sensor(0x373b, 0x00); // neil add 20150113
+		write_cmos_sensor(0x372f, 0xa0);//0x90
+		write_cmos_sensor(0x3780, 0x10); //neil add 20150108
 		write_cmos_sensor(0x3718, 0x10);
 		write_cmos_sensor(0x3767, 0x24);
 		write_cmos_sensor(0x3801, 0x38);
@@ -1352,8 +1609,7 @@ static kal_uint32 set_test_pattern_mode(kal_bool enable)
 static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
 {
     kal_uint8 i = 0;
-    kal_uint8 retry_total_cnt = 10; 
-    kal_uint8 retry = retry_total_cnt;
+    kal_uint8 retry = 2;
     //sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
     while (imgsensor_info.i2c_addr_table[i] != 0xff) {
         spin_lock(&imgsensor_drv_lock);
@@ -1369,7 +1625,7 @@ static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
             retry--;
         } while(retry > 0);
         i++;
-        retry = retry_total_cnt;
+        retry = 2;
     }
     if (*sensor_id != imgsensor_info.sensor_id) {
         // if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF
@@ -1437,8 +1693,16 @@ static kal_uint32 open(void)
     /* initail sequence write in  */
     sensor_init();
 	  //for OTP
-	  //otp_cali(imgsensor.i2c_write_id);
-
+	//if (!OV13850AC_OTP_combination_read())
+	//{
+		//ov13850r2a_update_eeprom();
+		//LOG_INF("otpdebug:moudle id = 0x01");
+	//}
+	//else
+	{
+		OV13850_checkOTP();
+		LOG_INF("otpdebug:moudle id = 0x01");
+	}
 	  write_cmos_sensor(0x0100, 0x00);
 	  
     spin_lock(&imgsensor_drv_lock);
@@ -1848,7 +2112,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
             imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
             imgsensor.min_frame_length = imgsensor.frame_length;
             spin_unlock(&imgsensor_drv_lock);
-            //set_dummy();
+            set_dummy();
             break;
         case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
             if(framerate == 0)
@@ -1859,7 +2123,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
             imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
             imgsensor.min_frame_length = imgsensor.frame_length;
             spin_unlock(&imgsensor_drv_lock);
-            //set_dummy();
+            set_dummy();
             break;
         case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
         	  if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {
@@ -1879,7 +2143,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 		            imgsensor.min_frame_length = imgsensor.frame_length;
 		            spin_unlock(&imgsensor_drv_lock);
             }
-            //set_dummy();
+            set_dummy();
             break;
         case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
             frame_length = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
@@ -1888,7 +2152,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
             imgsensor.frame_length = imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
             imgsensor.min_frame_length = imgsensor.frame_length;
             spin_unlock(&imgsensor_drv_lock);
-            //set_dummy();
+            set_dummy();
             break;
         case MSDK_SCENARIO_ID_SLIM_VIDEO:
             frame_length = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
@@ -1897,7 +2161,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
             imgsensor.frame_length = imgsensor_info.slim_video.framelength + imgsensor.dummy_line;
             imgsensor.min_frame_length = imgsensor.frame_length;
             spin_unlock(&imgsensor_drv_lock);
-            //set_dummy();
+            set_dummy();
             break;
         default:  //coding with  preview scenario by default
             frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
@@ -1906,7 +2170,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
             imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
             imgsensor.min_frame_length = imgsensor.frame_length;
             spin_unlock(&imgsensor_drv_lock);
-            //set_dummy();
+            set_dummy();
             LOG_ERR("error scenario_id = %d, we use preview scenario \n", scenario_id);
             break;
     }
@@ -2005,7 +2269,7 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
             set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
             break;
         case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
-            get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*(feature_data), (MUINT32 *)(uintptr_t)(*(feature_data+1)));
+            get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, (MUINT32 *)(uintptr_t)(*(feature_data+1)));
             break;
         case SENSOR_FEATURE_SET_TEST_PATTERN:
             set_test_pattern_mode((BOOL)*feature_data);
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6752/ov13850_mipi_raw/ov13850mipiraw_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6752/ov13850_mipi_raw/ov13850mipiraw_Sensor.h
index 6f184cc..5c70215 100644
--- a/drivers/misc/mediatek/imgsensor/src/mt6752/ov13850_mipi_raw/ov13850mipiraw_Sensor.h
+++ b/drivers/misc/mediatek/imgsensor/src/mt6752/ov13850_mipi_raw/ov13850mipiraw_Sensor.h
@@ -1,3 +1,18 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *     OV13850mipiraw_Sensor.h
+ *
+ * Project:
+ * --------
+ *     ALPS
+ *
+ * Description:
+ * ------------
+ *     CMOS sensor header file
+ *
+ ****************************************************************************/
 #ifndef _OV13850MIPIRAW_SENSOR_H
 #define _OV13850MIPIRAW_SENSOR_H
 
@@ -12,86 +27,88 @@ typedef enum{
 } IMGSENSOR_MODE;
 
 typedef struct imgsensor_mode_struct {
-    kal_uint32 pclk;                
-    kal_uint32 linelength;            
-    kal_uint32 framelength;            
+    kal_uint32 pclk;                //record different mode's pclk
+    kal_uint32 linelength;            //record different mode's linelength
+    kal_uint32 framelength;            //record different mode's framelength
 
-    kal_uint8 startx;                
-    kal_uint8 starty;                
+    kal_uint8 startx;                //record different mode's startx of grabwindow
+    kal_uint8 starty;                //record different mode's startx of grabwindow
 
-    kal_uint16 grabwindow_width;    
-    kal_uint16 grabwindow_height;    
+    kal_uint16 grabwindow_width;    //record different mode's width of grabwindow
+    kal_uint16 grabwindow_height;    //record different mode's height of grabwindow
 
-    
+    /*     following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario    */
     kal_uint8 mipi_data_lp2hs_settle_dc;
 
-    
+    /*     following for GetDefaultFramerateByScenario()    */
     kal_uint16 max_framerate;
 
 } imgsensor_mode_struct;
 
+/* SENSOR PRIVATE STRUCT FOR VARIABLES*/
 typedef struct imgsensor_struct {
-    kal_uint8 mirror;                
+    kal_uint8 mirror;                //mirrorflip information
 
-    kal_uint8 sensor_mode;            
+    kal_uint8 sensor_mode;            //record IMGSENSOR_MODE enum value
 
-    kal_uint32 shutter;                
-    kal_uint16 gain;                
+    kal_uint32 shutter;                //current shutter
+    kal_uint16 gain;                //current gain
 
-    kal_uint32 pclk;                
+    kal_uint32 pclk;                //current pclk
 
-    kal_uint32 frame_length;        
-    kal_uint32 line_length;            
+    kal_uint32 frame_length;        //current framelength
+    kal_uint32 line_length;            //current linelength
 
-    kal_uint32 min_frame_length;    
-    kal_uint16 dummy_pixel;            
-    kal_uint16 dummy_line;            
+    kal_uint32 min_frame_length;    //current min  framelength to max framerate
+    kal_uint16 dummy_pixel;            //current dummypixel
+    kal_uint16 dummy_line;            //current dummline
 
-    kal_uint16 current_fps;            
-    kal_bool   autoflicker_en;        
-    kal_bool test_pattern;            
-    MSDK_SCENARIO_ID_ENUM current_scenario_id;
-    kal_uint8  ihdr_en;                
+    kal_uint16 current_fps;            //current max fps
+    kal_bool   autoflicker_en;        //record autoflicker enable or disable
+    kal_bool test_pattern;            //record test pattern mode or not
+    MSDK_SCENARIO_ID_ENUM current_scenario_id;//current scenario id
+    kal_uint8  ihdr_en;                //ihdr enable or disable
 
-    kal_uint8 i2c_write_id;            
+    kal_uint8 i2c_write_id;            //record current sensor's i2c write id
 } imgsensor_struct;
 
+/* SENSOR PRIVATE STRUCT FOR CONSTANT*/
 typedef struct imgsensor_info_struct {
-    kal_uint32 sensor_id;            
-    kal_uint32 checksum_value;        
-    imgsensor_mode_struct pre;        
-    imgsensor_mode_struct cap;        
-    imgsensor_mode_struct cap1;        
-    imgsensor_mode_struct normal_video;
-    imgsensor_mode_struct hs_video;    
-    imgsensor_mode_struct slim_video;    
-
-    kal_uint8  ae_shut_delay_frame;    
-    kal_uint8  ae_sensor_gain_delay_frame;    
-    kal_uint8  ae_ispGain_delay_frame;    
-    kal_uint8  ihdr_support;        
-    kal_uint8  ihdr_le_firstline;    
-    kal_uint8  sensor_mode_num;        
-
-    kal_uint8  cap_delay_frame;        
-    kal_uint8  pre_delay_frame;        
-    kal_uint8  video_delay_frame;    
-    kal_uint8  hs_video_delay_frame;    
-    kal_uint8  slim_video_delay_frame;    
-
-    kal_uint8  margin;                
-    kal_uint32 min_shutter;            
-    kal_uint32 max_frame_length;    
-
-    kal_uint8  isp_driving_current;    
-    kal_uint8  sensor_interface_type;
-    kal_uint8  mipi_sensor_type; 
-    kal_uint8  mipi_settle_delay_mode; 
-    kal_uint8  sensor_output_dataformat;
-    kal_uint8  mclk;                
-
-    kal_uint8  mipi_lane_num;        
-    kal_uint8  i2c_addr_table[5];    
+    kal_uint32 sensor_id;            //record sensor id defined in Kd_imgsensor.h
+    kal_uint32 checksum_value;        //checksum value for Camera Auto Test
+    imgsensor_mode_struct pre;        //preview scenario relative information
+    imgsensor_mode_struct cap;        //capture scenario relative information
+    imgsensor_mode_struct cap1;        //capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
+    imgsensor_mode_struct normal_video;//normal video  scenario relative information
+    imgsensor_mode_struct hs_video;    //high speed video scenario relative information
+    imgsensor_mode_struct slim_video;    //slim video for VT scenario relative information
+
+    kal_uint8  ae_shut_delay_frame;    //shutter delay frame for AE cycle
+    kal_uint8  ae_sensor_gain_delay_frame;    //sensor gain delay frame for AE cycle
+    kal_uint8  ae_ispGain_delay_frame;    //isp gain delay frame for AE cycle
+    kal_uint8  ihdr_support;        //1, support; 0,not support
+    kal_uint8  ihdr_le_firstline;    //1,le first ; 0, se first
+    kal_uint8  sensor_mode_num;        //support sensor mode num
+
+    kal_uint8  cap_delay_frame;        //enter capture delay frame num
+    kal_uint8  pre_delay_frame;        //enter preview delay frame num
+    kal_uint8  video_delay_frame;    //enter video delay frame num
+    kal_uint8  hs_video_delay_frame;    //enter high speed video  delay frame num
+    kal_uint8  slim_video_delay_frame;    //enter slim video delay frame num
+
+    kal_uint8  margin;                //sensor framelength & shutter margin
+    kal_uint32 min_shutter;            //min shutter
+    kal_uint32 max_frame_length;    //max framelength by sensor register's limitation
+
+    kal_uint8  isp_driving_current;    //mclk driving current
+    kal_uint8  sensor_interface_type;//sensor_interface_type
+    kal_uint8  mipi_sensor_type; //0,MIPI_OPHY_NCSI2; 1,MIPI_OPHY_CSI2, default is NCSI2, don't modify this para
+    kal_uint8  mipi_settle_delay_mode; //0, high speed signal auto detect; 1, use settle delay,unit is ns, default is auto detect, don't modify this para
+    kal_uint8  sensor_output_dataformat;//sensor output first pixel color
+    kal_uint8  mclk;                //mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+
+    kal_uint8  mipi_lane_num;        //mipi lane num
+    kal_uint8  i2c_addr_table[5];    //record sensor support all write id addr, only supprt 4must end with 0xff
 } imgsensor_info_struct;
 
 typedef enum{
@@ -104,4 +121,3 @@ extern int iReadRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u8 * a_pRecvData, u
 extern int iWriteRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u16 i2cId);
 
 #endif
-
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6752/ov5670_mipi_raw/ov5670mipi_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6752/ov5670_mipi_raw/ov5670mipi_Sensor.c
index 2225b5a..6591e37 100644
--- a/drivers/misc/mediatek/imgsensor/src/mt6752/ov5670_mipi_raw/ov5670mipi_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6752/ov5670_mipi_raw/ov5670mipi_Sensor.c
@@ -40,15 +40,10 @@
 #include <linux/compat.h>
 #endif
 #define PFX "ov5670_camera_sensor"
-//#define LOG_WRN(format, args...) xlog_printk(ANDROID_LOG_WARN ,PFX, "[%S] " format, __FUNCTION__, ##args)
-//#defineLOG_INF(format, args...) xlog_printk(ANDROID_LOG_INFO ,PFX, "[%s] " format, __FUNCTION__, ##args)
-//#define LOG_DBG(format, args...) xlog_printk(ANDROID_LOG_DEBUG ,PFX, "[%S] " format, __FUNCTION__, ##args)
-#define LOG_INF(format, args...)	xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
-#define LOG_ERR(format, args...)	xlog_printk(ANDROID_LOG_ERROR   , PFX, "[%s] " format, __FUNCTION__, ##args)
+#define LOG_INF(format, args...)	pr_debug(PFX "[%s] " format, __FUNCTION__, ##args)
 
 static DEFINE_SPINLOCK(imgsensor_drv_lock);
 
-#define OV5670_OTP
 
 static imgsensor_info_struct imgsensor_info = { 
 	.sensor_id = OV5670MIPI_SENSOR_ID,		//record sensor id defined in Kd_imgsensor.h
@@ -129,15 +124,15 @@ static imgsensor_info_struct imgsensor_info = {
 	.ae_shut_delay_frame = 0,	//shutter delay frame for AE cycle, 2 frame with ispGain_delay-shut_delay=2-0=2
 	.ae_sensor_gain_delay_frame = 0,//sensor gain delay frame for AE cycle,2 frame with ispGain_delay-sensor_gain_delay=2-0=2
 	.ae_ispGain_delay_frame = 2,//isp gain delay frame for AE cycle
-	.ihdr_support = 0,	  //1, support; 0,not support
+	.ihdr_support = 1,	  //1, support; 0,not support
 	.ihdr_le_firstline = 0,  //1,le first ; 0, se first
 	.sensor_mode_num = 5,	  //support sensor mode num
 	
-	.cap_delay_frame = 3,		//enter capture delay frame num
-	.pre_delay_frame = 3, 		//enter preview delay frame num
-	.video_delay_frame = 3,		//enter video delay frame num
-	.hs_video_delay_frame = 3,	//enter high speed video  delay frame num
-	.slim_video_delay_frame = 3,//enter slim video delay frame num
+	.cap_delay_frame = 2,		//enter capture delay frame num
+	.pre_delay_frame = 2, 		//enter preview delay frame num
+	.video_delay_frame = 2,		//enter video delay frame num
+	.hs_video_delay_frame = 2,	//enter high speed video  delay frame num
+	.slim_video_delay_frame = 2,//enter slim video delay frame num
 	
 	.isp_driving_current = ISP_DRIVING_8MA, //mclk driving current
     .sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
@@ -146,9 +141,7 @@ static imgsensor_info_struct imgsensor_info = {
 	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_Gb,//sensor output first pixel color
 	.mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
 	.mipi_lane_num = SENSOR_MIPI_2_LANE,//mipi lane num
-//lenovo.sw wangsx3 START config sub camera for AIO
-	.i2c_addr_table = {0x20, 0xff, 0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
-//lenovo.sw wangsx3 END config sub camera for AIO
+	.i2c_addr_table = {0x6c, 0x20, 0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
 };
 
 
@@ -164,9 +157,7 @@ static imgsensor_struct imgsensor = {
 	.test_pattern = KAL_FALSE,		//test pattern mode or not. KAL_FALSE for in test pattern mode, KAL_TRUE for normal output
 	.current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
 	.ihdr_en = 0, //sensor need support LE, SE with HDR feature
-//lenovo.sw wangsx3 START config sub camera for AIO
-	.i2c_write_id = 0x20,//record current sensor's i2c write id
-//lenovo.sw wangsx3 END config sub camera for AIO
+	.i2c_write_id = 0x6c,//record current sensor's i2c write id
 };
 
 
@@ -194,365 +185,403 @@ static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
 	char pu_send_cmd[3] = {(char)(addr >> 8), (char)(addr & 0xFF), (char)(para & 0xFF)};
 	iWriteRegI2C(pu_send_cmd, 3, imgsensor.i2c_write_id);
 }
-#ifdef OV5670_OTP
-
-struct otp_struct {
-	int module_integrator_id;
-	int lens_id;
-	int production_year;
-	int production_month;
-	int production_day;
-	int rg_ratio;
-	int bg_ratio;
-	int r_golden;
-	int b_golden;
-	int gr_golden;
-	int gb_golden;
-};
-static void OV5670_OTP_read_begin(void)
+#if 0
+void OV5670ofilm_read_all()//(kal_uint16 start_addr,kal_uint16 end_addr,kal_uint16 *out_buf)
 {
-	// set reg 0x5002[3] to '0'
-	int temp1;
+      //kal_uint16 i=0;
+       //set 0x5002[3] to "0";
+       kal_uint16 temp1=0;
+       
+       temp1 =0;
+       temp1 = read_cmos_sensor(0x5002);
+       write_cmos_sensor(0x5002,(0x00&0x08)|(temp1&(~0x08)));
+
+
+		//test 
+		temp1 =0;
+		temp1 = read_cmos_sensor(0x302a);
+		LOG_INF("0x302a = %x",temp1);
+			
+	//clear otp buffer
+		//for(i=start_addr;i<=end_addr;i++)
+		{
+			//write_cmos_sensor(i,0x00);
+			write_cmos_sensor(0x7010,0x00);
+
+		}
+		
+
+    write_cmos_sensor(0x3d84,0xc0);
+    //partial mode otp write start address
+    //OV5670_write_cmos_sensor(0x3d88,(start_addr>>8)&0xff);
+    //OV5670_write_cmos_sensor(0x3d89,start_addr&0xff);
+    write_cmos_sensor(0x3d88,0x70);
+    write_cmos_sensor(0x3d89,0x10);
+    //partial mode otp write end address
+    write_cmos_sensor(0x3d8a,0x70);
+    write_cmos_sensor(0x3d8b,0x10);
+
+    //read otp into buffer
+    write_cmos_sensor(0x3d81,0x01);
+    
+    mdelay(10);
+
+    //read buf
+		//for(i=start_addr;i<=end_addr;i++)
+		//{
+		//  out_buf[i-start_addr] = OV5670_read_cmos_sensor(i);
+	  //}
+	  
+    temp1 = read_cmos_sensor(0x7010);
+    LOG_INF("0x7010 = %x",temp1);
+	        
+    mdelay(10);
+    
+    //clear buf
+    //for(i=start_addr;i<=end_addr;i++)
+    {
+		   //write_cmos_sensor(i,0x00);
+		write_cmos_sensor(0x7010,0x00);
+
+    }
+
+    //triggle write OTP
+	
 	temp1 = read_cmos_sensor(0x5002);
-	write_cmos_sensor(0x5002, (temp1 &(~0x08)));
+	write_cmos_sensor(0x5002,(0x02&0x08)|(temp1&(~0x08)));
+ 
 }
-
-static void OV5670_OTP_read_end(void)
+#endif
+#if 1
+void OV5670ofilm_read_all(kal_uint16 start_addr,kal_uint16 end_addr,kal_uint16 *out_buf)
 {
-	// set reg 0x5002[3] to '1'
-	int temp1;
+      kal_uint16 i;
+       //set 0x5002[3] to "0";
+       kal_uint16 temp1;
+       temp1 = read_cmos_sensor(0x5002);
+       write_cmos_sensor(0x5002,(0x00&0x08)|(temp1&(~0x08)));
+
+	//clear otp buffer
+		for(i=start_addr;i<=end_addr;i++)
+		{
+			write_cmos_sensor(i,0x00);
+		}		
+
+    write_cmos_sensor(0x3d84,0xc0);
+    //partial mode otp write start address
+    write_cmos_sensor(0x3d88,(start_addr>>8)&0xff);
+    write_cmos_sensor(0x3d89,start_addr&0xff);
+    //partial mode otp write end address
+    write_cmos_sensor(0x3d8a,(end_addr>>8)&0xff);
+    write_cmos_sensor(0x3d8b,end_addr & 0xff);
+
+    //read otp into buffer
+    write_cmos_sensor(0x3d81,0x01);
+    
+    mdelay(10);
+
+    //read buf
+    for(i=start_addr;i<=end_addr;i++)
+    {
+        out_buf[i-start_addr] = read_cmos_sensor(i);
+    }
+	        
+    mdelay(10);
+    
+    //clear buf
+    for(i=start_addr;i<=end_addr;i++)
+    {
+       write_cmos_sensor(i,0x00);
+     }
+
+    //triggle write OTP
+	
 	temp1 = read_cmos_sensor(0x5002);
-	write_cmos_sensor(0x5002, (0x08 | temp1));
+	write_cmos_sensor(0x5002,(0x02&0x08)|(temp1&(~0x08)));
+ 
+}
+
+void OV5670ofilm_read_single(kal_uint16 start_addr,kal_uint16 out_buf)
+{
+
+    kal_uint16 i;
+    //set 0x5002[3] to "0";
+    kal_uint16 temp1;
+    temp1 = read_cmos_sensor(0x5002);
+	   
+    write_cmos_sensor(0x5002,(0x00&0x08)|(temp1&(~0x08)));
+    
+    //clear otp buffer
+    
+    write_cmos_sensor(start_addr,0x00);
+		
+    write_cmos_sensor(0x3d84,0xc0);
+    //partial mode otp write start address
+    write_cmos_sensor(0x3d88,(start_addr>>8)&0xff);
+    write_cmos_sensor(0x3d89,start_addr & 0xff);
+    //partial mode otp write end address
+    write_cmos_sensor(0x3d8a,(start_addr>>8)&0xff);
+    write_cmos_sensor(0x3d8b,start_addr & 0xff);
+
+    //read otp into buffer
+    write_cmos_sensor(0x3d81,0x01);
+    
+    mdelay(10);
+
+    out_buf=read_cmos_sensor(start_addr);
+    LOG_INF("out_buf = %x\n",out_buf);    
+  
+     mdelay(10);
+	
+     write_cmos_sensor(start_addr, 0x00);
+	
+     temp1 = read_cmos_sensor(0x5002);
+     write_cmos_sensor(0x5002,(0x02&0x08)|(temp1&(~0x08)));
+     //return out_buf;	
+ 
 }
 
 
-// index: index of otp group. (1, 2, 3)
-// return: 0, group index is empty
-// 1, group index has invalid data
-// 2, group index has valid data
-static int check_otp_info(int index)
+void OV5670ofilm_update_wb_gain(kal_uint32 R_gain, kal_uint32 G_gain, kal_uint32 B_gain)
+{   
+	if(R_gain > 0x400)
+		{
+			write_cmos_sensor(0x5032,R_gain >> 8);
+			write_cmos_sensor(0x5033,(R_gain&0x00ff));
+		}
+	if(G_gain > 0x400)
+		{
+			write_cmos_sensor(0x5034,G_gain >> 8);
+			write_cmos_sensor(0x5035,(G_gain&0x00ff));
+		}
+	if(B_gain >0x400)
+		{
+			write_cmos_sensor(0x5036,B_gain >> 8);
+			write_cmos_sensor(0x5037,(B_gain&0x00ff));
+		}
+	LOG_INF("[OV5670OFILM_MIPI_update_wb_gain]R_gain[%x]G_gain[%x]B_gain[%x]\n",R_gain,G_gain,B_gain);
+
+	LOG_INF("[OV5670OFILM_MIPI_update_wb_gain_Finished");
+}
+
+void OV5670ofilm_ApplyWB(kal_uint16 rg,kal_uint16 bg,kal_uint16 RG_Ratio_Typical,kal_uint16 BG_Ratio_Typical)
+
 {
-	int flag=0, i=0;
-	int address_start = 0x7010;
-	int address_end = 0x7010;
-	write_cmos_sensor(0x0103,0x01);// ; software reset
-	mDELAY(10);
-	write_cmos_sensor(0x0100, 0x01); //;01	
-	mDELAY(5);
-	OV5670_OTP_read_begin();
-	// read otp into buffer
-	write_cmos_sensor(0x3d84, 0xc0); // program disable, manual mode
-	//partial mode OTP write start address
-	write_cmos_sensor(0x3d88, (address_start>>8));
-	write_cmos_sensor(0x3d89, (address_start & 0xff));
-	// partial mode OTP write end address
-	write_cmos_sensor(0x3d8A, (address_end>>8));
-
-	write_cmos_sensor(0x3d8B, (address_end & 0xff));
-	write_cmos_sensor(0x3d81, 0x01); // read otp
-	mdelay(5);
-	flag = read_cmos_sensor(0x7010);
-	LOG_INF("basic otp  index=%d,flag 0x7010= 0x%x\n",index,flag);
-	//select group
-	if(index==1)
-	{
-		flag = (flag>>6) & 0x03;
-	}
-	else if(index==2)
+   kal_uint16  R_Gain, G_Gain, B_Gain;
+
+   kal_uint16 nBase_gain;
+
+	R_Gain = (1000 * RG_Ratio_Typical)/rg;
+	B_Gain = (1000 * BG_Ratio_Typical)/bg;
+	G_Gain = 1000;
+
+	if (R_Gain<1000 || B_Gain<1000)
 	{
-		flag = (flag>>4) & 0x03;
+		if (R_Gain < B_Gain)
+		{
+			nBase_gain = R_Gain;
+		}
+		else
+		{
+			nBase_gain = B_Gain;
+		}
 	}
 	else
 	{
-		flag = (flag>>2) & 0x03;
-	}
-	// clear otp buffer
-	for (i=address_start;i<=address_end;i++) {
-		write_cmos_sensor(i, 0x00);
-	}
-	OV5670_OTP_read_end();
-	if (flag == 0x00) {
-		return 0;
-	}
-	else if (flag & 0x02) {
-		return 1;
-	}
-	else {
-		return 2;
+		nBase_gain = G_Gain;
 	}
+	
+	R_Gain = 0x400*R_Gain/(nBase_gain);
+	B_Gain = 0x400*B_Gain/(nBase_gain);
+	G_Gain = 0x400*G_Gain/(nBase_gain);
+	
+	OV5670ofilm_update_wb_gain(R_Gain, G_Gain, B_Gain);
 }
-// index: index of otp group. (1, 2, 3)
-// return: 0, group index is empty
-// 1, group index has invalid data
-// 2, group index has valid data
 
-static int check_otp_wb(int index)
+void OV5670Ofilm_otpcheck()
 {
-	int flag=0, i;
-	int address_start = 0x7041;
-	int address_end = 0x7041;
-	OV5670_OTP_read_begin();
-	// read otp into buffer
-	write_cmos_sensor(0x3d84, 0xc0); // program disable, manual mode
-	//partial mode OTP write start address
-	write_cmos_sensor(0x3d88, (address_start>>8));
-	write_cmos_sensor(0x3d89, (address_start & 0xff));
-	// partial mode OTP write end address
-	write_cmos_sensor(0x3d8A, (address_end>>8));
-	write_cmos_sensor(0x3d8B, (address_end & 0xff));
-	write_cmos_sensor(0x3d81, 0x01); // read OTP
-	mdelay(5);
-
-	//select group
-	flag = read_cmos_sensor(0x7041);
-	LOG_INF("AWB otp flag = 0x%x \n",flag);
-
-	if(index==1)
+
+	kal_uint16 valueGroup;
+	kal_uint16 i,sum,temp;
+	kal_uint16 flagvalue;
+	kal_uint16 WBflagvalue;
+	USHORT tempbuf[16] = {0};
+	USHORT tempWB[32] = {0};
+
+	//OV5670ofilm_read_single(0x7010,flagvalue);
+	OV5670ofilm_read_all(0x7010,0x7010,tempbuf);
+	LOG_INF("tempbuf[0] = %x",tempbuf[0]);
+	
+	if((tempbuf[0]&0xC0)==0x40)
 	{
-		flag = (flag>>6) & 0x03;
+		valueGroup=1;
 	}
-	else if(index==2)
+	else if((tempbuf[0]&0x30)==0x10)
 	{
-		flag = (flag>>4) & 0x03;
+		valueGroup=2;
 	}
-	else
+	else if((tempbuf[0]&0x0C)==0x04)
 	{
-		flag = (flag>>2) & 0x03;
-	}
-	// clear otp buffer
-	for (i=address_start;i<=address_end;i++) {
-		write_cmos_sensor(i, 0x00);
+		valueGroup=3;
 	}
-	OV5670_OTP_read_end();
-	if (flag == 0x00) {
-		return 0;
-	}
-	else if (flag & 0x02) {
-		return 1;
-	}
-	else {
-		return 2;
+	else
+	{
+	LOG_INF("OV5670 otp info is error or invalid ");
+	return ;
 	}
-}
 
-// index: index of otp group. (1, 2, 3)
-// otp_ptr: pointer of otp_struct
-// return: 0,
-static int read_otp_info(int index, struct otp_struct *otp_ptr)
-{
-	int i;
-	int address_start;
-	int address_end;
-	OV5670_OTP_read_begin();
-	// read otp into buffer
-	write_cmos_sensor(0x3d84, 0xc0); // program disable, manual mode
-	//select group
-	if(index==1)
+	LOG_INF("OV5670 otp basic info valueGroup = %d",valueGroup);
+
+	OV5670ofilm_read_all(0x7011+16*(valueGroup-1),0x7020+16*(valueGroup-1),tempbuf);
+
+	USHORT module_integrator_id = tempbuf[0];
+	USHORT otp_guide_version = tempbuf[1];
+	USHORT production_year = tempbuf[2];
+	USHORT production_month = tempbuf[3];
+	USHORT production_day = tempbuf[4];
+	USHORT sensor_id = tempbuf[5];
+	USHORT lens_id = tempbuf[6];
+	USHORT vcm_id = tempbuf[7];
+	USHORT driver_ic_id = tempbuf[8];
+	USHORT IR_BG_id = tempbuf[9];
+	USHORT color_temperature_id = tempbuf[10];
+	USHORT AF_FF_flag = tempbuf[11];
+	USHORT light_source_flag = tempbuf[12];
+	USHORT sensor_version = tempbuf[13];
+
+	if(module_integrator_id ==0x07)
 	{
-		address_start = 0x7011;
-		address_end = 0x7020;
+	 LOG_INF("The module is  from ofilm\n");
 	}
-	else if(index==2)
+	else
 	{
-		address_start = 0x7021;
-		address_end = 0x7030;
+	LOG_INF("The module is not from ofilm\n");
+	return ;
 	}
-	else
+
+       if(otp_guide_version == 0x01)
+   	{
+   	LOG_INF("The OTP guide version is 1.0\n");
+   	}
+       	
+	if(sensor_version == 0x01)
 	{
-		address_start = 0x7031;
-		address_end = 0x7040;
+	LOG_INF("The sensor version is 1.0\n");
 	}
-	//partial mode OTP write start address
-	write_cmos_sensor(0x3d88, (address_start>>8));
-	write_cmos_sensor(0x3d89, (address_start & 0xff));
-	// partial mode OTP write end address
-	write_cmos_sensor(0x3d8A, (address_end>>8));
-	write_cmos_sensor(0x3d8B, (address_end & 0xff));
-	write_cmos_sensor(0x3d81, 0x01); // load otp into buffer
-
-	mdelay(5);
-	(*otp_ptr).module_integrator_id = read_cmos_sensor(address_start);
-	(*otp_ptr).lens_id = read_cmos_sensor(address_start + 1);
-	(*otp_ptr).production_year = read_cmos_sensor(address_start + 2);
-	(*otp_ptr).production_month = read_cmos_sensor(address_start + 3);
-	(*otp_ptr).production_day = read_cmos_sensor(address_start + 4);
-	// clear otp buffer
-	for (i=address_start;i<=address_end;i++) {
-		write_cmos_sensor(i, 0x00);
+	
+	sum = 0;
+	for (i = 0; i<15; i++)
+	{
+		sum = sum + tempbuf[i];
 	}
-	OV5670_OTP_read_end();
-	return 0;
-}
 
-// index: index of otp group. (1, 2, 3)
-// otp_ptr: pointer of otp_struct
-// return: 0,
-static int read_otp_wb(int index, struct otp_struct *otp_ptr)
-{
-	int i, temp;
-	int address_start;
-	int address_end;
-	//select group
-	if(index==1){
-		address_start = 0x7042;
-		address_end = 0x705e;
+	temp = sum % 0xff +1;
+	if (tempbuf[15] != temp)
+	{
+        LOG_INF("OV5670 otp info checksum error");
+	return ;
+	} 
+	
+	//OV5670ofilm_read_singlel(0x7041,WBflagvalue);
+	//LOG_INF("temp2 value = %x",WBflagvalue);	
+
+	OV5670ofilm_read_all(0x7041,0x7041,tempWB);
+	LOG_INF("tempWB[0] = %x",tempWB[0]);
+	
+	if((tempWB[0]&0xC0)==0x40)
+	{
+		valueGroup=1;
 	}
-	else if(index==2){
-		address_start = 0x705f;
-		address_end = 0x707b;
+	else if((tempWB[0]&0x30)==0x10)
+	{
+		valueGroup=2;
 	}
-	else if(index==3){
-		address_start = 0x707c;
-		address_end = 0x7098;
+	else if((tempWB[0]&0x0C)==0x04)
+	{
+		valueGroup=3;
 	}
-	OV5670_OTP_read_begin();
-	// read otp into buffer
-	write_cmos_sensor(0x3d84, 0xc0); // program disable, manual mode
-	//partial mode OTP write start address
-	write_cmos_sensor(0x3d88, (address_start>>8));
-	write_cmos_sensor(0x3d89, (address_start & 0xff));
-	// partial mode OTP write end address
-	write_cmos_sensor(0x3d8A, (address_end>>8));
-	write_cmos_sensor(0x3d8B, (address_end & 0xff));
-	write_cmos_sensor(0x3d81, 0x01); // load otp into buffer
-	mdelay(5);
-	temp = read_cmos_sensor(address_start+1);
-	otp_ptr->rg_ratio = (read_cmos_sensor(address_start)<<2) + ((temp>>6) & 0x03);
-	temp = read_cmos_sensor(address_start+3);
-	otp_ptr->bg_ratio = (read_cmos_sensor(address_start + 2)<<2) + ((temp>>6) & 0x03);
-	temp = read_cmos_sensor(address_start+21);
-	otp_ptr->r_golden = (read_cmos_sensor(address_start + 20)<<2) + ((temp>>6) & 0x03);
-	temp = read_cmos_sensor(address_start+23);
-	otp_ptr->b_golden = (read_cmos_sensor(address_start + 22)<<2) + ((temp>>6) & 0x03);
-	temp = read_cmos_sensor(address_start+25);
-	otp_ptr->gr_golden = (read_cmos_sensor(address_start + 24)<<2) + ((temp>>6) & 0x03);
-	temp = read_cmos_sensor(address_start+27);
-	otp_ptr->gb_golden = (read_cmos_sensor(address_start + 26)<<2) + ((temp>>6) & 0x03);
-	// clear otp buffer
-
-	for (i=address_start;i<=address_end;i++) {
-		write_cmos_sensor(i, 0x00);
+	else
+	{
+	LOG_INF("OV5670 otp wb info is error or invalid");
+	return ;
 	}
-	OV5670_OTP_read_end();
-
-	LOG_INF("AWB otp: r_golden = %d \n",otp_ptr->r_golden);
-	LOG_INF("AWB otp: b_golden = %d \n",otp_ptr->b_golden);
-	LOG_INF("AWB otp: gr_golden = %d \n",otp_ptr->gr_golden);
-	LOG_INF("AWB otp: gb_golden = %d \n",otp_ptr->gb_golden);
 
+       LOG_INF("OV5670 otp wb info valueGroup = %d",valueGroup);
 	
-	return 0;
-}
-// R_gain, sensor red gain of AWB, 0x400 =1
-// G_gain, sensor green gain of AWB, 0x400 =1
-// B_gain, sensor blue gain of AWB, 0x400 =1
-// return 0;
-static int update_awb_gain(int R_gain, int G_gain, int B_gain)
-{
-	if (R_gain>=0x400) {
-		write_cmos_sensor(0x5032, R_gain>>8);
-		write_cmos_sensor(0x5033, R_gain & 0x00ff);
+	OV5670ofilm_read_all(0x7042 + 29*(valueGroup-1),0x705e + 29*(valueGroup-1),tempWB);
+
+       kal_uint16 rg = (tempWB[0]<<2) + (tempWB[1]>>6);
+	kal_uint16 bg = (tempWB[2]<<2) + (tempWB[3]>>6);
+       kal_uint16 RG_Ratio_Typical = (tempWB[6]<<2) + (tempWB[7]>>6);
+	kal_uint16 BG_Ratio_Typical = (tempWB[8]<<2) + (tempWB[9]>>6);
+
+	LOG_INF("rg = %x\n",rg);
+	LOG_INF("bg = %x\n",bg);
+	LOG_INF("RG_Ratio_Typical = %x\n",RG_Ratio_Typical);
+	LOG_INF("BG_Ratio_Typical = %x\n",BG_Ratio_Typical);
+
+	 if((rg != 0) && (bg != 0) && (RG_Ratio_Typical != 0) && (BG_Ratio_Typical != 0)) 
+	{
+		OV5670ofilm_ApplyWB(rg,bg,RG_Ratio_Typical,BG_Ratio_Typical);
 	}
-	if (G_gain>=0x400) {
-		write_cmos_sensor(0x5034, G_gain>>8);
-		write_cmos_sensor(0x5035, G_gain & 0x00ff);
+	
+       LOG_INF("[OV5670ofilm_mipi_update_wb_register_from_otp_Finished\n]");
+	
+	
+	sum = 0;
+	for (i = 0; i< 28; i++)
+	{
+		sum += tempWB[i];
 	}
+	temp =sum % 0xff+1;
 
-	if (B_gain>=0x400) {
-		write_cmos_sensor(0x5036, B_gain>>8);
-		write_cmos_sensor(0x5037, B_gain & 0x00ff);
+	if (tempWB[28] != temp)
+	{
+	LOG_INF("OV5670 otp wb info checksum error");
+	return ;
 	}
-	return 0;
-}
 
-// call this function after OV5670 initialization
-// return value: 0 update success
-// 1, no OTP
-static int update_otp_wb()
-{
-	struct otp_struct current_otp={0};
-	int i;
-	int otp_index,temp;
-	int BG_Ratio_Typical,RG_Ratio_Typical;
-	int R_gain, G_gain, B_gain, G_gain_R, G_gain_B;
-	int rg,bg,r_golden,b_golden,gr_golden,gb_golden;
-
-// R/G and B/G of current camera module is read out from sensor OTP
-// check first OTP with valid data
-	for(i=1;i<=3;i++) {
-		temp = check_otp_wb(i);
-		if (temp == 2) 
-		{
-			otp_index = i;
-			break;
-		}
+	//OTP TotalSum Check
+	
+	USHORT TotalCheckSumValue = 0;	
+	sum = 0;
+	TotalCheckSumValue = 0;
+	USHORT BufferCheckSum[255] = {0};
+	OV5670ofilm_read_all(0x7010,0x709b,BufferCheckSum);
+	mdelay(10);
+	
+	for(i=0x7010; i<=0x7098; i++)
+	{
+		sum = sum + BufferCheckSum[i-0x7010];
 	}
-	if (i>3) {
-	// no valid wb OTP data
-		return 1;
+       mdelay(10);
+       
+	TotalCheckSumValue = (sum%0xff + 1);
+	mdelay(10);
+	
+	if(BufferCheckSum[137] == TotalCheckSumValue)
+	{
+		valueGroup = 1;
 	}
-	read_otp_wb(otp_index, &current_otp);
-	rg = current_otp.rg_ratio;
-	bg = current_otp.bg_ratio;
-	
-	r_golden = current_otp.r_golden;
-	b_golden = current_otp.b_golden;
-	gr_golden = current_otp.gr_golden;
-	gb_golden = current_otp.gb_golden;
-	LOG_INF("-----------golden ration rg bg [0x%x,0x%x]\n",rg,bg);	
-	LOG_INF("-----------golden r b gr gb[0x%x,0x%x,0x%x,0x%x]\n",r_golden,b_golden,gr_golden,gb_golden);	
-	BG_Ratio_Typical = ((b_golden<<9)+((gr_golden+gb_golden)>>2)) / ((gr_golden+gb_golden)>>1);
-	RG_Ratio_Typical = ((r_golden<<9)+((gr_golden+gb_golden)>>2)) / ((gr_golden+gb_golden)>>1);
-	//calculate G gain
-	//0x400 = 1x gain
-	if(bg < BG_Ratio_Typical) {
-		if (rg< RG_Ratio_Typical) {
-			// current_otp.bg_ratio < BG_Ratio_typical &&
-			// current_otp.rg_ratio < RG_Ratio_typical
-			G_gain = 0x400;
-			B_gain = 0x400 * BG_Ratio_Typical / bg;
-			R_gain = 0x400 * RG_Ratio_Typical / rg;
-		}
-		else {
-			// current_otp.bg_ratio < BG_Ratio_typical &&
-			// current_otp.rg_ratio >= RG_Ratio_typical
-			R_gain = 0x400;
-			G_gain = 0x400 * rg / RG_Ratio_Typical;
-			B_gain = G_gain * BG_Ratio_Typical /bg;
-		}
+	else if(BufferCheckSum[138] == TotalCheckSumValue)
+	{
+		valueGroup = 2;
 	}
-	else {
-		if (rg < RG_Ratio_Typical) {
-			// current_otp.bg_ratio >= BG_Ratio_typical &&
-			// current_otp.rg_ratio < RG_Ratio_typical
-			B_gain = 0x400;
-			G_gain = 0x400 * bg / BG_Ratio_Typical;
-			R_gain = G_gain * RG_Ratio_Typical / rg;
-		}
-		else {
-			// current_otp.bg_ratio >= BG_Ratio_typical &&
-			// current_otp.rg_ratio >= RG_Ratio_typical
-			G_gain_B = 0x400 * bg / BG_Ratio_Typical;
-			G_gain_R = 0x400 * rg / RG_Ratio_Typical;
-			if(G_gain_B > G_gain_R ) {
-				B_gain = 0x400;
-				G_gain = G_gain_B;
-				R_gain = G_gain * RG_Ratio_Typical /rg;
-			}
-			else {
-				R_gain = 0x400;
-				G_gain = G_gain_R;
-				B_gain = G_gain * BG_Ratio_Typical / bg;
-			}
-		}
+	else if(BufferCheckSum[139] == TotalCheckSumValue)
+	{
+		valueGroup = 3;
 	}
-	LOG_INF("-----------golden RGB gain [0x%x,0x%x,0x%x]\n",R_gain,G_gain,B_gain);	
-	update_awb_gain(R_gain, G_gain, B_gain);
-	return 0;
+       else
+       {        
+        LOG_INF("OV5670 otp TotalCheckSum Flag or TotalCheckSum error ");
+	 return ;
+       } 
+       LOG_INF("OV5670 OFilm checksum valueGroup =%d",valueGroup);
+     
 }
 
-#endif
-      
+#endif 
+
 static void set_dummy()
 {
 	LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
@@ -567,10 +596,11 @@ static void set_dummy()
 
 static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
 {
+	kal_int16 dummy_line;
 	kal_uint32 frame_length = imgsensor.frame_length;
 	//unsigned long flags;
 
-	LOG_INF("framerate = %d, min framelength should enable? \n", framerate,min_framelength_en);
+	LOG_INF("framerate = %d, min framelength should enable = %d\n", framerate,min_framelength_en);
    
 	frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
 	spin_lock(&imgsensor_drv_lock);
@@ -598,6 +628,7 @@ static void write_shutter(kal_uint16 shutter)
 {
     unsigned long flags;
 	kal_uint16 realtime_fps = 0;
+	kal_uint32 frame_length = 0;
     spin_lock_irqsave(&imgsensor_drv_lock, flags);
     imgsensor.shutter = shutter;
     spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
@@ -617,10 +648,7 @@ static void write_shutter(kal_uint16 shutter)
 	spin_unlock(&imgsensor_drv_lock);
 	shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
 	shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
-
-    // Framelength should be an even number
-    shutter = (shutter >> 1) << 1;
-    imgsensor.frame_length = (imgsensor.frame_length >> 1) << 1;
+	
 	if (imgsensor.autoflicker_en) { 
 		realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
 		if(realtime_fps >= 297 && realtime_fps <= 305)
@@ -773,7 +801,6 @@ static kal_uint16 set_gain(kal_uint16 gain)
 static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
 {
 	LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
-	write_cmos_sensor(0x3820, 0x81);   //enable ihdr
 	if (imgsensor.ihdr_en) {
 		
 		spin_lock(&imgsensor_drv_lock);
@@ -889,11 +916,9 @@ static void sensor_init(void)
 	write_cmos_sensor(0x030f, 0x06); 
 	write_cmos_sensor(0x0312, 0x01); 
 	write_cmos_sensor(0x3000, 0x00); 
-	write_cmos_sensor(0x3002, 0x61); 
+	write_cmos_sensor(0x3002, 0x21); 
 	write_cmos_sensor(0x3005, 0xf0); 
 	write_cmos_sensor(0x3007, 0x00); 
-	write_cmos_sensor(0x300d, 0x00); 
-	write_cmos_sensor(0x3010, 0x40); 
 	write_cmos_sensor(0x3015, 0x0f); 
 	write_cmos_sensor(0x3018, 0x32); 
 	write_cmos_sensor(0x301a, 0xf0); 
@@ -1077,7 +1102,7 @@ static void sensor_init(void)
 	write_cmos_sensor(0x402e, 0x00); 
 	write_cmos_sensor(0x402f, 0x00); 
 	write_cmos_sensor(0x4040, 0x00); 
-	write_cmos_sensor(0x4041, 0x03); 
+	write_cmos_sensor(0x4041, 0x03); //shenan,0x00,141122
 	write_cmos_sensor(0x4042, 0x00); 
 	write_cmos_sensor(0x4043, 0x7a); 
 	write_cmos_sensor(0x4044, 0x00); 
@@ -1161,14 +1186,8 @@ static void sensor_init(void)
 	//;added					 
 //	write_cmos_sensor(0x3d85, 0x17); 
 //	write_cmos_sensor(0x3655, 0x20); 
-	//mipi settings
-	//data lane
-	write_cmos_sensor(0x4826, 0x50); //20 dafault 0x32 hs prepare 
-	write_cmos_sensor(0x481b, 0x50); //30 default 0x3c hs trail. 
-	//clk lane								   
 								   
 	write_cmos_sensor(0x0100, 0x01); //;01
-	
 	#ifdef OV5670_OTP
 	update_otp_wb();
 	#endif
@@ -1281,7 +1300,7 @@ static void capture_setting(kal_uint16 currefps)
 		write_cmos_sensor(0x3508, 0x03);  //gain
 		write_cmos_sensor(0x3509, 0x00);  //gain
 
-		write_cmos_sensor(0x3623, 0x00);  //gain
+//		write_cmos_sensor(0x3623, 0x00);  //gain
 		write_cmos_sensor(0x366e, 0x10); 
 		write_cmos_sensor(0x370b, 0x1b); 
 		write_cmos_sensor(0x3808, 0x0a); 
@@ -1305,7 +1324,7 @@ static void capture_setting(kal_uint16 currefps)
 		write_cmos_sensor(0x4502, 0x40); 
 		write_cmos_sensor(0x4508, 0xaa); 
 		write_cmos_sensor(0x4509, 0xaa); 
-		write_cmos_sensor(0x450a, 0x00);  // 
+//		write_cmos_sensor(0x450a, 0x00);  // 
 		write_cmos_sensor(0x4600, 0x01); 
 		write_cmos_sensor(0x4601, 0x03); 
 		write_cmos_sensor(0x4017, 0x08); //threshold= 2LSB for full size
@@ -1487,40 +1506,6 @@ static void slim_video_setting()
 
 }
 
-bool ov5670_otp_check_mid(void)
-{
-  u32 mid = 0x00;
-  int i=0,temp=0,otp_index=0;
-  u32 OTP_SENSOR_MID=0;
-  struct otp_struct otp_basic_info={0};
-  LOG_INF("ov5670_otp_check_mid start\n");
-  // check first OTP with valid data
-  for(i=1;i<=3;i++) {
-    temp = check_otp_info(i);
-    if (temp == 2) 
-    {
-      otp_index = i;
-      break;
-    }
-  }
-  if (i>3) {
-    // no valid wb OTP data
-    LOG_ERR(" no valid wb OTP data\n");
-    return 1;
-  }
-  read_otp_info(otp_index, &otp_basic_info);
-  OTP_SENSOR_MID = otp_basic_info.module_integrator_id;;
-  LOG_INF("%s OFILM MID=0x%02x \n",__func__,OTP_SENSOR_MID);
-
-  if (OTP_SENSOR_MID==0x07)//sunnny =0x01,,OFLIM=0x07,VCM_ID :OFILM A40=0x08,OFILM A50=0x04,
-  {
-    return TRUE;
-  }
-  else
-  {
-    return FALSE;
-  }
-}
 
 
 /*************************************************************************
@@ -1543,9 +1528,7 @@ static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
 {
 	kal_uint8 i = 0;
 	kal_uint8 retry = 2;
-    bool check_mid=0;
 	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
-    LOG_INF("ov5670 get_imgsensor_id start\n");
 	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
 		spin_lock(&imgsensor_drv_lock);
 		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
@@ -1553,17 +1536,10 @@ static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
 		do {
 			*sensor_id = ((read_cmos_sensor(0x300B) << 8) | read_cmos_sensor(0x300C));
 			if (*sensor_id == imgsensor_info.sensor_id) {				
-				LOG_INF("i2c write id: 0x%x, read sensor id=0x%x imgsensor_info.sensor_id=0x%x\n", imgsensor.i2c_write_id,*sensor_id,imgsensor_info.sensor_id);	  
-                check_mid=ov5670_otp_check_mid();
-                if (!check_mid)
-                {
-                  *sensor_id = 0xFFFFFFFF;
-                  LOG_INF("get_imgsensor_id, MID!= 0x04(lite=0x04,ofilm=0x07) \n");
-                  return ERROR_SENSOR_CONNECT_FAIL;
-                }
+				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);	  
 				return ERROR_NONE;
 			}	
-            LOG_INF("Read sensor id fail, write id: 0x%x, read sensor=0x%x imgsensor_info.sensor_id=0x%x\n", imgsensor.i2c_write_id,*sensor_id,imgsensor_info.sensor_id);
+			LOG_INF("Read sensor id fail, write id:0x%x id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
 			retry--;
 		} while(retry > 0);
 		i++;
@@ -1600,6 +1576,7 @@ static kal_uint32 open(void)
 	kal_uint8 i = 0;
 	kal_uint8 retry = 2;
 	kal_uint16 sensor_id = 0; 
+	LOG_INF("MIPI 2LANE\n");
 	LOG_INF("preview 1280*960@30fps,864Mbps/lane; video 1280*960@30fps,864Mbps/lane; capture 5M@30fps,864Mbps/lane\n");
 	
 	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
@@ -1613,7 +1590,7 @@ static kal_uint32 open(void)
 				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);	  
 				break;
 			}	
-			LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+			LOG_INF("Read sensor id fail, write id:0x%x id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
 			retry--;
 		} while(retry > 0);
 		i++;
@@ -1621,12 +1598,33 @@ static kal_uint32 open(void)
 			break;
 		retry = 2;
 	}		 
+	LOG_INF("shenan1,ov5670,exit cycle successful!\n");
 	if (imgsensor_info.sensor_id != sensor_id)
 		return ERROR_SENSOR_CONNECT_FAIL;
 	
+	LOG_INF("shenan2,ov5670,exit cycle successful!\n");
 	/* initail sequence write in  */
 	sensor_init();
 
+	//justify sensor version
+#if 1
+       USHORT temp;
+       temp = read_cmos_sensor(0x302A);
+       if(temp == 0xb0)
+       {
+       LOG_INF("OV5670 sensor version is 1.0");
+       }
+       else
+       {
+           LOG_INF("OV5670 sensor version is updated");
+       }
+#endif    
+	//add OTP function
+       #if 0
+	  OV5670ofilm_read_all();
+       #else
+       OV5670Ofilm_otpcheck();
+       #endif
 	spin_lock(&imgsensor_drv_lock);
 
 	imgsensor.autoflicker_en= KAL_FALSE;
@@ -2021,7 +2019,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
-			//set_dummy();			
+			set_dummy();			
 			break;			
 		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
 			if(framerate == 0)
@@ -2032,7 +2030,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 			imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
-			//set_dummy();			
+			set_dummy();			
 			break;
 		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:		
         	  if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {
@@ -2052,7 +2050,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
             }
-			//set_dummy();			
+			set_dummy();			
 			break;	
 		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
 			frame_length = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
@@ -2061,7 +2059,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 			imgsensor.frame_length = imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
-			//set_dummy();			
+			set_dummy();			
 			break;
 		case MSDK_SCENARIO_ID_SLIM_VIDEO:
 			frame_length = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
@@ -2070,7 +2068,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 			imgsensor.frame_length = imgsensor_info.slim_video.framelength + imgsensor.dummy_line;
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
-			//set_dummy();	
+			set_dummy();	
 			break;		
 		default:  //coding with  preview scenario by default
 			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
@@ -2079,7 +2077,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
-			//set_dummy();	
+			set_dummy();	
 			LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
 			break;
 	}	
@@ -2154,6 +2152,7 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
 			*feature_para_len=4;
 			break;
 		case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:	 
+            LOG_INF("feature_Control imgsensor.pclk = %d,imgsensor.current_fps = %d\n", imgsensor.pclk,imgsensor.current_fps);
 			*feature_return_para_32 = imgsensor.pclk;
 			*feature_para_len=4;
 			break;		   
@@ -2240,8 +2239,8 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
 					break;
 			}
 		case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
-            LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
-            ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+            LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2)); 
+            ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));    
 			break;
 		default:
 			break;
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6752/ov5670_mipi_raw/ov5670mipi_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6752/ov5670_mipi_raw/ov5670mipi_Sensor.h
index 813fd2e..7c81d3e 100644
--- a/drivers/misc/mediatek/imgsensor/src/mt6752/ov5670_mipi_raw/ov5670mipi_Sensor.h
+++ b/drivers/misc/mediatek/imgsensor/src/mt6752/ov5670_mipi_raw/ov5670mipi_Sensor.h
@@ -1,3 +1,18 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *	 OV5670mipi_Sensor.h
+ *
+ * Project:
+ * --------
+ *	 ALPS
+ *
+ * Description:
+ * ------------
+ *	 CMOS sensor header file
+ *
+ ****************************************************************************/
 #ifndef _OV5670MIPI_SENSOR_H
 #define _OV5670MIPI_SENSOR_H
 
@@ -12,88 +27,95 @@ typedef enum{
 } IMGSENSOR_MODE;
 
 typedef struct imgsensor_mode_struct {
-	kal_uint32 pclk;				
-	kal_uint32 linelength;			
-	kal_uint32 framelength;			
+	kal_uint32 pclk;				//record different mode's pclk
+	kal_uint32 linelength;			//record different mode's linelength
+	kal_uint32 framelength;			//record different mode's framelength
 
-	kal_uint8 startx;				
-	kal_uint8 starty;				
+	kal_uint8 startx;				//record different mode's startx of grabwindow
+	kal_uint8 starty;				//record different mode's startx of grabwindow
 
-	kal_uint16 grabwindow_width;	
-	kal_uint16 grabwindow_height;	
+	kal_uint16 grabwindow_width;	//record different mode's width of grabwindow
+	kal_uint16 grabwindow_height;	//record different mode's height of grabwindow
 
-	
+	/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
 	kal_uint8 mipi_data_lp2hs_settle_dc;
 
-	
+	/*	 following for GetDefaultFramerateByScenario()	*/
 	kal_uint16 max_framerate;
 	
 } imgsensor_mode_struct;
 
+/* SENSOR PRIVATE STRUCT FOR VARIABLES*/
 typedef struct imgsensor_struct {
-	kal_uint8 mirror;				
+	kal_uint8 mirror;				//mirrorflip information
 
-	kal_uint8 sensor_mode;			
+	kal_uint8 sensor_mode;			//record IMGSENSOR_MODE enum value
 
-	kal_uint32 shutter;				
-	kal_uint16 gain;				
+	kal_uint32 shutter;				//current shutter
+	kal_uint16 gain;				//current gain
 	
-	kal_uint32 pclk;				
+	kal_uint32 pclk;				//current pclk
 
-	kal_uint32 frame_length;		
-	kal_uint32 line_length;			
+	kal_uint32 frame_length;		//current framelength
+	kal_uint32 line_length;			//current linelength
 
-	kal_uint32 min_frame_length;	
-	kal_uint16 dummy_pixel;			
-	kal_uint16 dummy_line;			
+	kal_uint32 min_frame_length;	//current min  framelength to max framerate
+	kal_uint16 dummy_pixel;			//current dummypixel
+	kal_uint16 dummy_line;			//current dummline
 	
-	kal_uint16 current_fps;			
-	kal_bool   autoflicker_en;		
-	kal_bool test_pattern;			
-	MSDK_SCENARIO_ID_ENUM current_scenario_id;
-	kal_uint8  ihdr_en;				
+	kal_uint16 current_fps;			//current max fps
+	kal_bool   autoflicker_en;		//record autoflicker enable or disable
+	kal_bool test_pattern;			//record test pattern mode or not
+	MSDK_SCENARIO_ID_ENUM current_scenario_id;//current scenario id
+	kal_uint8  ihdr_en;				//ihdr enable or disable
 	
-	kal_uint8 i2c_write_id;			
+	kal_uint8 i2c_write_id;			//record current sensor's i2c write id
 } imgsensor_struct;
 
+/* SENSOR PRIVATE STRUCT FOR CONSTANT*/
 typedef struct imgsensor_info_struct { 
-	kal_uint16 sensor_id;			
-	kal_uint32 checksum_value;		
-	imgsensor_mode_struct pre;		
-	imgsensor_mode_struct cap;		
-	imgsensor_mode_struct cap1;		
-	imgsensor_mode_struct normal_video;
-	imgsensor_mode_struct hs_video;	
-	imgsensor_mode_struct slim_video;	
+	kal_uint16 sensor_id;			//record sensor id defined in Kd_imgsensor.h
+	kal_uint32 checksum_value;		//checksum value for Camera Auto Test
+	imgsensor_mode_struct pre;		//preview scenario relative information
+	imgsensor_mode_struct cap;		//capture scenario relative information
+	imgsensor_mode_struct cap1;		//capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
+	imgsensor_mode_struct normal_video;//normal video  scenario relative information
+	imgsensor_mode_struct hs_video;	//high speed video scenario relative information
+	imgsensor_mode_struct slim_video;	//slim video for VT scenario relative information
 	
-	kal_uint8  ae_shut_delay_frame;	
-	kal_uint8  ae_sensor_gain_delay_frame;	
-	kal_uint8  ae_ispGain_delay_frame;	
-	kal_uint8  ihdr_support;		
-	kal_uint8  ihdr_le_firstline;	
-	kal_uint8  sensor_mode_num;		
+	kal_uint8  ae_shut_delay_frame;	//shutter delay frame for AE cycle
+	kal_uint8  ae_sensor_gain_delay_frame;	//sensor gain delay frame for AE cycle
+	kal_uint8  ae_ispGain_delay_frame;	//isp gain delay frame for AE cycle
+	kal_uint8  ihdr_support;		//1, support; 0,not support
+	kal_uint8  ihdr_le_firstline;	//1,le first ; 0, se first
+	kal_uint8  sensor_mode_num;		//support sensor mode num
 	
-	kal_uint8  cap_delay_frame;		
-	kal_uint8  pre_delay_frame;		
-	kal_uint8  video_delay_frame;	
-	kal_uint8  hs_video_delay_frame;	
-	kal_uint8  slim_video_delay_frame;	
+	kal_uint8  cap_delay_frame;		//enter capture delay frame num
+	kal_uint8  pre_delay_frame;		//enter preview delay frame num
+	kal_uint8  video_delay_frame;	//enter video delay frame num
+	kal_uint8  hs_video_delay_frame;	//enter high speed video  delay frame num
+	kal_uint8  slim_video_delay_frame;	//enter slim video delay frame num
   
-	kal_uint8  margin;				
-	kal_uint32 min_shutter;			
-	kal_uint32 max_frame_length;	
-
-	kal_uint8  isp_driving_current;	
-	kal_uint8  sensor_interface_type;
-	kal_uint8  mipi_sensor_type; 
-	kal_uint8  mipi_settle_delay_mode; 
-	kal_uint8  sensor_output_dataformat;
-	kal_uint8  mclk;				
+	kal_uint8  margin;				//sensor framelength & shutter margin 
+	kal_uint32 min_shutter;			//min shutter
+	kal_uint32 max_frame_length;	//max framelength by sensor register's limitation
+
+	kal_uint8  isp_driving_current;	//mclk driving current
+	kal_uint8  sensor_interface_type;//sensor_interface_type
+	kal_uint8  mipi_sensor_type; //0,MIPI_OPHY_NCSI2; 1,MIPI_OPHY_CSI2, default is NCSI2, don't modify this para
+	kal_uint8  mipi_settle_delay_mode; //0, high speed signal auto detect; 1, use settle delay,unit is ns, default is auto detect, don't modify this para
+	kal_uint8  sensor_output_dataformat;//sensor output first pixel color
+	kal_uint8  mclk;				//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
 	
-	kal_uint8  mipi_lane_num;		
-	kal_uint8  i2c_addr_table[5];	
+	kal_uint8  mipi_lane_num;		//mipi lane num
+	kal_uint8  i2c_addr_table[5];	//record sensor support all write id addr, only supprt 4must end with 0xff
 } imgsensor_info_struct;
 
+/* SENSOR READ/WRITE ID */
+//#define IMGSENSOR_WRITE_ID_1 (0x6c)
+//#define IMGSENSOR_READ_ID_1  (0x6d)
+//#define IMGSENSOR_WRITE_ID_2 (0x20)
+//#define IMGSENSOR_READ_ID_2  (0x21)
 
 extern int iReadRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u8 * a_pRecvData, u16 a_sizeRecvData, u16 i2cId);
 extern int iWriteRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u16 i2cId);
diff --git a/drivers/misc/mediatek/kernel/mtk_memcfg.c b/drivers/misc/mediatek/kernel/mtk_memcfg.c
index ccfae4c..971d8e3 100644
--- a/drivers/misc/mediatek/kernel/mtk_memcfg.c
+++ b/drivers/misc/mediatek/kernel/mtk_memcfg.c
@@ -239,7 +239,7 @@ static const struct file_operations proc_slabtrace_operations = {
 	.open = slabtrace_open,
 	.read = seq_read,
 	.llseek = seq_lseek,
-	.release = seq_release,
+	.release = single_release,
 };
 #endif
 static int __init mtk_memcfg_late_init(void)
diff --git a/drivers/misc/mediatek/keypad/kpd.c b/drivers/misc/mediatek/keypad/kpd.c
index 424ce8e..d662bbd 100644
--- a/drivers/misc/mediatek/keypad/kpd.c
+++ b/drivers/misc/mediatek/keypad/kpd.c
@@ -19,6 +19,9 @@
 
 /*kpd.h file path: ALPS/mediatek/kernel/include/linux */
 #include <linux/kpd.h>
+#ifdef CONFIG_MTK_TC1_FM_AT_SUSPEND
+#include <linux/wakelock.h>
+#endif
 #ifdef CONFIG_OF
 #include <linux/of.h>
 #include <linux/of_address.h>
@@ -26,25 +29,25 @@
 #endif
 
 #define KPD_NAME	"mtk-kpd"
-//#define USE_EARLY_SUSPEND
-#define MTK_KP_WAKESOURCE	/* this is for auto set wake up source */
+//#define MTK_KP_WAKESOURCE	/* this is for auto set wake up source */
 
 #ifdef CONFIG_OF
 void __iomem *kp_base;
 static unsigned int kp_irqnr;
 #endif	
-
 #define FORCE_POWERKEY
 #define FORCE_POWERKEY_SECONDS   8
 struct timer_list timer;
 //extern void arch_reset(char mode, const char *cmd);
 extern void mt_power_off(void);
-
 struct input_dev *kpd_input_dev;
 static bool kpd_suspend = false;
 static int kpd_show_hw_keycode = 1;
 static int kpd_show_register = 1;
 static volatile int call_status = 0;
+#ifdef CONFIG_MTK_TC1_FM_AT_SUSPEND
+struct wake_lock kpd_suspend_lock; /* For suspend usage */
+#endif
 
 /*for kpd_memory_setting() function*/
 static u16 kpd_keymap[KPD_NUM_KEYS];
@@ -74,7 +77,7 @@ static void kpd_memory_setting(void);
 /*********************************************************************/
 static int kpd_pdrv_probe(struct platform_device *pdev);
 static int kpd_pdrv_remove(struct platform_device *pdev);
-#if !defined(CONFIG_HAS_EARLYSUSPEND) || !defined(USE_EARLY_SUSPEND)
+#ifndef USE_EARLY_SUSPEND
 static int kpd_pdrv_suspend(struct platform_device *pdev, pm_message_t state);
 static int kpd_pdrv_resume(struct platform_device *pdev);
 #endif
@@ -85,10 +88,11 @@ static const struct of_device_id kpd_of_match[] = {
 	{},
 };
 #endif
+
 static struct platform_driver kpd_pdrv = {
 	.probe = kpd_pdrv_probe,
 	.remove = kpd_pdrv_remove,
-#if !defined(CONFIG_HAS_EARLYSUSPEND) || !defined(USE_EARLY_SUSPEND)
+#ifndef USE_EARLY_SUSPEND
 	.suspend = kpd_pdrv_suspend,
 	.resume = kpd_pdrv_resume,
 #endif
@@ -123,7 +127,6 @@ static int timer_init()
     printk(KPD_SAY "add_timer for FORCE_POWERKEY\n"); 
     return 0; 
 }
-
 /********************************************************************/
 static void kpd_memory_setting(void)
 {
@@ -429,6 +432,10 @@ static void kpd_keymap_handler(unsigned long data)
 	u16 hw_keycode, linux_keycode;
 	kpd_get_keymap_state(new_state);
 
+#ifdef CONFIG_MTK_TC1_FM_AT_SUSPEND
+	wake_lock_timeout(&kpd_suspend_lock, HZ / 2);
+#endif
+
 	for (i = 0; i < KPD_NUM_MEMS; i++) {
 		change = new_state[i] ^ kpd_keymap_state[i];
 		if (!change)
@@ -823,6 +830,7 @@ static int kpd_pdrv_probe(struct platform_device *pdev)
 	}
 	pr_warn(KPD_SAY "kp base: 0x%p, addr:0x%p,  kp irq: %d\n", kp_base,&kp_base, kp_irqnr);
 #endif
+
 	kpd_ldvt_test_init();	/* API 2 for kpd LFVT test enviroment settings */
 
 	/* initialize and register input device (/dev/input/eventX) */
@@ -856,7 +864,7 @@ static int kpd_pdrv_probe(struct platform_device *pdev)
 		if (kpd_keymap[i] != 0)
 			__set_bit(kpd_keymap[i], kpd_input_dev->keybit);
 	}
-	
+
 #if KPD_AUTOTEST
 	for (i = 0; i < ARRAY_SIZE(kpd_auto_keymap); i++)
 		__set_bit(kpd_auto_keymap[i], kpd_input_dev->keybit);
@@ -892,6 +900,10 @@ static int kpd_pdrv_probe(struct platform_device *pdev)
 		return r;
 	}
 
+#ifdef CONFIG_MTK_TC1_FM_AT_SUSPEND
+	wake_lock_init(&kpd_suspend_lock, WAKE_LOCK_SUSPEND, "kpd wakelock");
+#endif
+
 	/* register IRQ and EINT */
 	kpd_set_debounce(KPD_KEY_DEBOUNCE);
 #ifdef CONFIG_OF
@@ -905,9 +917,7 @@ static int kpd_pdrv_probe(struct platform_device *pdev)
 		input_unregister_device(kpd_input_dev);
 		return r;
 	}
-#if KPD_PWRKEY_USE_EINT
 	mt_eint_register();
-#endif
 
 #ifndef KPD_EARLY_PORTING	/*add for avoid early porting build err the macro is defined in custom file */
 	long_press_reboot_function_setting();	/* /API 4 for kpd long press reboot function setting */
@@ -925,7 +935,6 @@ static int kpd_pdrv_probe(struct platform_device *pdev)
 		kpd_delete_attr(&kpd_pdrv.driver);
 		return err;
 	}
-
     pr_warn(KPD_SAY "%s Done\n", __FUNCTION__);
 	return 0;
 }
@@ -936,7 +945,7 @@ static int kpd_pdrv_remove(struct platform_device *pdev)
 	return 0;
 }
 
-#if !defined(CONFIG_HAS_EARLYSUSPEND) || !defined(USE_EARLY_SUSPEND)
+#ifndef USE_EARLY_SUSPEND
 static int kpd_pdrv_suspend(struct platform_device *pdev, pm_message_t state)
 {
 	kpd_suspend = true;
@@ -944,12 +953,11 @@ static int kpd_pdrv_suspend(struct platform_device *pdev, pm_message_t state)
 	if (call_status == 2) {
 		kpd_print("kpd_early_suspend wake up source enable!! (%d)\n", kpd_suspend);
 	} else {
-
 		kpd_wakeup_src_setting(0);
 		kpd_print("kpd_early_suspend wake up source disable!! (%d)\n", kpd_suspend);
 	}
 #else	
-//mt6325_upmu_set_k_control_smps(0x01);
+mt6325_upmu_set_k_control_smps(0x01);
 //mt6325_upmu_set_rg_homekey_rst_en(0x01);
 //mt6325_upmu_set_rg_int_en_bif(0x01);
 #endif
@@ -978,7 +986,7 @@ static int kpd_pdrv_resume(struct platform_device *pdev)
 #endif
 
 
-#if defined(CONFIG_HAS_EARLYSUSPEND) && defined(USE_EARLY_SUSPEND)
+#ifdef USE_EARLY_SUSPEND
 static void kpd_early_suspend(struct early_suspend *h)
 {
 	kpd_suspend = true;
@@ -1034,7 +1042,7 @@ static int __init kpd_mod_init(void)
 		printk(KPD_SAY "register driver failed (%d)\n", r);
 		return r;
 	}
-#if defined(CONFIG_HAS_EARLYSUSPEND) && defined(USE_EARLY_SUSPEND)
+#ifdef USE_EARLY_SUSPEND
 	register_early_suspend(&kpd_early_suspend_desc);
 #endif
 
diff --git a/drivers/misc/mediatek/keypad/mt6752/hal_kpd.c b/drivers/misc/mediatek/keypad/mt6752/hal_kpd.c
index 063187b..1f4d8a1 100644
--- a/drivers/misc/mediatek/keypad/mt6752/hal_kpd.c
+++ b/drivers/misc/mediatek/keypad/mt6752/hal_kpd.c
@@ -350,7 +350,7 @@ static void kpd_factory_mode_handler(void)
 	memcpy(kpd_keymap_state, new_state, sizeof(new_state));
 	kpd_print("save new keymap state\n");
 }
- 
+
 /********************************************************************/
 void kpd_auto_test_for_factorymode(void)
 {
diff --git a/drivers/misc/mediatek/lcm/inc/lcm_drv.h b/drivers/misc/mediatek/lcm/inc/lcm_drv.h
index d4657f7..8fedee7 100644
--- a/drivers/misc/mediatek/lcm/inc/lcm_drv.h
+++ b/drivers/misc/mediatek/lcm/inc/lcm_drv.h
@@ -498,7 +498,7 @@ typedef struct
     unsigned int		word_count;
     
     unsigned int		packet_size;
-    
+    unsigned int        packet_size_mult;
     unsigned int		vertical_sync_active;
     unsigned int		vertical_backporch;
     unsigned int		vertical_frontporch;
@@ -657,6 +657,7 @@ typedef struct
     int (*set_gpio_mode)(unsigned int pin, unsigned int mode);
     int (*set_gpio_dir)(unsigned int pin, unsigned int dir);
     int (*set_gpio_pull_enable)(unsigned int pin, unsigned char pull_en);
+    void (*dsi_set_cmdq_V11)(void* cmdq, unsigned int *pdata, unsigned int queue_size, unsigned char force_update);
     void (*dsi_set_cmdq_V22)(void* cmdq, unsigned cmd, unsigned char count, unsigned char *para_list, unsigned char force_update);
     void (*dsi_swap_port)(int swap);
 	void (*dsi_set_cmdq_V23)(void* cmdq, unsigned cmd, unsigned char count, unsigned char *para_list, unsigned char force_update);//dual
@@ -710,6 +711,7 @@ typedef struct
     ////switch mode
     void* (*switch_mode)(int mode);
 	void (*set_cmd)(void* handle,int* mode,unsigned int cmd_num);
+	void (*set_lcm_cmd)(void* handle,unsigned int *lcm_cmd,unsigned int *lcm_count,unsigned int *lcm_value);
 } LCM_DRIVER;
 
 
diff --git a/drivers/misc/mediatek/lcm/mt65xx_lcm_list.c b/drivers/misc/mediatek/lcm/mt65xx_lcm_list.c
index 6e23448..b42f753 100644
--- a/drivers/misc/mediatek/lcm/mt65xx_lcm_list.c
+++ b/drivers/misc/mediatek/lcm/mt65xx_lcm_list.c
@@ -238,13 +238,18 @@ extern LCM_DRIVER st7789h2_dbi_lcm_drv;
 extern LCM_DRIVER otm1284a_hd720_dsi_vdo_lcm_drv;
 LCM_DRIVER* lcm_driver_list[] =
 {
-#if defined(OTM1284A_HD720_DSI_VDO)
-	&otm1284a_hd720_dsi_vdo_lcm_drv,
-#endif
 #if defined(HX8394A_HD720_DSI_VDO_TIANMA)
 	&hx8394a_hd720_dsi_vdo_tianma_lcm_drv,
 #endif
 
+#if defined(OTM1284A_HD720_DSI_VDO_TM)
+	&otm1284a_hd720_dsi_vdo_tm_lcm_drv,
+#endif
+
+#if defined(OTM1285A_HD720_DSI_VDO_TM)
+	&otm1285a_hd720_dsi_vdo_tm_lcm_drv,
+#endif
+
 #if defined(S6E3FA2_FHD1080_DSI_VDO)
 	&s6e3fa2_fhd1080_dsi_vdo_lcm_drv,
 #endif
diff --git a/drivers/misc/mediatek/lcm/nt35595_fhd_dsi_vdo_truly_nt50358/nt35595_fhd_dsi_vdo_truly_nt50358.c b/drivers/misc/mediatek/lcm/nt35595_fhd_dsi_vdo_truly_nt50358/nt35595_fhd_dsi_vdo_truly_nt50358.c
index 46511df..81838af 100644
--- a/drivers/misc/mediatek/lcm/nt35595_fhd_dsi_vdo_truly_nt50358/nt35595_fhd_dsi_vdo_truly_nt50358.c
+++ b/drivers/misc/mediatek/lcm/nt35595_fhd_dsi_vdo_truly_nt50358/nt35595_fhd_dsi_vdo_truly_nt50358.c
@@ -101,7 +101,6 @@ static struct i2c_driver tps65132_iic_driver = {
 	.id_table	= tps65132_id,
 	.probe		= tps65132_probe,
 	.remove		= tps65132_remove,
-	//.detect		= mt6605_detect,
 	.driver		= {
 		.owner	= THIS_MODULE,
 		.name	= "tps65132",
diff --git a/drivers/misc/mediatek/lcm/otm1283a_hd720_dsi_vdo_tm/otm1283a_hd720_dsi_vdo_tm.c b/drivers/misc/mediatek/lcm/otm1283a_hd720_dsi_vdo_tm/otm1283a_hd720_dsi_vdo_tm.c
index f399d6d..385e2b7 100644
--- a/drivers/misc/mediatek/lcm/otm1283a_hd720_dsi_vdo_tm/otm1283a_hd720_dsi_vdo_tm.c
+++ b/drivers/misc/mediatek/lcm/otm1283a_hd720_dsi_vdo_tm/otm1283a_hd720_dsi_vdo_tm.c
@@ -445,12 +445,18 @@ static void lcm_init_registers()
 	unsigned int data_array[16];
 	data_array[0] = 0x00002300;
 	dsi_set_cmdq(&data_array, 1, 1);//EXTC = 1
+#ifndef BUILD_LK
+	printk("[KERNEL][LCM_INIT_REGS]otm1283a_hd720_dsi_vdo_tm----First cmd DONE\n");
+#endif	
 	
-	data_array[0] = 0x00042902;
+        data_array[0] = 0x00042902;
 	data_array[1] = 0x018312FF;
 	dsi_set_cmdq(&data_array, 2, 1);//EXTC = 1
+#ifndef BUILD_LK
+	printk("[KERNEL][LCM_INIT_REGS]otm1283a_hd720_dsi_vdo_tm----Second cmd DONE\n");
+#endif
 	
-	data_array[0] = 0x80002300;
+        data_array[0] = 0x80002300;
 	dsi_set_cmdq(&data_array, 1, 1);	//Orise mode enable
 	
 	data_array[0] = 0x00032902;
@@ -1589,7 +1595,14 @@ static void lcm_init(void)
     SET_RESET_PIN(1);
 	MDELAY(10);//100
 
+#ifndef BUILD_LK
+	printk("[KERNEL][LCM_INIT]otm1283a_hd720_dsi_vdo_tm----RESET DONE\n");
+#endif
 	lcm_init_registers();
+
+#ifndef BUILD_LK
+	printk("[KERNEL][LCM_INIT_REGS]otm1283a_hd720_dsi_vdo_tm----DONE\n");
+#endif
 	data_array[0] = 0x00352500;
 	dsi_set_cmdq(&data_array, 1, 1);
 	data_array[0] = 0x00362500;
@@ -1612,10 +1625,14 @@ static void lcm_init(void)
 	dsi_set_cmdq(data_array, 2, 1);
 
 	push_table(lcm_sleep_out_setting, sizeof(lcm_sleep_out_setting) / sizeof(struct LCM_setting_table), 1);
+#ifndef BUILD_LK
+	printk("[KERNEL][LCM_INIT]otm1283a_hd720_dsi_vdo_tm----SleepOut DONE\n");
+#endif
 #ifndef BUILD_LK	
 	// Refresh value of backlight level.for esd check recovery because lcm init need set backlight as 0.
 	lcm_backlight_level_setting[0].para_list[0] = 25;
 	push_table(lcm_backlight_level_setting, sizeof(lcm_backlight_level_setting) / sizeof(struct LCM_setting_table), 1);
+        printk("[KERNEL][LCM_INIT]otm1283a_hd720_dsi_vdo_tm----SetBacklight DONE\n");
 #endif	
 }
 
diff --git a/drivers/misc/mediatek/lcm/otm1906b_fhd_dsi_cmd_jdi_tps65132/otm1906b_fhd_dsi_cmd_jdi_tps65132.c b/drivers/misc/mediatek/lcm/otm1906b_fhd_dsi_cmd_jdi_tps65132/otm1906b_fhd_dsi_cmd_jdi_tps65132.c
index 038ef91..21e53bb 100644
--- a/drivers/misc/mediatek/lcm/otm1906b_fhd_dsi_cmd_jdi_tps65132/otm1906b_fhd_dsi_cmd_jdi_tps65132.c
+++ b/drivers/misc/mediatek/lcm/otm1906b_fhd_dsi_cmd_jdi_tps65132/otm1906b_fhd_dsi_cmd_jdi_tps65132.c
@@ -218,8 +218,9 @@ static const unsigned char LCD_MODULE_ID = 0x01; //  haobing modified 2013.07.11
 
 static LCM_DSI_MODE_SWITCH_CMD lcm_switch_mode_cmd;
 
-//#define UFO_ON_3X_60
-#define UFO_ON_3X_120
+#define UFO_ON_3X_60
+//#define UFO_ON_3X_120
+//#define UFO_OFF_60
 
 #ifndef TRUE
     #define TRUE 1
@@ -251,6 +252,7 @@ static int lcm_fps = 60;
 #define read_reg(cmd)										lcm_util.dsi_dcs_read_lcm_reg(cmd)
 #define read_reg_v2(cmd, buffer, buffer_size)   			lcm_util.dsi_dcs_read_lcm_reg_v2(cmd, buffer, buffer_size)
 #define dsi_set_cmdq_V22(cmdq, cmd, count, ppara, force_update)	lcm_util.dsi_set_cmdq_V22(cmdq, cmd, count, ppara, force_update)
+#define dsi_set_cmdq_V11(cmdq, pdata, queue_size, force_update)	lcm_util.dsi_set_cmdq_V11(cmdq, pdata, queue_size, force_update)
 
 struct LCM_setting_table {
     unsigned int cmd;
@@ -258,6 +260,43 @@ struct LCM_setting_table {
     unsigned char para_list[64];
 };
 
+static unsigned char od_table_33x33[] =
+{  
+  0,   8,  19,  30,  43,  53,  61,  74,  84,  94, 104, 113, 122, 130, 139, 148, 156, 164, 172, 180, 188, 195, 203, 210, 217, 224, 230, 237, 243, 247, 252, 255, 255,
+  0,   8,  16,  26,  39,  50,  60,  72,  83,  94, 104, 113, 122, 130, 139, 148, 156, 164, 172, 180, 188, 196, 203, 210, 217, 224, 230, 236, 242, 245, 250, 253, 255,
+  0,   8,  16,  24,  36,  47,  59,  70,  81,  91, 102, 112, 120, 130, 138, 146, 154, 162, 170, 178, 186, 194, 202, 209, 216, 222, 229, 236, 242, 245, 250, 253, 255,
+  0,   8,  16,  24,  34,  45,  55,  66,  77,  88,  98, 109, 118, 128, 137, 146, 154, 162, 170, 178, 186, 194, 202, 209, 216, 222, 229, 236, 242, 245, 250, 253, 255,
+  0,   8,  16,  24,  32,  42,  53,  64,  75,  84,  96, 106, 116, 126, 136, 144, 152, 160, 169, 176, 184, 192, 200, 208, 214, 221, 228, 235, 240, 246, 249, 253, 255,
+  0,   8,  15,  23,  32,  40,  50,  62,  72,  84,  93, 104, 114, 125, 134, 144, 152, 160, 168, 176, 184, 192, 200, 207, 214, 221, 228, 234, 240, 245, 250, 253, 255,
+  0,   8,  15,  22,  30,  39,  48,  58,  69,  80,  89, 100, 111, 121, 132, 141, 150, 158, 168, 176, 183, 192, 200, 206, 214, 221, 228, 234, 240, 245, 250, 253, 255,
+  0,   8,  15,  20,  28,  36,  46,  56,  65,  77,  86,  98, 108, 119, 128, 140, 150, 158, 166, 174, 182, 190, 198, 206, 212, 220, 226, 234, 240, 245, 250, 253, 255,
+  0,   8,  14,  20,  26,  34,  44,  55,  64,  74,  85,  95, 106, 116, 128, 137, 148, 156, 165, 174, 181, 190, 198, 206, 212, 220, 226, 232, 238, 244, 249, 254, 255,
+  0,   8,  14,  19,  26,  33,  42,  52,  62,  72,  81,  93, 103, 114, 124, 136, 145, 156, 164, 172, 180, 188, 196, 204, 211, 218, 226, 232, 238, 244, 249, 254, 255,
+  0,   7,  14,  19,  25,  32,  40,  50,  60,  70,  80,  89, 101, 110, 122, 132, 142, 152, 162, 170, 179, 188, 196, 204, 210, 218, 225, 232, 238, 244, 247, 252, 255,
+  0,   7,  14,  18,  24,  30,  38,  47,  57,  66,  78,  88,  98, 109, 119, 130, 140, 150, 160, 170, 178, 186, 194, 202, 210, 218, 224, 232, 238, 243, 248, 251, 255,
+  0,   7,  14,  17,  22,  29,  37,  46,  54,  65,  74,  85,  96, 105, 117, 126, 138, 147, 158, 166, 176, 186, 194, 202, 210, 216, 224, 230, 236, 242, 248, 251, 255,
+  0,   7,  14,  16,  22,  29,  36,  44,  53,  62,  73,  82,  94, 104, 114, 126, 135, 146, 156, 166, 174, 184, 192, 201, 208, 216, 222, 230, 236, 242, 247, 252, 255,
+  0,   7,  14,  16,  22,  28,  34,  42,  50,  60,  70,  81,  90, 102, 112, 122, 134, 143, 154, 163, 172, 182, 192, 200, 208, 216, 222, 230, 236, 242, 247, 252, 255,
+  0,   7,  13,  17,  22,  28,  34,  42,  50,  58,  68,  78,  89,  99, 111, 120, 131, 142, 151, 162, 170, 180, 190, 199, 208, 214, 222, 230, 236, 242, 247, 252, 255,
+  0,   7,  13,  17,  22,  27,  33,  40,  46,  56,  64,  75,  86,  97, 106, 119, 128, 140, 151, 161, 169, 184, 190, 199, 208, 220, 228, 234, 238, 246, 252, 255, 255,
+  0,   7,  12,  16,  22,  27,  33,  40,  46,  54,  64,  74,  84,  94, 106, 116, 128, 136, 150, 161, 167, 182, 188, 199, 208, 218, 226, 234, 240, 246, 252, 255, 255,
+  0,   7,  12,  16,  21,  26,  31,  38,  44,  52,  60,  71,  82,  92, 102, 114, 124, 136, 144, 158, 166, 181, 188, 198, 208, 217, 226, 233, 240, 246, 253, 255, 255,
+  0,   7,  12,  16,  21,  26,  31,  38,  44,  52,  60,  68,  80,  90, 100, 110, 121, 131, 143, 152, 165, 176, 185, 196, 206, 215, 224, 232, 240, 246, 253, 255, 255,
+  0,   7,  12,  15,  20,  25,  30,  36,  42,  50,  58,  66,  76,  86,  96, 106, 116, 127, 138, 149, 160, 172, 185, 195, 205, 216, 224, 232, 240, 246, 252, 255, 255,
+  0,   7,  12,  16,  19,  24,  30,  36,  42,  49,  56,  65,  73,  82,  92, 102, 110, 122, 133, 145, 158, 168, 180, 191, 201, 212, 222, 230, 238, 246, 252, 255, 255,
+  0,   6,   9,  14,  18,  23,  28,  34,  41,  48,  56,  64,  72,  80,  89,  99, 107, 118, 129, 140, 153, 165, 176, 188, 201, 211, 221, 229, 238, 245, 252, 255, 255,
+  0,   6,   9,  14,  17,  22,  28,  33,  40,  47,  54,  63,  71,  79,  88,  97, 105, 115, 125, 136, 147, 159, 172, 184, 194, 207, 218, 228, 237, 245, 252, 255, 255,
+  0,   6,   9,  14,  18,  21,  26,  32,  38,  44,  52,  60,  68,  77,  86,  95, 104, 114, 124, 134, 145, 156, 167, 180, 192, 202, 216, 226, 236, 245, 252, 255, 255,
+  0,   6,   9,  12,  15,  20,  26,  31,  37,  44,  51,  59,  67,  76,  84,  93, 101, 110, 120, 130, 140, 151, 164, 175, 188, 200, 212, 225, 236, 245, 252, 255, 255,
+  0,   4,   8,  12,  13,  18,  23,  29,  35,  42,  50,  58,  66,  75,  83,  92, 100, 109, 118, 128, 138, 149, 160, 171, 183, 196, 208, 220, 233, 244, 252, 255, 255,
+  0,   4,   7,  10,  12,  17,  22,  27,  33,  40,  48,  56,  64,  74,  82,  91,  99, 108, 117, 126, 136, 146, 156, 166, 180, 191, 204, 216, 230, 241, 251, 255, 255,
+  0,   4,   7,  10,  11,  16,  20,  26,  32,  40,  48,  56,  64,  73,  81,  90,  97, 106, 114, 122, 132, 142, 152, 163, 176, 188, 201, 214, 224, 240, 251, 255, 255,
+  0,   4,   7,   9,  11,  16,  20,  25,  32,  40,  48,  56,  64,  72,  80,  88,  96, 104, 112, 121, 130, 140, 151, 162, 173, 185, 198, 211, 223, 232, 245, 254, 255,
+  0,   4,   7,   9,  11,  14,  19,  25,  32,  40,  48,  56,  64,  72,  80,  88,  96, 104, 112, 121, 130, 140, 150, 160, 171, 182, 195, 208, 220, 231, 240, 250, 255,
+  0,   4,   6,   7,   9,  13,  18,  24,  32,  40,  48,  56,  64,  72,  80,  88,  96, 104, 112, 120, 128, 138, 148, 158, 168, 178, 189, 200, 211, 224, 237, 248, 255,
+  0,   4,   6,   7,   8,  12,  17,  24,  32,  40,  48,  56,  64,  72,  80,  88,  96, 104, 112, 120, 128, 136, 146, 156, 164, 177, 188, 198, 211, 224, 236, 248, 255,
+};
+
 static struct LCM_setting_table lcm_suspend_setting[] = {
 	{0x28,0,{}},
 	{0x10,0,{}},
@@ -274,7 +313,7 @@ static struct LCM_setting_table lcm_60fps_setting[] = {
     {0xFF,2,{0x19,0x06}},
 
     {0x00,1,{0x80}},
-    {0xC0,14,{0x00,0x77,0x06,0x95,0x0f,0x00,0x77,0x02,0x06,0x00,0x77,0x00,0x02,0x06}},
+    {0xC0,14,{0x00,0x74,0x07,0xb0,0x0f,0x00,0x74,0x02,0x06,0x00,0x74,0x07,0xb0,0x0f}},
 
     {0x00,1,{0x00}},
     {0xFB,1,{0x01}},
@@ -295,7 +334,7 @@ static struct LCM_setting_table lcm_120fps_setting[] = {
     {0xFF,2,{0x19,0x06}},
 
     {0x00,1,{0x80}},
-    {0xC0,14,{0x00,0x72,0x00,0x02,0x06,0x00,0x72,0x02,0x06,0x00,0x72,0x00,0x02,0x06}},
+    {0xC0,14,{0x00,0x74,0x00,0x02,0x06,0x00,0x74,0x02,0x06,0x00,0x74,0x00,0x02,0x06}},
 
     {0x00,1,{0x00}},
     {0xFB,1,{0x01}},
@@ -316,25 +355,58 @@ static struct LCM_setting_table lcm_initialization_setting[] = {
 	{0x00,1,{0x80}},
 	{0xFF,2,{0x19,0x06}},
 	
+    //ufoe on
 	{0x00,1,{0x00}},
-	//ufoe on
 	{0x1C,1,{0x04}},
 
+#if (!LCM_DSI_CMD_MODE)
+    {0x00,1,{0xA2}},
+    {0xC1,1,{0x01}},
+    
+    {0x00,1,{0x82}},
+    {0xC1,1,{0x01}},
+
+    {0x00,1,{0xC1}},
+    {0xC5,1,{0xBF}},
+#endif
+
+	{0x00,1,{0x80}},
+	{0xFF,2,{0x00,0x00}},
+
+	{0x00,1,{0x00}},
+	{0xFF,3,{0x00,0x00,0x00}},
+#if (defined UFO_ON_3X_60) || (defined UFO_OFF_60)
+	{0x00,1,{0x00}},
+	{0xFF,3,{0x19,0x06,0x01}},
+
+	{0x00,1,{0x80}},
+	{0xFF,2,{0x19,0x06}},
+
+	{0x00,1,{0x80}},
+	{0xC0,14,{0x00,0x74,0x07,0xb0,0x0f,0x00,0x74,0x02,0x06,0x00,0x74,0x07,0xb0,0x0f}},
+#ifdef UFO_OFF_60
+	{0x00,1,{0x00}},
+	//ufoe off
+	{0x1C,1,{0x00}},
+#endif
+	{0x00,1,{0x00}},
+	{0xFB,1,{0x01}},
+
 	{0x00,1,{0x80}},
 	{0xFF,2,{0x00,0x00}},
 
 	{0x00,1,{0x00}},
 	{0xFF,3,{0x00,0x00,0x00}},
+#endif
 
-	{0x35,1,{0x00}},             
-                  
+	{0x35,1,{0x00}},
 	{0x11,0,{}},    // Sleep out 
-	{REGFLAG_DELAY, 130, {}},             
+	{REGFLAG_DELAY, 130, {}},
+
 	{0x29,0,{}},    // Display on
-	{REGFLAG_END_OF_TABLE, 0x00, {}}	
+	{REGFLAG_END_OF_TABLE, 0x00, {}}
 };
 
-
 static struct LCM_setting_table lcm_backlight_level_setting[] = {
     {0x51, 1, {0xFF}},
     {REGFLAG_END_OF_TABLE, 0x00, {}}
@@ -408,13 +480,17 @@ static void lcm_get_params(LCM_PARAMS *params)
 
 	// Highly depends on LCD driver capability.
 	params->dsi.packet_size=256;
+
+#if (LCM_DSI_CMD_MODE)
+	params->dsi.packet_size_mult=4;
+#endif
 	//video mode timing
 
 	params->dsi.PS=LCM_PACKED_PS_24BIT_RGB888;
 
-	params->dsi.vertical_sync_active				= 1;
-	params->dsi.vertical_backporch					= 5;
-	params->dsi.vertical_frontporch					= 6;
+	params->dsi.vertical_sync_active				= 2;
+	params->dsi.vertical_backporch					= 16;
+	params->dsi.vertical_frontporch					= 16;
 	params->dsi.vertical_active_line				= FRAME_HEIGHT;
 
 	params->dsi.horizontal_sync_active				= 4;
@@ -426,7 +502,7 @@ static void lcm_get_params(LCM_PARAMS *params)
     /*command mode clock*/
 #if (LCM_DSI_CMD_MODE)
 #if (defined UFO_ON_3X_60) || (defined UFO_ON_3X_120)
-    params->dsi.PLL_CLOCK = 340;
+    params->dsi.PLL_CLOCK = 150;//260;
 #else
     params->dsi.PLL_CLOCK = 500; //this value must be in MTK suggested table
 #endif
@@ -435,7 +511,7 @@ static void lcm_get_params(LCM_PARAMS *params)
     /*video mode clock*/
 #if (!LCM_DSI_CMD_MODE)
 #if (defined UFO_ON_3X_60) || (defined UFO_ON_3X_120)
-    params->dsi.PLL_CLOCK = 340;
+    params->dsi.PLL_CLOCK = 380;
 #else
     params->dsi.PLL_CLOCK = 450; //this value must be in MTK suggested table
 #endif
@@ -447,12 +523,23 @@ static void lcm_get_params(LCM_PARAMS *params)
 	params->dsi.ufoe_params.vlc_disable = 0;
 	params->dsi.horizontal_active_pixel	= FRAME_WIDTH/3;
 #endif
-	params->dsi.esd_check_enable = 0;
+	params->dsi.esd_check_enable = 1;
 	params->dsi.customization_esd_check_enable = 0;
 	params->dsi.lcm_esd_check_table[0].cmd          = 0x53;
 	params->dsi.lcm_esd_check_table[0].count        = 1;
 	params->dsi.lcm_esd_check_table[0].para_list[0] = 0x24;
 
+	params->dsi.lane_swap_en = 1;
+
+	params->dsi.lane_swap[MIPITX_PHY_PORT_0][MIPITX_PHY_LANE_0] 	= MIPITX_PHY_LANE_0;
+	params->dsi.lane_swap[MIPITX_PHY_PORT_0][MIPITX_PHY_LANE_1] 	= MIPITX_PHY_LANE_3;
+	params->dsi.lane_swap[MIPITX_PHY_PORT_0][MIPITX_PHY_LANE_2] 	= MIPITX_PHY_LANE_2;
+	params->dsi.lane_swap[MIPITX_PHY_PORT_0][MIPITX_PHY_LANE_3] 	= MIPITX_PHY_LANE_1;
+	params->dsi.lane_swap[MIPITX_PHY_PORT_0][MIPITX_PHY_LANE_CK] 	= MIPITX_PHY_LANE_CK;
+	params->dsi.lane_swap[MIPITX_PHY_PORT_0][MIPITX_PHY_LANE_RX] 	= MIPITX_PHY_LANE_0;
+
+	//params->od_table_size = 33 * 33;
+	//params->od_table = (void*)&od_table_33x33;
 }
 
 static void lcm_init_power(void)
@@ -500,6 +587,7 @@ static void lcm_init(void)
 	mt_set_gpio_mode(GPIO_65132_EN, GPIO_MODE_00);
 	mt_set_gpio_dir(GPIO_65132_EN, GPIO_DIR_OUT);
 	mt_set_gpio_out(GPIO_65132_EN, GPIO_OUT_ONE);
+    MDELAY(5);
 
 #ifdef BUILD_LK
 	ret=TPS65132_write_byte(cmd,data);
@@ -592,8 +680,8 @@ static void lcm_update(unsigned int x, unsigned int y, unsigned int width, unsig
 	dsi_set_cmdq(data_array, 1, 0);	
 }
 
-#define LCM_OTM1906A_ID_ADD  (0xDA)
-#define LCM_OTM1906A_ID     (0x40)
+#define LCM_OTM1906B_ID_ADD  (0xDA)
+#define LCM_OTM1906B_ID     (0x40)
 
 static unsigned int lcm_compare_id(void)
 {
@@ -612,7 +700,7 @@ static unsigned int lcm_compare_id(void)
 	array[0] = 0x00023700;// read id return two byte,version and id
 	dsi_set_cmdq(array, 1, 1);
 	
-	read_reg_v2(LCM_OTM1906A_ID_ADD, buffer, 2);
+	read_reg_v2(LCM_OTM1906B_ID_ADD, buffer, 2);
 	id = buffer[0]; //we only need ID
 #ifdef BUILD_LK
 	dprintf(0, "%s, LK otm1906a debug: otm1906a id = 0x%08x\n", __func__, id);
@@ -620,7 +708,7 @@ static unsigned int lcm_compare_id(void)
 	printk("%s, kernel otm1906a horse debug: otm1906a id = 0x%08x\n", __func__, id);
 #endif
 
-	if(id == LCM_OTM1906A_ID)
+	if(id == LCM_OTM1906B_ID)
 		return 1;
 	else
 		return 0;
@@ -743,6 +831,64 @@ static void* lcm_switch_mode(int mode)
 #endif
 }
 
+static void lcm_send_60hz(void * cmdq)
+{
+    unsigned int array[]={
+        0x00001500,
+        0x00042902,
+        0x010619FF,
+        0x80001500,
+        0x00032902,
+        0x000619FF,
+        0x80001500,
+        0x000F2902,
+        0x077400C0,
+        0x74000fb0,
+        0x74000602,
+        0x000fb007,
+        0x00001500,
+        0x01FB2300,
+        0x80001500,
+        0x00032902,
+        0x000000FF,
+        0x00001500,
+        0x00042902,
+        0x000000FF
+    };
+    dsi_set_cmdq_V11(cmdq, array, sizeof(array)/sizeof(unsigned int),1);
+    return;
+    
+}
+
+
+static void lcm_send_120hz(void * cmdq)
+{
+    unsigned int array[]={
+        0x00001500,
+        0x00042902,
+        0x010619FF,
+        0x80001500,
+        0x00032902,
+        0x000619FF,
+        0x80001500,
+        0x000F2902,
+        0x007400C0,
+        0x74000602,
+        0x74000602,
+        0x00060200,
+        0x00001500,
+        0x01FB2300,
+        0x80001500,
+        0x00032902,
+        0x000000FF,
+        0x00001500,
+        0x00042902,
+        0x000000FF
+    };
+    dsi_set_cmdq_V11(cmdq, array, sizeof(array)/sizeof(unsigned int),1);
+    return;
+    
+}
 
 static int lcm_adjust_fps(void * cmdq, int fps)
 {
@@ -759,12 +905,14 @@ static int lcm_adjust_fps(void * cmdq, int fps)
     if(fps == 60)
     {
         lcm_fps = 60;
-	    push_table(cmdq, lcm_60fps_setting, sizeof(lcm_60fps_setting) / sizeof(struct LCM_setting_table), 1);
+	    //push_table(cmdq, lcm_60fps_setting, sizeof(lcm_60fps_setting) / sizeof(struct LCM_setting_table), 1);
+	    lcm_send_60hz(cmdq);
     }
     else if(fps == 120)
     {
         lcm_fps = 120;
-	    push_table(cmdq, lcm_120fps_setting, sizeof(lcm_120fps_setting) / sizeof(struct LCM_setting_table), 1);
+	    //push_table(cmdq, lcm_120fps_setting, sizeof(lcm_120fps_setting) / sizeof(struct LCM_setting_table), 1);
+        lcm_send_120hz(cmdq);
     }
     else
     {
@@ -788,7 +936,9 @@ LCM_DRIVER otm1906b_fhd_dsi_cmd_jdi_tps65132_lcm_drv=
      .init_power		= lcm_init_power,
      .resume_power      = lcm_resume_power,
      .suspend_power     = lcm_suspend_power,
+#if (defined UFO_ON_3X_60) || (defined UFO_ON_3X_120)
      .adjust_fps        = lcm_adjust_fps,
+#endif
      .esd_check         = lcm_esd_check,
      .set_backlight     = lcm_setbacklight,
 	 .ata_check		    = lcm_ata_check,
diff --git a/drivers/misc/mediatek/lcm/r63417_fhd_dsi_cmd_truly_nt50358/r63417_fhd_dsi_cmd_truly_nt50358.c b/drivers/misc/mediatek/lcm/r63417_fhd_dsi_cmd_truly_nt50358/r63417_fhd_dsi_cmd_truly_nt50358.c
index ca0174f..a2b9b52 100644
--- a/drivers/misc/mediatek/lcm/r63417_fhd_dsi_cmd_truly_nt50358/r63417_fhd_dsi_cmd_truly_nt50358.c
+++ b/drivers/misc/mediatek/lcm/r63417_fhd_dsi_cmd_truly_nt50358/r63417_fhd_dsi_cmd_truly_nt50358.c
@@ -96,7 +96,6 @@ static struct i2c_driver tps65132_iic_driver = {
 	.id_table	= tps65132_id,
 	.probe		= tps65132_probe,
 	.remove		= tps65132_remove,
-	//.detect		= mt6605_detect,
 	.driver		= {
 		.owner	= THIS_MODULE,
 		.name	= "tps65132",
diff --git a/drivers/misc/mediatek/lcm/r63419_wqhd_truly_phantom_2k_cmd_ok/r63419_wqhd_truly_phantom_2k_cmd_ok.c b/drivers/misc/mediatek/lcm/r63419_wqhd_truly_phantom_2k_cmd_ok/r63419_wqhd_truly_phantom_2k_cmd_ok.c
index 408dd06..23ba576 100644
--- a/drivers/misc/mediatek/lcm/r63419_wqhd_truly_phantom_2k_cmd_ok/r63419_wqhd_truly_phantom_2k_cmd_ok.c
+++ b/drivers/misc/mediatek/lcm/r63419_wqhd_truly_phantom_2k_cmd_ok/r63419_wqhd_truly_phantom_2k_cmd_ok.c
@@ -408,7 +408,7 @@ static void lcm_get_params(LCM_PARAMS *params)
     // Highly depends on LCD driver capability.
     params->dsi.packet_size=256;
 	params->dsi.ssc_disable=0;
-	params->dsi.ssc_range = 3;
+	params->dsi.ssc_range = 1;
     //video mode timing
 
     params->dsi.PS=LCM_PACKED_PS_24BIT_RGB888;
@@ -417,15 +417,18 @@ static void lcm_get_params(LCM_PARAMS *params)
     params->dsi.vertical_backporch					= 4;
     params->dsi.vertical_frontporch					= 8;
     params->dsi.vertical_active_line				= FRAME_HEIGHT;
+	
+	//params->dsi.vertical_frontporch_for_low_power	= 300;
+	
+	params->dsi.horizontal_sync_active				= 10;//;
+	params->dsi.horizontal_backporch				= 30;//hsa+hbp 60~80;
+	params->dsi.horizontal_frontporch				= 60;//>150
 
-    params->dsi.horizontal_sync_active				= 8;//;
-    params->dsi.horizontal_backporch				= 60;//hsa+hbp 60~80;
-    params->dsi.horizontal_frontporch				= 150;//>150
     params->dsi.horizontal_active_pixel				= FRAME_WIDTH;
 #if (LCM_DSI_CMD_MODE)	
-    params->dsi.PLL_CLOCK = 450; //this value must be in MTK suggested table
+    params->dsi.PLL_CLOCK = 423; //this value must be in MTK suggested table
 #else
-    params->dsi.PLL_CLOCK = 480; 
+    params->dsi.PLL_CLOCK = 423; 
 #endif        
     params->dsi.ufoe_enable  = 1;
     params->dsi.ufoe_params.lr_mode_en = 1;
diff --git a/drivers/misc/mediatek/leds/mt6752/leds.c b/drivers/misc/mediatek/leds/mt6752/leds.c
index 099cc55..a593ccf 100644
--- a/drivers/misc/mediatek/leds/mt6752/leds.c
+++ b/drivers/misc/mediatek/leds/mt6752/leds.c
@@ -871,7 +871,6 @@ static void power_switch(int level)
 }
 
 #endif
-
 #ifndef GPIO_CAMERA_FLASH_EN_PIN 
 #define GPIO_CAMERA_FLASH_EN_PIN GPIO143
 #define GPIO_CAMERA_FLASH_EN_PIN_M_GPIO GPIO_MODE_00
diff --git a/drivers/misc/mediatek/lens/Makefile b/drivers/misc/mediatek/lens/Makefile
index 1664a77..03f6e7c 100755
--- a/drivers/misc/mediatek/lens/Makefile
+++ b/drivers/misc/mediatek/lens/Makefile
@@ -108,9 +108,9 @@ else
 					endif
 				endif
 			endif
-						endif
-					endif
-				endif
+		endif
+	endif
+endif
 
 
 
diff --git a/drivers/misc/mediatek/lens/mt6752/dw9714af/DW9714AF.c b/drivers/misc/mediatek/lens/mt6752/dw9714af/DW9714AF.c
index e94cf91..3861ce3 100644
--- a/drivers/misc/mediatek/lens/mt6752/dw9714af/DW9714AF.c
+++ b/drivers/misc/mediatek/lens/mt6752/dw9714af/DW9714AF.c
@@ -33,19 +33,19 @@ static struct i2c_board_info __initdata kd_lens_dev={ I2C_BOARD_INFO(AF_DRVNAME,
 
 static spinlock_t g_AF_SpinLock;
 
-static struct i2c_client * g_pstAF_I2Cclient = NULL;
+static struct i2c_client * g_pstAF_I2Cclient;
 
 static dev_t g_AF_devno;
-static struct cdev * g_pAF_CharDrv = NULL;
-static struct class *actuator_class = NULL;
+static struct cdev * g_pAF_CharDrv;
+static struct class *actuator_class;
 
-static int    g_s4AF_Opened = 0;
-static long g_i4MotorStatus = 0;
-static long g_i4Dir = 0;
-static unsigned long g_u4AF_INF = 0;
+static int g_s4AF_Opened;
+static long g_i4MotorStatus;
+static long g_i4Dir;
+static unsigned long g_u4AF_INF;
 static unsigned long g_u4AF_MACRO = 1023;
-static unsigned long g_u4TargetPosition = 0;
-static unsigned long g_u4CurrPosition    = 0;
+static unsigned long g_u4TargetPosition;
+static unsigned long g_u4CurrPosition;
 
 static int g_sr = 3;
 
@@ -129,7 +129,7 @@ inline static int getAFInfo(__user stDW9714AF_MotorInfo * pstMotorInfo)
 
     return 0;
 }
-
+                                                                    
 #ifdef LensdrvCM3
 inline static int getAFMETA(__user stDW9714AF_MotorMETAInfo * pstMotorMETAInfo)
 {
@@ -218,6 +218,7 @@ inline static int moveAF(unsigned long a_u4Position)
     spin_unlock(&g_AF_SpinLock);
 
     
+    //LOG_INF("move [curr] %d [target] %d\n", g_u4CurrPosition, g_u4TargetPosition);
 
             spin_lock(&g_AF_SpinLock);
             g_sr = 3;
@@ -226,9 +227,9 @@ inline static int moveAF(unsigned long a_u4Position)
 
             if(s4AF_WriteReg((unsigned short)g_u4TargetPosition) == 0)
             {
-                spin_lock(&g_AF_SpinLock);
-                g_u4CurrPosition = (unsigned long)g_u4TargetPosition;
-                spin_unlock(&g_AF_SpinLock);
+		spin_lock(&g_AF_SpinLock);
+		g_u4CurrPosition = (unsigned long)g_u4TargetPosition;
+		spin_unlock(&g_AF_SpinLock);
             }
             else
             {
@@ -238,7 +239,7 @@ inline static int moveAF(unsigned long a_u4Position)
                 g_i4MotorStatus = -1;
                 spin_unlock(&g_AF_SpinLock);
             }
-
+                                                                   
     return 0;
 }
 
@@ -334,13 +335,18 @@ static int AF_Open(struct inode * a_pstInode, struct file * a_pstFile)
     return 0;
 }
 
+/* Main jobs: */
+/* 1.Deallocate anything that "open" allocated in private_data. */
+/* 2.Shut down the device on last close. */
+/* 3.Only called once on last time. */
+/* Q1 : Try release multiple times. */
 //Main jobs:
 // 1.Deallocate anything that "open" allocated in private_data.
 // 2.Shut down the device on last close.
 // 3.Only called once on last time.
 // Q1 : Try release multiple times.
-static int AF_Release(struct inode * a_pstInode, struct file * a_pstFile)
-{
+static int AF_Release(struct inode *a_pstInode, struct file *a_pstFile)
+    {
     LOG_INF("Start \n");
 
     if (g_s4AF_Opened)
@@ -352,13 +358,13 @@ static int AF_Release(struct inode * a_pstInode, struct file * a_pstFile)
         s4AF_WriteReg(100);
         msleep(10);
 
-        spin_lock(&g_AF_SpinLock);
-        g_s4AF_Opened = 0;
-        spin_unlock(&g_AF_SpinLock);
-    }
+		spin_lock(&g_AF_SpinLock);
+		g_s4AF_Opened = 0;
+		spin_unlock(&g_AF_SpinLock);
 
-    LOG_INF("End \n");
+	}
 
+    LOG_INF("End \n");
     return 0;
 }
 
diff --git a/drivers/misc/mediatek/m4u/mt6752/m4u_pgtable.c b/drivers/misc/mediatek/m4u/mt6752/m4u_pgtable.c
index 5cd8849..32a4bca 100644
--- a/drivers/misc/mediatek/m4u/mt6752/m4u_pgtable.c
+++ b/drivers/misc/mediatek/m4u/mt6752/m4u_pgtable.c
@@ -834,7 +834,7 @@ int m4u_map_phys_range(m4u_domain_t *m4u_domain, unsigned int iova,
 		pgsize_idx = __fls(pgsize);
 		pgsize = 1UL << pgsize_idx;
 
-		pr_debug("mapping: iova 0x%x pa 0x%lx pgsize %lu\n", iova,
+		M4ULOG_LOW("mapping: iova 0x%x pa 0x%lx pgsize %lu\n", iova,
 					paddr, pgsize);
 
 		ret = m4u_map_phys_align(m4u_domain, iova, paddr, pgsize, prot);
diff --git a/drivers/misc/mediatek/mach/mt6752/P70/accdet/accdet_custom.c b/drivers/misc/mediatek/mach/mt6752/P70/accdet/accdet_custom.c
index 2a88620..3647955 100644
--- a/drivers/misc/mediatek/mach/mt6752/P70/accdet/accdet_custom.c
+++ b/drivers/misc/mediatek/mach/mt6752/P70/accdet/accdet_custom.c
@@ -11,17 +11,14 @@ struct headset_key_custom* get_headset_key_custom_setting(void)
 	return &headset_key_custom_setting;
 }
 
-#ifdef  ACCDET_MULTI_KEY_FEATURE
+#if defined  ACCDET_EINT || defined ACCDET_EINT_IRQ
 static struct headset_mode_settings cust_headset_settings = {
-	0x900, 0x400, 1, 0x3f0, 0x800, 0x800, 0x20
+	0x900, 0x200, 1, 0x1f0, 0x800, 0x800, 0x20
 };
 #else
-//headset mode register settings(for MT6575)
-//static struct headset_mode_settings cust_headset_settings = {
-//	0x900, 0x400, 1, 0x3f0, 0x3000, 0x3000, 0x20
-//};
+//ACCDET only mode register settings
 static struct headset_mode_settings cust_headset_settings = {
-	0x640, 0x320, 1, 0x3f0, 0x400, 0x400, 0x400
+	0x900, 0x600, 1, 0x5f0, 0x3000, 0x3000, 0x400
 };
 #endif
 
diff --git a/drivers/misc/mediatek/mach/mt6752/P70/accdet/accdet_custom_def.h b/drivers/misc/mediatek/mach/mt6752/P70/accdet/accdet_custom_def.h
index ba612b0..8c320da 100644
--- a/drivers/misc/mediatek/mach/mt6752/P70/accdet/accdet_custom_def.h
+++ b/drivers/misc/mediatek/mach/mt6752/P70/accdet/accdet_custom_def.h
@@ -1,15 +1,26 @@
+// Headset mode MIC define
+typedef enum
+{
+	ACCDET_MIC_MODE_ACC = 1,
+	ACCDET_MIC_MODE_LOW_COST_WITHOUT_IN_BIAS = 2,
+	ACCDET_MIC_MODE_LOW_COST_WITH_IN_BIAS = 6,
+} ACCDET_MIC_MODE;
+#define ACCDET_MIC_MODE	(1)
 // use accdet + EINT solution
 #define ACCDET_EINT
-// support multi_key feature
-//#define ACCDET_MULTI_KEY_FEATURE
-// after 5s disable accdet
-#define ACCDET_LOW_POWER
+#ifndef ACCDET_EINT
+#define ACCDET_EINT_IRQ
+#endif
+//#define ACCDET_PIN_SWAP
 
-//#define ACCDET_PIN_RECOGNIZATION
-//#define ACCDET_28V_MODE
+#define ACCDET_HIGH_VOL_MODE
+#ifdef ACCDET_HIGH_VOL_MODE
+#define ACCDET_MIC_VOL 7     //2.5v
+#else
+#define ACCDET_MIC_VOL 2     //1.9v
+#endif
 
+//#define FOUR_KEY_HEADSET
 #define ACCDET_SHORT_PLUGOUT_DEBOUNCE
 #define ACCDET_SHORT_PLUGOUT_DEBOUNCE_CN 20
 
-//extern struct headset_mode_settings* get_cust_headset_settings(void);
-//extern int get_long_press_time_cust(void);
\ No newline at end of file
diff --git a/drivers/misc/mediatek/mach/mt6752/P70/power/cust_battery_meter.h b/drivers/misc/mediatek/mach/mt6752/P70/power/cust_battery_meter.h
index 1c5185a..7441a1b 100644
--- a/drivers/misc/mediatek/mach/mt6752/P70/power/cust_battery_meter.h
+++ b/drivers/misc/mediatek/mach/mt6752/P70/power/cust_battery_meter.h
@@ -72,7 +72,7 @@
 #define FG_VBAT_AVERAGE_SIZE 18
 #define R_FG_VALUE 			10 // mOhm, base is 20
 
-#define CUST_POWERON_DELTA_CAPACITY_TOLRANCE	35
+#define CUST_POWERON_DELTA_CAPACITY_TOLRANCE	25
 #define CUST_POWERON_LOW_CAPACITY_TOLRANCE		5
 #define CUST_POWERON_MAX_VBAT_TOLRANCE			90
 #define CUST_POWERON_DELTA_VBAT_TOLRANCE		30
diff --git a/drivers/misc/mediatek/mach/mt6752/P70/power/cust_charging.h b/drivers/misc/mediatek/mach/mt6752/P70/power/cust_charging.h
index cfb91a1..1abe398 100644
--- a/drivers/misc/mediatek/mach/mt6752/P70/power/cust_charging.h
+++ b/drivers/misc/mediatek/mach/mt6752/P70/power/cust_charging.h
@@ -53,7 +53,7 @@
 #define BATTERY_AVERAGE_SIZE 	30
 
 /* charger error check */
-#define BAT_LOW_TEMP_PROTECT_ENABLE         // stop charging if temp < MIN_CHARGE_TEMPERATURE
+//#define BAT_LOW_TEMP_PROTECT_ENABLE         // stop charging if temp < MIN_CHARGE_TEMPERATURE
 #define V_CHARGER_ENABLE 0				// 1:ON , 0:OFF	
 #define V_CHARGER_MAX 6500				// 6.5 V
 #define V_CHARGER_MIN 4400				// 4.4 V
diff --git a/drivers/misc/mediatek/mach/mt6752/camera_isp.c b/drivers/misc/mediatek/mach/mt6752/camera_isp.c
index 6079e89..8487be5 100644
--- a/drivers/misc/mediatek/mach/mt6752/camera_isp.c
+++ b/drivers/misc/mediatek/mach/mt6752/camera_isp.c
@@ -9089,11 +9089,13 @@ static __tcmfunc irqreturn_t ISP_Irq_CAM(
 	    /* LOG_INF("warning: fifo may overrun"); */
 	    /* } */
 	    if (IrqStatus[ISP_IRQ_TYPE_INT_STATUSX] & (~STATUSX_WARNING)) {
-		LOG_ERR("ISP INT ERR_P1 0x%x\n", IrqStatus[ISP_IRQ_TYPE_INT_STATUSX]);
+		//LOG_ERR("ISP INT ERR_P1 0x%x\n", IrqStatus[ISP_IRQ_TYPE_INT_STATUSX]);
+		IRQ_LOG_KEEPER(_IRQ,m_CurrentPPB,_LOG_ERR,"ISP INT ERR_P1 0x%x\n", IrqStatus[ISP_IRQ_TYPE_INT_STATUSX]);
 		g_ISPIntErr[_IRQ] |= IrqStatus[ISP_IRQ_TYPE_INT_STATUSX];
 	    }
 	    if (IrqStatus[ISP_IRQ_TYPE_INT_STATUS2X] & (~STATUSX_WARNING)) {
-		LOG_ERR("ISP INT ERR_P1_D 0x%x\n", IrqStatus[ISP_IRQ_TYPE_INT_STATUS2X]);
+		//LOG_ERR("ISP INT ERR_P1_D 0x%x\n", IrqStatus[ISP_IRQ_TYPE_INT_STATUS2X]);
+		IRQ_LOG_KEEPER(_IRQ,m_CurrentPPB,_LOG_ERR,"ISP INT ERR_P1_D 0x%x\n", IrqStatus[ISP_IRQ_TYPE_INT_STATUS2X]);
 		g_ISPIntErr[_IRQ_D] |= IrqStatus[ISP_IRQ_TYPE_INT_STATUS2X];
 	    }
 	}
@@ -9106,7 +9108,8 @@ static __tcmfunc irqreturn_t ISP_Irq_CAM(
 	    d_cur_v_cnt = ((ISP_RD32(ISP_REG_ADDR_TG2_INTER_ST)&0x00FF0000)>>16);
 	if ((IrqStatus[ISP_IRQ_TYPE_INT_P1_ST] & ISP_IRQ_P1_STATUS_PASS1_DON_ST) && (IrqStatus[ISP_IRQ_TYPE_INT_P1_ST] & ISP_IRQ_P1_STATUS_SOF1_INT_ST)) {
 	    if (cur_v_cnt != sof_count[_PASS1])
-		LOG_ERR("isp sof_don block, %d_%d\n", cur_v_cnt, sof_count[_PASS1]);
+		IRQ_LOG_KEEPER(_IRQ,m_CurrentPPB,_LOG_ERR,"isp sof_don block, %d_%d\n", cur_v_cnt, sof_count[_PASS1]);
+		//LOG_ERR("isp sof_don block, %d_%d\n", cur_v_cnt, sof_count[_PASS1]);
 	}
 #endif
 
@@ -9566,12 +9569,14 @@ static void ISP_TaskletFunc(unsigned long data)
 	{
 	    LOG_INF("tks_%d", (sof_count[_PASS1])?(sof_count[_PASS1]-1):(sof_count[_PASS1]));
 	    IRQ_LOG_PRINTER(_IRQ, m_CurrentPPB, _LOG_INF);
+	    IRQ_LOG_PRINTER(_IRQ,m_CurrentPPB,_LOG_ERR);
 	    LOG_INF("tke_%d", (sof_count[_PASS1])?(sof_count[_PASS1]-1):(sof_count[_PASS1]));
 	}
 	if (MTRUE == bRawDEn)
 	{
 	    LOG_INF("dtks_%d", (sof_count[_PASS1_D])?(sof_count[_PASS1_D]-1):(sof_count[_PASS1_D]));
 	    IRQ_LOG_PRINTER(_IRQ_D, m_CurrentPPB, _LOG_INF);
+	    IRQ_LOG_PRINTER(_IRQ_D,m_CurrentPPB,_LOG_ERR);
 	    LOG_INF("dtke_%d", (sof_count[_PASS1_D])?(sof_count[_PASS1_D]-1):(sof_count[_PASS1_D]));
 	}
     }
diff --git a/drivers/misc/mediatek/mach/mt6752/include/mach/board.h b/drivers/misc/mediatek/mach/mt6752/include/mach/board.h
index ea26570..2cc552d 100644
--- a/drivers/misc/mediatek/mach/mt6752/include/mach/board.h
+++ b/drivers/misc/mediatek/mach/mt6752/include/mach/board.h
@@ -24,7 +24,7 @@ typedef void (*pm_callback_t)(pm_message_t state, void *data);
 #endif
 #define MSDC_HS400          (1 <<13)  /* HS400 speed mode support      */
 
-#define MSDC_SD_NEED_POWER  (1 << 31) /* for Yecon board, need SD power always on!! or cannot recognize the sd card*/
+#define MSDC_SD_NEED_POWER  (1 << 31) /* for some board, need SD power always on!! or cannot recognize the sd card*/
 
 #define MSDC_SMPL_RISING    (0)
 #define MSDC_SMPL_FALLING   (1)
diff --git a/drivers/misc/mediatek/mach/mt6752/include/mach/hw_watchpoint.h b/drivers/misc/mediatek/mach/mt6752/include/mach/hw_watchpoint.h
index ed3cc1c..5077dcc 100644
--- a/drivers/misc/mediatek/mach/mt6752/include/mach/hw_watchpoint.h
+++ b/drivers/misc/mediatek/mach/mt6752/include/mach/hw_watchpoint.h
@@ -1,12 +1,12 @@
 #ifndef __HW_BREAKPOINT_H
 #define __HW_BREAKPOINT_H
 
-typedef int (*wp_handler)(unsigned int addr);
+typedef int (*wp_handler)(unsigned long addr);
 
 struct wp_event
 {
-    unsigned int virt;
-    unsigned int phys;
+    unsigned long virt;
+    unsigned long phys;
     int type;
     wp_handler handler;
     int in_use;
diff --git a/drivers/misc/mediatek/mach/mt6752/include/mach/mt_spm.h b/drivers/misc/mediatek/mach/mt6752/include/mach/mt_spm.h
index a3001f2..6eafa6a 100644
--- a/drivers/misc/mediatek/mach/mt6752/include/mach/mt_spm.h
+++ b/drivers/misc/mediatek/mach/mt6752/include/mach/mt_spm.h
@@ -239,7 +239,7 @@ extern u32 spm_irq_7;
 #define SPM_DRAM_RANK1_ADDR_SEL0	(1U << 19)
 #define SPM_DRAM_RANK1_ADDR_SEL1	(1U << 20)
 #define SPM_DRAM_RANK1_ADDR_SEL2	(1U << 21)
-#define SPM_DRAM_RANK1_ADDR_SEL3	(1U << 23)
+
 
 
 #define SPM_WAKE_SRC_LIST	{	\
diff --git a/drivers/misc/mediatek/mach/mt6752/include/mach/mt_thermal.h b/drivers/misc/mediatek/mach/mt6752/include/mach/mt_thermal.h
index 61b302f..c340240 100644
--- a/drivers/misc/mediatek/mach/mt6752/include/mach/mt_thermal.h
+++ b/drivers/misc/mediatek/mach/mt6752/include/mach/mt_thermal.h
@@ -39,7 +39,7 @@ extern void __iomem *INFRACFG_AO_base;
 /*******************************************************************************
  * AUXADC Register Definition
  ******************************************************************************/
-// AUXADC_BASE: 0xF1001000 from Vincent Liang 2014.5.8
+//K2 AUXADC_BASE: 0xF1001000 from Vincent Liang 2014.5.8
 
 #define AUXADC_CON0_V       (AUXADC_BASE_2 + 0x000)	//yes, 0x11003000
 #define AUXADC_CON1_V       (AUXADC_BASE_2 + 0x004)
@@ -116,7 +116,7 @@ extern void __iomem *INFRACFG_AO_base;
 /*******************************************************************************
  * APMixedSys Configuration Register Definition
  ******************************************************************************/
-//APMIXED_BASE: 0x1000C000 from KJ 2014.5.8 // TODO: FIXME
+//K2 APMIXED_BASE: 0x1000C000 from KJ 2014.5.8 // TODO: FIXME
 #define TS_CON0             (APMIXED_BASE_2 + 0x600) //yes 0x10209000
 #define TS_CON1             (APMIXED_BASE_2 + 0x604)
 #define TS_CON0_P           (apmixed_phy_base + 0x600)
diff --git a/drivers/misc/mediatek/mach/mt6752/include/mach/reg_accdet.h b/drivers/misc/mediatek/mach/mt6752/include/mach/reg_accdet.h
index 1f64289..dd8a449 100644
--- a/drivers/misc/mediatek/mach/mt6752/include/mach/reg_accdet.h
+++ b/drivers/misc/mediatek/mach/mt6752/include/mach/reg_accdet.h
@@ -143,8 +143,8 @@
 //#define ACCDET_DEFVAL_SEL        (1<<15)
 */
 //power mode and auxadc switch on/off
-#define ACCDET_1V9_MODE_OFF   0x1A10
-#define ACCDET_2V8_MODE_OFF   0x5A10
-#define ACCDET_1V9_MODE_ON   0x1E10
-#define ACCDET_2V8_MODE_ON   0x5A20
+//#define ACCDET_1V9_MODE_OFF   0x1A10
+//#define ACCDET_2V8_MODE_OFF   0x5A10
+//#define ACCDET_1V9_MODE_ON   0x1E10
+//#define ACCDET_2V8_MODE_ON   0x5A20
 #define ACCDET_SWCTRL_IDLE_EN    (0x07<<4)
diff --git a/drivers/misc/mediatek/mach/mt6752/mt_clkmgr.c b/drivers/misc/mediatek/mach/mt6752/mt_clkmgr.c
index 4d1d852..e23f605 100644
--- a/drivers/misc/mediatek/mach/mt6752/mt_clkmgr.c
+++ b/drivers/misc/mediatek/mach/mt6752/mt_clkmgr.c
@@ -3622,8 +3622,6 @@ static void cg_bootup_pdn(void)
     //MJC
     clk_writel(MJC_CG_SET, MJC_CG);
 }
-
-
 #ifdef MTK_KERNEL_POWER_OFF_CHARGING
 extern BOOTMODE g_boot_mode;
 #endif
@@ -3647,7 +3645,6 @@ static void mt_subsys_init(void)
     for (i = 0; i < NR_SYSS; i++) {
         sys = &syss[i];
         sys->state = sys->ops->get_state(sys);
-
 #ifndef CONFIG_MTK_ECCCI_DRIVER
         if(i==0)
             continue;
@@ -3659,7 +3656,6 @@ static void mt_subsys_init(void)
         }
 #endif
 #endif
-
         if (sys->state != sys->default_sta) {
             clk_info("[%s]%s, change state: (%u->%u)\n", __func__,
                     sys->name, sys->state, sys->default_sta);
diff --git a/drivers/misc/mediatek/mach/mt6752/mt_ptp.c b/drivers/misc/mediatek/mach/mt6752/mt_ptp.c
index 7854064..542bf23 100644
--- a/drivers/misc/mediatek/mach/mt6752/mt_ptp.c
+++ b/drivers/misc/mediatek/mach/mt6752/mt_ptp.c
@@ -112,9 +112,9 @@ static void ptp_init01_finish(struct ptp_det *det);
 #define PTPOD_PMIC_OFFSET (0x10)
 
 
-#define VMAX_VAL		PTP_VOLT_TO_PMIC_VAL(112500)
-#define VMIN_VAL		PTP_VOLT_TO_PMIC_VAL(80000)
-#define VMIN_VAL_GPU	PTP_VOLT_TO_PMIC_VAL(93000)
+#define VMAX_VAL		PTP_VOLT_TO_PMIC_VAL(112500) //K2
+#define VMIN_VAL		PTP_VOLT_TO_PMIC_VAL(80000)  //K2
+#define VMIN_VAL_GPU	PTP_VOLT_TO_PMIC_VAL(93000) //K2
 
 
 #define DTHI_VAL		0x01		/* positive */
@@ -1579,7 +1579,7 @@ static void ptp_set_ptp_volt(struct ptp_det *det)
 	//all scale of volt_tbl_pmic,volt_tbl,volt_offset are pmic value
 	//scale of det->volt_offset must equal 10uV
 	for (i = 0; i < det->num_freq_tbl; i++)
-		det->volt_tbl_pmic[i] = clamp(det->volt_tbl[i] + det->volt_offset + low_temp_offset, det->VMIN+PTPOD_PMIC_OFFSET, det->VMAX+PTPOD_PMIC_OFFSET);
+		det->volt_tbl_pmic[i] = clamp(det->volt_tbl[i] + det->volt_offset + low_temp_offset, det->VMIN, det->VMAX);
 
 	ctrl->volt_update |= PTP_VOLT_UPDATE;
 	wake_up_interruptible(&ctrl->wq);
diff --git a/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/Makefile b/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/Makefile
index fd5c737..5a7dfee 100644
--- a/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/Makefile
+++ b/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/Makefile
@@ -18,12 +18,6 @@ ifeq ($(CONFIG_MTK_HDMI_SUPPORT),y)
 obj-y	+=  hdmi/
 endif
 
-obj-$(CONFIG_CUSTOM_KERNEL_ALSPS) += alsps/
-obj-$(CONFIG_CUSTOM_KERNEL_ACCELEROMETER) += accelerometer/
-obj-$(CONFIG_CUSTOM_KERNEL_GYROSCOPE) += gyroscope/
-obj-$(CONFIG_CUSTOM_KERNEL_MAGNETOMETER) += magnetometer/
-obj-$(CONFIG_CUSTOM_KERNEL_BAROMETER) += barometer/
+#obj-$(CONFIG_CUSTOM_KERNEL_ALSPS) += alsps/
+#obj-$(CONFIG_CUSTOM_KERNEL_ACCELEROMETER) += accelerometer/
 
-ifdef CONFIG_CUSTOM_KERNEL_SENSORHUB
-obj-y	+= sensorHub/
-endif
diff --git a/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/accdet/accdet_custom_def.h b/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/accdet/accdet_custom_def.h
index f6fd0a5..8c320da 100644
--- a/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/accdet/accdet_custom_def.h
+++ b/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/accdet/accdet_custom_def.h
@@ -6,7 +6,6 @@ typedef enum
 	ACCDET_MIC_MODE_LOW_COST_WITH_IN_BIAS = 6,
 } ACCDET_MIC_MODE;
 #define ACCDET_MIC_MODE	(1)
-
 // use accdet + EINT solution
 #define ACCDET_EINT
 #ifndef ACCDET_EINT
@@ -25,4 +24,3 @@ typedef enum
 #define ACCDET_SHORT_PLUGOUT_DEBOUNCE
 #define ACCDET_SHORT_PLUGOUT_DEBOUNCE_CN 20
 
-
diff --git a/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/accelerometer/Makefile b/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/accelerometer/Makefile
index bc0034e..daba818 100755
--- a/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/accelerometer/Makefile
+++ b/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/accelerometer/Makefile
@@ -3,7 +3,10 @@ include $(srctree)/drivers/misc/mediatek/Makefile.custom
 
 # Module project related part
 
-ifeq ($(CONFIG_MTK_MPU6515A),y)
-obj-y	+=  mpu6515/
+ifeq ($(CONFIG_MTK_BMA222E_NEW),y)
+obj-y	+=  bma222E-new/
 endif
 
+ifeq ($(CONFIG_MTK_KXTJ2_1009_NEW),y)
+obj-y	+=  KXTJ2_1009-new/
+endif
diff --git a/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/alsps/Makefile b/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/alsps/Makefile
index ce1cf63..a8ff6fb 100755
--- a/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/alsps/Makefile
+++ b/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/alsps/Makefile
@@ -3,7 +3,7 @@ include $(srctree)/drivers/misc/mediatek/Makefile.custom
 
 # Module project related part
 
-ifeq ($(CONFIG_MTK_CM36652_NEW),y)
-obj-y	+=  cm36652-new/
+ifeq ($(CONFIG_MTK_STK3X1X),y)
+obj-y	+=  stk3x1x/
 endif
 
diff --git a/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/camera/camera/kd_camera_hw.c b/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/camera/camera/kd_camera_hw.c
index 2f18057..eb674d5 100644
--- a/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/camera/camera/kd_camera_hw.c
+++ b/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/camera/camera/kd_camera_hw.c
@@ -122,6 +122,32 @@ PowerUp PowerOnList={
                 {RST,   Vol_High, 0},
             },
         },
+		{SENSOR_DRVNAME_OV13850_MIPI_RAW,
+			{
+				{SensorMCLK,Vol_High, 0},
+				{RST,   Vol_Low,  4},//==pdn
+				{PDN,   Vol_Low,  1},//==rst
+				{DOVDD, Vol_1800, 0},
+				{RST,   Vol_High, 3},//==pdn
+				{AVDD,  Vol_2800, 3},
+				{DVDD,  VOL_1200, 10},
+				{AFVDD, Vol_2800, 5},
+				{PDN,   Vol_High, 0},
+			},
+		},
+		{SENSOR_DRVNAME_OV5670_MIPI_RAW,
+			{
+				{SensorMCLK,Vol_High, 0},
+				{PDN,   Vol_Low,  4},
+				{RST,   Vol_Low,  1},
+				{DOVDD, Vol_1800, 0},				
+				{PDN,   Vol_High, 3},
+				{AVDD,  Vol_2800, 3},
+				{DVDD,  Vol_1200, 10},
+				{AFVDD, Vol_2800, 5},
+				{RST,   Vol_High, 0},
+			},
+		},
         {SENSOR_DRVNAME_OV5648_MIPI_RAW,
             {
                 {SensorMCLK,Vol_High, 0},
@@ -426,6 +452,10 @@ BOOL hwpowerdown(PowerInformation pwInfo, char* mode_name)
 
         if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
         if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
+     #if 1
+	    if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");}
+			msleep(2);
+	 #else
         if(pwInfo.Voltage == Vol_High)
         {           
             if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");}
@@ -436,6 +466,7 @@ BOOL hwpowerdown(PowerInformation pwInfo, char* mode_name)
             if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");}
             msleep(1);
         }
+	 #endif
     }
     else if(pwInfo.PowerType==RST)
     {
@@ -446,14 +477,17 @@ BOOL hwpowerdown(PowerInformation pwInfo, char* mode_name)
         if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
         if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
         if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
-        if(pwInfo.Voltage == Vol_High)
-        {           
-            if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");}
-        }
-        else
-        {           
-            if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");}
-        }
+        msleep(2);
+	 #if 0
+		if(pwInfo.Voltage == Vol_High)
+		{			
+			if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");}
+		}
+		else
+		{			
+			if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");}
+		}
+	  #endif
 #else
         if(mt6306_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
         if(pwInfo.Voltage == Vol_High)
@@ -470,14 +504,17 @@ BOOL hwpowerdown(PowerInformation pwInfo, char* mode_name)
             if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
             if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
             if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
-            if(pwInfo.Voltage == Vol_High)
-            {           
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");}
-            }
-            else
-            {           
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");}
-            }
+         	msleep(2);
+		 #if 0
+			if(pwInfo.Voltage == Vol_High)
+			{			
+				if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");}
+			}
+			else
+			{			
+				if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");}
+			}
+		 #endif
         }
 
     }
diff --git a/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/dct/dct/codegen.dws b/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/dct/dct/codegen.dws
old mode 100755
new mode 100644
index 5c7250c..f89ae8a
Binary files a/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/dct/dct/codegen.dws and b/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/dct/dct/codegen.dws differ
diff --git a/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/leds/mt65xx/cust_leds.c b/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/leds/mt65xx/cust_leds.c
index e5d55be..0ccb920 100644
--- a/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/leds/mt65xx/cust_leds.c
+++ b/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/leds/mt65xx/cust_leds.c
@@ -103,14 +103,20 @@ unsigned int brightness_mapping(unsigned int level)
  *By default, clock_source = 0 and div = 0 => PWM freq. = 26 KHz 
  *-------------------------------------------------------------------------------------------
  */
+
+#ifndef GPIO_CAMERA_FLASH_MODE_PIN 
+#define GPIO_CAMERA_FLASH_MODE_PIN GPIO144
+#endif
+
 static struct cust_mt65xx_led cust_led_list[MT65XX_LED_TYPE_TOTAL] = {
-	{"red",               MT65XX_LED_MODE_NONE, -1,{0}},
-	{"green",             MT65XX_LED_MODE_NONE, -1,{0}},
+	{"red",               MT65XX_LED_MODE_PMIC, MT65XX_LED_PMIC_NLED_ISINK3,{0}},
+	{"green",             MT65XX_LED_MODE_PMIC, MT65XX_LED_PMIC_NLED_ISINK0,{0}},
 	{"blue",              MT65XX_LED_MODE_NONE, -1,{0}},
 	{"jogball-backlight", MT65XX_LED_MODE_NONE, -1,{0}},
 	{"keyboard-backlight",MT65XX_LED_MODE_NONE, -1,{0}},
-	{"button-backlight",  MT65XX_LED_MODE_NONE, -1,{0}},
+	{"button-backlight",  MT65XX_LED_MODE_PMIC, MT65XX_LED_PMIC_NLED_ISINK1,{0}},
 	{"lcd-backlight",     MT65XX_LED_MODE_CUST_BLS_PWM, (long)disp_bls_set_backlight,{0}},
+    {"torch",             MT65XX_LED_MODE_GPIO, GPIO_CAMERA_FLASH_MODE_PIN,{0}}
 };
 
 struct cust_mt65xx_led *get_cust_led_list(void)
diff --git a/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/leds/mt65xx/cust_leds.h b/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/leds/mt65xx/cust_leds.h
index 2fd2873..f8b63c3 100644
--- a/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/leds/mt65xx/cust_leds.h
+++ b/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/leds/mt65xx/cust_leds.h
@@ -11,6 +11,7 @@ enum mt65xx_led_type
 	MT65XX_LED_TYPE_KEYBOARD,
 	MT65XX_LED_TYPE_BUTTON,	
 	MT65XX_LED_TYPE_LCD,
+	MT65XX_LED_TYPE_TORCH,
 	MT65XX_LED_TYPE_TOTAL,
 };
 
diff --git a/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/power/cust_battery_meter.h b/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/power/cust_battery_meter.h
index b25bc2a..7441a1b 100644
--- a/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/power/cust_battery_meter.h
+++ b/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/power/cust_battery_meter.h
@@ -37,15 +37,15 @@
 #define FG_METER_RESISTANCE 	0
 
 /* Qmax for battery  */
-#define Q_MAX_POS_50	2500
-#define Q_MAX_POS_25	2432
-#define Q_MAX_POS_0		2244
-#define Q_MAX_NEG_10	1654
-
-#define Q_MAX_POS_50_H_CURRENT	2500
-#define Q_MAX_POS_25_H_CURRENT	2390
-#define Q_MAX_POS_0_H_CURRENT	1814
-#define Q_MAX_NEG_10_H_CURRENT	696
+#define Q_MAX_POS_50	3938//2500
+#define Q_MAX_POS_25	3932//2432
+#define Q_MAX_POS_0	    3913//2244
+#define Q_MAX_NEG_10	3988//1654
+
+#define Q_MAX_POS_50_H_CURRENT	3907//2500
+#define Q_MAX_POS_25_H_CURRENT	3903//2390
+#define Q_MAX_POS_0_H_CURRENT	3714//1814
+#define Q_MAX_NEG_10_H_CURRENT	3338//696
 
 
 /* Discharge Percentage */
diff --git a/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/power/cust_battery_meter_table.h b/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/power/cust_battery_meter_table.h
index 81e8800..620d96a 100644
--- a/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/power/cust_battery_meter_table.h
+++ b/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/power/cust_battery_meter_table.h
@@ -78,9 +78,9 @@ typedef enum
         { 35,6948},
         { 40,5834},
         { 45,4917},
-        { 50,4161},
-        { 55,3535},
-        { 60,3014}
+        { 50,3600},
+        { 55,3135},
+        { 60,2614}
     };
 #endif
 
@@ -109,334 +109,354 @@ typedef enum
 // T0 -10C
 BATTERY_PROFILE_STRUC battery_profile_t0[] =
 {
-	{0   , 4240},         
-	{3   , 4206},         
-	{6   , 4172},         
-	{9   , 4138},         
-	{12  , 4104},         
-	{15  , 4078},         
-	{18  , 4053},         
-	{21  , 4023},         
-	{24  , 3999},         
-	{27  , 3978},         
-	{30  , 3962},         
-	{33  , 3945},         
-	{36  , 3925},         
-	{39  , 3908},         
-	{42  , 3891},         
-	{45  , 3876},         
-	{48  , 3862},         
-	{51  , 3851},         
-	{54  , 3840},         
-	{57  , 3831},         
-	{60  , 3824},         
-	{63  , 3815},         
-	{66  , 3809},         
-	{69  , 3804},         
-	{72  , 3799},         
-	{75  , 3793},         
-	{78  , 3790},         
-	{81  , 3787},         
-	{83  , 3784},         
-	{85  , 3781},         
-	{86  , 3779},         
-	{87  , 3776},         
-	{89  , 3774},         
-	{89  , 3772},         
-	{90  , 3771},         
-	{91  , 3768},         
-	{92  , 3767},         
-	{92  , 3767},         
-	{93  , 3764},         
-	{93  , 3762},         
-	{94  , 3763},         
-	{94  , 3760},         
-	{95  , 3759},         
-	{95  , 3759},         
-	{95  , 3758},         
-	{96  , 3757},         
-	{96  , 3756},         
-	{96  , 3755},         
-	{96  , 3753},         
-	{97  , 3753},         
-	{97  , 3751},         
-	{97  , 3750},         
-	{97  , 3749},         
-	{97  , 3749},         
-	{97  , 3748},         
-	{98  , 3747},         
-	{98  , 3745},         
-	{98  , 3746},         
-	{98  , 3744},         
-	{98  , 3745},         
-	{98  , 3743},          
-  {98  , 3742},
-  {99  , 3742},
-  {99  , 3740},
-  {99  , 3740},
-  {99  , 3739},
-  {99  , 3740},
-  {99  , 3739},
-  {99  , 3739},
-  {99  , 3738},
-	{100 , 3736}, 
-	{100 , 3737},
-	{100 , 3737},
-	{100 , 3735},
-	{100 , 3735},
-	{100 , 3734}, 
-	{100 , 3734}	       
+    {1 ,	4337},
+    {3 ,	4315},
+    {4 ,	4294},
+    {5 ,	4278},
+    {6 ,	4263},
+    {8 ,	4248},
+    {9 ,	4233},
+    {10 ,	4219},
+    {11 ,	4206},
+    {13 ,	4193},
+    {14 ,	4180},
+    {15 ,	4168},
+    {16 ,	4156},
+    {18 ,	4143},
+    {19 ,	4129},
+    {20 ,	4116},
+    {21 ,	4104},
+    {23 ,	4092},
+    {24 ,	4085},
+    {25 ,	4077},
+    {27 ,	4067},
+    {28 ,	4049},
+    {29 ,	4023},
+    {30 ,	3996},
+    {32 ,	3976},
+    {33 ,	3961},
+    {34 ,	3948},
+    {35 ,	3938},
+    {37 ,	3928},
+    {38 ,	3920},
+    {39 ,	3914},
+    {40 ,	3905},
+    {42 ,	3899},
+    {43 ,	3889},
+    {44 ,	3880},
+    {45 ,	3871},
+    {47 ,	3864},
+    {48 ,	3856},
+    {49 ,	3849},
+    {50 ,	3842},
+    {52 ,	3835},
+    {53 ,	3829},
+    {54 ,	3823},
+    {56 ,	3817},
+    {57 ,	3813},
+    {58 ,	3808},
+    {59 ,	3803},
+    {61 ,	3798},
+    {62 ,	3794},
+    {63 ,	3791},
+    {64 ,	3787},
+    {66 ,	3785},
+    {67 ,	3783},
+    {68 ,	3780},
+    {69 ,	3779},
+    {69 ,	3776},
+    {71 ,	3775},
+    {72 ,	3771},
+    {73 ,	3768},
+    {74 ,	3765},
+    {76 ,	3762},
+    {77 ,	3759},
+    {78 ,	3755},
+    {80 ,	3750},
+    {81 ,	3746},
+    {82 ,	3740},
+    {83 ,	3735},
+    {85 ,	3729},
+    {86 ,	3723},
+    {87 ,	3715},
+    {88 ,	3706},
+    {90 ,	3700},
+    {91 ,	3695},
+    {92 ,	3691},
+    {93 ,	3687},
+    {95 ,	3681},
+    {96 ,	3667},
+    {97 ,	3634},
+    {98 ,	3579},
+    {100 ,	3502},
+    {100 ,	3371}
 };      
         
 // T1 0C 
 BATTERY_PROFILE_STRUC battery_profile_t1[] =
 {
-	{0   , 4291},         
-	{2   , 4258},         
-	{4   , 4234},         
-	{7   , 4210},         
-	{9   , 4187},         
-	{11  , 4165},         
-	{13  , 4145},         
-	{16  , 4122},         
-	{18  , 4103},         
-	{20  , 4086},         
-	{22  , 4066},         
-	{24  , 4042},         
-	{27  , 4016},         
-	{29  , 3995},         
-	{31  , 3976},         
-	{33  , 3956},         
-	{36  , 3935},         
-	{38  , 3916},         
-	{40  , 3899},         
-	{42  , 3884},         
-	{45  , 3869},         
-	{47  , 3858},         
-	{49  , 3848},         
-	{51  , 3839},         
-	{53  , 3830},         
-	{56  , 3821},         
-	{58  , 3813},         
-	{60  , 3805},         
-	{62  , 3799},         
-	{65  , 3794},         
-	{67  , 3789},         
-	{69  , 3783},         
-	{71  , 3779},         
-	{73  , 3774},         
-	{76  , 3766},         
-	{78  , 3757},         
+    {0 ,    4336},
+    {1 ,    4306},
+    {3 ,    4289},
+    {4 ,    4273},
+    {5 ,    4259},
+    {6 ,    4244},
+    {8 ,    4231},
+    {9 ,    4217},
+    {10 ,   4205},
+    {11 ,   4192},
+    {13 ,   4178},
+    {14 ,   4164},
+    {15 ,   4152},
+    {17 ,   4139},
+    {18 ,   4126},
+    {19 ,   4112},
+    {20 ,   4100},
+    {22 ,   4088},
+    {23 ,   4080},
+    {24 ,   4074},
+    {25 ,   4063},
+    {27 ,   4043},
+    {28 ,   4017},
+    {29 ,   3993},
+    {30 ,   3976},
+    {32 ,   3964},
+    {33 ,   3953},
+    {34 ,   3943},
+    {36 ,   3936},
+    {37 ,   3930},
+    {38 ,   3921},
+    {39 ,   3911},
+    {41 ,   3901},
+    {42 ,   3890},
+    {43 ,   3881},
+    {44 ,   3872},
+    {46 ,   3863},
+    {47 ,   3856},
+    {48 ,   3848},
+    {50 ,   3841},
+    {51 ,   3835},
+    {52 ,   3829},
+    {53 ,   3822},
+    {55 ,   3817},
+    {56 ,   3813},
+    {57 ,   3808},
+    {58 ,   3803},
+    {60 ,   3799},
+    {61 ,   3795},
+    {62 ,   3792},
+    {64 ,   3788},
+    {65 ,   3785},
+    {66 ,   3782},
+    {67 ,   3779},
+    {69 ,   3777},
+    {70 ,   3775},
+    {71 ,   3772},
+    {72 ,   3769},
+    {74 ,   3766},
+    {75 ,   3763},
+    {76 ,   3759},
+    {77 ,   3755},
+    {79 ,   3751},
 	{80  , 3747},         
-	{82  , 3733},         
-	{85  , 3717},         
-	{87  , 3708},         
-	{89  , 3701},         
-	{91  , 3697},         
-	{93  , 3692},         
-	{95  , 3676},         
-	{96  , 3656},         
-	{97  , 3638},         
-	{98  , 3623},         
-	{98  , 3610},         
-	{98  , 3600},         
-	{98  , 3594},         
-	{99  , 3588},         
-	{99  , 3582},         
-	{99  , 3576},         
-	{99  , 3572},         
-	{99  , 3567},         
-	{99  , 3565},         
-	{99  , 3562},         
-	{99  , 3558},         
-  {99  , 3555},
-	{99  , 3553},         
-	{99  , 3551},          
-  {100 , 3547},
-  {100 , 3545},
-  {100 , 3544},
-  {100 , 3542},
-  {100 , 3540},
-  {100 , 3537},
-  {100 , 3536},
-  {100 , 3534},
-  {100 , 3532},
-	{100 , 3529}, 
-	{100 , 3528},
-	{100 , 3526},
-	{100 , 3524},
-	{100 , 3522},
-	{100 , 3521}, 
-	{100 , 3519}	       
+    {81 ,   3741},
+    {83 ,   3735},
+    {84 ,   3729},
+    {85 ,   3722},
+    {86 ,   3714},
+    {88 ,   3704},
+    {89 ,   3696},
+    {90 ,   3692},
+    {91 ,   3690},
+    {93 ,   3686},
+    {94 ,   3681},
+    {95 ,   3665},
+    {97 ,   3619},
+    {98 ,   3550},
+    {99 ,   3449},
+    {100 ,  3264},
+    {100 ,  3109}
 };           
 
 // T2 25C
 BATTERY_PROFILE_STRUC battery_profile_t2[] =
 {
-	{0   , 4330},         
-	{2   , 4303},         
-	{4   , 4281},         
-	{6   , 4258},         
-	{8   , 4235},         
+    {0 ,    4339},
+    {1 ,    4319},
+    {3 ,    4301},
+    {4 ,    4285},
+    {5 ,    4270},
+    {6 ,    4256},
+    {8 ,    4241},
+    {9 ,    4226},
 	{10  , 4212},         
-	{12  , 4191},         
-	{14  , 4168},         
-	{16  , 4147},         
-	{18  , 4126},         
-	{20  , 4106},         
-	{22  , 4086},         
+    {11 ,   4199},
+    {13 ,   4185},
+    {14 ,   4171},
+    {15 ,   4158},
+    {17 ,   4145},
+    {18 ,   4131},
+    {19 ,   4118},
+    {20 ,   4104},
+    {22 ,   4092},
+    {23 ,   4080},
 	{24  , 4070},         
-	{27  , 4047},         
-	{29  , 4026},         
-	{31  , 4006},         
-	{33  , 3988},         
-	{35  , 3974},         
-	{37  , 3960},         
-	{39  , 3944},         
-	{41  , 3925},         
-	{43  , 3900},         
-	{45  , 3880},         
-	{47  , 3865},         
-	{49  , 3853},         
-	{51  , 3843},         
-	{53  , 3834},         
-	{55  , 3825},         
-	{57  , 3817},         
-	{59  , 3810},         
-	{61  , 3803},         
-	{63  , 3796},         
-	{65  , 3791},         
-	{67  , 3786},         
-	{69  , 3781},         
-	{71  , 3777},         
-	{73  , 3772},         
-	{75  , 3766},         
-	{77  , 3757},         
-	{80  , 3748},         
-	{82  , 3738},         
-	{84  , 3722},         
-	{86  , 3702},         
-	{88  , 3692},         
-	{90  , 3689},         
-	{92  , 3686},         
-	{94  , 3682},         
-	{96  , 3655},         
-	{98  , 3564},         
-	{100 , 3411},         
-	{100 , 3354},         
-	{100 , 3339},         
-	{100 , 3330},         
-	{100 , 3322},         
-	{100 , 3315},         
-	{100 , 3310},         
-	{100 , 3304},         
-	{100 , 3301},         
-	{100 , 3299},         
-	{100 , 3296},         
-	{100 , 3293},          
-  {100 , 3291},
-  {100 , 3290},
-  {100 , 3288},
-  {100 , 3286},
-  {100 , 3283},
-  {100 , 3281},
-  {100 , 3279},
-  {100 , 3276},
-  {100 , 3275},
-	{100 , 3272}, 
-	{100 , 3268},
-	{100 , 3267},
-	{100 , 3263},
-	{100 , 3261},
-	{100 , 3257},
-	{100 , 3255}	       
+    {26 ,   4064},
+    {27 ,   4054},
+    {28 ,   4033},
+    {29 ,   4011},
+    {31 ,   3994},
+    {32 ,   3981},
+    {33 ,   3973},
+    {34 ,   3969},
+    {36 ,   3964},
+    {37 ,   3955},
+    {38 ,   3944},
+    {40 ,   3934},
+    {41 ,   3924},
+    {42 ,   3909},
+    {43 ,   3896},
+    {45 ,   3881},
+    {46 ,   3871},
+    {47 ,   3862},
+    {49 ,   3854},
+    {50 ,   3847},
+    {51 ,   3840},
+    {52 ,   3834},
+    {54 ,   3827},
+    {55 ,   3822},
+    {56 ,   3817},
+    {57 ,   3811},
+    {59 ,   3808},
+    {60 ,   3802},
+    {61 ,   3798},
+    {63 ,   3795},
+    {64 ,   3791},
+    {65 ,   3787},
+    {66 ,   3784},
+    {68 ,   3781},
+    {69 ,   3777},
+    {70 ,   3774},
+    {71 ,   3768},
+    {73 ,   3764},
+    {74 ,   3759},
+    {75 ,   3754},
+    {77 ,   3749},
+    {78 ,   3744},
+    {79 ,   3740},
+    {80 ,   3735},
+    {82 ,   3732},
+    {83 ,   3726},
+    {84 ,   3720},
+    {86 ,   3712},
+    {87 ,   3706},
+    {88 ,   3698},
+    {89 ,   3689},
+    {91 ,   3685},
+    {92 ,   3683},
+    {93 ,   3682},
+    {94 ,   3679},
+    {96 ,   3670},
+    {97 ,   3632},
+    {98 ,   3571},
+    {100 ,  3488},
+    {100 ,  3353},
+    {100 ,  3053}
 };     
 
 // T3 50C
 BATTERY_PROFILE_STRUC battery_profile_t3[] =
 {
-	{0   , 4338},         
-	{2   , 4315},         
-	{4   , 4292},         
-	{6   , 4270},         
-	{8   , 4247},         
-	{10  , 4225},         
-	{12  , 4202},         
-	{15  , 4180},         
-	{17  , 4158},         
-	{19  , 4138},         
-	{21  , 4116},         
-	{23  , 4096},         
-	{25  , 4076},         
-	{27  , 4058},         
-	{29  , 4038},         
-	{31  , 4020},         
-	{33  , 4001},         
-	{35  , 3985},         
-	{37  , 3968},         
-	{39  , 3951},         
-	{41  , 3928},         
-	{44  , 3904},         
-	{46  , 3887},         
-	{48  , 3872},         
-	{50  , 3862},         
-	{52  , 3851},         
-	{54  , 3840},         
-	{56  , 3831},         
-	{58  , 3822},         
-	{60  , 3814},         
-	{62  , 3805},         
-	{64  , 3798},         
-	{66  , 3791},         
-	{68  , 3784},         
-	{70  , 3772},         
-	{73  , 3760},         
-	{75  , 3753},         
-	{77  , 3742},         
-	{79  , 3734},         
-	{81  , 3726},         
-	{83  , 3711},         
-	{85  , 3694},         
-	{87  , 3679},         
-	{89  , 3675},         
-	{91  , 3673},         
-	{93  , 3669},         
-	{95  , 3652},         
-	{97  , 3576},         
-	{100 , 3453},         
-	{100 , 3283},         
-	{100 , 3260},         
-	{100 , 3247},         
-	{100 , 3244},         
-	{100 , 3243},         
-	{100 , 3242},         
-	{100 , 3241},         
-	{100 , 3240},         
-	{100 , 3237},         
-	{100 , 3235},         
-	{100 , 3235},         
-	{100 , 3234},          
-  {100 , 3232},
-  {100 , 3230},
-  {100 , 3230},
-  {100 , 3227},
-  {100 , 3225},
-  {100 , 3224},
-  {100 , 3222},
-  {100 , 3222},
-  {100 , 3220},
-	{100 , 3217}, 
-	{100 , 3216},
-	{100 , 3215},
-	{100 , 3212},
-	{100 , 3211},
-	{100 , 3209},
-	{100 , 3207}	       
+    {0 ,    4339},
+    {1 ,    4308},
+    {3 ,    4291},
+    {4 ,    4276},
+    {5 ,    4260},
+    {6 ,    4246},
+    {8 ,    4231},
+    {9 ,    4217},
+    {10 ,   4203},
+    {12 ,   4190},
+    {13 ,   4174},
+    {14 ,   4162},
+    {15 ,   4149},
+    {17 ,   4135},
+    {18 ,   4122},
+    {19 ,   4109},
+    {20 ,   4095},
+    {22 ,   4083},
+    {23 ,   4071},
+    {24 ,   4058},
+    {26 ,   4046},
+    {27 ,   4035},
+    {28 ,   4023},
+    {29 ,   4010},
+    {31 ,   3999},
+    {32 ,   3988},
+    {33 ,   3978},
+    {35 ,   3969},
+    {36 ,   3958},
+    {37 ,   3949},
+    {38 ,   3939},
+    {40 ,   3930},
+    {41 ,   3920},
+    {42 ,   3908},
+    {43 ,   3894},
+    {45 ,   3877},
+    {46 ,   3867},
+    {47 ,   3859},
+    {49 ,   3851},
+    {50 ,   3843},
+    {51 ,   3837},
+    {52 ,   3829},
+    {54 ,   3823},
+    {55 ,   3818},
+    {56 ,   3813},
+    {58 ,   3808},
+    {59 ,   3804},
+    {60 ,   3799},
+    {61 ,   3794},
+    {63 ,   3790},
+    {64 ,   3786},
+    {65 ,   3782},
+    {66 ,   3779},
+    {68 ,   3777},
+    {69 ,   3772},
+    {70 ,   3768},
+    {72 ,   3762},
+    {73 ,   3752},
+    {74 ,   3744},
+    {75 ,   3740},
+    {77 ,   3734},
+    {78 ,   3729},
+    {79 ,   3716},
+    {81 ,   3720},
+    {82 ,   3717},
+    {83 ,   3710},
+    {84 ,   3704},
+    {86 ,   3697},
+    {87 ,   3691},
+    {88 ,   3683},
+    {89 ,   3674},
+    {91 ,   3671},
+    {92 ,   3669},
+    {93 ,   3667},
+    {95 ,   3665},
+    {96 ,   3656},
+    {97 ,   3620},
+    {98 ,   3564},
+    {100 ,  3488},
+    {100 ,  3373},
+    {100 ,  3143}
 };           
 
 // battery profile for actual temperature. The size should be the same as T1, T2 and T3
 BATTERY_PROFILE_STRUC battery_profile_temperature[] =
 {
+    {0, 0},
+    {0, 0},
+    {0, 0},
+    {0, 0},
   {0  , 0 },
 	{0  , 0 },
 	{0  , 0 },
@@ -522,334 +542,354 @@ BATTERY_PROFILE_STRUC battery_profile_temperature[] =
 // T0 -10C
 R_PROFILE_STRUC r_profile_t0[] =
 {
-	{953  , 4240},         
-	{953  , 4206},         
-	{970  , 4172},         
-	{998  , 4138},         
-	{1060 , 4104},         
-	{1143 , 4078},         
-	{1175 , 4053},         
-	{1185 , 4023},         
-	{1195 , 3999},         
-	{1198 , 3978},         
-	{1208 , 3962},         
-	{1220 , 3945},         
-	{1220 , 3925},         
-	{1220 , 3908},         
-	{1230 , 3891},         
-	{1235 , 3876},         
-	{1245 , 3862},         
-	{1255 , 3851},         
-	{1263 , 3840},         
-	{1280 , 3831},         
-	{1298 , 3824},         
-	{1310 , 3815},         
-	{1330 , 3809},         
-	{1348 , 3804},         
-	{1373 , 3799},         
-	{1395 , 3793},         
-	{1430 , 3790},         
-	{1470 , 3787},         
-	{1463 , 3784},         
-	{1453 , 3781},         
-	{1450 , 3779},         
-	{1440 , 3776},         
-	{1438 , 3774},         
-	{1433 , 3772},         
-	{1430 , 3771},         
-	{1423 , 3768},         
-	{1418 , 3767},         
-	{1423 , 3767},         
-	{1413 , 3764},         
-	{1405 , 3762},         
-	{1410 , 3763},         
-	{1400 , 3760},         
-	{1398 , 3759},         
-	{1400 , 3759},         
-	{1395 , 3758},         
-	{1395 , 3757},         
-	{1393 , 3756},         
-	{1390 , 3755},         
-	{1383 , 3753},         
-	{1385 , 3753},         
-	{1378 , 3751},         
-	{1378 , 3750},         
-	{1375 , 3749},         
-	{1375 , 3749},         
-	{1373 , 3748},         
-	{1373 , 3747},         
-	{1365 , 3745},         
-	{1368 , 3746},         
-	{1363 , 3744},         
-	{1365 , 3745},         
-	{1360 , 3743},          
-  {1363 , 3742},
-  {1358 , 3742},
-  {1353 , 3740},
-  {1350 , 3740},
-  {1353 , 3739},
-  {1360 , 3740},
-  {1358 , 3739},
-  {1348 , 3739},
-  {1350 , 3738},
-	{1345 , 3736}, 
-	{1345 , 3737},
-	{1345 , 3737},
-	{1343 , 3735},
-	{1340 , 3735},
-	{1345 , 3734}, 
-	{1338 , 3734}	       
+    {710 ,  4337},
+    {710 ,  4315},
+    {698 ,  4294},
+    {698 ,  4278},
+    {693 ,  4263},
+    {683 ,  4248},
+    {673 ,  4233},
+    {665 ,  4219},
+    {660 ,  4206},
+    {658 ,  4193},
+    {650 ,  4180},
+    {645 ,  4168},
+    {635 ,  4156},
+    {625 ,  4143},
+    {613 ,  4129},
+    {600 ,  4116},
+    {585 ,  4104},
+    {575 ,  4092},
+    {585 ,  4085},
+    {593 ,  4077},
+    {600 ,  4067},
+    {588 ,  4049},
+    {565 ,  4023},
+    {540 ,  3996},
+    {535 ,  3976},
+    {528 ,  3961},
+    {523 ,  3948},
+    {520 ,  3938},
+    {520 ,  3928},
+    {525 ,  3920},
+    {530 ,  3914},
+    {528 ,  3905},
+    {535 ,  3899},
+    {533 ,  3889},
+    {530 ,  3880},
+    {533 ,  3871},
+    {543 ,  3864},
+    {545 ,  3856},
+    {548 ,  3849},
+    {550 ,  3842},
+    {555 ,  3835},
+    {555 ,  3829},
+    {560 ,  3823},
+    {565 ,  3817},
+    {570 ,  3813},
+    {578 ,  3808},
+    {583 ,  3803},
+    {585 ,  3798},
+    {590 ,  3794},
+    {598 ,  3791},
+    {600 ,  3787},
+    {608 ,  3785},
+    {615 ,  3783},
+    {623 ,  3780},
+    {633 ,  3779},
+    {638 ,  3776},
+    {653 ,  3775},
+    {660 ,  3771},
+    {673 ,  3768},
+    {683 ,  3765},
+    {695 ,  3762},
+    {713 ,  3759},
+    {730 ,  3755},
+    {743 ,  3750},
+    {763 ,  3746},
+    {783 ,  3740},
+    {805 ,  3735},
+    {833 ,  3729},
+    {863 ,  3723},
+    {893 ,  3715},
+    {928 ,  3706},
+    {970 ,  3700},
+    {1025 , 3695},
+    {1093 , 3691},
+    {1178 , 3687},
+    {1288 , 3681},
+    {1415 , 3667},
+    {1568 , 3634},
+    {1743 , 3579},
+    {1908 , 3502},
+    {2055 , 3371}
 };      
 
 // T1 0C
 R_PROFILE_STRUC r_profile_t1[] =
 {
-	{425  , 4291},         
-	{425  , 4258},         
-	{440  , 4234},         
-	{448  , 4210},         
-	{450  , 4187},         
-	{463  , 4165},         
-	{478  , 4145},         
-	{480  , 4122},         
-	{488  , 4103},         
-	{500  , 4086},         
-	{518  , 4066},         
-	{530  , 4042},         
-	{528  , 4016},         
-	{538  , 3995},         
-	{548  , 3976},         
-	{543  , 3956},         
-	{535  , 3935},         
-	{540  , 3916},         
-	{535  , 3899},         
-	{538  , 3884},         
-	{543  , 3869},         
-	{550  , 3858},         
-	{563  , 3848},         
-	{583  , 3839},         
-	{593  , 3830},         
-	{598  , 3821},         
-	{613  , 3813},         
-	{630  , 3805},         
-	{643  , 3799},         
-	{658  , 3794},         
-	{678  , 3789},         
-	{703  , 3783},         
-	{733  , 3779},         
-	{758  , 3774},         
-	{783  , 3766},         
-	{818  , 3757},         
-	{850  , 3747},         
-	{868  , 3733},         
-	{893  , 3717},         
-	{933  , 3708},         
-	{963  , 3701},         
-	{1030 , 3697},         
-	{1120 , 3692},         
-	{1190 , 3676},         
-	{1143 , 3656},         
-	{1098 , 3638},         
-	{1058 , 3623},         
-	{1028 , 3610},         
-	{1003 , 3600},         
-	{988  , 3594},         
-	{973  , 3588},         
-	{955  , 3582},         
-	{945  , 3576},         
-	{933  , 3572},         
-	{920  , 3567},         
-	{915  , 3565},         
-	{905  , 3562},         
-	{898  , 3558},         
-	{893  , 3555},         
-	{883  , 3553},         
-	{880  , 3551},          
-  {875  , 3547},
-  {868  , 3545},
-  {865  , 3544},
-  {863  , 3542},
-  {855  , 3540},
-  {843  , 3537},
-  {850  , 3536},
-  {848  , 3534},
-  {843  , 3532},
-	{823  , 3529}, 
-	{828  , 3528},
-	{833  , 3526},
-	{823  , 3524},
-	{808  , 3522},
-	{820  , 3521}, 
-	{805  , 3519}	       
+    {488 ,  4336},
+    {488 ,  4306},
+    {493 ,  4289},
+    {490 ,  4273},
+    {490 ,  4259},
+    {483 ,  4244},
+    {475 ,  4231},
+    {470 ,  4217},
+    {473 ,  4205},
+    {470 ,  4192},
+    {463 ,  4178},
+    {455 ,  4164},
+    {445 ,  4152},
+    {438 ,  4139},
+    {433 ,  4126},
+    {425 ,  4112},
+    {425 ,  4100},
+    {423 ,  4088},
+    {433 ,  4080},
+    {448 ,  4074},
+    {452 ,  4063},
+    {443 ,  4043},
+    {435 ,  4017},
+    {428 ,  3993},
+    {428 ,  3976},
+    {435 ,  3964},
+    {428 ,  3953},
+    {428 ,  3943},
+    {430 ,  3936},
+    {433 ,  3930},
+    {425 ,  3921},
+    {423 ,  3911},
+    {415 ,  3901},
+    {408 ,  3890},
+    {405 ,  3881},
+    {405 ,  3872},
+    {403 ,  3863},
+    {405 ,  3856},
+    {403 ,  3848},
+    {400 ,  3841},
+    {403 ,  3835},
+    {403 ,  3829},
+    {403 ,  3822},
+    {410 ,  3817},
+    {418 ,  3813},
+    {420 ,  3808},
+    {413 ,  3803},
+    {418 ,  3799},
+    {423 ,  3795},
+    {430 ,  3792},
+    {433 ,  3788},
+    {438 ,  3785},
+    {438 ,  3782},
+    {443 ,  3779},
+    {448 ,  3777},
+    {455 ,  3775},
+    {458 ,  3772},
+    {463 ,  3769},
+    {465 ,  3766},
+    {470 ,  3763},
+    {475 ,  3759},
+    {480 ,  3755},
+    {485 ,  3751},
+    {493 ,  3747},
+    {498 ,  3741},
+    {508 ,  3735},
+    {518 ,  3729},
+    {525 ,  3722},
+    {535 ,  3714},
+    {545 ,  3704},
+    {560 ,  3696},
+    {578 ,  3692},
+    {605 ,  3690},
+    {635 ,  3686},
+    {678 ,  3681},
+    {725 ,  3665},
+    {768 ,  3619},
+    {848 ,  3550},
+    {948 ,  3449},
+    {1225 , 3264},
+    {7773 , 3109}
 };     
 
 // T2 25C
 R_PROFILE_STRUC r_profile_t2[] =
 {
-	{148 , 4330},         
-	{148 , 4303},         
-	{158 , 4281},         
-	{160 , 4258},         
-	{160 , 4235},         
-	{163 , 4212},         
-	{165 , 4191},         
-	{165 , 4168},         
-	{170 , 4147},         
-	{173 , 4126},         
-	{178 , 4106},         
-	{178 , 4086},         
-	{188 , 4070},         
-	{188 , 4047},         
-	{193 , 4026},         
-	{195 , 4006},         
-	{200 , 3988},         
-	{208 , 3974},         
-	{210 , 3960},         
-	{215 , 3944},         
-	{208 , 3925},         
-	{183 , 3900},         
-	{170 , 3880},         
-	{165 , 3865},         
-	{165 , 3853},         
-	{168 , 3843},         
-	{173 , 3834},         
-	{175 , 3825},         
-	{178 , 3817},         
-	{183 , 3810},         
-	{183 , 3803},         
-	{185 , 3796},         
-	{195 , 3791},         
-	{198 , 3786},         
-	{200 , 3781},         
-	{200 , 3777},         
-	{203 , 3772},         
-	{203 , 3766},         
-	{203 , 3757},         
-	{208 , 3748},         
-	{213 , 3738},         
-	{213 , 3722},         
-	{215 , 3702},         
-	{215 , 3692},         
-	{228 , 3689},         
-	{245 , 3686},         
-	{273 , 3682},         
-	{285 , 3655},         
-	{310 , 3564},         
-	{395 , 3411},         
-	{388 , 3354},         
-	{350 , 3339},         
-	{328 , 3330},         
-	{305 , 3322},         
-	{290 , 3315},         
-	{278 , 3310},         
-	{265 , 3304},         
-	{253 , 3301},         
-	{248 , 3299},         
-	{243 , 3296},         
-	{238 , 3293},          
-  {230 , 3291},
-  {233 , 3290},
-  {230 , 3288},
-  {230 , 3286},
-  {230 , 3283},
-  {228 , 3281},
-  {230 , 3279},
-  {230 , 3276},
-  {235 , 3275},
-	{240 , 3272}, 
-	{235 , 3268},
-	{238 , 3267},
-	{233 , 3263},
-	{238 , 3261},
-	{233 , 3257}, 
-	{235 , 3255}	       
+    {160 ,  4339},
+    {160 ,  4319},
+    {163 ,  4301},
+    {163 ,  4285},
+    {160 ,  4270},
+    {163 ,  4256},
+    {163 ,  4241},
+    {160 ,  4226},
+    {160 ,  4212},
+    {163 ,  4199},
+    {163 ,  4185},
+    {160 ,  4171},
+    {163 ,  4158},
+    {165 ,  4145},
+    {165 ,  4131},
+    {165 ,  4118},
+    {165 ,  4104},
+    {167 ,  4092},
+    {170 ,  4080},
+    {173 ,  4070},
+    {178 ,  4064},
+    {178 ,  4054},
+    {170 ,  4033},
+    {173 ,  4011},
+    {175 ,  3994},
+    {170 ,  3981},
+    {175 ,  3973},
+    {180 ,  3969},
+    {180 ,  3964},
+    {180 ,  3955},
+    {178 ,  3944},
+    {178 ,  3934},
+    {178 ,  3924},
+    {170 ,  3909},
+    {170 ,  3896},
+    {158 ,  3881},
+    {158 ,  3871},
+    {155 ,  3862},
+    {153 ,  3854},
+    {155 ,  3847},
+    {153 ,  3840},
+    {155 ,  3834},
+    {155 ,  3827},
+    {155 ,  3822},
+    {158 ,  3817},
+    {153 ,  3811},
+    {160 ,  3808},
+    {155 ,  3802},
+    {155 ,  3798},
+    {158 ,  3795},
+    {158 ,  3791},
+    {158 ,  3787},
+    {163 ,  3784},
+    {165 ,  3781},
+    {168 ,  3777},
+    {168 ,  3774},
+    {163 ,  3768},
+    {163 ,  3764},
+    {158 ,  3759},
+    {158 ,  3754},
+    {158 ,  3749},
+    {158 ,  3744},
+    {158 ,  3740},
+    {155 ,  3735},
+    {160 ,  3732},
+    {158 ,  3726},
+    {160 ,  3720},
+    {158 ,  3712},
+    {158 ,  3706},
+    {160 ,  3698},
+    {160 ,  3689},
+    {158 ,  3685},
+    {158 ,  3683},
+    {163 ,  3682},
+    {168 ,  3679},
+    {175 ,  3670},
+    {175 ,  3632},
+    {183 ,  3571},
+    {198 ,  3488},
+    {228 ,  3353},
+    {1455 , 3053}
 }; 
 
 // T3 50C
 R_PROFILE_STRUC r_profile_t3[] =
 {
-	{105  , 4338},         
-	{105  , 4315},         
-	{108  , 4292},         
-	{110  , 4270},         
-	{110  , 4247},         
-	{113  , 4225},         
-	{110  , 4202},         
-	{113  , 4180},         
-	{113  , 4158},         
-	{118  , 4138},         
-	{115  , 4116},         
-	{118  , 4096},         
-	{123  , 4076},         
-	{128  , 4058},         
-	{125  , 4038},         
-	{133  , 4020},         
-	{133  , 4001},         
-	{138  , 3985},         
-	{140  , 3968},         
-	{145  , 3951},         
-	{135  , 3928},         
-	{120  , 3904},         
-	{113  , 3887},         
-	{108  , 3872},         
-	{115  , 3862},         
-	{118  , 3851},         
-	{120  , 3840},         
-	{123  , 3831},         
-	{120  , 3822},         
-	{128  , 3814},         
-	{123  , 3805},         
-	{128  , 3798},         
-	{130  , 3791},         
-	{135  , 3784},         
-	{125  , 3772},         
-	{118  , 3760},         
-	{125  , 3753},         
-	{120  , 3742},         
-	{120  , 3734},         
-	{125  , 3726},         
-	{120  , 3711},         
-	{120  , 3694},         
-	{120  , 3679},         
-	{118  , 3675},         
-	{125  , 3673},         
-	{130  , 3669},         
-	{135  , 3652},         
-	{150  , 3576},         
-	{175  , 3453},         
-	{213  , 3283},         
-	{150  , 3260},         
-	{123  , 3247},         
-	{113  , 3244},         
-	{110  , 3243},         
-	{108  , 3242},         
-	{108  , 3241},         
-	{108  , 3240},         
-	{100  , 3237},         
-	{100  , 3235},         
-	{105  , 3235},         
-	{103  , 3234},          
-  {105  , 3232},
-  {100  , 3230},
-  {108  , 3230},
-  {103  , 3227},
-  {103  , 3225},
-  {103  , 3224},
-  {103  , 3222},
-  {103  , 3222},
-  {103  , 3220},
-	{100  , 3217}, 
-	{103  , 3216},
-	{105  , 3215},
-	{105  , 3212},
-	{103  , 3211},
-	{103  , 3209}, 
-	{105  , 3207}	       
+    {150 ,  4339},
+    {150 ,  4308},
+    {150 ,  4291},
+    {153 ,  4276},
+    {150 ,  4260},
+    {148 ,  4246},
+    {150 ,  4231},
+    {150 ,  4217},
+    {150 ,  4203},
+    {155 ,  4190},
+    {150 ,  4174},
+    {153 ,  4162},
+    {155 ,  4149},
+    {153 ,  4135},
+    {155 ,  4122},
+    {155 ,  4109},
+    {152 ,  4095},
+    {152 ,  4083},
+    {155 ,  4071},
+    {155 ,  4058},
+    {153 ,  4046},
+    {158 ,  4035},
+    {157 ,  4023},
+    {158 ,  4010},
+    {158 ,  3999},
+    {158 ,  3988},
+    {158 ,  3978},
+    {160 ,  3969},
+    {158 ,  3958},
+    {163 ,  3949},
+    {165 ,  3939},
+    {168 ,  3930},
+    {168 ,  3920},
+    {165 ,  3908},
+    {165 ,  3894},
+    {153 ,  3877},
+    {153 ,  3867},
+    {155 ,  3859},
+    {153 ,  3851},
+    {150 ,  3843},
+    {150 ,  3837},
+    {148 ,  3829},
+    {150 ,  3823},
+    {150 ,  3818},
+    {150 ,  3813},
+    {150 ,  3808},
+    {155 ,  3804},
+    {153 ,  3799},
+    {153 ,  3794},
+    {153 ,  3790},
+    {153 ,  3786},
+    {153 ,  3782},
+    {155 ,  3779},
+    {160 ,  3777},
+    {158 ,  3772},
+    {158 ,  3768},
+    {155 ,  3762},
+    {148 ,  3752},
+    {148 ,  3744},
+    {153 ,  3740},
+    {168 ,  3734},
+    {153 ,  3729},
+    {133 ,  3716},
+    {153 ,  3720},
+    {153 ,  3717},
+    {153 ,  3710},
+    {153 ,  3704},
+    {153 ,  3697},
+    {155 ,  3691},
+    {153 ,  3683},
+    {150 ,  3674},
+    {153 ,  3671},
+    {153 ,  3669},
+    {158 ,  3667},
+    {185 ,  3665},
+    {173 ,  3656},
+    {160 ,  3620},
+    {163 ,  3564},
+    {175 ,  3488},
+    {195 ,  3373},
+    {415 ,  3143}
 }; 
 
 // r-table profile for actual temperature. The size should be the same as T1, T2 and T3
 R_PROFILE_STRUC r_profile_temperature[] =
 {
+    {0, 0},
+    {0, 0},
+    {0, 0},
+    {0, 0},
   {0  , 0 },
 	{0  , 0 },
 	{0  , 0 },
diff --git a/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/power/cust_charging.h b/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/power/cust_charging.h
index a2600ca..1abe398 100644
--- a/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/power/cust_charging.h
+++ b/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/power/cust_charging.h
@@ -8,11 +8,13 @@
 
 /* Battery Temperature Protection */
 #define MTK_TEMPERATURE_RECHARGE_SUPPORT
-#define MAX_CHARGE_TEMPERATURE  50
+#define MAX_CHARGE_TEMPERATURE  52
 #define MAX_CHARGE_TEMPERATURE_MINUS_X_DEGREE	47
 #define MIN_CHARGE_TEMPERATURE  0
-#define MIN_CHARGE_TEMPERATURE_PLUS_X_DEGREE	6
+#define MIN_CHARGE_TEMPERATURE_PLUS_X_DEGREE	4
 #define ERR_CHARGE_TEMPERATURE  0xFF
+#define CHARGE_TMEPERATURE_15		15     //wangmeixia BATTERY_TEMP_CHARGING_CURRENT
+#define CHARGE_TMEPERATURE_45		45
 
 /* Linear Charging Threshold */
 #define V_PRE2CC_THRES	 		3400	//mV
@@ -26,15 +28,25 @@
 #define USB_CHARGER_CURRENT_UNCONFIGURED	CHARGE_CURRENT_70_00_MA	// 70mA
 #define USB_CHARGER_CURRENT_CONFIGURED		CHARGE_CURRENT_500_00_MA	// 500mA
 
+
 #define USB_CHARGER_CURRENT					CHARGE_CURRENT_500_00_MA	//500mA
 //#define AC_CHARGER_CURRENT					CHARGE_CURRENT_650_00_MA
-#define AC_CHARGER_CURRENT					CHARGE_CURRENT_1000_00_MA
+#define AC_CHARGER_CURRENT					CHARGE_CURRENT_2000_00_MA
 #define NON_STD_AC_CHARGER_CURRENT			CHARGE_CURRENT_500_00_MA
 #define CHARGING_HOST_CHARGER_CURRENT       CHARGE_CURRENT_650_00_MA
 #define APPLE_0_5A_CHARGER_CURRENT          CHARGE_CURRENT_500_00_MA
 #define APPLE_1_0A_CHARGER_CURRENT          CHARGE_CURRENT_650_00_MA
 #define APPLE_2_1A_CHARGER_CURRENT          CHARGE_CURRENT_800_00_MA
 
+#define POST_CHARGING_TIME		30 * 60		/* 30mins */
+#define FULL_CHECK_TIMES		6
+#define BATTERY_TEMP_CHARGING_CURRENT // tangqingcai add wangmeixia
+
+#define AC_CHARGER_CURRENT_05C          CHARGE_CURRENT_1950_00_MA  //BATTERY_TEMP_CHARGING_CURRENT
+#define AC_CHARGER_CURRENT_INPUT_05C	CHARGE_CURRENT_2000_00_MA	
+#define AC_CHARGER_CURRENT_02C		CHARGE_CURRENT_775_00_MA	
+#define AC_CHARGER_CURRENT_INPUT_02C	CHARGE_CURRENT_900_00_MA	
+#define AC_CHARGER_CURRENT_00C          CHARGE_CURRENT_0_00_MA      //wangmeixia
 
 /* Precise Tunning */
 #define BATTERY_AVERAGE_DATA_NUMBER	3	
@@ -104,5 +116,13 @@
 #ifdef CONFIG_MTK_FAN5405_SUPPORT
 #define FAN5405_BUSNUM 1
 #endif
+//BATTERY_TEMP_CHARGING_CURRENT
+    
+#define E_BAT_T_L_0  2	// (..., 0)
+#define E_BAT_T_B_0_15 3		//(0, 15]
+#define E_BAT_T_B_15_45 4	//(15, 45]
+#define E_BAT_T_B_45_50 5	//(45, 50]
+#define E_BAT_T_U_50 6		//(55, ...)
+
 
 #endif /* _CUST_BAT_H_ */ 
diff --git a/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/power/cust_pmic.h b/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/power/cust_pmic.h
index f9e8f80..a34b486 100644
--- a/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/power/cust_pmic.h
+++ b/drivers/misc/mediatek/mach/mt6752/vanzo6752_35gu_l/power/cust_pmic.h
@@ -27,7 +27,7 @@
 #define POWER_BAT_OC_CURRENT_L_RE 4000
 
 
-//#define BATTERY_MODULE_INIT
+#define BATTERY_MODULE_INIT
 
 #if defined(CONFIG_MTK_BQ24196_SUPPORT)\
 	||defined(CONFIG_MTK_BQ24296_SUPPORT)\
diff --git a/drivers/misc/mediatek/magnetometer/Makefile b/drivers/misc/mediatek/magnetometer/Makefile
index a357942..d0741a9 100644
--- a/drivers/misc/mediatek/magnetometer/Makefile
+++ b/drivers/misc/mediatek/magnetometer/Makefile
@@ -48,4 +48,4 @@ endif
 
 ifeq ($(CONFIG_MTK_ST480),y)
 obj-y   +=  st480/
-endif
\ No newline at end of file
+endif
diff --git a/drivers/misc/mediatek/magnetometer/st480/st480.c b/drivers/misc/mediatek/magnetometer/st480/st480.c
index bf11018..8d2478b 100644
--- a/drivers/misc/mediatek/magnetometer/st480/st480.c
+++ b/drivers/misc/mediatek/magnetometer/st480/st480.c
@@ -722,7 +722,7 @@ static long st480d_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
             break;
 			
 		//add by sen.luo
-              case CKT_MSENSOR_IOCTL_READ_FACTORY_SENSORDATA:			
+              case MSENSOR_IOCTL_READ_FACTORY_SENSORDATA:			
 			st480_work_func();
 			sprintf(buff, "%04x %04x %04x", mag.mag_x, mag.mag_y, mag.mag_z);
 			if(copy_to_user(argp, buff, strlen(buff)+1))
@@ -857,17 +857,17 @@ static long st480d_compat_ioctl(struct file *file, unsigned int cmd, unsigned lo
             break;
 			
 		//add by sen.luo
-        case COMPAT_CKT_MSENSOR_IOCTL_READ_FACTORY_SENSORDATA:			
+        case COMPAT_MSENSOR_IOCTL_READ_FACTORY_SENSORDATA:			
 			if(arg64 == NULL)
 			 {
 				 MSE_ERR("invalid argument.");
 				 return -EINVAL;
 			 }
 			 
-			 ret = file->f_op->unlocked_ioctl(file, CKT_MSENSOR_IOCTL_READ_FACTORY_SENSORDATA,
+			 ret = file->f_op->unlocked_ioctl(file, MSENSOR_IOCTL_READ_FACTORY_SENSORDATA,
 							(unsigned long)(arg64));
 			 if (ret){
-			 	MSE_ERR("COMPAT_CKT_MSENSOR_IOCTL_READ_FACTORY_SENSORDATA unlocked_ioctl failed.");
+			 	MSE_ERR("COMPAT_MSENSOR_IOCTL_READ_FACTORY_SENSORDATA unlocked_ioctl failed.");
 				return ret;
 			 }	
             break;
diff --git a/drivers/misc/mediatek/mmc-host/emmc_rpmb.c b/drivers/misc/mediatek/mmc-host/emmc_rpmb.c
index 9b63341..229ea8e 100644
--- a/drivers/misc/mediatek/mmc-host/emmc_rpmb.c
+++ b/drivers/misc/mediatek/mmc-host/emmc_rpmb.c
@@ -1087,6 +1087,8 @@ static int emmc_rpmb_open_session()
         MSG(INFO, "uuid[0]=%d, uuid[1]=%d, uuid[2]=%d, uuid[3]=%d\n", rpmb_uuid.value[0],rpmb_uuid.value[1],rpmb_uuid.value[2],rpmb_uuid.value[3]);
         
         rpmb_session.device_id = rpmb_devid;  
+        msleep(1000);
+        MSG(INFO, "%s, wait for 1 second and then open session\n", __func__);
 
         /* open session */
         mc_ret = mc_open_session(&rpmb_session, 
@@ -1097,6 +1099,11 @@ static int emmc_rpmb_open_session()
         if (mc_ret != MC_DRV_OK) {
             MSG(ERR, "%s, mc_open_session failed.(%d)\n", __func__, cnt);
             cnt++;
+            MSG(ERR, "%s, try free wsm and close device\n", __func__);
+            mc_ret = mc_free_wsm(rpmb_devid, rpmb_dci);
+            MSG(ERR, "%s, free wsm result (%d)\n", __func__, mc_ret);
+            mc_ret = mc_close_device(rpmb_devid);
+            MSG(ERR, "%s, close device result (%d)\n", __func__, mc_ret);
             continue;
         }
  
diff --git a/drivers/misc/mediatek/mmc-host/mt6752/sd.c b/drivers/misc/mediatek/mmc-host/mt6752/sd.c
index 4eacf8c..7e8c362 100644
--- a/drivers/misc/mediatek/mmc-host/mt6752/sd.c
+++ b/drivers/misc/mediatek/mmc-host/mt6752/sd.c
@@ -10799,12 +10799,8 @@ static int msdc_drv_probe(struct platform_device *pdev)
 #ifndef FPGA_PLATFORM
     msdc_set_host_power_control(host);
     if ((host->hw->host_function == MSDC_SD) && (host->hw->flags & MSDC_CD_PIN_EN)) {
-		if (host->hw->flags & MSDC_SD_NEED_POWER)
-			host->sd_keep_pwr = false;
-        msdc_sd_power(host, 0); //work around : hot-plug project SD card LDO alway on if no SD card insert
-        msdc_sd_power(host, 1);
-		if (host->hw->flags & MSDC_SD_NEED_POWER)
-			host->sd_keep_pwr = true;
+        msdc_sd_power(host, 1); //work around : hot-plug project SD card LDO alway on if no SD card insert
+        msdc_sd_power(host, 0);
     }
 #endif
     if(host->hw->host_function == MSDC_EMMC && !(host->hw->flags & MSDC_UHS1))
diff --git a/drivers/misc/mediatek/mtkpasr/mtkpasr_drv.c b/drivers/misc/mediatek/mtkpasr/mtkpasr_drv.c
index 6615068..2ea0ee8 100644
--- a/drivers/misc/mediatek/mtkpasr/mtkpasr_drv.c
+++ b/drivers/misc/mediatek/mtkpasr/mtkpasr_drv.c
@@ -17,12 +17,14 @@
 #include <linux/vmalloc.h>
 #include <linux/interrupt.h>
 #include <linux/swap.h>
+#include <linux/syscore_ops.h>
 #include <linux/suspend.h>
 #include <linux/earlysuspend.h>
 #include <linux/migrate.h>
 #include "mtkpasr_drv.h"
 
 /* #define NO_UART_CONSOLE */
+#define MTKPASR_FAST_PATH
 
 /* MTKPASR Information */
 static struct zs_pool *mtkpasr_mem_pool;
@@ -63,7 +65,10 @@ static int mtkpasr_admit_order;
 
 /* Switch : Enabled by default */
 int mtkpasr_enable = 1;
-int mtkpasr_enable_sr = 1;
+unsigned long mtkpasr_enable_sr = 1;
+
+/* Receive PM notifier flag */
+static bool pm_in_hibernation = false;
 
 /* Debug filter */
 #ifdef CONFIG_MT_ENG_BUILD
@@ -371,7 +376,7 @@ void mtkpasr_reset_slots(void)
 /* To avoid fragmentation through mtkpasr_admit_order */
 static struct page *mtkpasr_alloc(struct page *migratepage, unsigned long data, int **result)
 {
-#if 1	/* FAST PATH */
+#ifdef MTKPASR_FAST_PATH/* FAST PATH */
 	struct page *page = NULL, *end_page;
 	struct zone *z;
 	/*unsigned long flags;*/
@@ -405,6 +410,7 @@ retry:
 		while (page < end_page) {
 			/* Lock this zone */
 			/*** spin_lock_irqsave(&z->lock, flags); ***/
+			local_irq_disable();
 			/* Find free pages */
 			if (!PageBuddy(page)) {
 				/*** spin_unlock_irqrestore(&z->lock, flags); ***/
@@ -659,6 +665,7 @@ void mtkpasr_restoring(void)
  */
 static int check_if_compressed(long start, long end, int pfn)
 {
+#ifndef CONFIG_64BIT
 	long mid;
 	int found = 0;
 
@@ -679,6 +686,9 @@ static int check_if_compressed(long start, long end, int pfn)
 	}
 
 	return found;
+#else
+	return 0;
+#endif
 }
 
 /* Return the number of inuse pages */
@@ -722,10 +732,10 @@ static void compute_bank_inused(int all)
 	/*
 	 * Drain pcp LRU lists to free some "unused" pages!
 	 * (During page migration, there may be some OLD pages be in pcp pagevec! To free them!)
-	 * To call lru_add_drain_all();
+	 * To call lru_add_drain();
 	 *
 	 * Drain pcp free lists to free some hot/cold pages into buddy!
-	 * To call drain_all_pages();
+	 * To call drain_local_pages(NULL);
 	 */
 	MTKPASR_FLUSH();
 
@@ -1031,7 +1041,7 @@ void shrink_mtkpasr_all(void)
 					}
 				}
 				/* Start migration */
-				if (migrate_pages(&fromlist, compacting_alloc, 0, false, MIGRATE_ASYNC) != 0) {
+				if (MIGRATE_PAGES(&fromlist, compacting_alloc, 0) != 0) {
 					putback_lru_pages(&fromlist);
 				}
 				fromlist_count = 0;
@@ -1288,8 +1298,8 @@ static unsigned long putback_free_pages(struct list_head *freelist)
 #define COMPACTING_COLLECT()										\
 	{												\
 		if (collect_free_pages_for_compacting_banks(&bank_cc) >= fromlist_count) {		\
-			if (migrate_pages(&fromlist, compacting_alloc, 0, false, MIGRATE_ASYNC) != 0) {	\
-				mtkpasr_log("Bank[%d] can't be cleared!\n", from);			\
+			if (MIGRATE_PAGES(&fromlist, compacting_alloc, 0) != 0) {	\
+				mtkpasr_log("(AC) Bank[%d] can't be cleared!\n", from);			\
 				ret = -1;								\
 				goto next;								\
 			}										\
@@ -1364,7 +1374,7 @@ static int compacting_banks(int from, int to, unsigned long *from_cursor, unsign
 				--BANK_INUSED(from);
 			} else {
 				/* This bank can't be cleared! */
-				mtkpasr_log("Bank[%d] can't be cleared!\n", from);
+				mtkpasr_log("(BC) Bank[%d] can't be cleared!\n", from);
 				ret = -1;
 				break;
 			}
@@ -1613,14 +1623,17 @@ static int pasr_scan_memory(void *src_map, unsigned long start, unsigned long en
 		}
 	} while (++start_pfn < end_pfn);
 
+#ifndef CONFIG_64BIT
 	/* Clear sorted (we only need to clear (end-start) entries.)*/
 	memset(sorted, 0, (end-start)*sizeof(unsigned long));
+#endif
 
 	mtkpasr_info("@@@ start_pfn[0x%lx] end_pfn[0x%lx] - to process[%d] @@@\n", start, end, need_compressed);
 
 	return need_compressed;
 }
 
+#ifndef CONFIG_64BIT
 /* Implementation of MTKPASR Direct Compression! DON'T MODIFY IT.  */
 #define MTKPASR_DIRECT_COMPRESSION()							\
 	{										\
@@ -1648,6 +1661,9 @@ static int pasr_scan_memory(void *src_map, unsigned long start, unsigned long en
 		}									\
 		unlock_page(page);							\
 	}
+#else
+#define MTKPASR_DIRECT_COMPRESSION()	do { ret = 0; } while (0);
+#endif
 
 /*
  * Drop, Compress, Migration, Compaction
@@ -1682,8 +1698,12 @@ enum mtkpasr_phase mtkpasr_entering(void)
 	int ret = 0;
 	struct mtkpasr *mtkpasr;
 	struct page *page;
-	int current_bank, current_pos, current_index;
-	unsigned long which_pfn, bank_start_pfn, bank_end_pfn;
+	int current_bank, current_pos;
+	unsigned long bank_start_pfn, bank_end_pfn;
+#ifndef CONFIG_64BIT
+	int current_index;
+	unsigned long which_pfn;
+#endif
 #ifdef CONFIG_MTKPASR_DEBUG
 	int drop_cnt, to_be_migrated, splitting, no_migrated;
 #endif
@@ -1714,9 +1734,11 @@ enum mtkpasr_phase mtkpasr_entering(void)
 
 	/* Reset "CROSS-OPS" variables: extcomp position index, extcomp start & end positions */
 	atomic_set(&sloti, -1);
+#ifndef CONFIG_64BIT
 	for (current_bank = 0; current_bank < num_banks; ++current_bank) {
 		mtkpasr_banks[current_bank].comp_pos = 0;
 	}
+#endif
 
 #ifdef CONFIG_MTKPASR_MAFL
 	/* Set for verification of ops-invariant */
@@ -1775,8 +1797,10 @@ enum mtkpasr_phase mtkpasr_entering(void)
 	mtkpasr_last_scan = mtkpasr_start_pfn - pageblock_nr_pages;
 
 next_bank:
+#ifndef CONFIG_64BIT
 	/* Set start pos at extcomp */
 	mtkpasr_banks[current_bank].comp_start = (s16)compressed;
+#endif
 
 	/* Scan MTKPASR-imposed pages */
 #ifdef CONFIG_MTKPASR_MAFL
@@ -1868,7 +1892,7 @@ next_page:
 		splitting += current_pos;
 #endif
 		/* Migrate pages */
-		if (migrate_pages(this, mtkpasr_alloc, 0, false, MIGRATE_ASYNC)) {
+		if (MIGRATE_PAGES(this, mtkpasr_alloc, 0)) {
 			/* Failed migration on remaining pages! No list add/remove operations! */
 			list_for_each_entry(page, this, lru) {
 #ifdef CONFIG_MTKPASR_DEBUG
@@ -1888,6 +1912,7 @@ next_page:
 	putback_lru_pages(&batch_to_migrate);
 	putback_lru_pages(&to_migrate);
 
+#ifndef CONFIG_64BIT
 	/* Set pos next to the last one at extcomp */
 	mtkpasr_banks[current_bank].comp_end = (s16)compressed;
 	mtkpasr_info("bank[%d] - comp_start[%d] comp_end[%d]\n",
@@ -1912,6 +1937,7 @@ next_page:
 		}
 #endif
 	}
+#endif
 
 	/* Check whether we should go to the next bank */
 	/* Because PASR only takes effect on continuous PASR banks, we should add "!ret" to avoid unnecessary works */
@@ -1947,12 +1973,8 @@ next_page:
 no_safe:
 	/* Go to MTKPASR_DISABLINGSR state if success */
 	if (result == MTKPASR_SUCCESS) {
-		/* Compaction on banks */
-#ifndef CONFIG_MTKPASR_RDIRECT
-		if (current_bank < (num_banks - 1))
-#else
-		if (current_bank > 0)
-#endif
+		/* Migrate to non-PASR range is not feasible(Means there may be some movable pages), so we should compact banks for PASR. */
+		if (mtkpasr_admit_order < 0)
 			result = mtkpasr_compact();
 		/* Successful PASR ops */
 		if (result == MTKPASR_SUCCESS) {
@@ -2170,13 +2192,148 @@ static void __init mtkpasr_construct_bankrank(void)
 	for (bank = 0; bank < num_banks; bank++) {
 		if (mtkpasr_banks[bank].inused == 0) {
 			remove_bank_from_buddy(bank);
+			pr_notice("(+)bank[%d]\n",bank);
+		} else {
+			pr_notice("(-)bank[%d] inused[%u]\n",bank,mtkpasr_banks[bank].inused);
 		}
 	}
 
 	prev_mafl_count = mafl_total_count;
 #endif
+
+	/* Sanity check - confirm all pages in MTKPASR banks are MIGRATE_MTKPASR */
+	rank = 0;
+	for (bank = 0; bank < num_banks; bank++) {
+		spfn = mtkpasr_banks[bank].start_pfn;
+		epfn = mtkpasr_banks[bank].end_pfn;
+		for (; spfn < epfn; spfn += pageblock_nr_pages)
+			if (!is_migrate_mtkpasr(get_pageblock_migratetype(pfn_to_page(spfn))))
+				rank++;
+	}
+	if (rank != 0)
+		pr_alert("\n\n\n[%s][%d]: There is non-MIGRATE_MTKPASR page in MTKPASR range!!!\n\n\n",__func__,__LINE__);
+
+	pr_notice("Non-MIGRATE_MTKPASR pages in MTKPASR range [%d]\n",rank);
+}
+
+#ifdef CONFIG_PM
+
+static int mtkpasr_pm_event(struct notifier_block *notifier, unsigned long pm_event, void *unused)
+{
+	switch(pm_event) {
+	case PM_HIBERNATION_PREPARE: 	/* Going to hibernate */
+		/* MTKPASR off */
+		pm_in_hibernation = true;
+		return NOTIFY_DONE;
+	case PM_POST_HIBERNATION: 	/* Hibernation finished */
+		/* MTKPASR on */
+		pm_in_hibernation = false;
+		return NOTIFY_DONE;
+	}
+	return NOTIFY_OK;
+}
+
+static struct notifier_block mtkpasr_pm_notifier_block = {
+	.notifier_call = mtkpasr_pm_event,
+	.priority = 0,
+};
+
+extern unsigned long mtkpasr_triggered;
+extern unsigned long failed_mtkpasr;
+static int mtkpasr_syscore_suspend(void)
+{
+	enum mtkpasr_phase result;
+	int ret = 0;
+	int irq_disabled = 0;		/* MTKPASR_FLUSH -> drain_all_pages -> on_each_cpu_mask will enable local irq */
+
+	IS_MTKPASR_ENABLED;
+
+	/* If system is currently in hibernation, just return. */
+	if (pm_in_hibernation == true) {
+		mtkpasr_log("In hibernation!\n");
+		return 0;
+	}
+
+	/* Setup SPM wakeup event firstly */
+	spm_set_wakeup_src_check();
+	
+	/* Check whether we are in irq-disabled environment */
+	if (irqs_disabled()) {
+		irq_disabled = 1;
+	}
+
+	/* Count for every trigger */
+	++mtkpasr_triggered;
+
+	/* It will go to MTKPASR stage */
+	current->flags |= PF_MTKPASR | PF_SWAPWRITE;
+	
+	/* RAM-to-RAM compression - State change: MTKPASR_OFF -> MTKPASR_ENTERING -> MTKPASR_DISABLINGSR */
+	result = mtkpasr_entering();
+	
+	/* It will leave MTKPASR stage */
+	current->flags &= ~(PF_MTKPASR | PF_SWAPWRITE);
+	
+	/* Any pending wakeup source? */
+	if (result == MTKPASR_GET_WAKEUP) {
+		mtkpasr_restoring();
+		mtkpasr_err("PM: Failed to enter MTKPASR\n");
+		++failed_mtkpasr;
+		ret = -1;
+	} else if (result == MTKPASR_WRONG_STATE) {
+		mtkpasr_reset_state();
+		mtkpasr_err("Wrong state!\n");
+		++failed_mtkpasr;
+	}
+
+	/* Recover it to irq-disabled environment if needed */
+	if (irq_disabled == 1) {
+		if (!irqs_disabled()) {
+			mtkpasr_log("IRQ is enabled! To disable it here!\n");
+			arch_suspend_disable_irqs();
+		}
+	}
+
+	return ret;
 }
 
+static void mtkpasr_syscore_resume(void)
+{
+	enum mtkpasr_phase result;
+	
+	/* If system is currently in hibernation, just return. */
+	if (pm_in_hibernation == true) {
+		mtkpasr_log("In hibernation!\n");
+		return;
+	}
+
+	/* RAM-to-RAM decompression - State change: MTKPASR_EXITING -> MTKPASR_OFF */
+	result = mtkpasr_exiting();
+
+	if (result == MTKPASR_WRONG_STATE) {
+		mtkpasr_reset_state();
+		mtkpasr_err("Wrong state!\n");
+	} else if (result == MTKPASR_FAIL) {
+		printk(KERN_ERR"\n\n\n Some Fatal Error!\n\n\n");
+	}
+}
+
+static struct syscore_ops mtkpasr_syscore_ops = {
+	.suspend	= mtkpasr_syscore_suspend,
+	.resume		= mtkpasr_syscore_resume,
+};
+
+static int __init mtkpasr_init_ops(void)
+{
+	if (!register_pm_notifier(&mtkpasr_pm_notifier_block))
+		register_syscore_ops(&mtkpasr_syscore_ops);
+	else
+		mtkpasr_err("Failed to register pm notifier block\n");
+		
+	return 0;
+}
+#endif
+
 /* mtkpasr initcall */
 static int __init mtkpasr_init(void)
 {
@@ -2209,6 +2366,14 @@ static int __init mtkpasr_init(void)
 		goto out;
 	}
 
+	/* Construct memory rank & bank information */
+	num_banks = compute_valid_pasr_range(&mtkpasr_start_pfn, &mtkpasr_end_pfn, &num_ranks);
+	if (num_banks < 0) {
+		mtkpasr_err("No valid PASR range!\n");
+		ret = -EINVAL;
+		goto free_devices;
+	}
+
 	/* To allocate memory for src_pgmap if needed (corresponding to one bank size) */
 	if (src_pgmap == NULL) {
 		src_pgmap = (void *)__get_free_pages(GFP_KERNEL, get_order(pasrbank_pfns * sizeof(unsigned long)));
@@ -2220,7 +2385,7 @@ static int __init mtkpasr_init(void)
 	}
 
 	/* To allocate memory for keeping external compression information */
-	if (extcomp == NULL) {
+	if (extcomp == NULL && !!MTKPASR_MAX_EXTCOMP) {
 		extcomp = (unsigned long *)__get_free_pages(GFP_KERNEL, get_order(MTKPASR_MAX_EXTCOMP * sizeof(unsigned long)));
 		if (extcomp == NULL) {
 			mtkpasr_err("Failed to allocate memory for extcomp!\n");
@@ -2255,13 +2420,6 @@ static int __init mtkpasr_init(void)
 		goto reset_devices;
 	}
 
-	/* Construct memory rank & bank information */
-	num_banks = compute_valid_pasr_range(&mtkpasr_start_pfn, &mtkpasr_end_pfn, &num_ranks);
-	if (num_banks < 0) {
-		mtkpasr_err("No valid PASR range!\n");
-		ret = -EINVAL;
-		goto free_banks_ranks;
-	}
 	/* mtkpasr_total_pfns = mtkpasr_end_pfn - mtkpasr_start_pfn; */
 	mtkpasr_banks = kzalloc(num_banks * sizeof(struct mtkpasr_bank), GFP_KERNEL);
 	if (!mtkpasr_banks) {
@@ -2275,6 +2433,7 @@ static int __init mtkpasr_init(void)
 		ret = -ENOMEM;
 		goto free_banks_ranks;
 	}
+
 	mtkpasr_construct_bankrank();
 
 	/* Indicate migration end */
@@ -2286,6 +2445,11 @@ static int __init mtkpasr_init(void)
 	/* Register early suspend/resume desc */
 	register_early_suspend(&mtkpasr_early_suspend_desc);
 
+#ifdef CONFIG_PM
+	/* Register syscore_ops */
+	mtkpasr_init_ops();
+#endif
+
 	/* Setup others */
 	nz = &NODE_DATA(0)->node_zones[ZONE_NORMAL];
 	safe_level = low_wmark_pages(nz);
@@ -2309,8 +2473,10 @@ free_banks_ranks:
 
 reset_devices:
 	mtkpasr_reset_device(mtkpasr_device);
-	free_pages((unsigned long)extcomp, get_order(MTKPASR_MAX_EXTCOMP * sizeof(unsigned long)));
-	free_pages((unsigned long)sorted_for_extcomp, get_order(pasrbank_pfns * sizeof(unsigned long)));
+	if (extcomp != NULL) {
+		free_pages((unsigned long)extcomp, get_order(MTKPASR_MAX_EXTCOMP * sizeof(unsigned long)));
+		free_pages((unsigned long)sorted_for_extcomp, get_order(pasrbank_pfns * sizeof(unsigned long)));
+	}
 
 no_memory:
 	free_pages((unsigned long)src_pgmap, get_order(pasrbank_pfns * sizeof(unsigned long)));
@@ -2349,7 +2515,7 @@ static void __exit mtkpasr_exit(void)
 
 	pr_debug("Cleanup done!\n");
 }
-subsys_initcall_sync(mtkpasr_init);
+device_initcall_sync(mtkpasr_init);
 module_exit(mtkpasr_exit);
 
 MODULE_AUTHOR("MTK");
diff --git a/drivers/misc/mediatek/mtkpasr/mtkpasr_drv.h b/drivers/misc/mediatek/mtkpasr/mtkpasr_drv.h
index 6ef5ca9..7f4504c 100644
--- a/drivers/misc/mediatek/mtkpasr/mtkpasr_drv.h
+++ b/drivers/misc/mediatek/mtkpasr/mtkpasr_drv.h
@@ -70,8 +70,9 @@
 #endif
 
 #define MTKPASR_FLUSH() do {				\
-				lru_add_drain_all();	\
-				drain_all_pages();	\
+				local_irq_disable();	\
+				lru_add_drain();	\
+				drain_local_pages(NULL);\
 			} while (0)			\
 
 /* For every MTKPASR_CHECK_ABORTED loops, we will do a check on pending wakeup sources. */
@@ -101,6 +102,13 @@
 #define ZS_CREATE_POOL(name, flags)	zs_create_pool(flags)
 #endif
 
+/* Page Migration API */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0)
+#define MIGRATE_PAGES(from, func, priv)	migrate_pages(from, func, priv, false, MIGRATE_ASYNC)
+#else
+#define MIGRATE_PAGES(from, func, priv)	migrate_pages(from, func, priv, MIGRATE_ASYNC, MR_COMPACTION)
+#endif
+
 /*-- Configurable parameters */
 
 /* Default mtkpasr disk size: 50% of total RAM */
@@ -246,7 +254,7 @@ extern struct attribute_group mtkpasr_attr_group;
 
 /* MTKPASR switch */
 extern int mtkpasr_enable;
-extern int mtkpasr_enable_sr;
+extern unsigned long mtkpasr_enable_sr;
 
 /* Debug filter */
 extern int mtkpasr_debug_level;
diff --git a/drivers/misc/mediatek/mtkpasr/mtkpasr_preinit.c b/drivers/misc/mediatek/mtkpasr/mtkpasr_preinit.c
index f99ccb6..1757306 100644
--- a/drivers/misc/mediatek/mtkpasr/mtkpasr_preinit.c
+++ b/drivers/misc/mediatek/mtkpasr/mtkpasr_preinit.c
@@ -20,6 +20,8 @@
 #define MTKPASR_4GB_PFNS			(0x100000)	/* 4GB */
 #define MTKPASR_DRAM_MINSIZE			MTKPASR_2GB_PFNS
 
+#define MTKPASR_INVALID_TAG			(0xEFFFFFFF)
+
 /* #define NO_UART_CONSOLE */
 #ifndef NO_UART_CONSOLE
 #define PRINT(len, string, args...)	printk(KERN_ALERT string, ##args)
@@ -29,6 +31,13 @@ static int log_stored;
 #define PRINT(len, string, args...)	do { sprintf(mtkpasr_log_buf + log_stored, string, ##args); log_stored += len; } while (0)
 #endif
 
+/* Reserved possible PASR range */
+struct view_pasr {
+	unsigned long start_pfn;	/* The 1st pfn */
+	unsigned long end_pfn;		/* The pfn after the last valid one */
+};
+static struct view_pasr rp_pasr_info[2];
+
 /* Struct for parsing rank information (SW view) */
 struct view_rank {
 	unsigned long start_pfn;	/* The 1st pfn */
@@ -62,14 +71,13 @@ extern bool pasr_is_valid(void)__attribute__((weak));
 /* To confirm PASR is valid */
 static inline bool could_do_mtkpasr(void)
 {
-	return false;
-#if 0
-	if (pasr_is_valid) {
+	if (mtkpasr_start_rank == MTKPASR_INVALID_TAG)
+		return false;
+
+	if (pasr_is_valid)
 		return pasr_is_valid();
-	}
 
 	return false;
-#endif
 }
 
 #ifdef CONFIG_ARM_LPAE
@@ -209,7 +217,7 @@ static bool __init parse_dram_setting(unsigned long hint)
 			rank_info[rank].bank_pfn_size = rank_pfn >> 3;
 			rank_info[rank].valid_channel = 0x1;
 			start_pfn = kernel_pfn_to_virt(rank_info[rank].end_pfn, true);
-			PRINT(96, "Rank[%d] start_pfn[%8lu] end_pfn[%8lu] bank_pfn_size[%8lu] valid_channel[0x%-8lx]\n",
+			PRINT(96, "(--)Rank[%d] start_pfn[%8lu] end_pfn[%8lu] bank_pfn_size[%8lu] valid_channel[0x%-8lx]\n",
 					rank, rank_info[rank].start_pfn, rank_info[rank].end_pfn,
 					rank_info[rank].bank_pfn_size, rank_info[rank].valid_channel);
 		}
@@ -309,6 +317,7 @@ static void __init mark_valid_segment(unsigned long start, unsigned long end, bo
 	}
 }
 
+#if 0
 /* Set page mobility to MIGRATE_MTKPASR */
 static void __init set_page_mobility_mtkpasr(unsigned long start, unsigned long end, bool last)
 {
@@ -351,6 +360,7 @@ static void __init set_page_mobility_mtkpasr(unsigned long start, unsigned long
 		}
 	}
 }
+#endif
 
 /* Fix to accommodate some feature-reserved memblocks */
 static void __init fix_memblock_region(unsigned long *start, unsigned long *end)
@@ -384,6 +394,29 @@ static void __init fix_memblock_region(unsigned long *start, unsigned long *end)
 	*end = epfn;
 }
 
+/* Exclude memblock.reserved */
+static void __init exclude_memblock_reserved(unsigned long *start, unsigned long *end)
+{
+	struct memblock_region *rreg;
+	unsigned long rstart = 0;
+	unsigned long rend = ~(unsigned long)0;
+
+	/* Exclude kernel-reserved area */	
+	for_each_memblock(reserved, rreg) {
+		rstart = PHYS_TO_PFN(rreg->base);
+		rend = PHYS_TO_PFN(rreg->base + rreg->size);
+		if (rstart >= *start) {
+			if (rend <= *end)	/* All-included */
+				*start = rend;
+			else if (rstart < *end)	/* Overlapped */
+				*end = rstart;	
+		} else {
+			if (rend > *start) 	/* Overlapped */
+				*start = rend;	
+		}
+	}
+}
+
 /* Fill valid_segment & set page mobility */
 static void __init construct_mtkpasr_range(void)
 {
@@ -391,6 +424,9 @@ static void __init construct_mtkpasr_range(void)
 	struct memblock_region *reg;
 	unsigned long start = 0;
 	unsigned long end = ~(unsigned long)0;
+#ifdef CONFIG_MTKPASR_NO_LASTBANK
+	unsigned long last_valid = 0;
+#endif
 
 	/* memblock should be sorted! */
 	for_each_memblock(memory, reg) {
@@ -398,16 +434,29 @@ static void __init construct_mtkpasr_range(void)
 		vend = mtkpasr_pfn_end;
 		start = PHYS_TO_PFN(reg->base);
 		end = PHYS_TO_PFN(reg->base + reg->size);
+
+		/* Exclude memblock reserved */
+		exclude_memblock_reserved(&start, &end);
+
 		/* Fix memblock region */
 		fix_memblock_region(&start, &end);
 		/* Intersect */
 		if (end > vstart && start < vend) {
 			vstart = max(start, vstart);
+#ifdef CONFIG_MTKPASR_NO_LASTBANK
+			vstart = round_up_base_offset(vstart, pasrbank_pfns, rank_pfn_offset());
+#endif
 			vend = min(end, vend);
+#ifdef CONFIG_MTKPASR_NO_LASTBANK
+			vend = round_down_base_offset(vend, pasrbank_pfns, rank_pfn_offset());
+#endif
 			/* Mark valid segment */
 			mark_valid_segment(vstart, vend, false);
-			/* Set page mobility */
-			set_page_mobility_mtkpasr(vstart, vend, false);
+			/* Set page mobility
+			set_page_mobility_mtkpasr(vstart, vend, false);*/
+#ifdef CONFIG_MTKPASR_NO_LASTBANK
+			last_valid = vend;
+#endif
 		}
 	}
 
@@ -427,10 +476,182 @@ static void __init construct_mtkpasr_range(void)
 		vstart = max(end, mtkpasr_pfn_start);
 		/* Mark valid segment */
 		mark_valid_segment(vstart, vend, true);
-		/* Set page mobility */
-		set_page_mobility_mtkpasr(vstart, vend, true);
+		/* Set page mobility
+		set_page_mobility_mtkpasr(vstart, vend, true);*/
+	}
+#else
+	/* Update mtkpasr_pfn_end according to last_valid */
+	mtkpasr_pfn_end = last_valid;
+#endif
+}
+
+/* Mark those MTKPASRed pages as MOVABLE */
+static void __init remove_needless_reserved(void)
+{
+	int index, order;
+	struct list_head *curr, *tmp;
+	struct page *spage;
+	unsigned long flags;
+	unsigned long pfn;
+	unsigned long spfn, epfn;
+
+	/* No PASR, remove all */
+	if (mtkpasr_pfn_end == 0) {
+		/* Search freelist */
+		for (order = 0; order < MAX_ORDER; order++) {
+			spin_lock_irqsave(&MTKPASR_ZONE->lock, flags);
+			list_for_each_safe(curr, tmp, &MTKPASR_ZONE->free_area[order].free_list[MIGRATE_MTKPASR]) {
+				spage = list_entry(curr, struct page, lru);
+				/* Move it from original mobility to MIGRATE_MOVABLE */
+				list_move(&spage->lru, &MTKPASR_ZONE->free_area[order].free_list[MIGRATE_MOVABLE]);
+				/* Set it to MIGRATE_MOVABLE */
+				set_pageblock_mobility(spage, MIGRATE_MOVABLE);
+
+			}
+			spin_unlock_irqrestore(&MTKPASR_ZONE->lock, flags);
+		}
+		/* Search inuse */
+		for (index = 0; index < 2; index++) {
+			spfn = rp_pasr_info[index].start_pfn;
+			epfn = rp_pasr_info[index].end_pfn;
+			spin_lock_irqsave(&MTKPASR_ZONE->lock, flags);
+			for (pfn = spfn; pfn < epfn; pfn += pageblock_nr_pages) {
+				spage = pfn_to_page(pfn);
+				/* Set it to MIGRATE_MOVABLE */
+				set_pageblock_mobility(spage, MIGRATE_MOVABLE);
+			}
+			spin_unlock_irqrestore(&MTKPASR_ZONE->lock, flags);
+		}
+	} else {
+		/* Remove needless */
+		for (index = 0; index < 2; index++) {
+			spfn = rp_pasr_info[index].start_pfn;
+			epfn = rp_pasr_info[index].end_pfn;
+			if (spfn < epfn) {
+				/* Search freelist */
+				for (order = 0; order < MAX_ORDER; order++) {
+					spin_lock_irqsave(&MTKPASR_ZONE->lock, flags);
+					list_for_each_safe(curr, tmp, &MTKPASR_ZONE->free_area[order].free_list[MIGRATE_MTKPASR]) {
+						spage = list_entry(curr, struct page, lru);
+						pfn = page_to_pfn(spage);
+						if ((pfn >= spfn && pfn < mtkpasr_pfn_start) || (pfn >= mtkpasr_pfn_end && pfn < epfn)) {
+							/* Move it from original mobility to MIGRATE_MOVABLE */
+							list_move(&spage->lru, &MTKPASR_ZONE->free_area[order].free_list[MIGRATE_MOVABLE]);
+							/* Set it to MIGRATE_MOVABLE */
+							set_pageblock_mobility(spage, MIGRATE_MOVABLE);
+						}
+					}
+					spin_unlock_irqrestore(&MTKPASR_ZONE->lock, flags);
+				}
+				spin_lock_irqsave(&MTKPASR_ZONE->lock, flags);
+				/* Search inuse */
+				for (pfn = spfn; pfn < mtkpasr_pfn_start; pfn += pageblock_nr_pages) {
+					spage = pfn_to_page(pfn);
+					/* Set it to MIGRATE_MOVABLE */
+					set_pageblock_mobility(spage, MIGRATE_MOVABLE);
+				}
+				for (pfn = mtkpasr_pfn_end; pfn < epfn; pfn += pageblock_nr_pages) {
+					spage = pfn_to_page(pfn);
+					/* Set it to MIGRATE_MOVABLE */
+					set_pageblock_mobility(spage, MIGRATE_MOVABLE);
+				}
+				spin_unlock_irqrestore(&MTKPASR_ZONE->lock, flags);
+			}
+		}
 	}
+}
+
+/*
+ * Reserve a range for PASR operation. (MIGRATE_MTKPASR)
+ */
+void __init init_mtkpasr_range(struct zone *zone)
+{
+	struct memblock_region *reg;
+	unsigned long start = 0;
+	unsigned long end = ~(unsigned long)0;
+	unsigned long min_start;
+	struct page *page;
+
+#ifdef CONFIG_HIGHMEM
+	/* Start from HIGHMEM zone if we have CONFIG_HIGHMEM defined. */
+	zone = zone + ZONE_HIGHMEM;
+#else
+	/* 64-bit kernel */
+	zone = zone + ZONE_DMA;
 #endif
+
+	/* Sanity Check */
+	if (zone != MTKPASR_ZONE) {
+		mtkpasr_start_rank = MTKPASR_INVALID_TAG;
+		return;
+	}
+
+	/* Min start pfn of PASR (~ 3/8 total DRAM size) */
+	min_start = zone->zone_start_pfn + ((zone->spanned_pages * 3) >> 3);
+
+	/* Reserve possible PASR range */
+	for_each_memblock(memory, reg) {
+		start = PHYS_TO_PFN(reg->base);
+		end = PHYS_TO_PFN(reg->base + reg->size);
+
+		/* Exclude memblock reserved */
+		exclude_memblock_reserved(&start, &end);
+
+		/* Check MAX range and swap them (START with (0,0)) */
+		if ((end - start) > (rp_pasr_info[0].end_pfn - rp_pasr_info[0].start_pfn)) {
+			rp_pasr_info[1].start_pfn = rp_pasr_info[0].start_pfn;
+			rp_pasr_info[1].end_pfn = rp_pasr_info[0].end_pfn;
+			rp_pasr_info[0].start_pfn = start;
+			rp_pasr_info[0].end_pfn = end;
+		} else if ((end - start) > (rp_pasr_info[1].end_pfn - rp_pasr_info[1].start_pfn)) { /* Sub-MAX */
+			rp_pasr_info[1].start_pfn = start;
+			rp_pasr_info[1].end_pfn = end;
+		}
+	}
+
+	/* Should we remove sub-MAX */
+	if (rp_pasr_info[1].start_pfn < rp_pasr_info[0].start_pfn) {
+		/* smaller size & address, to remove it */
+		rp_pasr_info[1].start_pfn = 0;
+		rp_pasr_info[1].end_pfn = 0;
+	}
+
+	/* Do pre-reservation for PASR */
+	for (start = 0; start < 2; start++) {
+		/* Normalize and Remove rp_pasr_info which is beyond min_start */
+		if (rp_pasr_info[start].end_pfn <= min_start) {
+			rp_pasr_info[start].start_pfn = 0;
+			rp_pasr_info[start].end_pfn = 0;
+		} else if (rp_pasr_info[start].start_pfn < min_start) {
+			rp_pasr_info[start].start_pfn = min_start;
+		}
+		/* pageblock_nr_pages alignment */
+		rp_pasr_info[start].start_pfn = (rp_pasr_info[start].start_pfn + pageblock_nr_pages - 1) & ~(pageblock_nr_pages - 1); 
+		rp_pasr_info[start].end_pfn = (rp_pasr_info[start].end_pfn) & ~(pageblock_nr_pages - 1); 
+		/* Mark it as MIGRATE_MTKPASR */
+		for (end = rp_pasr_info[start].start_pfn; end < rp_pasr_info[start].end_pfn; end++) {
+			if (!pfn_valid(end))
+				continue;
+			/* Set it as MIGRATE_MTKPASR - no zone lock here! (zone is not completely ready) */
+			page = pfn_to_page(end);
+			if (!(end & (pageblock_nr_pages - 1)))
+				set_pageblock_mobility(page, MIGRATE_MTKPASR);
+		}
+	}
+
+	/* Sort rp_pasr_info by address */
+	if (rp_pasr_info[1].start_pfn != 0) {
+		if (rp_pasr_info[0].start_pfn > rp_pasr_info[1].start_pfn) {
+			start = rp_pasr_info[0].start_pfn;
+			end = rp_pasr_info[0].end_pfn;
+			rp_pasr_info[0].start_pfn = rp_pasr_info[1].start_pfn;
+			rp_pasr_info[0].end_pfn = rp_pasr_info[1].end_pfn;
+			rp_pasr_info[1].start_pfn = start;
+			rp_pasr_info[1].end_pfn = end;
+		}
+	}
+
+	/* Shall we call memblock_reserve */
 }
 
 /*
@@ -438,8 +659,9 @@ static void __init construct_mtkpasr_range(void)
  * This is done by setting those pages as MIGRATE_MTKPASR type.
  * It only takes effect on HIGHMEM zone now!
  */
-void __init init_mtkpasr_range(struct zone *zone)
+static bool __init initialize_mtkpasr_range(void)
 {
+	struct zone *zone;
 	struct pglist_data *pgdat;
 	int rank;
 	unsigned long start_pfn;
@@ -450,29 +672,23 @@ void __init init_mtkpasr_range(struct zone *zone)
 	/* Check whether our platform supports PASR */
 	if (!could_do_mtkpasr()) {
 		/* Can't support PASR */
-		return;
+		goto recover;
 	}
 
 	/* Indicate node */
+	zone = MTKPASR_ZONE;
 	pgdat = zone->zone_pgdat;
 
 	/* Parsing DRAM setting */
 	if (parse_dram_setting(pgdat->node_spanned_pages) == false) {
 		/* Can't support PASR */
-		return;
+		goto recover;
 	}
 
-#ifdef CONFIG_HIGHMEM
-	/* Start from HIGHMEM zone if we have CONFIG_HIGHMEM defined. */
-	zone = zone + ZONE_HIGHMEM;
-#else
-	zone = zone + ZONE_NORMAL;
-#endif
-
 	/* Sanity check - Is this zone empty? */
 	if (!populated_zone(zone)) {
 		/* Can't support PASR */
-		return;
+		goto recover;
 	}
 
 	/* Mark the end pfn */
@@ -525,7 +741,7 @@ void __init init_mtkpasr_range(struct zone *zone)
 	/* Sanity check */
 	if (!pfn_bank_alignment) {
 		/* Can't support PASR */
-		return;
+		goto recover;
 	}
 
 	/* 1st attempted bank size */
@@ -549,17 +765,33 @@ void __init init_mtkpasr_range(struct zone *zone)
 	}
 
 	/* Find out MTKPASR Start/End PFN */
-	mtkpasr_pfn_start = start_pfn;
-	mtkpasr_pfn_end	= end_pfn;
+	mtkpasr_pfn_start = max(start_pfn, rp_pasr_info[0].start_pfn);
+	if (rp_pasr_info[1].end_pfn != 0)
+		mtkpasr_pfn_end	= min(end_pfn, rp_pasr_info[1].end_pfn);
+	else
+		mtkpasr_pfn_end	= min(end_pfn, rp_pasr_info[0].end_pfn);
 
-	/* Round up mtkpasr_pfn_end (a little tricky, affected by CONFIG_MTKPASR_NO_LASTBANK) */
-	mtkpasr_pfn_end = round_up_base_offset(mtkpasr_pfn_end, pfn_bank_alignment, ARCH_PFN_OFFSET);
+	/* Round UP mtkpasr_pfn_start */
+	mtkpasr_pfn_start = round_up_base_offset(mtkpasr_pfn_start, pfn_bank_alignment, ARCH_PFN_OFFSET);
+
+	/* Round DOWN mtkpasr_pfn_end (a little tricky, affected by CONFIG_MTKPASR_NO_LASTBANK) */
+	mtkpasr_pfn_end = round_down_base_offset(mtkpasr_pfn_end, pfn_bank_alignment, ARCH_PFN_OFFSET);
 
 	/* Fix up - allow holes existing in the PASR range */
 	construct_mtkpasr_range();
 
 	PRINT(138, "[MTKPASR] @@@@@@ Start_pfn[%8lu] End_pfn[%8lu] (MTKPASR) start_pfn[%8lu] end_pfn[%8lu] Valid_segment[0x%8lx] @@@@@@\n",
 			start_pfn, end_pfn, mtkpasr_pfn_start, mtkpasr_pfn_end, valid_segment);
+
+	/* Put needless MIGRATE_MTKPASR pages back to buddy - TODO */
+	remove_needless_reserved();
+	return true;
+
+recover:
+	/* Recover pages with MIGRATE_MTKPASR flag to be MIGRATE_MOVABLE - TODO */
+	PRINT(45, "Change page mobility from MTKPASR to MOVABLE\n");
+	remove_needless_reserved();
+	return false;
 }
 
 /* Reserve NOT-MIGRATE_MTKPASR pages in PASR range */
@@ -570,6 +802,7 @@ static void mtkpasr_reserve_reserved(void)
 	struct page *spage;
 	unsigned long flags;
 	unsigned long pfn;
+	unsigned long fixed = 0;
 
 	/* Move pages */
 	for_each_migratetype_order(order, t) {
@@ -586,10 +819,13 @@ static void mtkpasr_reserve_reserved(void)
 					/* Set it to MIGRATE_MTKPASR */
 					set_pageblock_mobility(spage, MIGRATE_MTKPASR);
 					spin_unlock_irqrestore(&MTKPASR_ZONE->lock, flags);
+					fixed++;
 				}
 			}
 		}
 	}
+	
+	printk(KERN_ALERT "[%s][%d] Fixed migrate types[%lu]\n",__func__,__LINE__,fixed);
 }
 
 /*
@@ -605,20 +841,17 @@ static void mtkpasr_reserve_reserved(void)
 int __init compute_valid_pasr_range(unsigned long *start_pfn, unsigned long *end_pfn, int *num_ranks)
 {
 	int num_banks, rank, seg_num;
-	unsigned long vseg = valid_segment;
+	unsigned long vseg;
 	bool contain_rank;
 
-	/* Check whether our platform supports PASR */
-	if (!could_do_mtkpasr()) {
-		/* Can't support PASR */
-		return -1;
-	}
-
-	/* Check whether we have a valid PASR range */
-	if (mtkpasr_pfn_start == mtkpasr_pfn_end) {
+	/* Initialize MTKPASR range */
+	if (!initialize_mtkpasr_range()) {
 		/* Can't support PASR */
 		return -1;
 	}
+	
+	/* Bitmap for valid_segment */
+	vseg = valid_segment;
 
 	/* Set PASR/DPD range */
 	*start_pfn = mtkpasr_pfn_start;
@@ -750,6 +983,7 @@ u32 __init pasr_bank_to_segment(unsigned long start_pfn, unsigned long end_pfn)
 				break;
 			}
 			num_segment += (repfn - rspfn) / rank_info[rank].bank_pfn_size;
+			num_segment = (num_segment + 7) & ~(0x7);
 		}
 	}
 
diff --git a/drivers/misc/mediatek/mtkpasr/mtkpasr_sysfs.c b/drivers/misc/mediatek/mtkpasr/mtkpasr_sysfs.c
index a67e15e..1868461 100644
--- a/drivers/misc/mediatek/mtkpasr/mtkpasr_sysfs.c
+++ b/drivers/misc/mediatek/mtkpasr/mtkpasr_sysfs.c
@@ -43,8 +43,8 @@ static unsigned long long mtkpasr_start_ns, mtkpasr_end_ns;
 #endif
 
 /* Statistics */
-static unsigned long mtkpasr_triggered;
-static unsigned long failed_mtkpasr;
+unsigned long mtkpasr_triggered;
+unsigned long failed_mtkpasr;
 static int mtkpasr_sroff;
 static int mtkpasr_dpd;
 
@@ -111,7 +111,7 @@ static ssize_t page_reserved_show(struct device *dev, struct device_attribute *a
 
 static ssize_t enable_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	return sprintf(buf, "%d [%d]\n", mtkpasr_enable, mtkpasr_enable_sr);
+	return sprintf(buf, "%d [%lu]\n", mtkpasr_enable, mtkpasr_enable_sr);
 }
 
 /* 0: all disabled 1: enable MTKPASR 2: enable SR control 3: all enabled*/
@@ -125,7 +125,7 @@ static ssize_t enable_store(struct device *dev, struct device_attribute *attr, c
 		return ret;
 
 	mtkpasr_enable = (value & 0x1) ? 1 : 0;
-	mtkpasr_enable_sr = (value & 0x2) ? 1 : 0;
+	mtkpasr_enable_sr = ((unsigned long)value & 0x2) ? 1 : 0;
 	return len;
 }
 
@@ -191,7 +191,7 @@ static ssize_t execstate_show(struct device *dev, struct device_attribute *attr,
 	len += tmp;
 
 	/* Enable status */
-	tmp = sprintf(buf, "%d [%d]\n", mtkpasr_enable, mtkpasr_enable_sr);
+	tmp = sprintf(buf, "%d [%lu]\n", mtkpasr_enable, mtkpasr_enable_sr);
 	buf += tmp;
 	len += tmp;
 
@@ -291,35 +291,6 @@ int pasr_enter(u32 *sr, u32 *dpd)
 		irq_disabled = 1;
 	}
 
-	++mtkpasr_triggered;
-
-	/* It will go to MTKPASR stage */
-	current->flags |= PF_MTKPASR | PF_SWAPWRITE;
-
-	MTKPASR_START_PROFILE();
-
-	/* RAM-to-RAM compression - State change: MTKPASR_OFF -> MTKPASR_ENTERING -> MTKPASR_DISABLINGSR */
-	result = mtkpasr_entering();
-
-	MTKPASR_END_PROFILE();
-
-	/* It will leave MTKPASR stage */
-	current->flags &= ~(PF_MTKPASR | PF_SWAPWRITE);
-
-	/* Any pending wakeup source? */
-	if (result == MTKPASR_GET_WAKEUP) {
-		mtkpasr_restoring();
-		mtkpasr_err("PM: Failed to enter MTKPASR\n");
-		++failed_mtkpasr;
-		ret = -1;
-		goto out;
-	} else if (result == MTKPASR_WRONG_STATE) {
-		mtkpasr_reset_state();
-		mtkpasr_err("Wrong state!\n");
-		++failed_mtkpasr;
-		goto out;
-	}
-
 	MTKPASR_START_PROFILE();
 
 	/* SR-Off/DPD - Check which banks/ranks can enter PASR/DPD - State change:MTKPASR_DISABLINGSR -> MTKPASR_ON (-> MTKPASR_DPD_ON) */
@@ -345,14 +316,12 @@ int pasr_enter(u32 *sr, u32 *dpd)
 		mtkpasr_err("PM: Failed to enter SR_OFF/DPD\n");
 		++failed_mtkpasr;
 		ret = -1;
-		goto out;
 	} else if (result == MTKPASR_WRONG_STATE) {
 		mtkpasr_reset_state();
 		mtkpasr_err("Wrong state!\n");
 		++failed_mtkpasr;
 	}
 
-out:
 	/* Recover it to irq-disabled environment if needed */
 	if (irq_disabled == 1) {
 		if (!irqs_disabled()) {
@@ -380,23 +349,8 @@ int pasr_exit(void)
 
 	if (result == MTKPASR_WRONG_STATE) {
 		mtkpasr_err("Wrong state!\n");
-		goto out;
 	}
-
-	MTKPASR_START_PROFILE();
-
-	/* RAM-to-RAM decompression - State change: MTKPASR_EXITING -> MTKPASR_OFF */
-	result = mtkpasr_exiting();
-
-	MTKPASR_END_PROFILE();
-
-	if (result == MTKPASR_WRONG_STATE) {
-		mtkpasr_err("Wrong state!\n");
-	} else if (result == MTKPASR_FAIL) {
-		printk(KERN_ERR"\n\n\n Some Fatal Error!\n\n\n");
-	}
-
-out:
+	
 	return 0;
 }
 #endif
diff --git a/drivers/misc/mediatek/mtprof/prof_main.c b/drivers/misc/mediatek/mtprof/prof_main.c
index db9910d..565999b 100644
--- a/drivers/misc/mediatek/mtprof/prof_main.c
+++ b/drivers/misc/mediatek/mtprof/prof_main.c
@@ -136,11 +136,11 @@ static ssize_t mt_sched_debug_write(struct file *filp, const char *ubuf, size_t
 	return cnt;
 }
 
+#ifdef CONFIG_MTPROF_CPUTIME
 /* 2. cputime */
 MT_DEBUG_ENTRY(cputime);
 static int mt_cputime_show(struct seq_file *m, void *v)
 {
-#ifdef CONFIG_MTPROF_CPUTIME
 	struct mt_proc_struct *mtproc = mt_proc_head;
 	int i = 0;
 	unsigned long long end_ts;
@@ -320,13 +320,11 @@ static int mt_cputime_show(struct seq_file *m, void *v)
 			   SPLIT_NS(total_excul_time));
 	}
 
-#endif
 	return 0;
 }
 
 static ssize_t mt_cputime_write(struct file *filp, const char *ubuf, size_t cnt, loff_t *data)
 {
-#ifdef CONFIG_MTPROF_CPUTIME
 	char buf[64];
 	unsigned long val;
 	int ret;
@@ -348,10 +346,10 @@ static ssize_t mt_cputime_write(struct file *filp, const char *ubuf, size_t cnt,
 /* val = !!val; */
 	/* 0: off, 1:on */
 	mt_cputime_switch(val);
-#endif
 	return cnt;
 
 }
+#endif
 
 /* 4. prof status*/
 MT_DEBUG_ENTRY(status);
@@ -642,9 +640,11 @@ static int __init init_mtsched_prof(void)
 	pe = proc_create("mtprof/sched", 0444, NULL, &mt_sched_debug_fops);
 	if (!pe)
 		return -ENOMEM;
+#ifdef CONFIG_MTPROF_CPUTIME
 	pe = proc_create("mtprof/cputime", 0664, NULL, &mt_cputime_fops);
     if (!pe)
-	return -ENOMEM;
+        return -ENOMEM;
+#endif
 	pe = proc_create("mtprof/reboot_pid", 0660, NULL, &mt_pid_fops);
 	if (!pe)
 		return -ENOMEM;
diff --git a/drivers/misc/mediatek/mu3d/drv/mt_usb.c b/drivers/misc/mediatek/mu3d/drv/mt_usb.c
index f740155..8d99092 100644
--- a/drivers/misc/mediatek/mu3d/drv/mt_usb.c
+++ b/drivers/misc/mediatek/mu3d/drv/mt_usb.c
@@ -22,6 +22,7 @@
 #endif
 
 extern struct musb *_mu3d_musb;
+extern u32 fake_CDP;
 
 #ifdef CONFIG_MTK_UART_USB_SWITCH
 typedef enum
@@ -46,16 +47,22 @@ extern void wake_up_bat(void);
 #endif
 #endif
 
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+#include <mach/mt_boot_common.h>
+extern BOOTMODE g_boot_mode;
+#endif
+
+
 #ifdef FOR_BRING_UP
 
 static inline void BATTERY_SetUSBState(int usb_state) {};
-static inline CHARGER_TYPE mt_charger_type_detection(void) { return STANDARD_HOST; };
+static inline CHARGER_TYPE  mt_get_charger_type(void) { return STANDARD_HOST;};
 static inline bool upmu_is_chr_det(void) { return true; };
 static inline u32 upmu_get_rgs_chrdet(void) { return 1; };
 
 #else /* NOT CONFIG_ARM64 */
 
-extern CHARGER_TYPE mt_charger_type_detection(void);
+extern CHARGER_TYPE mt_get_charger_type(void);
 extern bool upmu_is_chr_det(void);
 extern void BATTERY_SetUSBState(int usb_state);
 extern u32 upmu_get_rgs_chrdet(void);
@@ -134,6 +141,26 @@ void connection_work(struct work_struct *data)
 #endif
 	bool is_usb_cable = usb_cable_connected();
 
+	bool cmode_effect_on = false;
+	CHARGER_TYPE chg_type = mt_get_charger_type();
+	if(fake_CDP && chg_type == STANDARD_HOST){
+			os_printk(K_INFO, "%s, fake to type 2\n", __func__);
+			chg_type = CHARGING_HOST;
+	}
+	os_printk(K_NOTICE, "%s type=%d\n", __func__, chg_type);
+	if((musb->usb_mode == CABLE_MODE_HOST_ONLY && chg_type == STANDARD_HOST) || musb->usb_mode == CABLE_MODE_CHRG_ONLY){
+		cmode_effect_on = true;
+	}
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+	if(g_boot_mode == KERNEL_POWER_OFF_CHARGING_BOOT || g_boot_mode == LOW_POWER_OFF_CHARGING_BOOT){
+		if(chg_type == STANDARD_HOST){
+			cmode_effect_on = true;
+		}
+	}
+#endif
+	os_printk(K_INFO, "%s type=%d, cmode_effect_on=%d, usb_mode:%d\n", __func__, chg_type, cmode_effect_on, musb->usb_mode);
+
+
 #ifndef CONFIG_MTK_FPGA
 	if(!mt_usb_is_device()){
 		connection_work_dev_status = OFF;
@@ -146,7 +173,7 @@ void connection_work(struct work_struct *data)
 
 	os_printk(K_INFO, "%s musb %s, cable %s\n", __func__, ((connection_work_dev_status==0)?"INIT":((connection_work_dev_status==1)?"ON":"OFF")), (is_usb_cable?"IN":"OUT"));
 
-	if ((is_usb_cable == true) && (connection_work_dev_status != ON) && (musb->usb_mode == CABLE_MODE_NORMAL)) {
+	if ((is_usb_cable == true) && (connection_work_dev_status != ON) && (!cmode_effect_on)) {
 
 		connection_work_dev_status = ON;
 		#ifndef CONFIG_USBIF_COMPLIANCE
@@ -161,7 +188,7 @@ void connection_work(struct work_struct *data)
 		musb_start(musb);
 
 		os_printk(K_INFO, "%s ----Connect----\n", __func__);
-	} else if (((is_usb_cable == false) && (connection_work_dev_status != OFF)) || (musb->usb_mode != CABLE_MODE_NORMAL)) {
+	} else if (((is_usb_cable == false) && (connection_work_dev_status != OFF)) || (cmode_effect_on)) {
 
 		connection_work_dev_status = OFF;
 		#ifndef CONFIG_USBIF_COMPLIANCE
@@ -250,7 +277,7 @@ bool usb_cable_connected(void)
 {
 #ifndef CONFIG_MTK_FPGA
 #ifdef CONFIG_POWER_EXT
-	CHARGER_TYPE chg_type = mt_charger_type_detection();
+	CHARGER_TYPE chg_type = mt_get_charger_type();
 	os_printk(K_INFO, "%s ext-chrdet=%d type=%d\n", __func__, upmu_get_rgs_chrdet(), chg_type);
 	if (upmu_get_rgs_chrdet() && (chg_type == STANDARD_HOST))
 	{
@@ -259,9 +286,9 @@ bool usb_cable_connected(void)
 #else
 	if (upmu_is_chr_det())
 	{
-		CHARGER_TYPE chg_type = mt_charger_type_detection();
+		CHARGER_TYPE chg_type = mt_get_charger_type();
 		os_printk(K_INFO, "%s type=%d\n", __func__, chg_type);
-		if (chg_type == STANDARD_HOST)
+		if (chg_type == STANDARD_HOST || chg_type == CHARGING_HOST)
 			return true;
 	}
 #endif
diff --git a/drivers/misc/mediatek/mu3d/drv/musb_core.c b/drivers/misc/mediatek/mu3d/drv/musb_core.c
index fb0f873..fb3b359 100644
--- a/drivers/misc/mediatek/mu3d/drv/musb_core.c
+++ b/drivers/misc/mediatek/mu3d/drv/musb_core.c
@@ -136,9 +136,11 @@ const char musb_driver_name[] = MUSB_DRIVER_NAME;
 struct musb	*_mu3d_musb = NULL;
 
 u32 debug_level = K_ALET | K_CRIT | K_ERR | K_WARNIN | K_NOTICE | K_INFO;
+u32 fake_CDP = 0;
 
 module_param(debug_level , int, 0644);
 MODULE_PARM_DESC(debug_level, "Debug Print Log Lvl");
+module_param(fake_CDP , int, 0644);
 
 #ifdef EP_PROFILING
 u32 is_prof = 1;
@@ -871,6 +873,7 @@ static void ep_prof_work(struct work_struct *data)
 
 static void musb_restore_context(struct musb *musb);
 static void musb_save_context(struct musb *musb);
+extern void usb20_pll_settings(bool host, bool forceOn);
 
 /*-------------------------------------------------------------------------*/
 /*
@@ -897,6 +900,9 @@ void musb_start(struct musb *musb)
 		/* disable IP reset and power down, disable U2/U3 ip power down */
 		_ex_mu3d_hal_ssusb_en();
 
+		/* USB PLL Force settings */
+		usb20_pll_settings(false, false);
+
 		/* reset U3D all dev module. */
 		mu3d_hal_rst_dev();
 
diff --git a/drivers/misc/mediatek/mu3d/drv/musb_gadget.c b/drivers/misc/mediatek/mu3d/drv/musb_gadget.c
index 15b48c2..39b516c 100644
--- a/drivers/misc/mediatek/mu3d/drv/musb_gadget.c
+++ b/drivers/misc/mediatek/mu3d/drv/musb_gadget.c
@@ -107,6 +107,9 @@ static inline void map_dma_buffer(struct musb_request *request,
 	struct dma_controller *dma = musb->dma_controller;
 #endif
 
+	unsigned length;
+	length = ALIGN(request->request.length ,dma_get_cache_alignment());
+
 	request->map_state = UN_MAPPED;
 
 #ifndef USE_SSUSB_QMU
@@ -129,7 +132,7 @@ static inline void map_dma_buffer(struct musb_request *request,
 		request->request.dma = dma_map_single(
 				musb->controller,
 				request->request.buf,
-				request->request.length,
+				length,
 				request->tx
 					? DMA_TO_DEVICE
 					: DMA_FROM_DEVICE);
@@ -137,7 +140,7 @@ static inline void map_dma_buffer(struct musb_request *request,
 	} else {
 		dma_sync_single_for_device(musb->controller,
 			request->request.dma,
-			request->request.length,
+			length,
 			request->tx
 				? DMA_TO_DEVICE
 				: DMA_FROM_DEVICE);
@@ -149,6 +152,9 @@ static inline void map_dma_buffer(struct musb_request *request,
 static inline void unmap_dma_buffer(struct musb_request *request,
 				struct musb *musb)
 {
+	unsigned length;
+	length = ALIGN(request->request.length ,dma_get_cache_alignment());
+
 	if (!is_buffer_mapped(request))
 		return;
 
@@ -160,7 +166,7 @@ static inline void unmap_dma_buffer(struct musb_request *request,
 	if (request->map_state == MUSB_MAPPED) {
 		dma_unmap_single(musb->controller,
 			request->request.dma,
-			request->request.length,
+			length,
 			request->tx
 				? DMA_TO_DEVICE
 				: DMA_FROM_DEVICE);
@@ -168,7 +174,7 @@ static inline void unmap_dma_buffer(struct musb_request *request,
 	} else { /* PRE_MAPPED */
 		dma_sync_single_for_cpu(musb->controller,
 			request->request.dma,
-			request->request.length,
+			length,
 			request->tx
 				? DMA_TO_DEVICE
 				: DMA_FROM_DEVICE);
@@ -924,8 +930,6 @@ static int musb_gadget_queue(struct usb_ep *ep, struct usb_request *req,
 
 	os_printk(K_DEBUG, "%s %s, req=%p, len#%d\n", __func__, ep->name, req, request->request.length);
 
-	dev_dbg(musb->controller, "<== to %s request=%p\n", ep->name, req);
-
 	/* request is mine now... */
 	request->request.actual = 0;
 	request->request.status = -EINPROGRESS;
@@ -1450,6 +1454,26 @@ static int musb_gadget_vbus_draw(struct usb_gadget *gadget, unsigned mA)
 	return usb_phy_set_power(musb->xceiv, mA);
 }
 
+static int usb_rdy;         /* default value 0 */
+static struct delayed_work mu3d_clk_off_work;
+static struct musb *mu3d_clk_off_musb;
+extern void wake_up_bat(void);
+static void do_mu3d_clk_off_work(struct work_struct *work)
+{
+	os_printk(K_NOTICE, "do_mu3d_clk_off_work, issue connection work\n");
+	schedule_delayed_work_on(0, &mu3d_clk_off_musb->connection_work, 0);
+}
+void set_usb_rdy(void){
+	os_printk(K_NOTICE, "set usb_rdy, wake up bat\n");
+	usb_rdy = 1;
+	wake_up_bat();
+}
+kal_bool is_usb_rdy(void){
+	if (usb_rdy)
+		return KAL_TRUE;
+	else
+		return KAL_FALSE;
+}
 static int musb_gadget_pullup(struct usb_gadget *gadget, int is_on)
 {
 	struct musb	*musb = gadget_to_musb(gadget);
@@ -1470,6 +1494,17 @@ static int musb_gadget_pullup(struct usb_gadget *gadget, int is_on)
 	spin_unlock_irqrestore(&musb->lock, flags);
 
 	pm_runtime_put(musb->controller);
+	if(is_usb_rdy() == KAL_FALSE && is_on){
+		set_usb_rdy();
+		if (!is_otg_enabled(musb)){
+#define MY_DELAY 2000
+			INIT_DELAYED_WORK(&mu3d_clk_off_work, do_mu3d_clk_off_work);
+			mu3d_clk_off_musb = musb;
+			os_printk(K_NOTICE, "queue mu3d_clk_off_work, %d ms delayed\n", MY_DELAY);
+			schedule_delayed_work(&mu3d_clk_off_work, msecs_to_jiffies(MY_DELAY));
+		}
+	}
+
 
 	return 0;
 }
@@ -1673,7 +1708,12 @@ static int musb_gadget_start(struct usb_gadget *g,
 	musb->gadget_driver = driver;
 
 	spin_lock_irqsave(&musb->lock, flags);
-	musb->is_active = 1;
+	if(is_usb_rdy() == KAL_TRUE){
+		musb->is_active = 1;
+	}else{
+		os_printk(K_NOTICE, "skip set is_active to 1, leave it to connection_work\n");
+	}
+
 
 	otg_set_peripheral(otg, &musb->g);
 	musb->xceiv->state = OTG_STATE_B_IDLE;
@@ -1685,9 +1725,6 @@ static int musb_gadget_start(struct usb_gadget *g,
 	 * hosts only see fully functional devices.
 	 */
 
-	if (!is_otg_enabled(musb))
-		schedule_delayed_work_on(0, &musb->connection_work, 0);
-
 	spin_unlock_irqrestore(&musb->lock, flags);
 
 	if (is_otg_enabled(musb)) {
diff --git a/drivers/misc/mediatek/mu3d/drv/musb_init.c b/drivers/misc/mediatek/mu3d/drv/musb_init.c
index 8213a72..e7558f2 100644
--- a/drivers/misc/mediatek/mu3d/drv/musb_init.c
+++ b/drivers/misc/mediatek/mu3d/drv/musb_init.c
@@ -676,6 +676,9 @@ static int mtu3d_musb_exit(struct musb *musb)
 extern bool usb_phy_check_in_uart_mode(void);
 extern bool in_uart_mode;
 #endif
+
+extern void usb20_pll_settings(bool host, bool forceOn);
+
 static void mtu3d_musb_reg_init(struct musb *musb)
 {
 	int ret = 1;
@@ -709,6 +712,9 @@ static void mtu3d_musb_reg_init(struct musb *musb)
 		/* disable ip power down, disable U2/U3 ip power down */
 		_ex_mu3d_hal_ssusb_en();
 
+		/* USB PLL Force settings */
+		usb20_pll_settings(false, false);
+
 		/* reset U3D all dev module. */
 		mu3d_hal_rst_dev();
 
diff --git a/drivers/misc/mediatek/pmic_wrap/mt_pmic_wrap.c b/drivers/misc/mediatek/pmic_wrap/mt_pmic_wrap.c
index 3b03a05..916572d 100644
--- a/drivers/misc/mediatek/pmic_wrap/mt_pmic_wrap.c
+++ b/drivers/misc/mediatek/pmic_wrap/mt_pmic_wrap.c
@@ -33,6 +33,14 @@ struct mt_pmic_wrap_driver *get_mt_pmic_wrap_drv(void)
 {
 	return &mt_wrp;
 }
+/*this function only used for ROME plus*/
+int check_pmic_wrap_init(void)
+{
+	if(mt_wrp.wacs2_hal == NULL)
+		return -1;
+	else
+		return 0;
+}
 
 /* ****************************************************************************** */
 /* --external API for pmic_wrap user------------------------------------------------- */
diff --git a/drivers/misc/mediatek/power/mt6752/Makefile b/drivers/misc/mediatek/power/mt6752/Makefile
index eb8bddf..504e094 100755
--- a/drivers/misc/mediatek/power/mt6752/Makefile
+++ b/drivers/misc/mediatek/power/mt6752/Makefile
@@ -1,6 +1,6 @@
 include $(srctree)/drivers/misc/mediatek/Makefile.custom
 
-obj-$(CONFIG_MTK_PMIC)          += pmic.o upmu_common.o pmic_auxadc.o pmic_chr_type_det.o pmic_otg_type_det.o mt6311.o tps6128x.o
+obj-$(CONFIG_MTK_PMIC)          += pmic.o upmu_common.o pmic_auxadc.o pmic_chr_type_det.o tps6128x.o mt6311.o
 
 ifeq ($(CONFIG_MTK_PMIC_DVT_SUPPORT),y)
      obj-$(CONFIG_MTK_PMIC)     += pmic_dvt.o
@@ -8,7 +8,7 @@ endif
 
 obj-$(CONFIG_MTK_SMART_BATTERY) += battery_meter_hal.o 
 
-ifeq ($(MTK_BQ24296_SUPPORT),yes) 
+ifeq ($(CONFIG_MTK_BQ24296_SUPPORT),y) 
       obj-$(CONFIG_MTK_SMART_BATTERY) += charging_hw_bq24296.o bq24296.o tbl_helper_func.o
 else
 ifeq ($(CONFIG_MTK_BQ24261_SUPPORT),y)
@@ -33,5 +33,4 @@ else
       endif
 endif
 
-
 endif
\ No newline at end of file
diff --git a/drivers/misc/mediatek/power/mt6752/battery_meter_hal.c b/drivers/misc/mediatek/power/mt6752/battery_meter_hal.c
index 1fd77d4..71fd0f6 100644
--- a/drivers/misc/mediatek/power/mt6752/battery_meter_hal.c
+++ b/drivers/misc/mediatek/power/mt6752/battery_meter_hal.c
@@ -372,7 +372,7 @@ static kal_int32 fgauge_read_current_sign(void *data)
     return STATUS_OK;
 }
 
-static kal_int32 fgauge_read_columb_internal(void *data, int reset)
+static kal_int32 fgauge_read_columb_internal(void *data, int reset, int precise)
 {
 #if defined(CONFIG_POWER_EXT)
     *(kal_int32*)(data) = 0;
@@ -476,8 +476,13 @@ static kal_int32 fgauge_read_columb_internal(void *data, int reset)
     dvalue_CAR = Temp_Value / 1000; //mAh
     #else
     //dvalue_CAR = (Temp_Value/8)/1000; //mAh, due to FG_OSR=0x8
-    do_div(Temp_Value, 8);
-    do_div(Temp_Value, 1000);
+    if (precise == 0) {
+        do_div(Temp_Value, 8);
+        do_div(Temp_Value, 1000);
+    } else {
+        do_div(Temp_Value, 8);
+        do_div(Temp_Value, 100);
+    }
 
     if(uvalue32_CAR_MSB == 0x1)
         dvalue_CAR = (kal_int32)(Temp_Value - (Temp_Value*2));  // keep negative value
@@ -523,7 +528,12 @@ static kal_int32 fgauge_read_columb_internal(void *data, int reset)
 
 static kal_int32 fgauge_read_columb(void *data)
 {
-    return fgauge_read_columb_internal(data, 0);
+    return fgauge_read_columb_internal(data, 0, 0);
+}
+
+static kal_int32 fgauge_read_columb_accurate(void *data)
+{
+    return fgauge_read_columb_internal(data, 0, 1);
 }
 
 static kal_int32 fgauge_hw_reset(void *data)
@@ -540,7 +550,7 @@ static kal_int32 fgauge_hw_reset(void *data)
     while(val_car != 0x0)
     {
         ret=pmic_config_interface(MT6325_FGADC_CON0, 0x7100, 0xFF00, 0x0);
-        fgauge_read_columb_internal(&val_car_temp, 1);
+        fgauge_read_columb_internal(&val_car_temp, 1, 0);
         val_car = val_car_temp;
         bm_print(BM_LOG_FULL, "#");
     }
@@ -635,6 +645,11 @@ static kal_int32 dump_register_fgadc(void *data)
     return STATUS_OK;
 }
 
+static kal_int32 read_battery_plug_out_status(void *data)
+{
+	return STATUS_OK;
+}
+
 static kal_int32 (* const bm_func[BATTERY_METER_CMD_NUMBER])(void *data)=
 {
     fgauge_initialization		//hw fuel gague used only
@@ -642,6 +657,7 @@ static kal_int32 (* const bm_func[BATTERY_METER_CMD_NUMBER])(void *data)=
     ,fgauge_read_current		//hw fuel gague used only
     ,fgauge_read_current_sign	//hw fuel gague used only
     ,fgauge_read_columb			//hw fuel gague used only
+    ,fgauge_read_columb_accurate
 
     ,fgauge_hw_reset			//hw fuel gague used only
 
@@ -651,6 +667,7 @@ static kal_int32 (* const bm_func[BATTERY_METER_CMD_NUMBER])(void *data)=
     ,read_adc_v_charger
 
     ,read_hw_ocv
+    ,read_battery_plug_out_status
     ,dump_register_fgadc		//hw fuel gague used only
 };
 
diff --git a/drivers/misc/mediatek/power/mt6752/pmic.c b/drivers/misc/mediatek/power/mt6752/pmic.c
index e821aca..e14467d 100644
--- a/drivers/misc/mediatek/power/mt6752/pmic.c
+++ b/drivers/misc/mediatek/power/mt6752/pmic.c
@@ -115,10 +115,7 @@ extern void charger_hv_detect_sw_workaround_init(void);
 extern void pmu_drv_tool_customization_init(void);
 extern void pmic_auxadc_init(void);
 extern int PMIC_IMM_GetOneChannelValue(upmu_adc_chl_list_enum dwChannel, int deCount, int trimd);
-#ifdef HQ_BOOT_WITH_VIBRATOR
-BOOL kernel_vibrate_flag = false; //vibration flag in MTK_KERNEL_POWER_OFF_CHARGING mode
-BOOL pwrkey_pressed_flag = false;//Powerkey pressed flag for vibration in MTK_KERNEL_POWER_OFF_CHARGING mode
-#endif
+
 #if defined (CONFIG_MTK_KERNEL_POWER_OFF_CHARGING)
 extern void mt_power_off(void);
 static kal_bool long_pwrkey_press = false;
@@ -695,10 +692,6 @@ void pwrkey_int_handler(void)
         #if defined (CONFIG_MTK_KERNEL_POWER_OFF_CHARGING)
         if(g_boot_mode == KERNEL_POWER_OFF_CHARGING_BOOT && timer_pre != 0)
         {
-        #ifdef HQ_BOOT_WITH_VIBRATOR
-		BOOL kernel_vibrate_flag = false; //vibration flag in MTK_KERNEL_POWER_OFF_CHARGING mode
-		BOOL pwrkey_pressed_flag = false;//Powerkey pressed flag for vibration in MTK_KERNEL_POWER_OFF_CHARGING mode
-       #endif
                 timer_pos = sched_clock();
                 if(timer_pos - timer_pre >= LONG_PWRKEY_PRESS_TIME)
                 {
@@ -723,9 +716,6 @@ void pwrkey_int_handler(void)
         #if defined (CONFIG_MTK_KERNEL_POWER_OFF_CHARGING)
         if(g_boot_mode == KERNEL_POWER_OFF_CHARGING_BOOT)
         {
-         #ifdef HQ_BOOT_WITH_VIBRATOR
-         pwrkey_pressed_flag = true;
-         #endif
             timer_pre = sched_clock();
         }
         #endif
diff --git a/drivers/misc/mediatek/power/mt6752/tbl_helper_func.c b/drivers/misc/mediatek/power/mt6752/tbl_helper_func.c
index e775480..b063fa5 100644
--- a/drivers/misc/mediatek/power/mt6752/tbl_helper_func.c
+++ b/drivers/misc/mediatek/power/mt6752/tbl_helper_func.c
@@ -1,19 +1,19 @@
 #include <linux/xlog.h>
 #include <mach/mt_typedefs.h>
 
-#ifdef MTK_BQ24196_SUPPORT
+#ifdef CONFIG_MTK_BQ24196_SUPPORT
 #include "bq24196.h"
 #endif
 
-#ifdef MTK_BQ24158_SUPPORT
+#ifdef CONFIG_MTK_BQ24158_SUPPORT
 #include "bq24158.h"
 #endif
 
-#ifdef MTK_BQ24297_SUPPORT
+#ifdef CONFIG_MTK_BQ24297_SUPPORT
 #include "bq24297.h"
 #endif
 
-#ifdef MTK_BQ24296_SUPPORT
+#ifdef CONFIG_MTK_BQ24296_SUPPORT
 #include "bq24296.h"
 #endif
 
@@ -28,26 +28,26 @@ void tbl_charger_otg_vbus(int mode)
     
     if(mode&0xFF)
     {
-#ifdef MTK_BQ24196_SUPPORT    
+#ifdef CONFIG_MTK_BQ24196_SUPPORT    
         bq24196_set_chg_config(0x3); //OTG
         bq24196_set_boost_lim(0x1); //1.3A on VBUS
         bq24196_set_en_hiz(0x0);
 #endif        
 
-#ifdef MTK_BQ24158_SUPPORT
+#ifdef CONFIG_MTK_BQ24158_SUPPORT
         bq24158_set_hz_mode(0);
         bq24158_set_opa_mode(1);
         bq24158_set_otg_pl(1);
         bq24158_set_otg_en(1);
 #endif        
 
-#ifdef MTK_BQ24297_SUPPORT    
+#ifdef CONFIG_MTK_BQ24297_SUPPORT    
         bq24297_set_otg_config(0x1); //OTG
         bq24297_set_boost_lim(0x1); //1.5A on VBUS
         bq24297_set_en_hiz(0x0);
 #endif        
 
-#ifdef MTK_BQ24296_SUPPORT
+#ifdef CONFIG_MTK_BQ24296_SUPPORT
         bq24296_set_chg_config(0x0); //disable charge
         bq24296_set_otg_config(0x1); //OTG
         bq24296_set_boostv(0x7); //boost voltage 4.998V
@@ -57,21 +57,21 @@ void tbl_charger_otg_vbus(int mode)
     }
     else
     {
-#ifdef MTK_BQ24196_SUPPORT        
+#ifdef CONFIG_MTK_BQ24196_SUPPORT        
         bq24196_set_chg_config(0x0); //OTG & Charge disabled
 #endif        
 
-#ifdef MTK_BQ24158_SUPPORT    
+#ifdef CONFIG_MTK_BQ24158_SUPPORT    
         bq24158_set_opa_mode(0);
         bq24158_set_otg_pl(1);
         bq24158_set_otg_en(0);
 #endif        
 
-#ifdef MTK_BQ24297_SUPPORT        
+#ifdef CONFIG_MTK_BQ24297_SUPPORT        
         bq24297_set_otg_config(0x0); //OTG & Charge disabled
 #endif        
 
-#ifdef MTK_BQ24296_SUPPORT
+#ifdef CONFIG_MTK_BQ24296_SUPPORT
         bq24296_set_otg_config(0x0); //OTG disabled
         bq24296_set_chg_config(0x0); //Charge disabled
 #endif
diff --git a/drivers/misc/mediatek/ram_console/mtk_ram_console.c b/drivers/misc/mediatek/ram_console/mtk_ram_console.c
index 6507a32..425fed2 100644
--- a/drivers/misc/mediatek/ram_console/mtk_ram_console.c
+++ b/drivers/misc/mediatek/ram_console/mtk_ram_console.c
@@ -26,6 +26,8 @@
 
 static int mtk_cpu_num;
 
+static int ram_console_init_done;
+
 /*
    This group of API call by sub-driver module to report reboot reasons
    aee_rr_* stand for previous reboot reason
@@ -467,6 +469,7 @@ static int __init ram_console_init(struct ram_console_buffer *buffer, size_t buf
 #if 1
 	register_console(&ram_console);
 #endif
+    ram_console_init_done = 1;
 	return 0;
 }
 
@@ -695,6 +698,8 @@ unsigned int aee_rr_curr_exp_type(void)
 /* composite api */
 void aee_rr_rec_last_irq_enter(int cpu, int irq, u64 jiffies)
 {
+    if (!ram_console_init_done)
+        return;
 	if (cpu >= 0 && cpu < NR_CPUS) {
 		LAST_RR_SET_WITH_ID(last_irq_enter, cpu, irq);
 		LAST_RR_SET_WITH_ID(jiffies_last_irq_enter, cpu, jiffies);
@@ -704,6 +709,8 @@ void aee_rr_rec_last_irq_enter(int cpu, int irq, u64 jiffies)
 
 void aee_rr_rec_last_irq_exit(int cpu, int irq, u64 jiffies)
 {
+    if (!ram_console_init_done)
+        return;
 	if (cpu >=0 && cpu < NR_CPUS) {
 		LAST_RR_SET_WITH_ID(last_irq_exit, cpu, irq);
 		LAST_RR_SET_WITH_ID(jiffies_last_irq_exit, cpu, jiffies);
@@ -713,6 +720,8 @@ void aee_rr_rec_last_irq_exit(int cpu, int irq, u64 jiffies)
 
 void aee_rr_rec_last_sched_jiffies(int cpu, u64 jiffies, const char *comm)
 {
+    if (!ram_console_init_done)
+        return;
 	if (cpu >=0 && cpu < NR_CPUS) {
 		LAST_RR_SET_WITH_ID(jiffies_last_sched, cpu, jiffies);
 		LAST_RR_MEMCPY_WITH_ID(last_sched_comm, cpu, comm, TASK_COMM_LEN);
diff --git a/drivers/misc/mediatek/selinux_warning/mtk_selinux_warning_list.h b/drivers/misc/mediatek/selinux_warning/mtk_selinux_warning_list.h
index a62c580..e7acd0a 100644
--- a/drivers/misc/mediatek/selinux_warning/mtk_selinux_warning_list.h
+++ b/drivers/misc/mediatek/selinux_warning/mtk_selinux_warning_list.h
@@ -10,60 +10,10 @@ extern int selinux_enforcing;
 #define AEE_FILTER_NUM 70
 const char *aee_filter_list[AEE_FILTER_NUM] = {
 /*	"u:r:adbd:s0", */
-	"u:r:bootanim:s0",
-	"u:r:bluetooth:s0",
-	"u:r:binderservicedomain:s0",
-/*	"u:r:clatd:s0", */
-	"u:r:dex2oat:s0",
-/*	"u:r:debuggerd:s0", */
-	"u:r:dhcp:s0",
-	"u:r:dnsmasq:s0",
-	"u:r:drmserver:s0",
-	"u:r:dumpstate:s0",
-	"u:r:gpsd:s0",
-	"u:r:healthd:s0",
-	"u:r:hci_attach:s0",
-	"u:r:hostapd:s0",
-	"u:r:inputflinger:s0",
-	"u:r:installd:s0",
-	"u:r:isolated_app:s0",
-	"u:r:keystore:s0",
-	"u:r:lmkd:s0",
-	"u:r:mdnsd:s0",
-	"u:r:logd:s0",
-/*	"u:r:mediaserver:s0", */
-	"u:r:mtp:s0",
+	"u:r:zygote:s0",
 	"u:r:netd:s0",
-	"u:r:nfc:s0",
-	"u:r:ppp:s0",
-/*	"u:r:platform_app:s0", */
-	"u:r:racoon:s0",
-/*	"u:r:radio:s0", */
-	"u:r:recovery:s0",
-	"u:r:rild:s0",
-	"u:r:runas:s0",
-	"u:r:sdcardd:s0",
-	"u:r:servicemanager:s0",
-	"u:r:shared_relro:s0",
-/*	"u:r:shell:s0", */
-	"u:r:system_app:s0",
-/*	"u:r:system_server:s0", */
-	"u:r:surfaceflinger:s0",
-	"u:r:tee:s0",
-	"u:r:uncrypt:s0",
-	"u:r:watchdogd:s0",
-	"u:r:wpa:s0",
-	"u:r:ueventd:s0",
+	"u:r:installd:s0",
 	"u:r:vold:s0",
-	"u:r:vdc:s0",
-/*	"u:r:untrusted_app:s0", */
-	"u:r:zygote:s0",
-	"u:r:mobile_log_d:s0",
-	"u:r:guiext-server:s0",
-	"u:r:mtkrild:s0",
-	"u:r:mtkrildmd2:s0",
-	"u:r:nvram_agent_binder:s0",
-	"u:r:nvram_daemon:s0",
 };
 
 #endif
diff --git a/drivers/misc/mediatek/sensorHub/SCP_sensorHub/SCP_sensorHub.c b/drivers/misc/mediatek/sensorHub/SCP_sensorHub/SCP_sensorHub.c
index 945182f..f36e6da 100644
--- a/drivers/misc/mediatek/sensorHub/SCP_sensorHub/SCP_sensorHub.c
+++ b/drivers/misc/mediatek/sensorHub/SCP_sensorHub/SCP_sensorHub.c
@@ -311,6 +311,21 @@ static void SCP_sensorHub_power(struct sensorHub_hw *hw, unsigned int on)
 {
 }
 /*----------------------------------------------------------------------------*/
+static unsigned long long SCP_sensorHub_GetCurNS()
+{
+/*
+    int64_t  nt;
+    struct timespec time;
+
+    time.tv_sec = 0;
+    time.tv_nsec = 0;
+    get_monotonic_boottime(&time);
+    nt = time.tv_sec*1000000000LL+time.tv_nsec;
+*/
+
+    return sched_clock();
+}
+/*----------------------------------------------------------------------------*/
 //md32 may lock hw semaphore about 6.x ms to push data to dram.
 static int SCP_sensorHub_get_md32_semaphore()
 {
@@ -741,6 +756,7 @@ static void SCP_sensorHub_late_resume(struct early_suspend *h)
 /*----------------------------------------------------------------------------*/
 #endif //#if !defined(CONFIG_HAS_EARLYSUSPEND) || !defined(USE_EARLY_SUSPEND)
 /*----------------------------------------------------------------------------*/
+static unsigned long long t1, t2, t3, t4, t5, t6;
 int SCP_sensorHub_req_send(SCP_SENSOR_HUB_DATA_P data, uint *len, unsigned int wait)
 {
     ipi_status status;
@@ -817,6 +833,8 @@ int SCP_sensorHub_req_send(SCP_SENSOR_HUB_DATA_P data, uint *len, unsigned int w
         wait_event_interruptible(SCP_sensorHub_req_wq, (atomic_read(&(obj_data->wait_rsp)) == 0));
         del_timer_sync(&obj_data->timer);
         err = userData->rsp.errCode;
+        if (t6-t1 > 3000000LL)
+            SCP_ERR("%llu, %llu, %llu, %llu, %llu, %llu\n", t1, t2, t3, t4, t5, t6);
         mutex_unlock(&SCP_sensorHub_req_mutex);
     }
 
@@ -888,6 +906,8 @@ static void SCP_sensorHub_IPI_handler(int id, void *data, unsigned int len)
     bool do_registed_handler = false;
     static int first_init_done = 0;
 
+    t1 = SCP_sensorHub_GetCurNS();
+
     if (SCP_TRC_FUN == atomic_read(&(obj_data->trace)))
         SCP_FUN();
 
@@ -945,6 +965,8 @@ static void SCP_sensorHub_IPI_handler(int id, void *data, unsigned int len)
                 return;
         }
 
+        t2 = SCP_sensorHub_GetCurNS();
+
         if (ID_SENSOR_MAX_HANDLE < rsp->rsp.sensorType)
         {
             SCP_ERR("SCP_sensorHub_IPI_handler invalid sensor type %d\n", rsp->rsp.sensorType);
@@ -958,6 +980,8 @@ static void SCP_sensorHub_IPI_handler(int id, void *data, unsigned int len)
             }
         }
 
+        t3 = SCP_sensorHub_GetCurNS();
+
         if(atomic_read(&(obj_data->wait_rsp)) == 1 && true == wake_up_req)
         {
             if (NULL == userData || NULL == userDataLen)
@@ -973,8 +997,11 @@ static void SCP_sensorHub_IPI_handler(int id, void *data, unsigned int len)
                 memcpy(userData, rsp, len);
                 *userDataLen = len;
             }
+            t4 = SCP_sensorHub_GetCurNS();
             atomic_set(&(obj_data->wait_rsp), 0);
+            t5 = SCP_sensorHub_GetCurNS();
             wake_up(&SCP_sensorHub_req_wq);
+            t6 = SCP_sensorHub_GetCurNS();
         }
     }
 }
@@ -1038,7 +1065,7 @@ static int SCP_sensorHub_get_fifo_status(int *dataLen, int *status, char *reserv
 
     if (SCP_TRC_FUN == atomic_read(&(obj_data->trace)))
         SCP_FUN();
-    for (i=0;i<=MAX_ANDROID_SENSOR_NUM;i++)
+    for (i=0;i<=ID_SENSOR_MAX_HANDLE;i++)
     {
         pt[i].total_count = 0;
     }
@@ -1241,7 +1268,7 @@ static int SCP_sensorHub_probe(/*struct platform_device *pdev*/)
 
     ctl.enable_hw_batch = SCP_sensorHub_enable_hw_batch;
 	ctl.flush = SCP_sensorHub_flush;
-	err = batch_register_control_path(MAX_ANDROID_SENSOR_NUM, &ctl);
+	err = batch_register_control_path(ID_SENSOR_MAX_HANDLE, &ctl);
 	if(err)
 	{
 	 	SCP_ERR("register SCP sensor hub control path err\n");
@@ -1251,7 +1278,7 @@ static int SCP_sensorHub_probe(/*struct platform_device *pdev*/)
 	data.get_data = SCP_sensorHub_get_data;
     data.get_fifo_status = SCP_sensorHub_get_fifo_status;
 	data.is_batch_supported = 1;
-	err = batch_register_data_path(MAX_ANDROID_SENSOR_NUM, &data);
+	err = batch_register_data_path(ID_SENSOR_MAX_HANDLE, &data);
 	if(err)
 	{
 	 	SCP_ERR("register SCP sensor hub control data path err\n");
diff --git a/drivers/misc/mediatek/spm/mt6752/mt_spm_dpidle.c b/drivers/misc/mediatek/spm/mt6752/mt_spm_dpidle.c
index 1e07fd1..c2aa900 100644
--- a/drivers/misc/mediatek/spm/mt6752/mt_spm_dpidle.c
+++ b/drivers/misc/mediatek/spm/mt6752/mt_spm_dpidle.c
@@ -204,21 +204,19 @@ static const u32 dpidle_binary[] = {
 	0xe2200088, 0xe2200002, 0xe8208000, 0x10059c24, 0x00000001, 0x1b80001f,
 	0x20000158, 0xd0006bc0, 0x17c07c1f, 0xe2200088, 0xe2200000, 0xe8208000,
 	0x10059c24, 0x00000001, 0x1b80001f, 0x20000158, 0xf0000000, 0x17c07c1f,
-	0x1880001f, 0x0000001d, 0x814a1801, 0xd8006ec5, 0x17c07c1f, 0x81499801,
-	0xd8006fc5, 0x17c07c1f, 0x814a9801, 0xd80070c5, 0x17c07c1f, 0x814b9801,
-	0xd80071c5, 0x17c07c1f, 0x18d0001f, 0x40000000, 0x18d0001f, 0x40000000,
-	0xd8006dc2, 0x00a00402, 0xd00072c0, 0x17c07c1f, 0x18d0001f, 0x40000000,
-	0x18d0001f, 0x80000000, 0xd8006ec2, 0x00a00402, 0xd00072c0, 0x17c07c1f,
-	0x18d0001f, 0x40000000, 0x18d0001f, 0x60000000, 0xd8006fc2, 0x00a00402,
-	0xd00072c0, 0x17c07c1f, 0x18d0001f, 0x40000000, 0x18d0001f, 0xc0000000,
-	0xd80070c2, 0x00a00402, 0xd00072c0, 0x17c07c1f, 0x18d0001f, 0x40000000,
-	0x18d0001f, 0xa0000000, 0xd80071c2, 0x00a00402, 0xd00072c0, 0x17c07c1f,
-	0xf0000000, 0x17c07c1f
+	0x1880001f, 0x0000001d, 0x814a1801, 0xd8006e65, 0x17c07c1f, 0x81499801,
+	0xd8006f65, 0x17c07c1f, 0x814a9801, 0xd8007065, 0x17c07c1f, 0x18d0001f,
+	0x40000000, 0x18d0001f, 0x40000000, 0xd8006d62, 0x00a00402, 0xd0007160,
+	0x17c07c1f, 0x18d0001f, 0x40000000, 0x18d0001f, 0x80000000, 0xd8006e62,
+	0x00a00402, 0xd0007160, 0x17c07c1f, 0x18d0001f, 0x40000000, 0x18d0001f,
+	0x60000000, 0xd8006f62, 0x00a00402, 0xd0007160, 0x17c07c1f, 0x18d0001f,
+	0x40000000, 0x18d0001f, 0xc0000000, 0xd8007062, 0x00a00402, 0xd0007160,
+	0x17c07c1f, 0xf0000000, 0x17c07c1f
 };
 static struct pcm_desc dpidle_pcm = {
-	.version	= "pcm_deepidle_v19.16_20150105",
+	.version	= "pcm_deepidle_v19.15_20140731-exp1-no_6311_low_power_mode",
 	.base		= dpidle_binary,
-	.size		= 920,
+	.size		= 909,
 	.sess		= 2,
 	.replace	= 0,
 	.vec0		= EVENT_VEC(11, 1, 0, 0),	/* FUNC_26M_WAKEUP */
@@ -587,8 +585,6 @@ bool spm_set_dpidle_pcm_init_flag(void)
         slp_spm_deepidle_flags |= SPM_DRAM_RANK1_ADDR_SEL1;		
     else if(dram_info->rank_info[1].start==0xc0000000)
         slp_spm_deepidle_flags |= SPM_DRAM_RANK1_ADDR_SEL2;	
-    else if(dram_info->rank_info[1].start==0xa0000000)
-        slp_spm_deepidle_flags |= SPM_DRAM_RANK1_ADDR_SEL3;	    
     else if(dram_info->rank_info[1].size!=0x0)
     {
         //printk("dram rank1_info_error: %x\n",dram_info->rank_info[1].start);
diff --git a/drivers/misc/mediatek/spm/mt6752/mt_spm_sleep.c b/drivers/misc/mediatek/spm/mt6752/mt_spm_sleep.c
index eb3ac15..5369f7a 100644
--- a/drivers/misc/mediatek/spm/mt6752/mt_spm_sleep.c
+++ b/drivers/misc/mediatek/spm/mt6752/mt_spm_sleep.c
@@ -971,8 +971,6 @@ static int dt_scan_memory(unsigned long node, const char *uname, int depth, void
             spm_suspend_flag |= SPM_DRAM_RANK1_ADDR_SEL1;		
         else if(dram_info->rank_info[1].start==0xc0000000)
             spm_suspend_flag |= SPM_DRAM_RANK1_ADDR_SEL2;	
-        else if(dram_info->rank_info[1].start==0xa0000000)
-            spm_suspend_flag  |= SPM_DRAM_RANK1_ADDR_SEL3;	
         else if(dram_info->rank_info[1].size!=0x0)
         {
             spm_err("dram rank1_info_error: 0x%llx\n",dram_info->rank_info[1].start);
diff --git a/drivers/misc/mediatek/step_counter/step_counter.c b/drivers/misc/mediatek/step_counter/step_counter.c
index 5eb3b13..c3404c1 100644
--- a/drivers/misc/mediatek/step_counter/step_counter.c
+++ b/drivers/misc/mediatek/step_counter/step_counter.c
@@ -168,7 +168,7 @@ static int step_d_real_enable(int enable)
   if(0==enable)
   {
     
-     err = cxt->step_c_ctl.enable_nodata(0);
+     err = cxt->step_c_ctl.enable_step_detect(0);
      if(err)
      { 
         	STEP_C_ERR("step_d enable(%d) err = %d\n", enable, err);
diff --git a/drivers/misc/mediatek/thermal/mt6752/mtk_ts_bts.c b/drivers/misc/mediatek/thermal/mt6752/mtk_ts_bts.c
index 9a51060..53f3cc1 100644
--- a/drivers/misc/mediatek/thermal/mt6752/mtk_ts_bts.c
+++ b/drivers/misc/mediatek/thermal/mt6752/mtk_ts_bts.c
@@ -104,7 +104,7 @@ typedef struct{
 
 #define CH_IN0_NTC (0) //NTC6301
 
-#if 1 //K2
+#if 1
 static int g_RAP_pull_up_R = 390000;//390K,pull up resister
 static int g_TAP_over_critical_low =4251000 ;//base on 100K NTC temp default value -40 deg
 static int g_RAP_pull_up_voltage = 1800;//1.8V ,pull up voltage
diff --git a/drivers/misc/mediatek/thermal/mt6752/mtk_ts_btsmdpa.c b/drivers/misc/mediatek/thermal/mt6752/mtk_ts_btsmdpa.c
index 8803b3f..b420e4b 100644
--- a/drivers/misc/mediatek/thermal/mt6752/mtk_ts_btsmdpa.c
+++ b/drivers/misc/mediatek/thermal/mt6752/mtk_ts_btsmdpa.c
@@ -103,7 +103,7 @@ typedef struct{
 #define CH_IN1_NTC (1)
 
 
-#if 1 //K2
+#if 1
 static int g_RAP_pull_up_R = 390000;//390K,pull up resister
 static int g_TAP_over_critical_low =4251000 ;//base on 100K NTC temp default value -40 deg
 static int g_RAP_pull_up_voltage = 1800;//1.8V ,pull up voltage
diff --git a/drivers/misc/mediatek/usb20/mt6752/usb20_host.c b/drivers/misc/mediatek/usb20/mt6752/usb20_host.c
index 10a26c6..0b80a53 100644
--- a/drivers/misc/mediatek/usb20/mt6752/usb20_host.c
+++ b/drivers/misc/mediatek/usb20/mt6752/usb20_host.c
@@ -36,7 +36,6 @@
 #include <linux/of_i2c.h>
 #endif
 
-
 // tangqingcai sync usb otg
 #ifdef CONFIG_MTK_BQ24296_SUPPORT
 extern void bq24296_set_en_hiz(kal_uint32 val);
diff --git a/drivers/misc/mediatek/usb20/mt6752/usb20_phy.c b/drivers/misc/mediatek/usb20/mt6752/usb20_phy.c
index 2e0866f..e3e1239 100644
--- a/drivers/misc/mediatek/usb20/mt6752/usb20_phy.c
+++ b/drivers/misc/mediatek/usb20/mt6752/usb20_phy.c
@@ -434,41 +434,15 @@ static void usb_phy_savecurrent_internal(void){
 void usb_phy_savecurrent(void){
 
     usb_phy_savecurrent_internal();
-    //to avoid hw access during clock-off
-    unsigned long flags;
-    int do_lock = 0;
-    extern int musb_is_shutting;
-
-    // to avoid deadlock, musb_shutdown will hold this clock too
-    if(mtk_musb && !musb_is_shutting){
-        spin_lock_irqsave(&mtk_musb->lock, flags);
-        do_lock = 1;
-    }
     //4 14. turn off internal 48Mhz PLL.
     usb_enable_clock(false);
-
-    if(do_lock){
-        spin_unlock_irqrestore(&mtk_musb->lock, flags);
-    }
-
     printk("usb save current success\n");
 }
 
 void usb_phy_recover(void){
 
-    unsigned long flags;
-    int do_lock = 0;
-    dump_stack();
-    if(mtk_musb){
-        spin_lock_irqsave(&mtk_musb->lock, flags);
-        do_lock = 1;
-    }
     //4 1. turn on USB reference clock.
     usb_enable_clock(true);
-
-    if(do_lock){
-        spin_unlock_irqrestore(&mtk_musb->lock, flags);
-    }
     //4 2. wait 50 usec.
     udelay(50);
 
@@ -552,8 +526,6 @@ void usb_phy_recover(void){
     #endif
     hs_slew_rate_cal();
 
-	// adjust TERM_VREF_SEL to 440mv
-     USBPHY_SET8(0x05, 0x70);
     printk("usb recovery success\n");
     return;
 }
diff --git a/drivers/misc/mediatek/watchpoint/mt6752/aarch32/hw_watchpoint_aarch32.c b/drivers/misc/mediatek/watchpoint/mt6752/aarch32/hw_watchpoint_aarch32.c
index c0704fe..691ddea 100644
--- a/drivers/misc/mediatek/watchpoint/mt6752/aarch32/hw_watchpoint_aarch32.c
+++ b/drivers/misc/mediatek/watchpoint/mt6752/aarch32/hw_watchpoint_aarch32.c
@@ -20,19 +20,19 @@ struct wp_trace_context_t wp_tracer;
  int err;
  volatile int my_watch_data2;
  int wp_flag;
- int my_wp_handler1(unsigned int addr)
+ int my_wp_handler1(unsigned long addr)
  {
      
      wp_flag++; 
-     pr_notice("[MTK WP] Access my data from an instruction at 0x%x\n" ,addr);
+     pr_notice("[MTK WP] Access my data from an instruction at 0x%lx\n" ,addr);
      return 0;
  }
 
- int my_wp_handler2(unsigned int addr)
+ int my_wp_handler2(unsigned long addr)
  {
    
      //this_cpu = get_cpu();
-     pr_notice("[MTK WP] In my_wp_handler2 Access my data from an instruction at 0x%x\n",addr);
+     pr_notice("[MTK WP] In my_wp_handler2 Access my data from an instruction at 0x%lx\n",addr);
      /* trigger exception */
      return 0;
  }
@@ -167,6 +167,39 @@ void wp_test3(void)
 } 
 #endif
 
+
+unsigned int non_invasive_debug_enable(void){
+        unsigned int auth_status = 0 ;
+        unsigned int wp_enable = 0;
+
+#ifdef CONFIG_ARM64
+        asm volatile("MRS %0,DBGAUTHSTATUS_EL1" : "=r" (auth_status));
+        wp_enable = (auth_status >> NSNID_SHIFT) & 0x1;
+#else
+
+/*
+* Since we can't read SCR register in non-secure mode, we can't get info about
+* which mode we are in.
+* Thus, We use these config to identify if this is ATF or TEE Project.
+* If, it is ATF/TEE Proejct kernel is run in non-secure mode, else it is run in secure mode.
+*/
+
+#if  defined(CONFIG_ARM_PSCI) || defined(CONFIG_MTK_PSCI)
+        asm volatile("MRC p14,0,%0,c7,c14,6" : "=r" (auth_status));
+        wp_enable = (auth_status >> NSNID_SHIFT) & 0x1;
+#else
+        asm volatile("MRC p14,0,%0,c7,c14,6" : "=r" (auth_status));
+        wp_enable = (auth_status >> SNID_SHIFT) & 0x1;
+#endif
+#endif
+        pr_notice("[MTK WP] Authencation Interface, status 0x%x, wp_enable 0x%x\n",auth_status,wp_enable);
+        return wp_enable;
+
+};
+
+
+
+
 void smp_read_dbgdscr_callback(void *info)
 {
     unsigned long tmp;
@@ -257,6 +290,13 @@ int enable_hw_watchpoint(void)
     unsigned int args;
     int oslsr;
     int dbglsr;
+
+
+    if(!non_invasive_debug_enable()){
+        pr_notice("[MTK WP] WATCHPOINT DEBUG is not permitted by authentication interface of this chip\n");
+        return -EPERM;
+    }
+
     pr_notice("[MTK WP] Hotplug disable\n");
     cpu_hotplug_disable();
     for(i = 0 ; i < num_possible_cpus() ; i++) {
@@ -307,6 +347,11 @@ int add_hw_watchpoint(struct wp_event *wp_event)
     unsigned long flags;
     unsigned int ctl;
 
+    if(!non_invasive_debug_enable()){
+        pr_notice("[MTK WP] WATCHPOINT DEBUG is not permitted by authentication interface of this chip\n");
+        return -EPERM ;
+    }
+
     if (!wp_event) {
         return -EINVAL;
     }
@@ -350,7 +395,7 @@ int add_hw_watchpoint(struct wp_event *wp_event)
     wp_tracer.wp_events[i].auto_disable = wp_event->auto_disable;
     pr_notice("[MTK WP] Hotplug disable\n");
     cpu_hotplug_disable();
-    pr_notice("[MTK WP] Add watchpoint %d at address 0x%x\n", i, wp_tracer.wp_events[i].virt);
+    pr_notice("[MTK WP] Add watchpoint %d at address 0x%lx\n", i, wp_tracer.wp_events[i].virt);
     for(j = 0; j <  num_possible_cpus(); j++) {
         if(cpu_online(j)){
           cs_cpu_write(wp_tracer.debug_regs[j], DBGWVR + (i << 4),wp_tracer.wp_events[i].virt);
@@ -383,6 +428,12 @@ int del_hw_watchpoint(struct wp_event *wp_event)
     unsigned long flags;
     int i, j;
 
+    if(!non_invasive_debug_enable()){
+        pr_notice("[MTK WP] WATCHPOINT DEBUG is not permitted by authentication interface of this chip\n");
+        return -EPERM ;
+    }
+
+
     if (!wp_event) {
         return -EINVAL;
     }
@@ -447,6 +498,12 @@ int watchpoint_handler(unsigned long addr, unsigned int fsr, struct pt_regs *reg
     /* update PC to avoid re-execution of the instruction under watching */
     regs->ARM_pc += thumb_mode(regs)? 2: 4;
 
+    if(!non_invasive_debug_enable()){
+        pr_notice("[MTK WP] WATCHPOINT DEBUG is not permitted by authentication interface of this chip\n");
+        return -EPERM;
+    }
+
+
     for (i = 0; i < MAX_NR_WATCH_POINT; i++) {
         if (wp_tracer.wp_events[i].in_use && wp_tracer.wp_events[i].virt == (daddr)) {
             pr_notice("[MTK WP] Watchpoint %d triggers.\n", i);
@@ -512,6 +569,12 @@ int wp_probe(struct platform_device *pdev)
            pr_notice("[MTK WP] debug_interface %d @ vm:0x%p pm:0x%x \n", i, wp_tracer.debug_regs[i],IO_VIRT_TO_PHYS((unsigned int)wp_tracer.debug_regs[i]));
          }
     }
+
+    if(!non_invasive_debug_enable()){
+        pr_notice("[MTK WP] WATCHPOINT DEBUG is not permitted by authentication interface of this chip\n");
+        return -EPERM;
+    }
+
     ARM_DBG_READ(c0,c0,0,wp_tracer.dbgdidr); 
     wp_tracer.wp_nr=((wp_tracer.dbgdidr & (0xf <<28))>>28);
     wp_tracer.bp_nr=((wp_tracer.dbgdidr & (0xf <<24))>>24);
@@ -573,7 +636,6 @@ DRIVER_ATTR(wp_test_suit, 0664, wp_test_suit_show, wp_test_suit_store);
 static int __init hw_watchpoint_init(void)
 {
     int err;
-    int ret;
     spin_lock_init(&wp_lock);
     err = platform_driver_register(&wp_driver);
     if (err) {
diff --git a/drivers/misc/mediatek/watchpoint/mt6752/aarch32/hw_watchpoint_aarch32.h b/drivers/misc/mediatek/watchpoint/mt6752/aarch32/hw_watchpoint_aarch32.h
index b402873..5eef5d8 100644
--- a/drivers/misc/mediatek/watchpoint/mt6752/aarch32/hw_watchpoint_aarch32.h
+++ b/drivers/misc/mediatek/watchpoint/mt6752/aarch32/hw_watchpoint_aarch32.h
@@ -1,37 +1,8 @@
-#ifndef __HW_BREAKPOINT_H
-#define __HW_BREAKPOINT_H
+#ifndef __HW_BREAKPOINT_32_H
+#define __HW_BREAKPOINT_32_H
 #include <mach/sync_write.h>
 #include <asm/io.h>
-typedef int (*wp_handler)(unsigned int addr);
-
-struct wp_event
-{
-    unsigned int virt;
-    unsigned int phys;
-    int type;
-    wp_handler handler;
-    int in_use;
-    int auto_disable;
-};
-
-#define WP_EVENT_TYPE_READ 1
-#define WP_EVENT_TYPE_WRITE 2
-#define WP_EVENT_TYPE_ALL 3
-
-#define init_wp_event(__e, __v, __p, __t, __h)   \
-        do {    \
-            (__e)->virt = (__v);    \
-            (__e)->phys = (__p);    \
-            (__e)->type = (__t);    \
-            (__e)->handler = (__h);    \
-            (__e)->auto_disable = 0;    \
-        } while (0)
-
-#define auto_disable_wp(__e)   \
-        do {    \
-            (__e)->auto_disable = 1;    \
-        } while (0)
-
+#include <mach/hw_watchpoint.h>
 
 #define MAX_NR_WATCH_POINT 4  
 struct wp_trace_context_t
@@ -80,6 +51,7 @@ struct dbgreg_set {
 
 #define DBGLAR 0xFB0
 #define DBGLSR 0xFB4
+#define DBGAUTHSTATUS_EL1 0xFB8
 #define DBGOSLAR 0x300
 //#define NUM_CPU    4 // max cpu# per cluster
 
@@ -93,6 +65,8 @@ struct dbgreg_set {
 #define LSC_STR (2 << 3)
 #define LSC_ALL (3 << 3)
 
+#define NSNID_SHIFT 2
+#define SNID_SHIFT 6
 //#define WATCHPOINT_TEST_SUIT
 
 #define ARM_DBG_READ(N, M, OP2, VAL) do {\
@@ -129,11 +103,9 @@ void smp_read_dbgdscr_callback(void *info);
 void smp_write_dbgdscr_callback(void *info);
 void smp_read_dbgoslsr_callback(void *info);
 void smp_write_dbgoslsr_callback(void *info);
- void smp_read_dbgvcr_callback(void *info);
+void smp_read_dbgvcr_callback(void *info);
 void smp_write_dbgvcr_callback(void *info);
 int register_wp_context(struct wp_trace_context_t **wp_tracer_context );
-extern int add_hw_watchpoint(struct wp_event *wp_event);
-extern int del_hw_watchpoint(struct wp_event *wp_event);
 void __iomem* get_wp_base(void);
 void smp_read_dbgdscr_callback(void *info);
 void smp_write_dbgdscr_callback(void *info);
@@ -141,4 +113,4 @@ void smp_read_dbgoslsr_callback(void *info);
 void smp_write_dbgoslsr_callback(void *info);
 
 
-#endif  /* !__HW_BREAKPOINT_H */
+#endif  /* !__HW_BREAKPOINT_32_H */
diff --git a/drivers/misc/mediatek/watchpoint/mt6752/aarch64/hw_watchpoint_aarch64.c b/drivers/misc/mediatek/watchpoint/mt6752/aarch64/hw_watchpoint_aarch64.c
index 82a9855..b367bc7 100644
--- a/drivers/misc/mediatek/watchpoint/mt6752/aarch64/hw_watchpoint_aarch64.c
+++ b/drivers/misc/mediatek/watchpoint/mt6752/aarch64/hw_watchpoint_aarch64.c
@@ -171,6 +171,38 @@ void wp_test3(void)
 } 
 #endif
 
+
+static unsigned int non_invasive_debug_enable(void){
+        unsigned int auth_status = 0 ;
+        unsigned int wp_enable = 0;
+
+#ifdef CONFIG_ARM64
+        asm volatile("MRS %0,DBGAUTHSTATUS_EL1" : "=r" (auth_status));
+        wp_enable = (auth_status >> NSNID_SHIFT) & 0x1;
+#else
+
+
+/*
+* Since we can't read SCR register in non-secure mode, we can't get info about
+* which mode we are in.
+* Thus, We use these config to identify if this is ATF or TEE Project.
+* If, it is ATF/TEE Proejct kernel is run in non-secure mode, else it is run in secure mode.
+*/
+
+#if  defined(CONFIG_ARM_PSCI) || defined(CONFIG_MTK_PSCI)
+        asm volatile("MRC p14,0,%0,c7,c14,6" : "=r" (auth_status));
+        wp_enable = (auth_status >> NSNID_SHIFT) & 0x1;
+#else
+        asm volatile("MRC p14,0,%0,c7,c14,6" : "=r" (auth_status));
+        wp_enable = (auth_status >> SNID_SHIFT) & 0x1;
+#endif
+#endif
+        pr_notice("[MTK WP] Authencation Interface, status 0x%x, wp_enable 0x%x\n",auth_status,wp_enable);
+        return wp_enable;
+
+};
+
+
 void smp_read_MDSCR_EL1_callback(void *info)
 {
     unsigned int tmp;
@@ -215,6 +247,11 @@ int enable_hw_watchpoint(void)
     unsigned int args;
     int oslsr_el1;
     int edlsr;
+
+    if(!non_invasive_debug_enable()){
+        pr_notice("[MTK WP] WATCHPOINT DEBUG is not permitted by authentication interface of this chip\n");
+        return -EPERM;
+    }
     pr_notice("[MTK WP] Hotplug disable\n");
     cpu_hotplug_disable();
     for(i = 0 ; i < num_possible_cpus() ; i++) {
@@ -262,6 +299,12 @@ void reset_watchpoint(void)
 	int j;
     int i;
     unsigned int args;
+
+    if(!non_invasive_debug_enable()){
+        pr_notice("[MTK WP] WATCHPOINT DEBUG is not permitted by authentication interface of this chip\n");
+        return ;
+    }
+
     for(j = 0; j <  num_possible_cpus(); j++) {
 		if(cpu_online(j)){
    		    cs_cpu_write(wp_tracer.debug_regs[j], EDLAR ,UNLOCK_KEY);
@@ -312,6 +355,12 @@ int add_hw_watchpoint(struct wp_event *wp_event)
     unsigned long flags;
     unsigned int ctl;
 
+    if(!non_invasive_debug_enable()){
+        pr_notice("[MTK WP] WATCHPOINT DEBUG is not permitted by authentication interface of this chip\n");
+        return -EPERM;
+    }
+
+
     if (!wp_event) {
         return -EINVAL;
     }
@@ -396,6 +445,11 @@ int del_hw_watchpoint(struct wp_event *wp_event)
     unsigned long flags;
     int i, j;
 
+    if(!non_invasive_debug_enable()){
+        pr_notice("[MTK WP] WATCHPOINT DEBUG is not permitted by authentication interface of this chip\n");
+        return -EPERM;
+    }
+
     if (!wp_event) {
         return -EINVAL;
     }
@@ -446,6 +500,11 @@ static int watchpoint_handler(unsigned long addr, unsigned int esr,
 
     /* update PC to avoid re-execution of the instruction under watching */
     regs->pc += compat_thumb_mode(regs)? 2: 8;
+    if(!non_invasive_debug_enable()){
+        pr_notice("[MTK WP] WATCHPOINT DEBUG is not permitted by authentication interface of this chip\n");
+        return -EPERM;
+    }
+
 
     for (i = 0; i < MAX_NR_WATCH_POINT; i++) {
         if (wp_tracer.wp_events[i].in_use && wp_tracer.wp_events[i].virt == (daddr)) {
@@ -513,6 +572,13 @@ int wp_probe(struct platform_device *pdev)
            pr_notice("[MTK WP] debug_interface %d @ vm:0x%p pm:0x%lx \n", i, wp_tracer.debug_regs[i],vmalloc_to_pfn((void *)wp_tracer.debug_regs[i])<<12);
          }
     }
+
+
+    if(!non_invasive_debug_enable()){
+        pr_notice("[MTK WP] WATCHPOINT DEBUG is not permitted by authentication interface of this chip\n");
+        return -EPERM;
+    }
+
     asm volatile("mrs %0, ID_AA64DFR0_EL1" : "=r" (wp_tracer.id_aaa64dfr0_el1)); 
     wp_tracer.wp_nr=((wp_tracer.id_aaa64dfr0_el1 & (0xf <<20))>>20)+1;
     wp_tracer.bp_nr=((wp_tracer.id_aaa64dfr0_el1 & (0xf <<12))>>12)+1;
diff --git a/drivers/misc/mediatek/watchpoint/mt6752/aarch64/hw_watchpoint_aarch64.h b/drivers/misc/mediatek/watchpoint/mt6752/aarch64/hw_watchpoint_aarch64.h
index af2a3d7..11ffb81 100644
--- a/drivers/misc/mediatek/watchpoint/mt6752/aarch64/hw_watchpoint_aarch64.h
+++ b/drivers/misc/mediatek/watchpoint/mt6752/aarch64/hw_watchpoint_aarch64.h
@@ -1,37 +1,8 @@
-#ifndef __HW_BREAKPOINT_H
-#define __HW_BREAKPOINT_H
+#ifndef __HW_BREAKPOINT_64_H
+#define __HW_BREAKPOINT_64_H
 #include <mach/sync_write.h>
 #include <asm/io.h>
-typedef int (*wp_handler)(unsigned long addr);
-
-struct wp_event
-{
-    unsigned long virt;
-    unsigned long phys;
-    int type;
-    wp_handler handler;
-    int in_use;
-    int auto_disable;
-};
-
-#define WP_EVENT_TYPE_READ 1
-#define WP_EVENT_TYPE_WRITE 2
-#define WP_EVENT_TYPE_ALL 3
-
-#define init_wp_event(__e, __v, __p, __t, __h)   \
-        do {    \
-            (__e)->virt = (__v);    \
-            (__e)->phys = (__p);    \
-            (__e)->type = (__t);    \
-            (__e)->handler = (__h);    \
-            (__e)->auto_disable = 0;    \
-        } while (0)
-
-#define auto_disable_wp(__e)   \
-        do {    \
-            (__e)->auto_disable = 1;    \
-        } while (0)
-
+#include <mach/hw_watchpoint.h>
 
 #define MAX_NR_WATCH_POINT 4  
 struct wp_trace_context_t
@@ -81,6 +52,7 @@ struct dbgreg_set {
 
 #define EDLAR 0xFB0
 #define EDLSR 0xFB4
+#define DBGAUTHSTATUS_EL1 0xFB8
 #define OSLAR_EL1 0x300
 
 #define UNLOCK_KEY 0xC5ACCE55
@@ -94,6 +66,9 @@ struct dbgreg_set {
 #define LSC_STR (2 << 3)
 #define LSC_ALL (3 << 3)
 
+#define NSNID_SHIFT 2
+#define SNID_SHIFT 6
+
 //#define WATCHPOINT_TEST_SUIT
 
 #define ARM_DBG_READ(N, M, OP2, VAL) do {\
@@ -158,8 +133,6 @@ void smp_read_MDSCR_EL1_callback(void *info);
 void smp_write_MDSCR_EL1_callback(void *info);
 void smp_read_OSLSR_EL1_callback(void *info);
 int register_wp_context(struct wp_trace_context_t **wp_tracer_context );
-extern int add_hw_watchpoint(struct wp_event *wp_event);
-extern int del_hw_watchpoint(struct wp_event *wp_event);
 void __iomem* get_wp_base(void);
 
 
diff --git a/drivers/misc/mediatek/wdk/wd_common_drv.c b/drivers/misc/mediatek/wdk/wd_common_drv.c
index 2caaf8b..9e39282 100644
--- a/drivers/misc/mediatek/wdk/wd_common_drv.c
+++ b/drivers/misc/mediatek/wdk/wd_common_drv.c
@@ -599,7 +599,8 @@ static int __cpuinit wk_cpu_callback(struct notifier_block *nfb, unsigned long a
 }
 
 static struct notifier_block cpu_nfb __cpuinitdata = {
-	.notifier_call = wk_cpu_callback
+	.notifier_call = wk_cpu_callback,
+	.priority = 6
 };
 
 
diff --git a/drivers/misc/mediatek/xhci/Makefile b/drivers/misc/mediatek/xhci/Makefile
index 6459731..1077450 100755
--- a/drivers/misc/mediatek/xhci/Makefile
+++ b/drivers/misc/mediatek/xhci/Makefile
@@ -11,4 +11,8 @@ ifeq ($(CONFIG_USB_DEBUG),y)
 	EXTRA_CFLAGS		+= -DDEBUG
 endif
 
+ifeq ($(CONFIG_CUSTOM_KERNEL_HDMI),"Sii8348")
+	ccflags-y += 	-DMHL_SII8348
+endif
+
 obj-y	+= xhci-mtk-power.o xhci-mtk-scheduler.o xhci-mtk.o xhci-mtk-attrs.o
\ No newline at end of file
diff --git a/drivers/misc/mediatek/xhci/xhci-mtk.c b/drivers/misc/mediatek/xhci/xhci-mtk.c
index 126dbf8..c06d844 100644
--- a/drivers/misc/mediatek/xhci/xhci-mtk.c
+++ b/drivers/misc/mediatek/xhci/xhci-mtk.c
@@ -68,6 +68,7 @@ struct xhci_hcd *mtk_xhci;
 static spinlock_t *mtk_hub_event_lock;
 static struct list_head* mtk_hub_event_list;
 static int mtk_ep_count;
+static int vbus_on = 0;
 
 static struct wake_lock mtk_xhci_wakelock;
 
@@ -164,10 +165,20 @@ static void pmic_restore_regs(void){
 	}
 }
 
-static void mtk_enable_pmic_otg_mode(void)
+void mtk_enable_pmic_otg_mode(void)
 {
-	int val;
+	int val = 0;
+	int cnt = 0;
 
+    vbus_on++;
+    /// vbus_on =1;
+    mtk_xhci_mtk_log("set pmic power on, %d\n", vbus_on);
+    #if 1
+	if(vbus_on > 1)
+	{
+	    return;
+    }
+    #endif
 	mt_set_gpio_mode(GPIO_OTG_DRVVBUS_PIN, GPIO_MODE_GPIO);
 	mt_set_gpio_pull_select(GPIO_OTG_DRVVBUS_PIN, GPIO_PULL_DOWN);
 	mt_set_gpio_pull_enable(GPIO_OTG_DRVVBUS_PIN, GPIO_PULL_ENABLE);
@@ -195,7 +206,7 @@ static void mtk_enable_pmic_otg_mode(void)
 	#else
 	pmic_config_interface(0x803E, 0x0, 0x1, 10);
 	#endif
-	
+
 	pmic_config_interface(0x8044, 0x3, 0x3, 0);
 	pmic_config_interface(0x8044, 0x3, 0x7, 8);
 	pmic_config_interface(0x8044, 0x1, 0x1, 11);
@@ -211,19 +222,35 @@ static void mtk_enable_pmic_otg_mode(void)
 	mdelay(50);
 
 	val = 0;
-	while (val == 0) {
+	while (val == 0 && cnt < 20) {
 		pmic_read_interface(0x8060, &val, 0x1, 14);
+		cnt++;
+		mdelay(2);
 	}
 
 	#ifdef CONFIG_MTK_OTG_OC_DETECTOR
 	schedule_delayed_work_on(0, &mtk_xhci_oc_delaywork, msecs_to_jiffies(OC_DETECTOR_TIMER));
 	#endif
-	mtk_xhci_mtk_log("set pmic power on, done\n");
+	mtk_xhci_mtk_log("set pmic power on(cnt:%d), done\n", cnt);
 }
 
-static void mtk_disable_pmic_otg_mode(void)
+void mtk_disable_pmic_otg_mode(void)
 {
-	int val;
+	int val =0;
+	int cnt = 0;
+
+	///vbus_on = 0;
+
+    vbus_on--;
+    mtk_xhci_mtk_log("set pmic power off %d\n", vbus_on);
+
+    if(vbus_on < 0 || vbus_on > 0)
+    {
+        if(vbus_on < 0)
+            vbus_on = 0;
+        return;
+    }
+
 
 	pmic_config_interface(0x8068, 0x0, 0x1, 0);
 	pmic_config_interface(0x8084, 0x0, 0x1, 0);
@@ -231,8 +258,10 @@ static void mtk_disable_pmic_otg_mode(void)
 	pmic_config_interface(0x8068, 0x0, 0x1, 1);
 
 	val = 1;
-	while (val == 1) {
+	while (val == 1 && cnt <20) {
 		pmic_read_interface(0x805E, &val, 0x1, 4);
+		cnt++;
+		mdelay(2);
 	}
 
 	#if 0
@@ -249,7 +278,7 @@ static void mtk_disable_pmic_otg_mode(void)
 	#ifdef CONFIG_MTK_OTG_OC_DETECTOR
 	cancel_delayed_work(&mtk_xhci_oc_delaywork);
 	#endif
-	mtk_xhci_mtk_log("set pimc power off, done\n");
+	mtk_xhci_mtk_log("set pmic power off(cnt:%d), done\n", cnt);
 }
 
 #ifdef CONFIG_MTK_OTG_OC_DETECTOR
@@ -269,7 +298,7 @@ void xhci_send_event(char * event)
 static bool mtk_is_over_current(void)
 {
 	int vol = battery_meter_get_charger_voltage();
-	
+
 	if(vol < 4200){
 		mtk_xhci_mtk_log("over current occurs, voltage(%d)\n", vol);
 		return true;
@@ -281,7 +310,7 @@ static bool mtk_is_over_current(void)
 static void mtk_xhci_oc_detector(struct work_struct *work)
 {
 	int ret;
-	
+
 	if(mtk_is_over_current()){
 		xhci_send_event("OVER_CURRENT");
 		mtk_disable_pmic_otg_mode();
@@ -338,17 +367,17 @@ static int mtk_xhci_hcd_init(void)
 		printk(KERN_ERR "Problem creating xhci attributes.\n");
 		goto unreg_plat;
 	}
-	
+
 	#ifdef CONFIG_MTK_OTG_PMIC_BOOST_5V
 	#ifdef CONFIG_MTK_OTG_OC_DETECTOR
 	retval = misc_register(&xhci_misc_uevent);
 	if (retval){
 		printk(KERN_ERR "create the xhci_uevent_device fail, ret(%d)\n", retval) ;
 		goto unreg_attrs;
-	}	
+	}
 	#endif
 	#endif
-	
+
 	/*
 	 * Check the compiler generated sizes of structures that must be laid
 	 * out in specific ways for hardware access.
@@ -385,7 +414,7 @@ static void mtk_xhci_hcd_cleanup(void)
 	misc_deregister(&xhci_misc_uevent);
 	#endif
 	#endif
-	
+
 	xhci_attrs_exit();
 	xhci_unregister_plat();
 }
@@ -400,6 +429,8 @@ static void mtk_xhci_imod_set(u32 imod)
 	xhci_writel(mtk_xhci, temp, &mtk_xhci->ir_set->irq_control);
 }
 
+extern void usb20_pll_settings(bool host, bool forceOn);
+
 static int mtk_xhci_driver_load(void)
 {
 	int ret = 0;
@@ -421,6 +452,9 @@ static int mtk_xhci_driver_load(void)
 #else
 #ifdef CONFIG_MTK_OTG_PMIC_BOOST_5V
 	mtk_enable_pmic_otg_mode();
+
+	/* USB PLL Force settings */
+	usb20_pll_settings(true, true);
 #else
 	enableXhciAllPortPower(mtk_xhci);
 #endif
@@ -469,6 +503,9 @@ void mtk_xhci_switch_init(void)
 #endif
 }
 
+#if defined(MHL_SII8348)
+extern void switch_mhl_to_d3(void);
+#endif
 void mtk_xhci_mode_switch(struct work_struct *work)
 {
 	static bool is_load = false;
@@ -499,12 +536,16 @@ void mtk_xhci_mode_switch(struct work_struct *work)
 		if (is_load) {
 			if(!is_pwoff)
 				mtk_xhci_disPortPower();
-			if(mtk_is_hub_active()){
+
+			/* prevent hang here */
+			/* if(mtk_is_hub_active()){
 				is_pwoff = true;
 				schedule_delayed_work_on(0, &mtk_xhci_delaywork, msecs_to_jiffies(mtk_iddig_debounce));
 				mtk_xhci_mtk_log("wait, hub is still active, ep cnt %d !!!\n", mtk_ep_count);
 				return;
-			}
+			} */
+			/* USB PLL Force settings */
+			usb20_pll_settings(true, false);
 
 			mtk_xhci_driver_unload();
 			is_pwoff = false;
@@ -513,6 +554,10 @@ void mtk_xhci_mode_switch(struct work_struct *work)
 			switch_set_state(&mtk_otg_state, 0);
 #endif
 			mtk_xhci_wakelock_unlock();
+
+#if defined(MHL_SII8348)
+			switch_mhl_to_d3();
+#endif			
 		}
 
 		/* expect next isr is for id-pin in action */
@@ -577,7 +622,7 @@ int mtk_xhci_eint_iddig_init(void)
 	mtk_idpin_irqnum = mt_gpio_to_irq(iddig_gpio);
 
 	/* microseconds */
-	mt_gpio_set_debounce(iddig_gpio, 50);
+	mt_gpio_set_debounce(iddig_gpio, 150000);
 
 	retval =
 	    request_irq(mtk_idpin_irqnum, xhci_eint_iddig_isr, IRQF_TRIGGER_LOW, "iddig_eint",
@@ -586,7 +631,7 @@ int mtk_xhci_eint_iddig_init(void)
 		mtk_xhci_mtk_log("request_irq fail, ret %d, irqnum %d!!!\n", retval, mtk_idpin_irqnum);
 		return retval;
 	}
-	mtk_xhci_mtk_log("external iddig register done, irqnum = %d, gpio_mode(%d), gpio_pull_enable(%d), gpio_pull_select(%d)\n", 
+	mtk_xhci_mtk_log("external iddig register done, irqnum = %d, gpio_mode(%d), gpio_pull_enable(%d), gpio_pull_select(%d)\n",
 		mtk_idpin_irqnum, mt_get_gpio_mode(GPIO_OTG_IDDIG_EINT_PIN), mt_get_gpio_pull_enable(GPIO_OTG_IDDIG_EINT_PIN), mt_get_gpio_pull_select(GPIO_OTG_IDDIG_EINT_PIN));
 
 	/* set in-detect and umask the iddig interrupt */
@@ -625,7 +670,7 @@ void mtk_set_host_mode_out(void)
 
 bool mtk_is_host_mode(void)
 {
-	return (mtk_idpin_cur_stat == IDPIN_IN_HOST) ? true : false;
+	return (vbus_on > 0 || mtk_idpin_cur_stat == IDPIN_IN_HOST) ? true : false;
 }
 
 #endif
@@ -706,7 +751,7 @@ void mtk_xhci_ck_timer_init(struct xhci_hcd *xhci)
 		writel(temp, addr);
 		mtk_xhci_mtk_log("mu3d sys_clk, addr 0x%p, value 0x%x\n",
 				(void *)_SSUSB_SYS_CK_CTRL(xhci->sif_regs), readl((__u32 __iomem *)_SSUSB_SYS_CK_CTRL(xhci->sif_regs)));
-		
+
 		num_u3_port = SSUSB_U3_PORT_NUM(readl((void __iomem *)_SSUSB_IP_CAP(xhci->sif_regs)));
 		if (num_u3_port) {
 			#if 0
@@ -730,7 +775,7 @@ void mtk_xhci_ck_timer_init(struct xhci_hcd *xhci)
 			temp |= MTK_CNT_1US_VALUE;
 			writel(temp, addr);
 		}
-		
+
 		/* set U2 MAC SYS_CK */
 		addr = (void __iomem *)(_SSUSB_U2_SYS_BASE(xhci->base_regs) + USB20_TIMING_PARAMETER);
 		temp &= ~(0xff);
@@ -794,7 +839,7 @@ static int mtk_xhci_phy_init(int argc, char **argv)
 int mtk_xhci_ip_init(struct usb_hcd *hcd, struct xhci_hcd *xhci)
 {
 	mtk_xhci_set(hcd, xhci);
-	
+
 #ifdef CONFIG_MTK_FPGA
 	u3_base = xhci->base_regs;
 	u3_sif_base = xhci->sif_regs;
diff --git a/drivers/mmc/host/sdhci-pxav3.c b/drivers/mmc/host/sdhci-pxav3.c
index 1ae358e..4edb24b 100644
--- a/drivers/mmc/host/sdhci-pxav3.c
+++ b/drivers/mmc/host/sdhci-pxav3.c
@@ -201,8 +201,8 @@ static struct sdhci_pxa_platdata *pxav3_get_mmc_pdata(struct device *dev)
 	if (!pdata)
 		return NULL;
 
-	of_property_read_u32(np, "mrvl,clk-delay-cycles", &clk_delay_cycles);
-	if (clk_delay_cycles > 0)
+	if (!of_property_read_u32(np, "mrvl,clk-delay-cycles",
+				  &clk_delay_cycles))
 		pdata->clk_delay_cycles = clk_delay_cycles;
 
 	return pdata;
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 2ea429c..836e2ac 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -1316,6 +1316,8 @@ static void sdhci_request(struct mmc_host *mmc, struct mmc_request *mrq)
 
 	sdhci_runtime_pm_get(host);
 
+	present = mmc_gpio_get_cd(host->mmc);
+
 	spin_lock_irqsave(&host->lock, flags);
 
 	WARN_ON(host->mrq != NULL);
@@ -1344,7 +1346,6 @@ static void sdhci_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	 *     zero: cd-gpio is used, and card is removed
 	 *     one: cd-gpio is used, and card is present
 	 */
-	present = mmc_gpio_get_cd(host->mmc);
 	if (present < 0) {
 		/* If polling, assume that the card is always present. */
 		if (host->quirks & SDHCI_QUIRK_BROKEN_CARD_DETECTION)
diff --git a/drivers/net/can/dev.c b/drivers/net/can/dev.c
index 9bf47a0..a4694aa 100644
--- a/drivers/net/can/dev.c
+++ b/drivers/net/can/dev.c
@@ -643,10 +643,14 @@ static int can_changelink(struct net_device *dev,
 		if (dev->flags & IFF_UP)
 			return -EBUSY;
 		cm = nla_data(data[IFLA_CAN_CTRLMODE]);
-		if (cm->flags & ~priv->ctrlmode_supported)
+
+		/* check whether changed bits are allowed to be modified */
+		if (cm->mask & ~priv->ctrlmode_supported)
 			return -EOPNOTSUPP;
+
+		/* clear bits to be modified and copy the flag values */
 		priv->ctrlmode &= ~cm->mask;
-		priv->ctrlmode |= cm->flags;
+		priv->ctrlmode |= (cm->flags & cm->mask);
 	}
 
 	if (data[IFLA_CAN_BITTIMING]) {
diff --git a/drivers/net/can/usb/kvaser_usb.c b/drivers/net/can/usb/kvaser_usb.c
index cc3df8a..a3fb8b5 100644
--- a/drivers/net/can/usb/kvaser_usb.c
+++ b/drivers/net/can/usb/kvaser_usb.c
@@ -579,7 +579,7 @@ static int kvaser_usb_simple_msg_async(struct kvaser_usb_net_priv *priv,
 			  usb_sndbulkpipe(dev->udev,
 					  dev->bulk_out->bEndpointAddress),
 			  buf, msg->len,
-			  kvaser_usb_simple_msg_callback, priv);
+			  kvaser_usb_simple_msg_callback, netdev);
 	usb_anchor_urb(urb, &priv->tx_submitted);
 
 	err = usb_submit_urb(urb, GFP_ATOMIC);
@@ -654,11 +654,6 @@ static void kvaser_usb_rx_error(const struct kvaser_usb *dev,
 	priv = dev->nets[channel];
 	stats = &priv->netdev->stats;
 
-	if (status & M16C_STATE_BUS_RESET) {
-		kvaser_usb_unlink_tx_urbs(priv);
-		return;
-	}
-
 	skb = alloc_can_err_skb(priv->netdev, &cf);
 	if (!skb) {
 		stats->rx_dropped++;
@@ -669,7 +664,7 @@ static void kvaser_usb_rx_error(const struct kvaser_usb *dev,
 
 	netdev_dbg(priv->netdev, "Error status: 0x%02x\n", status);
 
-	if (status & M16C_STATE_BUS_OFF) {
+	if (status & (M16C_STATE_BUS_OFF | M16C_STATE_BUS_RESET)) {
 		cf->can_id |= CAN_ERR_BUSOFF;
 
 		priv->can.can_stats.bus_off++;
@@ -695,9 +690,7 @@ static void kvaser_usb_rx_error(const struct kvaser_usb *dev,
 		}
 
 		new_state = CAN_STATE_ERROR_PASSIVE;
-	}
-
-	if (status == M16C_STATE_BUS_ERROR) {
+	} else if (status & M16C_STATE_BUS_ERROR) {
 		if ((priv->can.state < CAN_STATE_ERROR_WARNING) &&
 		    ((txerr >= 96) || (rxerr >= 96))) {
 			cf->can_id |= CAN_ERR_CRTL;
@@ -707,7 +700,8 @@ static void kvaser_usb_rx_error(const struct kvaser_usb *dev,
 
 			priv->can.can_stats.error_warning++;
 			new_state = CAN_STATE_ERROR_WARNING;
-		} else if (priv->can.state > CAN_STATE_ERROR_ACTIVE) {
+		} else if ((priv->can.state > CAN_STATE_ERROR_ACTIVE) &&
+			   ((txerr < 96) && (rxerr < 96))) {
 			cf->can_id |= CAN_ERR_PROT;
 			cf->data[2] = CAN_ERR_PROT_ACTIVE;
 
@@ -1238,6 +1232,9 @@ static int kvaser_usb_close(struct net_device *netdev)
 	if (err)
 		netdev_warn(netdev, "Cannot stop device, error %d\n", err);
 
+	/* reset tx contexts */
+	kvaser_usb_unlink_tx_urbs(priv);
+
 	priv->can.state = CAN_STATE_STOPPED;
 	close_candev(priv->netdev);
 
@@ -1286,12 +1283,14 @@ static netdev_tx_t kvaser_usb_start_xmit(struct sk_buff *skb,
 	if (!urb) {
 		netdev_err(netdev, "No memory left for URBs\n");
 		stats->tx_dropped++;
-		goto nourbmem;
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
 	}
 
 	buf = kmalloc(sizeof(struct kvaser_msg), GFP_ATOMIC);
 	if (!buf) {
 		stats->tx_dropped++;
+		dev_kfree_skb(skb);
 		goto nobufmem;
 	}
 
@@ -1326,6 +1325,7 @@ static netdev_tx_t kvaser_usb_start_xmit(struct sk_buff *skb,
 		}
 	}
 
+	/* This should never happen; it implies a flow control bug */
 	if (!context) {
 		netdev_warn(netdev, "cannot find free context\n");
 		ret =  NETDEV_TX_BUSY;
@@ -1356,9 +1356,6 @@ static netdev_tx_t kvaser_usb_start_xmit(struct sk_buff *skb,
 	if (unlikely(err)) {
 		can_free_echo_skb(netdev, context->echo_index);
 
-		skb = NULL; /* set to NULL to avoid double free in
-			     * dev_kfree_skb(skb) */
-
 		atomic_dec(&priv->active_tx_urbs);
 		usb_unanchor_urb(urb);
 
@@ -1380,8 +1377,6 @@ releasebuf:
 	kfree(buf);
 nobufmem:
 	usb_free_urb(urb);
-nourbmem:
-	dev_kfree_skb(skb);
 	return ret;
 }
 
@@ -1493,6 +1488,10 @@ static int kvaser_usb_init_one(struct usb_interface *intf,
 	struct kvaser_usb_net_priv *priv;
 	int i, err;
 
+	err = kvaser_usb_send_simple_msg(dev, CMD_RESET_CHIP, channel);
+	if (err)
+		return err;
+
 	netdev = alloc_candev(sizeof(*priv), MAX_TX_URBS);
 	if (!netdev) {
 		dev_err(&intf->dev, "Cannot alloc candev\n");
@@ -1578,7 +1577,7 @@ static int kvaser_usb_probe(struct usb_interface *intf,
 {
 	struct kvaser_usb *dev;
 	int err = -ENOMEM;
-	int i;
+	int i, retry = 3;
 
 	dev = devm_kzalloc(&intf->dev, sizeof(*dev), GFP_KERNEL);
 	if (!dev)
@@ -1596,10 +1595,15 @@ static int kvaser_usb_probe(struct usb_interface *intf,
 
 	usb_set_intfdata(intf, dev);
 
-	for (i = 0; i < MAX_NET_DEVICES; i++)
-		kvaser_usb_send_simple_msg(dev, CMD_RESET_CHIP, i);
+	/* On some x86 laptops, plugging a Kvaser device again after
+	 * an unplug makes the firmware always ignore the very first
+	 * command. For such a case, provide some room for retries
+	 * instead of completely exiting the driver.
+	 */
+	do {
+		err = kvaser_usb_get_software_info(dev);
+	} while (--retry && err == -ETIMEDOUT);
 
-	err = kvaser_usb_get_software_info(dev);
 	if (err) {
 		dev_err(&intf->dev,
 			"Cannot get software infos, error %d\n", err);
diff --git a/drivers/net/ethernet/atheros/alx/main.c b/drivers/net/ethernet/atheros/alx/main.c
index d30085c..a85a9c2 100644
--- a/drivers/net/ethernet/atheros/alx/main.c
+++ b/drivers/net/ethernet/atheros/alx/main.c
@@ -184,15 +184,16 @@ static void alx_schedule_reset(struct alx_priv *alx)
 	schedule_work(&alx->reset_wk);
 }
 
-static bool alx_clean_rx_irq(struct alx_priv *alx, int budget)
+static int alx_clean_rx_irq(struct alx_priv *alx, int budget)
 {
 	struct alx_rx_queue *rxq = &alx->rxq;
 	struct alx_rrd *rrd;
 	struct alx_buffer *rxb;
 	struct sk_buff *skb;
 	u16 length, rfd_cleaned = 0;
+	int work = 0;
 
-	while (budget > 0) {
+	while (work < budget) {
 		rrd = &rxq->rrd[rxq->rrd_read_idx];
 		if (!(rrd->word3 & cpu_to_le32(1 << RRD_UPDATED_SHIFT)))
 			break;
@@ -203,7 +204,7 @@ static bool alx_clean_rx_irq(struct alx_priv *alx, int budget)
 		    ALX_GET_FIELD(le32_to_cpu(rrd->word0),
 				  RRD_NOR) != 1) {
 			alx_schedule_reset(alx);
-			return 0;
+			return work;
 		}
 
 		rxb = &rxq->bufs[rxq->read_idx];
@@ -243,7 +244,7 @@ static bool alx_clean_rx_irq(struct alx_priv *alx, int budget)
 		}
 
 		napi_gro_receive(&alx->napi, skb);
-		budget--;
+		work++;
 
 next_pkt:
 		if (++rxq->read_idx == alx->rx_ringsz)
@@ -258,21 +259,22 @@ next_pkt:
 	if (rfd_cleaned)
 		alx_refill_rx_ring(alx, GFP_ATOMIC);
 
-	return budget > 0;
+	return work;
 }
 
 static int alx_poll(struct napi_struct *napi, int budget)
 {
 	struct alx_priv *alx = container_of(napi, struct alx_priv, napi);
 	struct alx_hw *hw = &alx->hw;
-	bool complete = true;
 	unsigned long flags;
+	bool tx_complete;
+	int work;
 
-	complete = alx_clean_tx_irq(alx) &&
-		   alx_clean_rx_irq(alx, budget);
+	tx_complete = alx_clean_tx_irq(alx);
+	work = alx_clean_rx_irq(alx, budget);
 
-	if (!complete)
-		return 1;
+	if (!tx_complete || work == budget)
+		return budget;
 
 	napi_complete(&alx->napi);
 
@@ -284,7 +286,7 @@ static int alx_poll(struct napi_struct *napi, int budget)
 
 	alx_post_write(hw);
 
-	return 0;
+	return work;
 }
 
 static irqreturn_t alx_intr_handle(struct alx_priv *alx, u32 intr)
diff --git a/drivers/net/ethernet/broadcom/tg3.c b/drivers/net/ethernet/broadcom/tg3.c
index 5501cad..8c1eab1 100644
--- a/drivers/net/ethernet/broadcom/tg3.c
+++ b/drivers/net/ethernet/broadcom/tg3.c
@@ -17389,23 +17389,6 @@ static int tg3_init_one(struct pci_dev *pdev,
 		goto err_out_apeunmap;
 	}
 
-	/*
-	 * Reset chip in case UNDI or EFI driver did not shutdown
-	 * DMA self test will enable WDMAC and we'll see (spurious)
-	 * pending DMA on the PCI bus at that point.
-	 */
-	if ((tr32(HOSTCC_MODE) & HOSTCC_MODE_ENABLE) ||
-	    (tr32(WDMAC_MODE) & WDMAC_MODE_ENABLE)) {
-		tw32(MEMARB_MODE, MEMARB_MODE_ENABLE);
-		tg3_halt(tp, RESET_KIND_SHUTDOWN, 1);
-	}
-
-	err = tg3_test_dma(tp);
-	if (err) {
-		dev_err(&pdev->dev, "DMA engine test failed, aborting\n");
-		goto err_out_apeunmap;
-	}
-
 	intmbx = MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW;
 	rcvmbx = MAILBOX_RCVRET_CON_IDX_0 + TG3_64BIT_REG_LOW;
 	sndmbx = MAILBOX_SNDHOST_PROD_IDX_0 + TG3_64BIT_REG_LOW;
@@ -17450,6 +17433,23 @@ static int tg3_init_one(struct pci_dev *pdev,
 			sndmbx += 0xc;
 	}
 
+	/*
+	 * Reset chip in case UNDI or EFI driver did not shutdown
+	 * DMA self test will enable WDMAC and we'll see (spurious)
+	 * pending DMA on the PCI bus at that point.
+	 */
+	if ((tr32(HOSTCC_MODE) & HOSTCC_MODE_ENABLE) ||
+	    (tr32(WDMAC_MODE) & WDMAC_MODE_ENABLE)) {
+		tw32(MEMARB_MODE, MEMARB_MODE_ENABLE);
+		tg3_halt(tp, RESET_KIND_SHUTDOWN, 1);
+	}
+
+	err = tg3_test_dma(tp);
+	if (err) {
+		dev_err(&pdev->dev, "DMA engine test failed, aborting\n");
+		goto err_out_apeunmap;
+	}
+
 	tg3_init_coal(tp);
 
 	pci_set_drvdata(pdev, dev);
diff --git a/drivers/net/ethernet/cisco/enic/enic_main.c b/drivers/net/ethernet/cisco/enic/enic_main.c
index 635f559..8cc0eaa 100644
--- a/drivers/net/ethernet/cisco/enic/enic_main.c
+++ b/drivers/net/ethernet/cisco/enic/enic_main.c
@@ -1294,10 +1294,14 @@ static void enic_rq_indicate_buf(struct vnic_rq *rq,
 		skb_put(skb, bytes_written);
 		skb->protocol = eth_type_trans(skb, netdev);
 
-		if ((netdev->features & NETIF_F_RXCSUM) && !csum_not_calc) {
-			skb->csum = htons(checksum);
-			skb->ip_summed = CHECKSUM_COMPLETE;
-		}
+		/* Hardware does not provide whole packet checksum. It only
+		 * provides pseudo checksum. Since hw validates the packet
+		 * checksum but not provide us the checksum value. use
+		 * CHECSUM_UNNECESSARY.
+		 */
+		if ((netdev->features & NETIF_F_RXCSUM) && tcp_udp_csum_ok &&
+		    ipv4_csum_ok)
+			skb->ip_summed = CHECKSUM_UNNECESSARY;
 
 		if (vlan_stripped)
 			__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan_tci);
diff --git a/drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c b/drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c
index af951f3..50104a7 100644
--- a/drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c
+++ b/drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c
@@ -2315,7 +2315,10 @@ static int netxen_nic_poll(struct napi_struct *napi, int budget)
 
 	work_done = netxen_process_rcv_ring(sds_ring, budget);
 
-	if ((work_done < budget) && tx_complete) {
+	if (!tx_complete)
+		work_done = budget;
+
+	if (work_done < budget) {
 		napi_complete(&sds_ring->napi);
 		if (test_bit(__NX_DEV_UP, &adapter->state))
 			netxen_nic_enable_int(sds_ring);
diff --git a/drivers/net/ethernet/ti/cpsw.c b/drivers/net/ethernet/ti/cpsw.c
index b1ab3a4..e18240d 100644
--- a/drivers/net/ethernet/ti/cpsw.c
+++ b/drivers/net/ethernet/ti/cpsw.c
@@ -1293,6 +1293,19 @@ static int cpsw_ndo_vlan_rx_add_vid(struct net_device *ndev,
 	if (vid == priv->data.default_vlan)
 		return 0;
 
+	if (priv->data.dual_emac) {
+		/* In dual EMAC, reserved VLAN id should not be used for
+		 * creating VLAN interfaces as this can break the dual
+		 * EMAC port separation
+		 */
+		int i;
+
+		for (i = 0; i < priv->data.slaves; i++) {
+			if (vid == priv->slaves[i].port_vlan)
+				return -EINVAL;
+		}
+	}
+
 	dev_info(priv->dev, "Adding vlanid %d to vlan filter\n", vid);
 	return cpsw_add_vlan_ale_entry(priv, vid);
 }
@@ -1306,6 +1319,15 @@ static int cpsw_ndo_vlan_rx_kill_vid(struct net_device *ndev,
 	if (vid == priv->data.default_vlan)
 		return 0;
 
+	if (priv->data.dual_emac) {
+		int i;
+
+		for (i = 0; i < priv->data.slaves; i++) {
+			if (vid == priv->slaves[i].port_vlan)
+				return -EINVAL;
+		}
+	}
+
 	dev_info(priv->dev, "removing vlanid %d from vlan filter\n", vid);
 	ret = cpsw_ale_del_vlan(priv->ale, vid, 0);
 	if (ret != 0)
diff --git a/drivers/net/macvtap.c b/drivers/net/macvtap.c
index 2d255ba..8fc46fc 100644
--- a/drivers/net/macvtap.c
+++ b/drivers/net/macvtap.c
@@ -658,12 +658,15 @@ static unsigned long iov_pages(const struct iovec *iv, int offset,
 	return pages;
 }
 
+/* Neighbour code has some assumptions on HH_DATA_MOD alignment */
+#define MACVTAP_RESERVE HH_DATA_OFF(ETH_HLEN)
+
 /* Get packet from user space buffer */
 static ssize_t macvtap_get_user(struct macvtap_queue *q, struct msghdr *m,
 				const struct iovec *iv, unsigned long total_len,
 				size_t count, int noblock)
 {
-	int good_linear = SKB_MAX_HEAD(NET_IP_ALIGN);
+	int good_linear = SKB_MAX_HEAD(MACVTAP_RESERVE);
 	struct sk_buff *skb;
 	struct macvlan_dev *vlan;
 	unsigned long len = total_len;
@@ -722,7 +725,7 @@ static ssize_t macvtap_get_user(struct macvtap_queue *q, struct msghdr *m,
 			linear = vnet_hdr.hdr_len;
 	}
 
-	skb = macvtap_alloc_skb(&q->sk, NET_IP_ALIGN, copylen,
+	skb = macvtap_alloc_skb(&q->sk, MACVTAP_RESERVE, copylen,
 				linear, noblock, &err);
 	if (!skb)
 		goto err;
diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
index 38f0b31..427e48a 100644
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -203,6 +203,25 @@ static inline int phy_find_valid(int idx, u32 features)
 }
 
 /**
+ * phy_check_valid - check if there is a valid PHY setting which matches
+ *		     speed, duplex, and feature mask
+ * @speed: speed to match
+ * @duplex: duplex to match
+ * @features: A mask of the valid settings
+ *
+ * Description: Returns true if there is a valid setting, false otherwise.
+ */
+static inline bool phy_check_valid(int speed, int duplex, u32 features)
+{
+	unsigned int idx;
+
+	idx = phy_find_valid(phy_find_setting(speed, duplex), features);
+
+	return settings[idx].speed == speed && settings[idx].duplex == duplex &&
+		(settings[idx].setting & features);
+}
+
+/**
  * phy_sanitize_settings - make sure the PHY is set to supported speed and duplex
  * @phydev: the target phy_device struct
  *
@@ -1011,7 +1030,7 @@ int phy_init_eee(struct phy_device *phydev, bool clk_stop_enable)
 	    (phydev->interface == PHY_INTERFACE_MODE_RGMII))) {
 		int eee_lp, eee_cap, eee_adv;
 		u32 lp, cap, adv;
-		int idx, status;
+		int status;
 
 		/* Read phy status to properly get the right settings */
 		status = phy_read_status(phydev);
@@ -1043,8 +1062,7 @@ int phy_init_eee(struct phy_device *phydev, bool clk_stop_enable)
 
 		adv = mmd_eee_adv_to_ethtool_adv_t(eee_adv);
 		lp = mmd_eee_adv_to_ethtool_adv_t(eee_lp);
-		idx = phy_find_setting(phydev->speed, phydev->duplex);
-		if (!(lp & adv & settings[idx].setting))
+		if (!phy_check_valid(phydev->speed, phydev->duplex, lp & adv))
 			goto eee_exit;
 
 		if (clk_stop_enable) {
diff --git a/drivers/net/ppp/ppp_deflate.c b/drivers/net/ppp/ppp_deflate.c
index 602c625..b5edc7f 100644
--- a/drivers/net/ppp/ppp_deflate.c
+++ b/drivers/net/ppp/ppp_deflate.c
@@ -246,7 +246,7 @@ static int z_compress(void *arg, unsigned char *rptr, unsigned char *obuf,
 	/*
 	 * See if we managed to reduce the size of the packet.
 	 */
-	if (olen < isize) {
+	if (olen < isize && olen <= osize) {
 		state->stats.comp_bytes += olen;
 		state->stats.comp_packets++;
 	} else {
diff --git a/drivers/net/team/team.c b/drivers/net/team/team.c
index 1222229..14179a6 100644
--- a/drivers/net/team/team.c
+++ b/drivers/net/team/team.c
@@ -42,9 +42,7 @@
 
 static struct team_port *team_port_get_rcu(const struct net_device *dev)
 {
-	struct team_port *port = rcu_dereference(dev->rx_handler_data);
-
-	return team_port_exists(dev) ? port : NULL;
+	return rcu_dereference(dev->rx_handler_data);
 }
 
 static struct team_port *team_port_get_rtnl(const struct net_device *dev)
@@ -1523,11 +1521,11 @@ static int team_set_mac_address(struct net_device *dev, void *p)
 	if (dev->type == ARPHRD_ETHER && !is_valid_ether_addr(addr->sa_data))
 		return -EADDRNOTAVAIL;
 	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
-	rcu_read_lock();
-	list_for_each_entry_rcu(port, &team->port_list, list)
+	mutex_lock(&team->lock);
+	list_for_each_entry(port, &team->port_list, list)
 		if (team->ops.port_change_dev_addr)
 			team->ops.port_change_dev_addr(team, port);
-	rcu_read_unlock();
+	mutex_unlock(&team->lock);
 	return 0;
 }
 
diff --git a/drivers/net/usb/plusb.c b/drivers/net/usb/plusb.c
index 0fcc8e6..74323e9 100644
--- a/drivers/net/usb/plusb.c
+++ b/drivers/net/usb/plusb.c
@@ -136,6 +136,11 @@ static const struct usb_device_id	products [] = {
 }, {
 	USB_DEVICE(0x050d, 0x258a),     /* Belkin F5U258/F5U279 (PL-25A1) */
 	.driver_info =  (unsigned long) &prolific_info,
+}, {
+	USB_DEVICE(0x3923, 0x7825),     /* National Instruments USB
+					 * Host-to-Host Cable
+					 */
+	.driver_info =  (unsigned long) &prolific_info,
 },
 
 	{ },		// END
diff --git a/drivers/net/wireless/ath/ath5k/reset.c b/drivers/net/wireless/ath/ath5k/reset.c
index a3399c4..b9b651e 100644
--- a/drivers/net/wireless/ath/ath5k/reset.c
+++ b/drivers/net/wireless/ath/ath5k/reset.c
@@ -478,7 +478,7 @@ ath5k_hw_wisoc_reset(struct ath5k_hw *ah, u32 flags)
 	regval = ioread32(reg);
 	iowrite32(regval | val, reg);
 	regval = ioread32(reg);
-	usleep_range(100, 150);
+	udelay(100);	/* NB: should be atomic */
 
 	/* Bring BB/MAC out of reset */
 	iowrite32(regval & ~val, reg);
diff --git a/drivers/net/wireless/iwlwifi/mvm/mac80211.c b/drivers/net/wireless/iwlwifi/mvm/mac80211.c
index 88b9c09..e6660d6 100644
--- a/drivers/net/wireless/iwlwifi/mvm/mac80211.c
+++ b/drivers/net/wireless/iwlwifi/mvm/mac80211.c
@@ -360,9 +360,6 @@ static void iwl_mvm_cleanup_iterator(void *data, u8 *mac,
 	mvmvif->uploaded = false;
 	mvmvif->ap_sta_id = IWL_MVM_STATION_COUNT;
 
-	/* does this make sense at all? */
-	mvmvif->color++;
-
 	spin_lock_bh(&mvm->time_event_lock);
 	iwl_mvm_te_clear_data(mvm, &mvmvif->time_event_data);
 	spin_unlock_bh(&mvm->time_event_lock);
@@ -544,7 +541,7 @@ static int iwl_mvm_mac_add_interface(struct ieee80211_hw *hw,
 
 	ret = iwl_mvm_mac_ctxt_add(mvm, vif);
 	if (ret)
-		goto out_release;
+		goto out_remove_mac;
 
 	/*
 	 * Update power state on the new interface. Admittedly, based on
diff --git a/drivers/net/wireless/iwlwifi/mvm/tx.c b/drivers/net/wireless/iwlwifi/mvm/tx.c
index 4ec8385..3dd0e5b 100644
--- a/drivers/net/wireless/iwlwifi/mvm/tx.c
+++ b/drivers/net/wireless/iwlwifi/mvm/tx.c
@@ -832,6 +832,11 @@ int iwl_mvm_rx_ba_notif(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb,
 	sta_id = ba_notif->sta_id;
 	tid = ba_notif->tid;
 
+	if (WARN_ONCE(sta_id >= IWL_MVM_STATION_COUNT ||
+		      tid >= IWL_MAX_TID_COUNT,
+		      "sta_id %d tid %d", sta_id, tid))
+		return 0;
+
 	rcu_read_lock();
 
 	sta = rcu_dereference(mvm->fw_id_to_mac_id[sta_id]);
diff --git a/drivers/net/wireless/iwlwifi/pcie/tx.c b/drivers/net/wireless/iwlwifi/pcie/tx.c
index 48acfc6..f05962c 100644
--- a/drivers/net/wireless/iwlwifi/pcie/tx.c
+++ b/drivers/net/wireless/iwlwifi/pcie/tx.c
@@ -720,7 +720,12 @@ void iwl_trans_pcie_tx_reset(struct iwl_trans *trans)
 	iwl_write_direct32(trans, FH_KW_MEM_ADDR_REG,
 			   trans_pcie->kw.dma >> 4);
 
-	iwl_pcie_tx_start(trans, trans_pcie->scd_base_addr);
+	/*
+	 * Send 0 as the scd_base_addr since the device may have be reset
+	 * while we were in WoWLAN in which case SCD_SRAM_BASE_ADDR will
+	 * contain garbage.
+	 */
+	iwl_pcie_tx_start(trans, 0);
 }
 
 /*
diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 66aabde..5548a13 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1267,7 +1267,7 @@ static int pci_uevent(struct device *dev, struct kobj_uevent_env *env)
 	if (add_uevent_var(env, "PCI_SLOT_NAME=%s", pci_name(pdev)))
 		return -ENOMEM;
 
-	if (add_uevent_var(env, "MODALIAS=pci:v%08Xd%08Xsv%08Xsd%08Xbc%02Xsc%02Xi%02x",
+	if (add_uevent_var(env, "MODALIAS=pci:v%08Xd%08Xsv%08Xsd%08Xbc%02Xsc%02Xi%02X",
 			   pdev->vendor, pdev->device,
 			   pdev->subsystem_vendor, pdev->subsystem_device,
 			   (u8)(pdev->class >> 16), (u8)(pdev->class >> 8),
diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index c5d0a08..d6d4997 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -69,6 +69,7 @@ size_t pci_get_rom_size(struct pci_dev *pdev, void __iomem *rom, size_t size)
 {
 	void __iomem *image;
 	int last_image;
+	unsigned length;
 
 	image = rom;
 	do {
@@ -91,9 +92,9 @@ size_t pci_get_rom_size(struct pci_dev *pdev, void __iomem *rom, size_t size)
 		if (readb(pds + 3) != 'R')
 			break;
 		last_image = readb(pds + 21) & 0x80;
-		/* this length is reliable */
-		image += readw(pds + 16) * 512;
-	} while (!last_image);
+		length = readw(pds + 16);
+		image += length * 512;
+	} while (length && !last_image);
 
 	/* never return a size larger than the PCI resource window */
 	/* there are known ROMs that get the size wrong */
diff --git a/drivers/pinctrl/core.c b/drivers/pinctrl/core.c
index bb7ee9c..9c9fc69 100644
--- a/drivers/pinctrl/core.c
+++ b/drivers/pinctrl/core.c
@@ -1693,14 +1693,15 @@ void pinctrl_unregister(struct pinctrl_dev *pctldev)
 	if (pctldev == NULL)
 		return;
 
-	mutex_lock(&pinctrldev_list_mutex);
 	mutex_lock(&pctldev->mutex);
-
 	pinctrl_remove_device_debugfs(pctldev);
+	mutex_unlock(&pctldev->mutex);
 
 	if (!IS_ERR(pctldev->p))
 		pinctrl_put(pctldev->p);
 
+	mutex_lock(&pinctrldev_list_mutex);
+	mutex_lock(&pctldev->mutex);
 	/* TODO: check that no pinmuxes are still active? */
 	list_del(&pctldev->node);
 	/* Destroy descriptor tree */
diff --git a/drivers/platform/x86/hp_accel.c b/drivers/platform/x86/hp_accel.c
index 0ed96df..3458eb6 100644
--- a/drivers/platform/x86/hp_accel.c
+++ b/drivers/platform/x86/hp_accel.c
@@ -237,6 +237,7 @@ static struct dmi_system_id lis3lv02d_dmi_ids[] = {
 	AXIS_DMI_MATCH("HPB64xx", "HP ProBook 64", xy_swap),
 	AXIS_DMI_MATCH("HPB64xx", "HP EliteBook 84", xy_swap),
 	AXIS_DMI_MATCH("HPB65xx", "HP ProBook 65", x_inverted),
+	AXIS_DMI_MATCH("HPZBook15", "HP ZBook 15", x_inverted),
 	{ NULL, }
 /* Laptop models without axis info (yet):
  * "NC6910" "HP Compaq 6910"
diff --git a/drivers/power/88pm860x_charger.c b/drivers/power/88pm860x_charger.c
index 36fb4b5..1ef35ab 100644
--- a/drivers/power/88pm860x_charger.c
+++ b/drivers/power/88pm860x_charger.c
@@ -711,6 +711,7 @@ static int pm860x_charger_probe(struct platform_device *pdev)
 	return 0;
 
 out_irq:
+	power_supply_unregister(&info->usb);
 	while (--i >= 0)
 		free_irq(info->irq[i], info);
 out:
diff --git a/drivers/power/mediatek/Makefile b/drivers/power/mediatek/Makefile
index c4329eb..c9cfd94 100755
--- a/drivers/power/mediatek/Makefile
+++ b/drivers/power/mediatek/Makefile
@@ -1,6 +1,10 @@
 include $(srctree)/drivers/misc/mediatek/Makefile.custom
 
-obj-$(CONFIG_MTK_SMART_BATTERY) += battery_meter.o battery_common.o
+ifeq ($(CONFIG_MTK_HAFG_20),y)
+    obj-$(CONFIG_MTK_SMART_BATTERY) += battery_meter_fg_20.o battery_common_fg_20.o
+else
+    obj-$(CONFIG_MTK_SMART_BATTERY) += battery_meter.o battery_common.o
+endif
 
 ifeq ($(CONFIG_MTK_FAN5402_SUPPORT),y)
     obj-$(CONFIG_MTK_SMART_BATTERY) += switch_charging.o
diff --git a/drivers/power/mediatek/battery_common.c b/drivers/power/mediatek/battery_common.c
index 663c504..6fbcdf1 100644
--- a/drivers/power/mediatek/battery_common.c
+++ b/drivers/power/mediatek/battery_common.c
@@ -131,13 +131,11 @@ kal_bool g_bat_init_flag = 0;
 unsigned int g_call_state = CALL_IDLE;
 kal_bool g_charging_full_reset_bat_meter = KAL_FALSE;
 int g_platform_boot_mode = 0;
-
 //huangyisong_add_20130925 for_runin tangqingcai sync
 int g_runin_test_enter = 0;
 int g_runin_battery_test_flag = 0;
 extern void pchr_turn_on_charging (void);
 //tangqingcai sync end
-
 struct timespec g_bat_time_before_sleep;
 int g_smartbook_update = 0;
 
@@ -154,10 +152,6 @@ kal_bool battery_suspended = KAL_FALSE;
 extern U32 suspend_time;
 #endif
 
-#if defined(CUST_SYSTEM_OFF_VOLTAGE)
-#define SYSTEM_OFF_VOLTAGE CUST_SYSTEM_OFF_VOLTAGE
-#endif
-
 /* ////////////////////////////////////////////////////////////////////////////// */
 /* Integrate with NVRAM */
 /* ////////////////////////////////////////////////////////////////////////////// */
@@ -287,6 +281,7 @@ static enum power_supply_property battery_props[] = {
 	POWER_SUPPLY_PROP_PRESENT,
 	POWER_SUPPLY_PROP_TECHNOLOGY,
 	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
 	/* Add for Battery Service */
 	POWER_SUPPLY_PROP_batt_vol,
 	POWER_SUPPLY_PROP_batt_temp,
@@ -374,7 +369,7 @@ kal_bool upmu_is_chr_det(void)
 {
 #if !defined(CONFIG_POWER_EXT)
 	kal_uint32 tmp32;
-#endif	
+#endif
 
     if(battery_charging_control == NULL)
     {
@@ -591,6 +586,9 @@ static int battery_get_property(struct power_supply *psy,
         //add end sync end
 		val->intval = data->BAT_CAPACITY;
 		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = data->BAT_batt_vol * 1000; /* uV */
+		break;
 	case POWER_SUPPLY_PROP_batt_vol:
 		val->intval = data->BAT_batt_vol;
 		break;
@@ -1700,14 +1698,14 @@ static kal_bool mt_battery_0Percent_tracking_check(void)
 	if (BMT_status.UI_SOC <= 0) {
 		BMT_status.UI_SOC = 0;
 	} else {
-		if (BMT_status.bat_vol > SYSTEM_OFF_VOLTAGE && BMT_status.UI_SOC > 1) {
+		if (BMT_status.bat_vol > SHUTDOWN_SYSTEM_VOLTAGE && BMT_status.UI_SOC > 1) {
 			BMT_status.UI_SOC--;
-		} else if (BMT_status.bat_vol <= SYSTEM_OFF_VOLTAGE) {
+		} else if (BMT_status.bat_vol <= SHUTDOWN_SYSTEM_VOLTAGE) {
 			BMT_status.UI_SOC--;
 		}
 	}
 
-	battery_log(BAT_LOG_CRTI, "0Percent, VBAT < %d UI_SOC=%d\r\n", SYSTEM_OFF_VOLTAGE,
+	battery_log(BAT_LOG_CRTI, "0Percent, VBAT < %d UI_SOC=%d\r\n", SHUTDOWN_SYSTEM_VOLTAGE,
 			    BMT_status.UI_SOC);
 
 	return resetBatteryMeter;
@@ -1845,6 +1843,7 @@ static void battery_update(struct battery_data *bat_data)
 		else
 	//add end
 		set_rtc_spare_fg_value(battery_meter_get_battery_soc()); /*use battery_soc */
+
 	//add tangqingcai
 	}
 	//add end
@@ -2115,7 +2114,7 @@ static void mt_battery_average_method_init(BATTERY_AVG_ENUM type, kal_uint32 *bu
 			#if !defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
 			if (BMT_status.charger_type == STANDARD_CHARGER) {
 			#else
-			if ((BMT_status.charger_type == STANDARD_CHARGER) || 
+			if ((BMT_status.charger_type == STANDARD_CHARGER) ||
 			    (DISO_data.diso_state.cur_vdc_state == DISO_ONLINE)) {
 			#endif
 				data = AC_CHARGER_CURRENT / 100;
@@ -2134,9 +2133,9 @@ static void mt_battery_average_method_init(BATTERY_AVG_ENUM type, kal_uint32 *bu
 			#if !defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
 			if (BMT_status.charger_type == STANDARD_CHARGER) {
 			#else
-			if ((BMT_status.charger_type == STANDARD_CHARGER) || 
+			if ((BMT_status.charger_type == STANDARD_CHARGER) ||
 			    (DISO_data.diso_state.cur_vdc_state == DISO_ONLINE)) {
-			#endif			
+			#endif
 				data = AC_CHARGER_CURRENT / 100;
 			} else if (BMT_status.charger_type == CHARGING_HOST) {
 				data = CHARGING_HOST_CHARGER_CURRENT / 100;
@@ -2241,7 +2240,7 @@ void mt_battery_GetBatteryData(void)
 	    mt_battery_average_method(BATTERY_AVG_CURRENT, &batteryCurrentBuffer[0], ICharging, &icharging_sum,
 				      batteryIndex);
 
-    
+
 	if (previous_SOC == -1 && bat_vol <= V_0PERCENT_TRACKING) {
 		battery_log(BAT_LOG_CRTI,
 				    "battery voltage too low, use ZCV to init average data.\n");
@@ -2419,7 +2418,7 @@ static void mt_battery_CheckBatteryStatus(void)
 				    "[mt_battery_CheckBatteryStatus] cmd_discharging=(%d)\n",
 				    cmd_discharging);
 		BMT_status.bat_charging_state = CHR_ERROR;
-		battery_charging_control(CHARGING_CMD_SET_ERROR_STATE, &cmd_discharging);	
+		battery_charging_control(CHARGING_CMD_SET_ERROR_STATE, &cmd_discharging);
 		return;
 	} else if (cmd_discharging == 0) {
 		BMT_status.bat_charging_state = CHR_PRE;
@@ -2716,12 +2715,12 @@ CHARGER_TYPE mt_charger_type_detection(void)
 			BMT_status.bat_charging_state = CHR_BATFULL;
 			BMT_status.bat_full = KAL_TRUE;
 			g_charging_full_reset_bat_meter = KAL_TRUE;
-		}	
+		}
 
 		 if(g_battery_soc_ready == KAL_FALSE) {
 			if(BMT_status.nPercent_ZCV == 0)
 				battery_meter_initial();
-					
+
 			BMT_status.SOC = battery_meter_get_battery_percentage();
 		}
 #endif
@@ -2866,7 +2865,7 @@ void do_chrdet_int_task(void)
 			#if defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
 			battery_log(BAT_LOG_CRTI, 
 					    "turn off charging for no avaliable charging source\n");
-			battery_charging_control(CHARGING_CMD_ENABLE,&BMT_status.charger_exist); 
+			battery_charging_control(CHARGING_CMD_ENABLE,&BMT_status.charger_exist);
 			#endif
 
 #ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
@@ -2894,7 +2893,7 @@ void do_chrdet_int_task(void)
 			}
 #endif
 			#if defined(CONFIG_MTK_PUMP_EXPRESS_SUPPORT) || defined(CONFIG_MTK_PUMP_EXPRESS_PLUS_SUPPORT)
-				 is_ta_connect = KAL_FALSE;    
+				 is_ta_connect = KAL_FALSE;
 				 ta_check_chr_type = KAL_TRUE;
 				 ta_cable_out_occur = KAL_TRUE;
 			#endif
@@ -2948,34 +2947,6 @@ void BAT_thread(void)
 	}
 	mt_battery_thermal_check();
 	mt_battery_notify_check();
-#ifdef HQ_BOOT_WITH_VIBRATOR
-       #ifdef MTK_KERNEL_POWER_OFF_CHARGING
-       printk("[kernel:battery_common] pwrkey_pressed_flag:%d!\r\n",pwrkey_pressed_flag);
-       if(pwrkey_pressed_flag == true && timer_init == 0){
-           timer_init =sched_clock();
-       }else if (pwrkey_pressed_flag == true &&timer_init !=0){
-           timer_end = sched_clock();
-       }else if (pwrkey_pressed_flag == false){
-           timer_init = 0;
-           timer_end = 0;
-       }
-       
-       printk("[kernel:battery_common] timer_init:%d ,timer_end:%d, kernel_vibrate_flag:%d!!!\r\n",
-           timer_init,timer_end,kernel_vibrate_flag);
-       
-       if(kernel_vibrate_flag == false){//vibration only once
-           if(timer_end -timer_init >= PWRKEY_LONG_PRESS_TIME){
-               vibr_Enable_HW();
-               mdelay(300);
-               vibr_Disable_HW();
-               mdelay(200);
-               printk("[kernel:battery_common] vibr_Enable_HW--->>>vibr_Disable_HW!!!\r\n");
-               timer_init = 0;
-               timer_end = 0;
-           }
-       }
-       #endif
-   #endif 
 
 	if (BMT_status.charger_exist == KAL_TRUE) {
 		mt_battery_CheckBatteryStatus();
@@ -2989,10 +2960,23 @@ void BAT_thread(void)
 /* ///////////////////////////////////////////////////////////////////////////////////////// */
 /* // Internal API */
 /* ///////////////////////////////////////////////////////////////////////////////////////// */
+#ifdef BATTERY_CDP_WORKAROUND
+extern kal_bool is_usb_rdy(void);
+#endif
 int bat_thread_kthread(void *x)
 {
 	ktime_t ktime = ktime_set(3, 0);	/* 10s, 10* 1000 ms */
 
+#ifdef BATTERY_CDP_WORKAROUND
+	if(is_usb_rdy()==KAL_FALSE){
+		battery_log(BAT_LOG_CRTI, "CDP, block\n");
+		wait_event(bat_thread_wq, (is_usb_rdy()==KAL_TRUE));
+		battery_log(BAT_LOG_CRTI, "CDP, free\n");
+	}else{
+		battery_log(BAT_LOG_CRTI, "CDP, PASS\n");
+	}
+#endif
+
 	/* Run on a process content */
 	while (1) {
 		mutex_lock(&bat_mutex);
@@ -3693,7 +3677,7 @@ static int battery_probe(struct platform_device *dev)
 
 	wake_lock_init(&battery_suspend_lock, WAKE_LOCK_SUSPEND, "battery suspend wakelock");
 	#if defined(CONFIG_MTK_PUMP_EXPRESS_SUPPORT) || defined(CONFIG_MTK_PUMP_EXPRESS_PLUS_SUPPORT)
-	wake_lock_init(&TA_charger_suspend_lock, WAKE_LOCK_SUSPEND, "TA charger suspend wakelock");  
+	wake_lock_init(&TA_charger_suspend_lock, WAKE_LOCK_SUSPEND, "TA charger suspend wakelock");
 	#endif
 
 	/* Integrate with Android Battery Service */
@@ -3900,7 +3884,7 @@ static void battery_timer_resume(void)
 	battery_charging_control(CHARGING_CMD_GET_IS_PCM_TIMER_TRIGGER, &is_pcm_timer_trigger);
 
 	if(is_pcm_timer_trigger == KAL_TRUE || bat_spm_timeout)
-	{	
+	{
 		mutex_lock(&bat_mutex);
 		BAT_thread();
 		mutex_unlock(&bat_mutex);
@@ -4138,13 +4122,13 @@ static ssize_t discharging_cmd_write(struct file *file, const char *buffer, size
 	int len = 0;
 	char desc[32];
 	U32 charging_enable = false;
-    
+
 	len = (count < (sizeof(desc) - 1)) ? count : (sizeof(desc) - 1);
 	if (copy_from_user(desc, buffer, len)) {
 		return 0;
 	}
 	desc[len] = '\0';
-    
+
 	if (sscanf(desc, "%d %d", &charging_enable, &adjust_power) == 2) {
 		battery_log(BAT_LOG_CRTI, "[current_cmd_write] adjust_power = %d\n", adjust_power);
 		return count;
@@ -4155,8 +4139,8 @@ static ssize_t discharging_cmd_write(struct file *file, const char *buffer, size
     	return -EINVAL;
 }
 
-static const struct file_operations discharging_cmd_proc_fops = { 
-	.open  = proc_utilization_open, 
+static const struct file_operations discharging_cmd_proc_fops = {
+	.open  = proc_utilization_open,
 	.read  = seq_read,
 	.write = discharging_cmd_write,
 };
@@ -4190,7 +4174,7 @@ static int mt_batteryNotify_probe(struct platform_device *dev)
 		battery_log(BAT_LOG_CRTI, "proc_create current_cmd_proc_fops\n");
 		proc_create("discharging_cmd", S_IRUGO | S_IWUSR, battery_dir, &discharging_cmd_proc_fops);
 		battery_log(BAT_LOG_CRTI, "proc_create discharging_cmd_proc_fops\n");
-            
+
 
 #else
 		entry = create_proc_entry("battery_cmd", S_IRUGO | S_IWUSR, battery_dir);
@@ -4309,7 +4293,7 @@ static struct platform_driver battery_dts_driver = {
 	.shutdown = NULL,
 	.driver = {
 		   .name = "battery-dts",
-        #ifdef CONFIG_OF 
+        #ifdef CONFIG_OF
  		.of_match_table = mt_battery_of_match,
         #endif
 	},
@@ -4362,7 +4346,7 @@ static struct platform_driver mt_batteryNotify_dts_driver = {
 	.driver = {
 		   .name = "mt-dts-battery",
         #ifdef CONFIG_OF
-		.of_match_table = mt_bat_notify_of_match,    
+		.of_match_table = mt_bat_notify_of_match,
         #endif
 	},
 };
@@ -4402,7 +4386,7 @@ static int __init battery_init(void)
 #ifdef CONFIG_OF
 	//
 #else
-    
+
 #ifdef BATTERY_MODULE_INIT
 	ret = platform_device_register(&battery_device);
 	if (ret) {
@@ -4439,7 +4423,7 @@ static int __init battery_init(void)
 #ifdef CONFIG_OF
 	ret = platform_driver_register(&battery_dts_driver);
 	ret = platform_driver_register(&mt_batteryNotify_dts_driver);
-#endif	
+#endif
 	ret = register_pm_notifier(&battery_pm_notifier_block);
 	if (ret)
 		printk("[%s] failed to register PM notifier %d\n", __func__, ret);
diff --git a/drivers/power/mediatek/battery_meter.c b/drivers/power/mediatek/battery_meter.c
index 310aa9d..1200b5e 100644
--- a/drivers/power/mediatek/battery_meter.c
+++ b/drivers/power/mediatek/battery_meter.c
@@ -2663,15 +2663,15 @@ kal_int32 battery_meter_get_charging_current(void)
 #ifdef DISABLE_CHARGING_CURRENT_MEASURE
 	return 0;
 #elif !defined (EXTERNAL_SWCHR_SUPPORT)
-	kal_int32 ADC_BAT_SENSE_tmp[10] =
-	    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	kal_int32 ADC_BAT_SENSE_tmp[20] =
+	    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 	kal_int32 ADC_BAT_SENSE_sum = 0;
 	kal_int32 ADC_BAT_SENSE = 0;
-	kal_int32 ADC_I_SENSE_tmp[10] =
-	    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	kal_int32 ADC_I_SENSE_tmp[20] =
+	    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 	kal_int32 ADC_I_SENSE_sum = 0;
 	kal_int32 ADC_I_SENSE = 0;
-	int repeat = 10;
+	int repeat = 20;
 	int i = 0;
 	int j = 0;
 	kal_int32 temp = 0;
@@ -2727,14 +2727,18 @@ kal_int32 battery_meter_get_charging_current(void)
 	bm_print(BM_LOG_FULL, "\r\n");
 
 	ADC_BAT_SENSE_sum -= ADC_BAT_SENSE_tmp[0];
-	ADC_BAT_SENSE_sum -= ADC_BAT_SENSE_tmp[9];
-	ADC_BAT_SENSE = ADC_BAT_SENSE_sum / (repeat - 2);
+	ADC_BAT_SENSE_sum -= ADC_BAT_SENSE_tmp[1];
+	ADC_BAT_SENSE_sum -= ADC_BAT_SENSE_tmp[18];
+	ADC_BAT_SENSE_sum -= ADC_BAT_SENSE_tmp[19];
+	ADC_BAT_SENSE = ADC_BAT_SENSE_sum / (repeat - 4);
 
 	bm_print(BM_LOG_FULL, "[g_Get_I_Charging] ADC_BAT_SENSE=%d\r\n", ADC_BAT_SENSE);
 
 	ADC_I_SENSE_sum -= ADC_I_SENSE_tmp[0];
-	ADC_I_SENSE_sum -= ADC_I_SENSE_tmp[9];
-	ADC_I_SENSE = ADC_I_SENSE_sum / (repeat - 2);
+	ADC_I_SENSE_sum -= ADC_I_SENSE_tmp[1];
+	ADC_I_SENSE_sum -= ADC_I_SENSE_tmp[18];
+	ADC_I_SENSE_sum -= ADC_I_SENSE_tmp[19];
+	ADC_I_SENSE = ADC_I_SENSE_sum / (repeat - 4);
 
 	bm_print(BM_LOG_FULL, "[g_Get_I_Charging] ADC_I_SENSE(Before)=%d\r\n", ADC_I_SENSE);
 
diff --git a/drivers/power/mediatek/linear_charging.c b/drivers/power/mediatek/linear_charging.c
index d92d5a2..d57c5d9 100644
--- a/drivers/power/mediatek/linear_charging.c
+++ b/drivers/power/mediatek/linear_charging.c
@@ -79,7 +79,7 @@ kal_uint32 		v_cc2topoff_threshold = V_CC2TOPOFF_THRES;
  CHR_CURRENT_ENUM	ulc_cv_charging_current = AC_CHARGER_CURRENT;	
  kal_bool 		ulc_cv_charging_current_flag = KAL_FALSE;
 static bool 		usb_unlimited=false;
-
+BATTERY_VOLTAGE_ENUM cv_voltage;
   /* ///////////////////////////////////////////////////////////////////////////////////////// */
   /* // JEITA */
   /* ///////////////////////////////////////////////////////////////////////////////////////// */
@@ -529,8 +529,6 @@ static void battery_pump_express_algorithm_start(void)
 
 static BATTERY_VOLTAGE_ENUM select_jeita_cv(void)
 {
-	BATTERY_VOLTAGE_ENUM cv_voltage;
-
 	if (g_temp_status == TEMP_ABOVE_POS_60) {
 		cv_voltage = JEITA_TEMP_ABOVE_POS_60_CV_VOLTAGE;
 	} else if (g_temp_status == TEMP_POS_45_TO_POS_60) {
@@ -557,7 +555,6 @@ static BATTERY_VOLTAGE_ENUM select_jeita_cv(void)
 PMU_STATUS do_jeita_state_machine(void)
 {
 	int previous_g_temp_status;
-	BATTERY_VOLTAGE_ENUM cv_voltage;
 
 	previous_g_temp_status = g_temp_status;
 	/* JEITA battery temp Standard */
@@ -959,9 +956,6 @@ static void pchr_sw_cv_charing_current_check(void)
 
 static void pchr_turn_on_charging(void)
 {
-#if !defined(CONFIG_MTK_JEITA_STANDARD_SUPPORT)
-	BATTERY_VOLTAGE_ENUM cv_voltage;
-#endif
 	kal_uint32 charging_enable = KAL_TRUE;
 
 	battery_log(BAT_LOG_FULL, "[BATTERY] pchr_turn_on_charging()!\r\n");
diff --git a/drivers/power/mediatek/switch_charging.c b/drivers/power/mediatek/switch_charging.c
index 167f7bd..57c4589 100644
--- a/drivers/power/mediatek/switch_charging.c
+++ b/drivers/power/mediatek/switch_charging.c
@@ -54,7 +54,7 @@
  /* ============================================================ // */
  /* define */
  /* ============================================================ // */
-
+ /* cut off to full */
 
  /* ============================================================ // */
  /* global variable */
@@ -66,7 +66,7 @@ CHR_CURRENT_ENUM g_temp_CC_value = CHARGE_CURRENT_0_00_MA;
 CHR_CURRENT_ENUM g_temp_input_CC_value = CHARGE_CURRENT_0_00_MA;
 kal_uint32 g_usb_state = USB_UNCONFIGURED;
 static bool usb_unlimited=false;
-
+BATTERY_VOLTAGE_ENUM cv_voltage;
   /* ///////////////////////////////////////////////////////////////////////////////////////// */
   /* // PUMP EXPRESS */
   /* ///////////////////////////////////////////////////////////////////////////////////////// */
@@ -308,8 +308,6 @@ static void battery_pump_express_algorithm_start(void)
 
 static BATTERY_VOLTAGE_ENUM select_jeita_cv(void)
 {
-	BATTERY_VOLTAGE_ENUM cv_voltage;
-
 	if (g_temp_status == TEMP_ABOVE_POS_60) {
 		cv_voltage = JEITA_TEMP_ABOVE_POS_60_CV_VOLTAGE;
 	} else if (g_temp_status == TEMP_POS_45_TO_POS_60) {
@@ -335,8 +333,6 @@ static BATTERY_VOLTAGE_ENUM select_jeita_cv(void)
 
 PMU_STATUS do_jeita_state_machine(void)
 {
-	BATTERY_VOLTAGE_ENUM cv_voltage;
-
 	/* JEITA battery temp Standard */
 
 	if (BMT_status.temperature >= TEMP_POS_60_THRESHOLD) {
@@ -567,7 +563,7 @@ kal_uint32 set_bat_charging_current_limit(int current_limit)
 	pchr_turn_on_charging();
 
 	return g_bcct_flag;
-}    
+}
 #if defined(BATTERY_TEMP_CHARGING_CURRENT)
 g_tempStatus = E_BAT_T_B_15_45;
 void check_battery_temperature(void)
@@ -588,7 +584,7 @@ void check_battery_temperature(void)
 	else if(BMT_status.temperature > MAX_CHARGE_TEMPERATURE) {
 		g_tempStatus = E_BAT_T_U_50;
 	}
-	
+
 	BMT_status.bat_temp_status = g_tempStatus;
 }
 void set_current_according_to_temperature(void)
@@ -630,7 +626,6 @@ void select_charging_curret(void)
 		if (g_temp_CC_value == CHARGE_CURRENT_450_00_MA) {
 			g_temp_input_CC_value = CHARGE_CURRENT_500_00_MA;
 		} else {
-
             #if defined(BATTERY_TEMP_CHARGING_CURRENT)
 			set_current_according_to_temperature();
 			#else
@@ -674,10 +669,9 @@ void select_charging_curret(void)
         	#if defined(BATTERY_TEMP_CHARGING_CURRENT)
 			set_current_according_to_temperature();
 			#else
-        	g_temp_input_CC_value = AC_CHARGER_CURRENT;
+			g_temp_input_CC_value = AC_CHARGER_CURRENT;
 			g_temp_CC_value = AC_CHARGER_CURRENT;
 			#endif
-
 #if defined(CONFIG_MTK_PUMP_EXPRESS_PLUS_SUPPORT)
         		if(is_ta_connect == KAL_TRUE)
         			set_ta_charging_current();
@@ -740,12 +734,10 @@ static kal_uint32 charging_full_check(void)
 //huangyisong_add_20130926 add
 extern int g_runin_test_enter;
 
+
 // tangqingcai modify for_runin
 void pchr_turn_on_charging (void)
 {
-#if !defined(CONFIG_MTK_JEITA_STANDARD_SUPPORT)
-	BATTERY_VOLTAGE_ENUM cv_voltage;
-#endif	
 #ifdef BATTERY_TEMP_CHARGING_CURRENT
    kal_uint32 cv_value =0;
 #endif
diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a86d123..e873e8f 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1410,7 +1410,7 @@ struct regulator *regulator_get_exclusive(struct device *dev, const char *id)
 }
 EXPORT_SYMBOL_GPL(regulator_get_exclusive);
 
-/* Locks held by regulator_put() */
+/* regulator_list_mutex lock held by regulator_put() */
 static void _regulator_put(struct regulator *regulator)
 {
 	struct regulator_dev *rdev;
@@ -1425,12 +1425,14 @@ static void _regulator_put(struct regulator *regulator)
 	/* remove any sysfs entries */
 	if (regulator->dev)
 		sysfs_remove_link(&rdev->dev.kobj, regulator->supply_name);
+	mutex_lock(&rdev->mutex);
 	kfree(regulator->supply_name);
 	list_del(&regulator->list);
 	kfree(regulator);
 
 	rdev->open_count--;
 	rdev->exclusive = 0;
+	mutex_unlock(&rdev->mutex);
 
 	module_put(rdev->owner);
 }
diff --git a/drivers/s390/char/con3215.c b/drivers/s390/char/con3215.c
index bb86494..19915c5 100644
--- a/drivers/s390/char/con3215.c
+++ b/drivers/s390/char/con3215.c
@@ -288,12 +288,16 @@ static void raw3215_timeout(unsigned long __data)
 	unsigned long flags;
 
 	spin_lock_irqsave(get_ccwdev_lock(raw->cdev), flags);
-	if (raw->flags & RAW3215_TIMER_RUNS) {
-		del_timer(&raw->timer);
-		raw->flags &= ~RAW3215_TIMER_RUNS;
-		if (!(raw->port.flags & ASYNC_SUSPENDED)) {
-			raw3215_mk_write_req(raw);
-			raw3215_start_io(raw);
+	raw->flags &= ~RAW3215_TIMER_RUNS;
+	if (!(raw->port.flags & ASYNC_SUSPENDED)) {
+		raw3215_mk_write_req(raw);
+		raw3215_start_io(raw);
+		if ((raw->queued_read || raw->queued_write) &&
+		    !(raw->flags & RAW3215_WORKING) &&
+		    !(raw->flags & RAW3215_TIMER_RUNS)) {
+			raw->timer.expires = RAW3215_TIMEOUT + jiffies;
+			add_timer(&raw->timer);
+			raw->flags |= RAW3215_TIMER_RUNS;
 		}
 	}
 	spin_unlock_irqrestore(get_ccwdev_lock(raw->cdev), flags);
@@ -317,17 +321,15 @@ static inline void raw3215_try_io(struct raw3215_info *raw)
 		    (raw->flags & RAW3215_FLUSHING)) {
 			/* execute write requests bigger than minimum size */
 			raw3215_start_io(raw);
-			if (raw->flags & RAW3215_TIMER_RUNS) {
-				del_timer(&raw->timer);
-				raw->flags &= ~RAW3215_TIMER_RUNS;
-			}
-		} else if (!(raw->flags & RAW3215_TIMER_RUNS)) {
-			/* delay small writes */
-			raw->timer.expires = RAW3215_TIMEOUT + jiffies;
-			add_timer(&raw->timer);
-			raw->flags |= RAW3215_TIMER_RUNS;
 		}
 	}
+	if ((raw->queued_read || raw->queued_write) &&
+	    !(raw->flags & RAW3215_WORKING) &&
+	    !(raw->flags & RAW3215_TIMER_RUNS)) {
+		raw->timer.expires = RAW3215_TIMEOUT + jiffies;
+		add_timer(&raw->timer);
+		raw->flags |= RAW3215_TIMER_RUNS;
+	}
 }
 
 /*
@@ -1027,12 +1029,26 @@ static int tty3215_write(struct tty_struct * tty,
 			 const unsigned char *buf, int count)
 {
 	struct raw3215_info *raw;
+	int i, written;
 
 	if (!tty)
 		return 0;
 	raw = (struct raw3215_info *) tty->driver_data;
-	raw3215_write(raw, buf, count);
-	return count;
+	written = count;
+	while (count > 0) {
+		for (i = 0; i < count; i++)
+			if (buf[i] == '\t' || buf[i] == '\n')
+				break;
+		raw3215_write(raw, buf, i);
+		count -= i;
+		buf += i;
+		if (count > 0) {
+			raw3215_putchar(raw, *buf);
+			count--;
+			buf++;
+		}
+	}
+	return written;
 }
 
 /*
@@ -1180,7 +1196,7 @@ static int __init tty3215_init(void)
 	driver->subtype = SYSTEM_TYPE_TTY;
 	driver->init_termios = tty_std_termios;
 	driver->init_termios.c_iflag = IGNBRK | IGNPAR;
-	driver->init_termios.c_oflag = ONLCR | XTABS;
+	driver->init_termios.c_oflag = ONLCR;
 	driver->init_termios.c_lflag = ISIG;
 	driver->flags = TTY_DRIVER_REAL_RAW;
 	tty_set_operations(driver, &tty3215_ops);
diff --git a/drivers/s390/crypto/ap_bus.c b/drivers/s390/crypto/ap_bus.c
index 9de41aa..6f512fa 100644
--- a/drivers/s390/crypto/ap_bus.c
+++ b/drivers/s390/crypto/ap_bus.c
@@ -44,6 +44,7 @@
 #include <linux/hrtimer.h>
 #include <linux/ktime.h>
 #include <asm/facility.h>
+#include <linux/crypto.h>
 
 #include "ap_bus.h"
 
diff --git a/drivers/scsi/be2iscsi/be_main.c b/drivers/scsi/be2iscsi/be_main.c
index d24a286..1ad39c7 100644
--- a/drivers/scsi/be2iscsi/be_main.c
+++ b/drivers/scsi/be2iscsi/be_main.c
@@ -564,7 +564,6 @@ static struct beiscsi_hba *beiscsi_hba_alloc(struct pci_dev *pcidev)
 			"beiscsi_hba_alloc - iscsi_host_alloc failed\n");
 		return NULL;
 	}
-	shost->dma_boundary = pcidev->dma_mask;
 	shost->max_id = BE2_MAX_SESSIONS;
 	shost->max_channel = 0;
 	shost->max_cmd_len = BEISCSI_MAX_CMD_LEN;
diff --git a/drivers/scsi/ipr.c b/drivers/scsi/ipr.c
index 0ff37a5..f7732f3 100644
--- a/drivers/scsi/ipr.c
+++ b/drivers/scsi/ipr.c
@@ -645,6 +645,7 @@ static void ipr_init_ipr_cmnd(struct ipr_cmnd *ipr_cmd,
 	ipr_reinit_ipr_cmnd(ipr_cmd);
 	ipr_cmd->u.scratch = 0;
 	ipr_cmd->sibling = NULL;
+	ipr_cmd->eh_comp = NULL;
 	ipr_cmd->fast_done = fast_done;
 	init_timer(&ipr_cmd->timer);
 }
@@ -810,6 +811,8 @@ static void ipr_scsi_eh_done(struct ipr_cmnd *ipr_cmd)
 
 	scsi_dma_unmap(ipr_cmd->scsi_cmd);
 	scsi_cmd->scsi_done(scsi_cmd);
+	if (ipr_cmd->eh_comp)
+		complete(ipr_cmd->eh_comp);
 	list_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_free_q);
 }
 
@@ -4767,6 +4770,84 @@ static int ipr_slave_alloc(struct scsi_device *sdev)
 	return rc;
 }
 
+/**
+ * ipr_match_lun - Match function for specified LUN
+ * @ipr_cmd:	ipr command struct
+ * @device:		device to match (sdev)
+ *
+ * Returns:
+ *	1 if command matches sdev / 0 if command does not match sdev
+ **/
+static int ipr_match_lun(struct ipr_cmnd *ipr_cmd, void *device)
+{
+	if (ipr_cmd->scsi_cmd && ipr_cmd->scsi_cmd->device == device)
+		return 1;
+	return 0;
+}
+
+/**
+ * ipr_wait_for_ops - Wait for matching commands to complete
+ * @ipr_cmd:	ipr command struct
+ * @device:		device to match (sdev)
+ * @match:		match function to use
+ *
+ * Returns:
+ *	SUCCESS / FAILED
+ **/
+static int ipr_wait_for_ops(struct ipr_ioa_cfg *ioa_cfg, void *device,
+			    int (*match)(struct ipr_cmnd *, void *))
+{
+	struct ipr_cmnd *ipr_cmd;
+	int wait;
+	unsigned long flags;
+	struct ipr_hrr_queue *hrrq;
+	signed long timeout = IPR_ABORT_TASK_TIMEOUT;
+	DECLARE_COMPLETION_ONSTACK(comp);
+
+	ENTER;
+	do {
+		wait = 0;
+
+		for_each_hrrq(hrrq, ioa_cfg) {
+			spin_lock_irqsave(hrrq->lock, flags);
+			list_for_each_entry(ipr_cmd, &hrrq->hrrq_pending_q, queue) {
+				if (match(ipr_cmd, device)) {
+					ipr_cmd->eh_comp = &comp;
+					wait++;
+				}
+			}
+			spin_unlock_irqrestore(hrrq->lock, flags);
+		}
+
+		if (wait) {
+			timeout = wait_for_completion_timeout(&comp, timeout);
+
+			if (!timeout) {
+				wait = 0;
+
+				for_each_hrrq(hrrq, ioa_cfg) {
+					spin_lock_irqsave(hrrq->lock, flags);
+					list_for_each_entry(ipr_cmd, &hrrq->hrrq_pending_q, queue) {
+						if (match(ipr_cmd, device)) {
+							ipr_cmd->eh_comp = NULL;
+							wait++;
+						}
+					}
+					spin_unlock_irqrestore(hrrq->lock, flags);
+				}
+
+				if (wait)
+					dev_err(&ioa_cfg->pdev->dev, "Timed out waiting for aborted commands\n");
+				LEAVE;
+				return wait ? FAILED : SUCCESS;
+			}
+		}
+	} while (wait);
+
+	LEAVE;
+	return SUCCESS;
+}
+
 static int ipr_eh_host_reset(struct scsi_cmnd *cmd)
 {
 	struct ipr_ioa_cfg *ioa_cfg;
@@ -4985,11 +5066,17 @@ static int __ipr_eh_dev_reset(struct scsi_cmnd *scsi_cmd)
 static int ipr_eh_dev_reset(struct scsi_cmnd *cmd)
 {
 	int rc;
+	struct ipr_ioa_cfg *ioa_cfg;
+
+	ioa_cfg = (struct ipr_ioa_cfg *) cmd->device->host->hostdata;
 
 	spin_lock_irq(cmd->device->host->host_lock);
 	rc = __ipr_eh_dev_reset(cmd);
 	spin_unlock_irq(cmd->device->host->host_lock);
 
+	if (rc == SUCCESS)
+		rc = ipr_wait_for_ops(ioa_cfg, cmd->device, ipr_match_lun);
+
 	return rc;
 }
 
@@ -5167,13 +5254,18 @@ static int ipr_eh_abort(struct scsi_cmnd *scsi_cmd)
 {
 	unsigned long flags;
 	int rc;
+	struct ipr_ioa_cfg *ioa_cfg;
 
 	ENTER;
 
+	ioa_cfg = (struct ipr_ioa_cfg *) scsi_cmd->device->host->hostdata;
+
 	spin_lock_irqsave(scsi_cmd->device->host->host_lock, flags);
 	rc = ipr_cancel_op(scsi_cmd);
 	spin_unlock_irqrestore(scsi_cmd->device->host->host_lock, flags);
 
+	if (rc == SUCCESS)
+		rc = ipr_wait_for_ops(ioa_cfg, scsi_cmd->device, ipr_match_lun);
 	LEAVE;
 	return rc;
 }
diff --git a/drivers/scsi/ipr.h b/drivers/scsi/ipr.h
index 07a85ce..535f573 100644
--- a/drivers/scsi/ipr.h
+++ b/drivers/scsi/ipr.h
@@ -1578,6 +1578,7 @@ struct ipr_cmnd {
 		struct scsi_device *sdev;
 	} u;
 
+	struct completion *eh_comp;
 	struct ipr_hrr_queue *hrrq;
 	struct ipr_ioa_cfg *ioa_cfg;
 };
diff --git a/drivers/scsi/sg.c b/drivers/scsi/sg.c
index df5e961..eb81c98 100644
--- a/drivers/scsi/sg.c
+++ b/drivers/scsi/sg.c
@@ -522,7 +522,7 @@ static ssize_t
 sg_new_read(Sg_fd * sfp, char __user *buf, size_t count, Sg_request * srp)
 {
 	sg_io_hdr_t *hp = &srp->header;
-	int err = 0;
+	int err = 0, err2;
 	int len;
 
 	if (count < SZ_SG_IO_HDR) {
@@ -551,8 +551,8 @@ sg_new_read(Sg_fd * sfp, char __user *buf, size_t count, Sg_request * srp)
 		goto err_out;
 	}
 err_out:
-	err = sg_finish_rem_req(srp);
-	return (0 == err) ? count : err;
+	err2 = sg_finish_rem_req(srp);
+	return err ? : err2 ? : count;
 }
 
 static ssize_t
diff --git a/drivers/scsi/storvsc_drv.c b/drivers/scsi/storvsc_drv.c
index 87ca72d..a899078 100644
--- a/drivers/scsi/storvsc_drv.c
+++ b/drivers/scsi/storvsc_drv.c
@@ -1439,13 +1439,12 @@ static int storvsc_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *scmnd)
 	if (ret == -EAGAIN) {
 		/* no more space */
 
-		if (cmd_request->bounce_sgl_count) {
+		if (cmd_request->bounce_sgl_count)
 			destroy_bounce_buffer(cmd_request->bounce_sgl,
 					cmd_request->bounce_sgl_count);
 
-			ret = SCSI_MLQUEUE_DEVICE_BUSY;
-			goto queue_error;
-		}
+		ret = SCSI_MLQUEUE_DEVICE_BUSY;
+		goto queue_error;
 	}
 
 	return 0;
diff --git a/drivers/spi/spi-dw-mid.c b/drivers/spi/spi-dw-mid.c
index 0791c92..1389fef 100644
--- a/drivers/spi/spi-dw-mid.c
+++ b/drivers/spi/spi-dw-mid.c
@@ -222,7 +222,6 @@ int dw_spi_mid_init(struct dw_spi *dws)
 	iounmap(clk_reg);
 
 	dws->num_cs = 16;
-	dws->fifo_len = 40;	/* FIFO has 40 words buffer */
 
 #ifdef CONFIG_SPI_DW_MID_DMA
 	dws->dma_priv = kzalloc(sizeof(struct mid_dma), GFP_KERNEL);
diff --git a/drivers/spi/spi-pxa2xx.c b/drivers/spi/spi-pxa2xx.c
index d26a2d1..cc42ee5 100644
--- a/drivers/spi/spi-pxa2xx.c
+++ b/drivers/spi/spi-pxa2xx.c
@@ -393,8 +393,8 @@ static void giveback(struct driver_data *drv_data)
 			cs_deassert(drv_data);
 	}
 
-	spi_finalize_current_message(drv_data->master);
 	drv_data->cur_chip = NULL;
+	spi_finalize_current_message(drv_data->master);
 }
 
 static void reset_sccr1(struct driver_data *drv_data)
diff --git a/drivers/staging/android/ion/ion.c b/drivers/staging/android/ion/ion.c
index e53b2ee..ae2490c 100644
--- a/drivers/staging/android/ion/ion.c
+++ b/drivers/staging/android/ion/ion.c
@@ -812,6 +812,8 @@ static int ion_debug_client_show(struct seq_file *s, void *unused)
 	const char *names[ION_NUM_HEAP_IDS] = {NULL};
 	int i;
 
+        seq_printf(s, "%16.s %8.s %8.s %8.s %8.s %8.s\n", "heap_name","pid", "size", "handle_count","handle","buffer");
+
 	mutex_lock(&client->lock);
 	for (n = rb_first(&client->handles); n; n = rb_next(n)) {
 		struct ion_handle *handle = rb_entry(n, struct ion_handle,
@@ -821,9 +823,15 @@ static int ion_debug_client_show(struct seq_file *s, void *unused)
 		if (!names[id])
 			names[id] = handle->buffer->heap->name;
 		sizes[id] += handle->buffer->size;
+
+	        struct ion_buffer *buffer = handle->buffer;
+	        seq_printf(s, "%16.s %3d %8zu %3d %p %p.\n", buffer->heap->name, 
+                               client->pid, buffer->size, buffer->handle_count, handle, buffer);
 	}
 	mutex_unlock(&client->lock);
 
+        seq_printf(s, "----------------------------------------------------\n");
+
 	seq_printf(s, "%16.16s: %16.16s\n", "heap_name", "size_in_bytes");
 	for (i = 0; i < ION_NUM_HEAP_IDS; i++) {
 		if (!names[i])
@@ -1645,6 +1653,7 @@ static int ion_debug_heap_show(struct seq_file *s, void *unused)
 		}
 	}
 	up_read(&dev->lock);
+
 	seq_printf(s, "----------------------------------------------------\n");
 	seq_printf(s, "orphaned allocations (info is from last known client):"
 		   "\n");
@@ -1691,6 +1700,30 @@ static const struct file_operations debug_heap_fops = {
 	.release = single_release,
 };
 
+static int ion_debug_heap_pool_show(struct seq_file *s, void *unused)
+{
+	struct ion_heap *heap = s->private;
+	struct ion_device *dev = heap->dev;
+	struct rb_node *n;
+	size_t total_size = heap->ops->page_pool_total(heap);
+
+	seq_printf(s, "%16.s %16zu\n", "total_in_pool ", total_size);
+
+	return 0;
+}
+
+static int ion_debug_heap_pool_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ion_debug_heap_pool_show, inode->i_private);
+}
+
+static const struct file_operations debug_heap_pool_fops = {
+	.open = ion_debug_heap_pool_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
 #ifdef DEBUG_HEAP_SHRINKER
 static int debug_shrink_set(void *data, u64 val)
 {
@@ -1779,6 +1812,19 @@ void ion_device_add_heap(struct ion_device *dev, struct ion_heap *heap)
 		}
 	}
 #endif
+
+        char tmp_name[64];
+
+	snprintf(tmp_name, 64, "%s_total_in_pool", heap->name);
+	debug_file = debugfs_create_file(
+			tmp_name, 0644, dev->heaps_debug_root, heap,
+				     &debug_heap_pool_fops);
+	if (!debug_file) {
+		char buf[256], *path;
+		path = dentry_path(dev->heaps_debug_root, buf, 256);
+		pr_err("Failed to create heap page pool debugfs at %s/%s\n", path, tmp_name);
+	}
+
 	up_write(&dev->lock);
 }
 
diff --git a/drivers/staging/android/ion/ion_priv.h b/drivers/staging/android/ion/ion_priv.h
index 3697834..d0599d1 100644
--- a/drivers/staging/android/ion/ion_priv.h
+++ b/drivers/staging/android/ion/ion_priv.h
@@ -210,6 +210,7 @@ struct ion_heap_ops {
 			 struct vm_area_struct *vma);
 	int (*shrink)(struct ion_heap *heap, gfp_t gfp_mask, int nr_to_scan);
 	void (*add_freelist) (struct ion_buffer *buffer);
+	int (*page_pool_total)(struct ion_heap *heap);
 };
 
 /**
diff --git a/drivers/staging/android/ion/mtk/ion_mm_heap.c b/drivers/staging/android/ion/mtk/ion_mm_heap.c
index 4332b30..3c53337 100644
--- a/drivers/staging/android/ion/mtk/ion_mm_heap.c
+++ b/drivers/staging/android/ion/mtk/ion_mm_heap.c
@@ -397,6 +397,22 @@ void ion_mm_heap_add_freelist(struct ion_buffer *buffer)
     ion_mm_heap_free_bufferInfo(buffer);
 }
 
+int ion_mm_heap_pool_total(struct ion_heap *heap) {
+	struct ion_system_heap *sys_heap;
+	int total = 0;
+	int i;
+
+	sys_heap = container_of(heap, struct ion_system_heap, heap);
+
+	for (i = 0; i < num_orders; i++) {
+		struct ion_page_pool *pool = sys_heap->pools[i];
+		total += (pool->high_count + pool->low_count) * (1 << pool->order);
+                pool = sys_heap->cached_pools[i];
+		total += (pool->high_count + pool->low_count) * (1 << pool->order);
+	}
+
+	return total;
+}
 
 static struct ion_heap_ops system_heap_ops = {
     .allocate = ion_mm_heap_allocate,
@@ -409,6 +425,7 @@ static struct ion_heap_ops system_heap_ops = {
     .phys = ion_mm_heap_phys,
 	.shrink = ion_mm_heap_shrink,
     .add_freelist = ion_mm_heap_add_freelist,
+    .page_pool_total = ion_mm_heap_pool_total,
 };
 
 static int ion_mm_heap_debug_show(struct ion_heap *heap, struct seq_file *s,
@@ -430,7 +447,6 @@ static int ion_mm_heap_debug_show(struct ion_heap *heap, struct seq_file *s,
 		ION_PRINT_LOG_OR_SEQ(s, "%d order %u lowmem pages in pool = %lu total\n",
 			   pool->low_count, pool->order,
 			   (1 << pool->order) * PAGE_SIZE * pool->low_count);
-
 		pool = sys_heap->cached_pools[i];
 		ION_PRINT_LOG_OR_SEQ(s, "%d order %u highmem pages in cached_pool = %lu total\n",
 			   pool->high_count, pool->order,
diff --git a/drivers/staging/android/uapi/ashmem.h b/drivers/staging/android/uapi/ashmem.h
index ba4743c..13df42d 100644
--- a/drivers/staging/android/uapi/ashmem.h
+++ b/drivers/staging/android/uapi/ashmem.h
@@ -13,6 +13,7 @@
 #define _UAPI_LINUX_ASHMEM_H
 
 #include <linux/ioctl.h>
+#include <linux/types.h>
 
 #define ASHMEM_NAME_LEN		256
 
diff --git a/drivers/staging/comedi/comedi_compat32.c b/drivers/staging/comedi/comedi_compat32.c
index ad208cd..83bcf96 100644
--- a/drivers/staging/comedi/comedi_compat32.c
+++ b/drivers/staging/comedi/comedi_compat32.c
@@ -270,7 +270,7 @@ static int compat_cmd(struct file *file, unsigned long arg)
 {
 	struct comedi_cmd __user *cmd;
 	struct comedi32_cmd_struct __user *cmd32;
-	int rc;
+	int rc, err;
 
 	cmd32 = compat_ptr(arg);
 	cmd = compat_alloc_user_space(sizeof(*cmd));
@@ -279,7 +279,15 @@ static int compat_cmd(struct file *file, unsigned long arg)
 	if (rc)
 		return rc;
 
-	return translated_ioctl(file, COMEDI_CMD, (unsigned long)cmd);
+	rc = translated_ioctl(file, COMEDI_CMD, (unsigned long)cmd);
+	if (rc == -EAGAIN) {
+		/* Special case: copy cmd back to user. */
+		err = put_compat_cmd(cmd32, cmd);
+		if (err)
+			rc = err;
+	}
+
+	return rc;
 }
 
 /* Handle 32-bit COMEDI_CMDTEST ioctl. */
diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index c3e5495..4220a44 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -455,6 +455,29 @@ static const struct comedi_lrange ai_ranges_64xx = {
 	 }
 };
 
+static const uint8_t ai_range_code_64xx[8] = {
+	0x0, 0x1, 0x2, 0x3,	/* bipolar 10, 5, 2,5, 1.25 */
+	0x8, 0x9, 0xa, 0xb	/* unipolar 10, 5, 2.5, 1.25 */
+};
+
+/* analog input ranges for 64-Mx boards */
+static const struct comedi_lrange ai_ranges_64_mx = {
+	7, {
+		BIP_RANGE(5),
+		BIP_RANGE(2.5),
+		BIP_RANGE(1.25),
+		BIP_RANGE(0.625),
+		UNI_RANGE(5),
+		UNI_RANGE(2.5),
+		UNI_RANGE(1.25)
+	}
+};
+
+static const uint8_t ai_range_code_64_mx[7] = {
+	0x0, 0x1, 0x2, 0x3,	/* bipolar 5, 2.5, 1.25, 0.625 */
+	0x9, 0xa, 0xb		/* unipolar 5, 2.5, 1.25 */
+};
+
 /* analog input ranges for 60xx boards */
 static const struct comedi_lrange ai_ranges_60xx = {
 	4,
@@ -466,6 +489,10 @@ static const struct comedi_lrange ai_ranges_60xx = {
 	 }
 };
 
+static const uint8_t ai_range_code_60xx[4] = {
+	0x0, 0x1, 0x4, 0x7	/* bipolar 10, 5, 0.5, 0.05 */
+};
+
 /* analog input ranges for 6030, etc boards */
 static const struct comedi_lrange ai_ranges_6030 = {
 	14,
@@ -487,6 +514,11 @@ static const struct comedi_lrange ai_ranges_6030 = {
 	 }
 };
 
+static const uint8_t ai_range_code_6030[14] = {
+	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, /* bip 10, 5, 2, 1, 0.5, 0.2, 0.1 */
+	0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf  /* uni 10, 5, 2, 1, 0.5, 0.2, 0.1 */
+};
+
 /* analog input ranges for 6052, etc boards */
 static const struct comedi_lrange ai_ranges_6052 = {
 	15,
@@ -509,6 +541,11 @@ static const struct comedi_lrange ai_ranges_6052 = {
 	 }
 };
 
+static const uint8_t ai_range_code_6052[15] = {
+	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,	/* bipolar 10 ... 0.05 */
+	0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf	/* unipolar 10 ... 0.1 */
+};
+
 /* analog input ranges for 4020 board */
 static const struct comedi_lrange ai_ranges_4020 = {
 	2,
@@ -616,6 +653,7 @@ struct pcidas64_board {
 	int ai_bits;		/*  analog input resolution */
 	int ai_speed;		/*  fastest conversion period in ns */
 	const struct comedi_lrange *ai_range_table;
+	const uint8_t *ai_range_code;
 	int ao_nchan;		/*  number of analog out channels */
 	int ao_bits;		/*  analog output resolution */
 	int ao_scan_speed;	/*  analog output scan speed */
@@ -674,6 +712,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_64XX,
 		.ai_range_table	= &ai_ranges_64xx,
+		.ai_range_code	= ai_range_code_64xx,
 		.ao_range_table	= &ao_ranges_64xx,
 		.ao_range_code	= ao_range_code_64xx,
 		.ai_fifo	= &ai_fifo_64xx,
@@ -689,6 +728,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_64XX,
 		.ai_range_table	= &ai_ranges_64xx,
+		.ai_range_code	= ai_range_code_64xx,
 		.ao_range_table	= &ao_ranges_64xx,
 		.ao_range_code	= ao_range_code_64xx,
 		.ai_fifo	= &ai_fifo_64xx,
@@ -703,7 +743,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_bits	= 16,
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_64XX,
-		.ai_range_table	= &ai_ranges_64xx,
+		.ai_range_table	= &ai_ranges_64_mx,
+		.ai_range_code	= ai_range_code_64_mx,
 		.ao_range_table	= &ao_ranges_64xx,
 		.ao_range_code	= ao_range_code_64xx,
 		.ai_fifo	= &ai_fifo_64xx,
@@ -718,7 +759,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_bits	= 16,
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_64XX,
-		.ai_range_table	= &ai_ranges_64xx,
+		.ai_range_table	= &ai_ranges_64_mx,
+		.ai_range_code	= ai_range_code_64_mx,
 		.ao_range_table	= &ao_ranges_64xx,
 		.ao_range_code	= ao_range_code_64xx,
 		.ai_fifo	= &ai_fifo_64xx,
@@ -733,7 +775,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_bits	= 16,
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_64XX,
-		.ai_range_table	= &ai_ranges_64xx,
+		.ai_range_table	= &ai_ranges_64_mx,
+		.ai_range_code	= ai_range_code_64_mx,
 		.ao_range_table	= &ao_ranges_64xx,
 		.ao_range_code	= ao_range_code_64xx,
 		.ai_fifo	= &ai_fifo_64xx,
@@ -748,6 +791,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_bits	= 16,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_60xx,
+		.ai_range_code	= ai_range_code_60xx,
 		.ao_range_table	= &range_bipolar10,
 		.ao_range_code	= ao_range_code_60xx,
 		.ai_fifo	= &ai_fifo_60xx,
@@ -763,6 +807,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 100000,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_60xx,
+		.ai_range_code	= ai_range_code_60xx,
 		.ao_range_table	= &range_bipolar10,
 		.ao_range_code	= ao_range_code_60xx,
 		.ai_fifo	= &ai_fifo_60xx,
@@ -777,6 +822,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 100000,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_60xx,
+		.ai_range_code	= ai_range_code_60xx,
 		.ao_range_table	= &range_bipolar10,
 		.ao_range_code	= ao_range_code_60xx,
 		.ai_fifo	= &ai_fifo_60xx,
@@ -792,6 +838,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 100000,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_60xx,
+		.ai_range_code	= ai_range_code_60xx,
 		.ao_range_table	= &range_bipolar10,
 		.ao_range_code	= ao_range_code_60xx,
 		.ai_fifo	= &ai_fifo_60xx,
@@ -807,6 +854,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_6030,
+		.ai_range_code	= ai_range_code_6030,
 		.ao_range_table	= &ao_ranges_6030,
 		.ao_range_code	= ao_range_code_6030,
 		.ai_fifo	= &ai_fifo_60xx,
@@ -822,6 +870,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_6030,
+		.ai_range_code	= ai_range_code_6030,
 		.ao_range_table	= &ao_ranges_6030,
 		.ao_range_code	= ao_range_code_6030,
 		.ai_fifo	= &ai_fifo_60xx,
@@ -835,6 +884,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_nchan	= 0,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_6030,
+		.ai_range_code	= ai_range_code_6030,
 		.ai_fifo	= &ai_fifo_60xx,
 		.has_8255	= 0,
 	},
@@ -846,6 +896,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_nchan	= 0,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_6030,
+		.ai_range_code	= ai_range_code_6030,
 		.ai_fifo	= &ai_fifo_60xx,
 		.has_8255	= 0,
 	},
@@ -858,6 +909,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 0,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_60xx,
+		.ai_range_code	= ai_range_code_60xx,
 		.ai_fifo	= &ai_fifo_60xx,
 		.has_8255	= 0,
 	},
@@ -871,6 +923,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 100000,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_60xx,
+		.ai_range_code	= ai_range_code_60xx,
 		.ao_range_table	= &range_bipolar10,
 		.ao_range_code	= ao_range_code_60xx,
 		.ai_fifo	= &ai_fifo_60xx,
@@ -886,6 +939,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 100000,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_60xx,
+		.ai_range_code	= ai_range_code_60xx,
 		.ao_range_table	= &range_bipolar10,
 		.ao_range_code	= ao_range_code_60xx,
 		.ai_fifo	= &ai_fifo_60xx,
@@ -901,6 +955,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 1000,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_6052,
+		.ai_range_code	= ai_range_code_6052,
 		.ao_range_table	= &ao_ranges_6030,
 		.ao_range_code	= ao_range_code_6030,
 		.ai_fifo	= &ai_fifo_60xx,
@@ -916,6 +971,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 3333,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_6052,
+		.ai_range_code	= ai_range_code_6052,
 		.ao_range_table	= &ao_ranges_6030,
 		.ao_range_code	= ao_range_code_6030,
 		.ai_fifo	= &ai_fifo_60xx,
@@ -931,6 +987,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 1000,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_6052,
+		.ai_range_code	= ai_range_code_6052,
 		.ao_range_table	= &ao_ranges_6030,
 		.ao_range_code	= ao_range_code_6030,
 		.ai_fifo	= &ai_fifo_60xx,
@@ -946,6 +1003,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 1000,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_6052,
+		.ai_range_code	= ai_range_code_6052,
 		.ao_range_table	= &ao_ranges_6030,
 		.ao_range_code	= ao_range_code_6030,
 		.ai_fifo	= &ai_fifo_60xx,
@@ -980,6 +1038,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_64XX,
 		.ai_range_table	= &ai_ranges_64xx,
+		.ai_range_code	= ai_range_code_64xx,
 		.ai_fifo	= ai_fifo_64xx,
 		.has_8255	= 1,
 	},
@@ -991,7 +1050,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_nchan	= 0,
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_64XX,
-		.ai_range_table	= &ai_ranges_64xx,
+		.ai_range_table	= &ai_ranges_64_mx,
+		.ai_range_code	= ai_range_code_64_mx,
 		.ai_fifo	= ai_fifo_64xx,
 		.has_8255	= 1,
 	},
@@ -1003,7 +1063,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_nchan	= 0,
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_64XX,
-		.ai_range_table	= &ai_ranges_64xx,
+		.ai_range_table	= &ai_ranges_64_mx,
+		.ai_range_code	= ai_range_code_64_mx,
 		.ai_fifo	= ai_fifo_64xx,
 		.has_8255	= 1,
 	},
@@ -1015,7 +1076,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_nchan	= 0,
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_64XX,
-		.ai_range_table	= &ai_ranges_64xx,
+		.ai_range_table	= &ai_ranges_64_mx,
+		.ai_range_code	= ai_range_code_64_mx,
 		.ai_fifo	= ai_fifo_64xx,
 		.has_8255	= 1,
 	},
@@ -1027,7 +1089,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_nchan	= 2,
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_64XX,
-		.ai_range_table	= &ai_ranges_64xx,
+		.ai_range_table	= &ai_ranges_64_mx,
+		.ai_range_code	= ai_range_code_64_mx,
 		.ai_fifo	= ai_fifo_64xx,
 		.has_8255	= 1,
 	},
@@ -1039,7 +1102,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_nchan	= 2,
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_64XX,
-		.ai_range_table	= &ai_ranges_64xx,
+		.ai_range_table	= &ai_ranges_64_mx,
+		.ai_range_code	= ai_range_code_64_mx,
 		.ai_fifo	= ai_fifo_64xx,
 		.has_8255	= 1,
 	},
@@ -1051,7 +1115,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_nchan	= 2,
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_64XX,
-		.ai_range_table	= &ai_ranges_64xx,
+		.ai_range_table	= &ai_ranges_64_mx,
+		.ai_range_code	= ai_range_code_64_mx,
 		.ai_fifo	= ai_fifo_64xx,
 		.has_8255	= 1,
 	},
@@ -1148,45 +1213,8 @@ static unsigned int ai_range_bits_6xxx(const struct comedi_device *dev,
 				       unsigned int range_index)
 {
 	const struct pcidas64_board *thisboard = comedi_board(dev);
-	const struct comedi_krange *range =
-		&thisboard->ai_range_table->range[range_index];
-	unsigned int bits = 0;
 
-	switch (range->max) {
-	case 10000000:
-		bits = 0x000;
-		break;
-	case 5000000:
-		bits = 0x100;
-		break;
-	case 2000000:
-	case 2500000:
-		bits = 0x200;
-		break;
-	case 1000000:
-	case 1250000:
-		bits = 0x300;
-		break;
-	case 500000:
-		bits = 0x400;
-		break;
-	case 200000:
-	case 250000:
-		bits = 0x500;
-		break;
-	case 100000:
-		bits = 0x600;
-		break;
-	case 50000:
-		bits = 0x700;
-		break;
-	default:
-		comedi_error(dev, "bug! in ai_range_bits_6xxx");
-		break;
-	}
-	if (range->min == 0)
-		bits += 0x900;
-	return bits;
+	return thisboard->ai_range_code[range_index] << 8;
 }
 
 static unsigned int hw_revision(const struct comedi_device *dev,
diff --git a/drivers/staging/zram/zram_drv.c b/drivers/staging/zram/zram_drv.c
index 081e9dc..a7ba434 100644
--- a/drivers/staging/zram/zram_drv.c
+++ b/drivers/staging/zram/zram_drv.c
@@ -307,7 +307,7 @@ static int remove_node_from_zram_list(struct zram *zram,struct zram_meta *meta,u
                                 {
 					u32 tmp_index = 0;
 	                                printk("[ZRAM]ERROR !!can't find2 meta->table[%d].size %d chunksum %d in list\n",index,meta->table[index].size,meta->table[index].checksum);
-					tmp_index = meta->table[current_index].copy_count;
+					tmp_index = meta->table[current_index].copy_index;
 					if(i > meta->table[tmp_index].copy_count)
                                         {
                                                 BUG_ON(1);
diff --git a/drivers/target/iscsi/iscsi_target_login.c b/drivers/target/iscsi/iscsi_target_login.c
index e14e105..0493e8b 100644
--- a/drivers/target/iscsi/iscsi_target_login.c
+++ b/drivers/target/iscsi/iscsi_target_login.c
@@ -1360,6 +1360,9 @@ old_sess_out:
 		conn->sock = NULL;
 	}
 
+	if (conn->conn_transport->iscsit_wait_conn)
+		conn->conn_transport->iscsit_wait_conn(conn);
+
 	if (conn->conn_transport->iscsit_free_conn)
 		conn->conn_transport->iscsit_free_conn(conn);
 
diff --git a/drivers/target/iscsi/iscsi_target_tq.c b/drivers/target/iscsi/iscsi_target_tq.c
index 8128952..bd53364 100644
--- a/drivers/target/iscsi/iscsi_target_tq.c
+++ b/drivers/target/iscsi/iscsi_target_tq.c
@@ -26,36 +26,22 @@
 #include "iscsi_target_tq.h"
 #include "iscsi_target.h"
 
-static LIST_HEAD(active_ts_list);
 static LIST_HEAD(inactive_ts_list);
-static DEFINE_SPINLOCK(active_ts_lock);
 static DEFINE_SPINLOCK(inactive_ts_lock);
 static DEFINE_SPINLOCK(ts_bitmap_lock);
 
-static void iscsi_add_ts_to_active_list(struct iscsi_thread_set *ts)
-{
-	spin_lock(&active_ts_lock);
-	list_add_tail(&ts->ts_list, &active_ts_list);
-	iscsit_global->active_ts++;
-	spin_unlock(&active_ts_lock);
-}
-
 static void iscsi_add_ts_to_inactive_list(struct iscsi_thread_set *ts)
 {
+	if (!list_empty(&ts->ts_list)) {
+		WARN_ON(1);
+		return;
+	}
 	spin_lock(&inactive_ts_lock);
 	list_add_tail(&ts->ts_list, &inactive_ts_list);
 	iscsit_global->inactive_ts++;
 	spin_unlock(&inactive_ts_lock);
 }
 
-static void iscsi_del_ts_from_active_list(struct iscsi_thread_set *ts)
-{
-	spin_lock(&active_ts_lock);
-	list_del(&ts->ts_list);
-	iscsit_global->active_ts--;
-	spin_unlock(&active_ts_lock);
-}
-
 static struct iscsi_thread_set *iscsi_get_ts_from_inactive_list(void)
 {
 	struct iscsi_thread_set *ts;
@@ -68,7 +54,7 @@ static struct iscsi_thread_set *iscsi_get_ts_from_inactive_list(void)
 
 	ts = list_first_entry(&inactive_ts_list, struct iscsi_thread_set, ts_list);
 
-	list_del(&ts->ts_list);
+	list_del_init(&ts->ts_list);
 	iscsit_global->inactive_ts--;
 	spin_unlock(&inactive_ts_lock);
 
@@ -219,8 +205,6 @@ static void iscsi_deallocate_extra_thread_sets(void)
 
 void iscsi_activate_thread_set(struct iscsi_conn *conn, struct iscsi_thread_set *ts)
 {
-	iscsi_add_ts_to_active_list(ts);
-
 	spin_lock_bh(&ts->ts_state_lock);
 	conn->thread_set = ts;
 	ts->conn = conn;
@@ -423,7 +407,6 @@ struct iscsi_conn *iscsi_rx_thread_pre_handler(struct iscsi_thread_set *ts)
 
 	if (ts->delay_inactive && (--ts->thread_count == 0)) {
 		spin_unlock_bh(&ts->ts_state_lock);
-		iscsi_del_ts_from_active_list(ts);
 
 		if (!iscsit_global->in_shutdown)
 			iscsi_deallocate_extra_thread_sets();
@@ -476,7 +459,6 @@ struct iscsi_conn *iscsi_tx_thread_pre_handler(struct iscsi_thread_set *ts)
 
 	if (ts->delay_inactive && (--ts->thread_count == 0)) {
 		spin_unlock_bh(&ts->ts_state_lock);
-		iscsi_del_ts_from_active_list(ts);
 
 		if (!iscsit_global->in_shutdown)
 			iscsi_deallocate_extra_thread_sets();
diff --git a/drivers/target/iscsi/iscsi_target_util.c b/drivers/target/iscsi/iscsi_target_util.c
index c9790f6..016e882 100644
--- a/drivers/target/iscsi/iscsi_target_util.c
+++ b/drivers/target/iscsi/iscsi_target_util.c
@@ -1349,15 +1349,15 @@ static int iscsit_do_tx_data(
 	struct iscsi_conn *conn,
 	struct iscsi_data_count *count)
 {
-	int data = count->data_length, total_tx = 0, tx_loop = 0, iov_len;
+	int ret, iov_len;
 	struct kvec *iov_p;
 	struct msghdr msg;
 
 	if (!conn || !conn->sock || !conn->conn_ops)
 		return -1;
 
-	if (data <= 0) {
-		pr_err("Data length is: %d\n", data);
+	if (count->data_length <= 0) {
+		pr_err("Data length is: %d\n", count->data_length);
 		return -1;
 	}
 
@@ -1366,20 +1366,16 @@ static int iscsit_do_tx_data(
 	iov_p = count->iov;
 	iov_len = count->iov_count;
 
-	while (total_tx < data) {
-		tx_loop = kernel_sendmsg(conn->sock, &msg, iov_p, iov_len,
-					(data - total_tx));
-		if (tx_loop <= 0) {
-			pr_debug("tx_loop: %d total_tx %d\n",
-				tx_loop, total_tx);
-			return tx_loop;
-		}
-		total_tx += tx_loop;
-		pr_debug("tx_loop: %d, total_tx: %d, data: %d\n",
-					tx_loop, total_tx, data);
+	ret = kernel_sendmsg(conn->sock, &msg, iov_p, iov_len,
+			     count->data_length);
+	if (ret != count->data_length) {
+		pr_err("Unexpected ret: %d send data %d\n",
+		       ret, count->data_length);
+		return -EPIPE;
 	}
+	pr_debug("ret: %d, sent data: %d\n", ret, count->data_length);
 
-	return total_tx;
+	return ret;
 }
 
 int rx_data(
diff --git a/drivers/target/loopback/tcm_loop.c b/drivers/target/loopback/tcm_loop.c
index 7c90814..9c02eb4 100644
--- a/drivers/target/loopback/tcm_loop.c
+++ b/drivers/target/loopback/tcm_loop.c
@@ -179,7 +179,7 @@ static void tcm_loop_submission_work(struct work_struct *work)
 		goto out_done;
 	}
 
-	tl_nexus = tl_hba->tl_nexus;
+	tl_nexus = tl_tpg->tl_nexus;
 	if (!tl_nexus) {
 		scmd_printk(KERN_ERR, sc, "TCM_Loop I_T Nexus"
 				" does not exist\n");
@@ -258,20 +258,20 @@ static int tcm_loop_device_reset(struct scsi_cmnd *sc)
 	 */
 	tl_hba = *(struct tcm_loop_hba **)shost_priv(sc->device->host);
 	/*
+	 * Locate the tl_tpg and se_tpg pointers from TargetID in sc->device->id
+	 */
+	tl_tpg = &tl_hba->tl_hba_tpgs[sc->device->id];
+	se_tpg = &tl_tpg->tl_se_tpg;
+	/*
 	 * Locate the tl_nexus and se_sess pointers
 	 */
-	tl_nexus = tl_hba->tl_nexus;
+	tl_nexus = tl_tpg->tl_nexus;
 	if (!tl_nexus) {
 		pr_err("Unable to perform device reset without"
 				" active I_T Nexus\n");
 		return FAILED;
 	}
 	se_sess = tl_nexus->se_sess;
-	/*
-	 * Locate the tl_tpg and se_tpg pointers from TargetID in sc->device->id
-	 */
-	tl_tpg = &tl_hba->tl_hba_tpgs[sc->device->id];
-	se_tpg = &tl_tpg->tl_se_tpg;
 
 	tl_cmd = kmem_cache_zalloc(tcm_loop_cmd_cache, GFP_KERNEL);
 	if (!tl_cmd) {
@@ -879,8 +879,8 @@ static int tcm_loop_make_nexus(
 	struct tcm_loop_nexus *tl_nexus;
 	int ret = -ENOMEM;
 
-	if (tl_tpg->tl_hba->tl_nexus) {
-		pr_debug("tl_tpg->tl_hba->tl_nexus already exists\n");
+	if (tl_tpg->tl_nexus) {
+		pr_debug("tl_tpg->tl_nexus already exists\n");
 		return -EEXIST;
 	}
 	se_tpg = &tl_tpg->tl_se_tpg;
@@ -915,7 +915,7 @@ static int tcm_loop_make_nexus(
 	 */
 	__transport_register_session(se_tpg, tl_nexus->se_sess->se_node_acl,
 			tl_nexus->se_sess, tl_nexus);
-	tl_tpg->tl_hba->tl_nexus = tl_nexus;
+	tl_tpg->tl_nexus = tl_nexus;
 	pr_debug("TCM_Loop_ConfigFS: Established I_T Nexus to emulated"
 		" %s Initiator Port: %s\n", tcm_loop_dump_proto_id(tl_hba),
 		name);
@@ -931,9 +931,8 @@ static int tcm_loop_drop_nexus(
 {
 	struct se_session *se_sess;
 	struct tcm_loop_nexus *tl_nexus;
-	struct tcm_loop_hba *tl_hba = tpg->tl_hba;
 
-	tl_nexus = tpg->tl_hba->tl_nexus;
+	tl_nexus = tpg->tl_nexus;
 	if (!tl_nexus)
 		return -ENODEV;
 
@@ -949,13 +948,13 @@ static int tcm_loop_drop_nexus(
 	}
 
 	pr_debug("TCM_Loop_ConfigFS: Removing I_T Nexus to emulated"
-		" %s Initiator Port: %s\n", tcm_loop_dump_proto_id(tl_hba),
+		" %s Initiator Port: %s\n", tcm_loop_dump_proto_id(tpg->tl_hba),
 		tl_nexus->se_sess->se_node_acl->initiatorname);
 	/*
 	 * Release the SCSI I_T Nexus to the emulated SAS Target Port
 	 */
 	transport_deregister_session(tl_nexus->se_sess);
-	tpg->tl_hba->tl_nexus = NULL;
+	tpg->tl_nexus = NULL;
 	kfree(tl_nexus);
 	return 0;
 }
@@ -971,7 +970,7 @@ static ssize_t tcm_loop_tpg_show_nexus(
 	struct tcm_loop_nexus *tl_nexus;
 	ssize_t ret;
 
-	tl_nexus = tl_tpg->tl_hba->tl_nexus;
+	tl_nexus = tl_tpg->tl_nexus;
 	if (!tl_nexus)
 		return -ENODEV;
 
diff --git a/drivers/target/loopback/tcm_loop.h b/drivers/target/loopback/tcm_loop.h
index dd7a84e..4ed8588 100644
--- a/drivers/target/loopback/tcm_loop.h
+++ b/drivers/target/loopback/tcm_loop.h
@@ -25,11 +25,6 @@ struct tcm_loop_tmr {
 };
 
 struct tcm_loop_nexus {
-	int it_nexus_active;
-	/*
-	 * Pointer to Linux/SCSI HBA from linux/include/scsi_host.h
-	 */
-	struct scsi_host *sh;
 	/*
 	 * Pointer to TCM session for I_T Nexus
 	 */
@@ -45,6 +40,7 @@ struct tcm_loop_tpg {
 	atomic_t tl_tpg_port_count;
 	struct se_portal_group tl_se_tpg;
 	struct tcm_loop_hba *tl_hba;
+	struct tcm_loop_nexus *tl_nexus;
 };
 
 struct tcm_loop_hba {
@@ -53,7 +49,6 @@ struct tcm_loop_hba {
 	struct se_hba_s *se_hba;
 	struct se_lun *tl_hba_lun;
 	struct se_port *tl_hba_lun_sep;
-	struct tcm_loop_nexus *tl_nexus;
 	struct device dev;
 	struct Scsi_Host *sh;
 	struct tcm_loop_tpg tl_hba_tpgs[TL_TPGS_PER_HBA];
diff --git a/drivers/target/target_core_device.c b/drivers/target/target_core_device.c
index 2be407e..4deb0c9 100644
--- a/drivers/target/target_core_device.c
+++ b/drivers/target/target_core_device.c
@@ -1037,10 +1037,10 @@ int se_dev_set_optimal_sectors(struct se_device *dev, u32 optimal_sectors)
 				" changed for TCM/pSCSI\n", dev);
 		return -EINVAL;
 	}
-	if (optimal_sectors > dev->dev_attrib.fabric_max_sectors) {
+	if (optimal_sectors > dev->dev_attrib.hw_max_sectors) {
 		pr_err("dev[%p]: Passed optimal_sectors %u cannot be"
-			" greater than fabric_max_sectors: %u\n", dev,
-			optimal_sectors, dev->dev_attrib.fabric_max_sectors);
+			" greater than hw_max_sectors: %u\n", dev,
+			optimal_sectors, dev->dev_attrib.hw_max_sectors);
 		return -EINVAL;
 	}
 
@@ -1442,7 +1442,6 @@ struct se_device *target_alloc_device(struct se_hba *hba, const char *name)
 				DA_UNMAP_GRANULARITY_ALIGNMENT_DEFAULT;
 	dev->dev_attrib.max_write_same_len = DA_MAX_WRITE_SAME_LEN;
 	dev->dev_attrib.fabric_max_sectors = DA_FABRIC_MAX_SECTORS;
-	dev->dev_attrib.optimal_sectors = DA_FABRIC_MAX_SECTORS;
 
 	return dev;
 }
@@ -1475,6 +1474,7 @@ int target_configure_device(struct se_device *dev)
 	dev->dev_attrib.hw_max_sectors =
 		se_dev_align_max_sectors(dev->dev_attrib.hw_max_sectors,
 					 dev->dev_attrib.hw_block_size);
+	dev->dev_attrib.optimal_sectors = dev->dev_attrib.hw_max_sectors;
 
 	dev->dev_index = scsi_get_new_index(SCSI_DEVICE_INDEX);
 	dev->creation_time = get_jiffies_64();
diff --git a/drivers/target/target_core_file.c b/drivers/target/target_core_file.c
index 3b28793..8baaa0a 100644
--- a/drivers/target/target_core_file.c
+++ b/drivers/target/target_core_file.c
@@ -554,7 +554,16 @@ fd_execute_rw(struct se_cmd *cmd)
 	enum dma_data_direction data_direction = cmd->data_direction;
 	struct se_device *dev = cmd->se_dev;
 	int ret = 0;
-
+	/*
+	 * We are currently limited by the number of iovecs (2048) per
+	 * single vfs_[writev,readv] call.
+	 */
+	if (cmd->data_length > FD_MAX_BYTES) {
+		pr_err("FILEIO: Not able to process I/O of %u bytes due to"
+		       "FD_MAX_BYTES: %u iovec count limitiation\n",
+			cmd->data_length, FD_MAX_BYTES);
+		return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
+	}
 	/*
 	 * Call vectorized fileio functions to map struct scatterlist
 	 * physical memory addresses to struct iovec virtual memory.
diff --git a/drivers/target/target_core_iblock.c b/drivers/target/target_core_iblock.c
index aa1620a..b358b3d 100644
--- a/drivers/target/target_core_iblock.c
+++ b/drivers/target/target_core_iblock.c
@@ -122,7 +122,7 @@ static int iblock_configure_device(struct se_device *dev)
 	q = bdev_get_queue(bd);
 
 	dev->dev_attrib.hw_block_size = bdev_logical_block_size(bd);
-	dev->dev_attrib.hw_max_sectors = UINT_MAX;
+	dev->dev_attrib.hw_max_sectors = queue_max_hw_sectors(q);
 	dev->dev_attrib.hw_queue_depth = q->nr_requests;
 
 	/*
diff --git a/drivers/target/target_core_sbc.c b/drivers/target/target_core_sbc.c
index 0ef75fb..70b0d26 100644
--- a/drivers/target/target_core_sbc.c
+++ b/drivers/target/target_core_sbc.c
@@ -561,23 +561,9 @@ sbc_parse_cdb(struct se_cmd *cmd, struct sbc_ops *ops)
 	if (cmd->se_cmd_flags & SCF_SCSI_DATA_CDB) {
 		unsigned long long end_lba;
 
-		if (sectors > dev->dev_attrib.fabric_max_sectors) {
-			printk_ratelimited(KERN_ERR "SCSI OP %02xh with too"
-				" big sectors %u exceeds fabric_max_sectors:"
-				" %u\n", cdb[0], sectors,
-				dev->dev_attrib.fabric_max_sectors);
-			return TCM_INVALID_CDB_FIELD;
-		}
-		if (sectors > dev->dev_attrib.hw_max_sectors) {
-			printk_ratelimited(KERN_ERR "SCSI OP %02xh with too"
-				" big sectors %u exceeds backend hw_max_sectors:"
-				" %u\n", cdb[0], sectors,
-				dev->dev_attrib.hw_max_sectors);
-			return TCM_INVALID_CDB_FIELD;
-		}
-
 		end_lba = dev->transport->get_blocks(dev) + 1;
-		if (cmd->t_task_lba + sectors > end_lba) {
+		if (((cmd->t_task_lba + sectors) < cmd->t_task_lba) ||
+		    ((cmd->t_task_lba + sectors) > end_lba)) {
 			pr_err("cmd exceeds last lba %llu "
 				"(lba %llu, sectors %u)\n",
 				end_lba, cmd->t_task_lba, sectors);
diff --git a/drivers/target/target_core_spc.c b/drivers/target/target_core_spc.c
index 34254b2..9998ae2 100644
--- a/drivers/target/target_core_spc.c
+++ b/drivers/target/target_core_spc.c
@@ -444,7 +444,6 @@ static sense_reason_t
 spc_emulate_evpd_b0(struct se_cmd *cmd, unsigned char *buf)
 {
 	struct se_device *dev = cmd->se_dev;
-	u32 max_sectors;
 	int have_tp = 0;
 
 	/*
@@ -469,9 +468,7 @@ spc_emulate_evpd_b0(struct se_cmd *cmd, unsigned char *buf)
 	/*
 	 * Set MAXIMUM TRANSFER LENGTH
 	 */
-	max_sectors = min(dev->dev_attrib.fabric_max_sectors,
-			  dev->dev_attrib.hw_max_sectors);
-	put_unaligned_be32(max_sectors, &buf[8]);
+	put_unaligned_be32(dev->dev_attrib.hw_max_sectors, &buf[8]);
 
 	/*
 	 * Set OPTIMAL TRANSFER LENGTH
diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 8c1b878..bdfe8ec 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -214,6 +214,9 @@ static int pty_signal(struct tty_struct *tty, int sig)
 	unsigned long flags;
 	struct pid *pgrp;
 
+	if (sig != SIGINT && sig != SIGQUIT && sig != SIGTSTP)
+		return -EINVAL;
+
 	if (tty->link) {
 		spin_lock_irqsave(&tty->link->ctrl_lock, flags);
 		pgrp = get_pid(tty->link->pgrp);
diff --git a/drivers/tty/tty_io.c b/drivers/tty/tty_io.c
index 28b667f..a7d0396 100644
--- a/drivers/tty/tty_io.c
+++ b/drivers/tty/tty_io.c
@@ -992,8 +992,8 @@ EXPORT_SYMBOL(start_tty);
 /* We limit tty time update visibility to every 8 seconds or so. */
 static void tty_update_time(struct timespec *time)
 {
-	unsigned long sec = get_seconds() & ~7;
-	if ((long)(sec - time->tv_sec) > 0)
+	unsigned long sec = get_seconds();
+	if (abs(sec - time->tv_sec) & ~7)
 		time->tv_sec = sec;
 }
 
diff --git a/drivers/tty/tty_ioctl.c b/drivers/tty/tty_ioctl.c
index 088b4ca..b46aca5 100644
--- a/drivers/tty/tty_ioctl.c
+++ b/drivers/tty/tty_ioctl.c
@@ -217,11 +217,17 @@ void tty_wait_until_sent(struct tty_struct *tty, long timeout)
 #endif
 	if (!timeout)
 		timeout = MAX_SCHEDULE_TIMEOUT;
+
 	if (wait_event_interruptible_timeout(tty->write_wait,
-			!tty_chars_in_buffer(tty), timeout) >= 0) {
-		if (tty->ops->wait_until_sent)
-			tty->ops->wait_until_sent(tty, timeout);
+			!tty_chars_in_buffer(tty), timeout) < 0) {
+		return;
 	}
+
+	if (timeout == MAX_SCHEDULE_TIMEOUT)
+		timeout = 0;
+
+	if (tty->ops->wait_until_sent)
+		tty->ops->wait_until_sent(tty, timeout);
 }
 EXPORT_SYMBOL(tty_wait_until_sent);
 
diff --git a/drivers/tty/vt/vt.c b/drivers/tty/vt/vt.c
index 0d1b375..db9d69f 100644
--- a/drivers/tty/vt/vt.c
+++ b/drivers/tty/vt/vt.c
@@ -498,6 +498,7 @@ void invert_screen(struct vc_data *vc, int offset, int count, int viewed)
 #endif
 	if (DO_UPDATE(vc))
 		do_update_region(vc, (unsigned long) p, count);
+	notify_update(vc);
 }
 
 /* used by selection: complement pointer position */
@@ -514,6 +515,7 @@ void complement_pos(struct vc_data *vc, int offset)
 		scr_writew(old, screenpos(vc, old_offset, 1));
 		if (DO_UPDATE(vc))
 			vc->vc_sw->con_putc(vc, old, oldy, oldx);
+		notify_update(vc);
 	}
 
 	old_offset = offset;
@@ -531,8 +533,8 @@ void complement_pos(struct vc_data *vc, int offset)
 			oldy = (offset >> 1) / vc->vc_cols;
 			vc->vc_sw->con_putc(vc, new, oldy, oldx);
 		}
+		notify_update(vc);
 	}
-
 }
 
 static void insert_char(struct vc_data *vc, unsigned int nr)
diff --git a/drivers/usb/core/buffer.c b/drivers/usb/core/buffer.c
index b0585e6..19fa68a 100644
--- a/drivers/usb/core/buffer.c
+++ b/drivers/usb/core/buffer.c
@@ -22,17 +22,25 @@
  */
 
 /* FIXME tune these based on pool statistics ... */
-static const size_t	pool_max[HCD_BUFFER_POOLS] = {
-	/* platforms without dma-friendly caches might need to
-	 * prevent cacheline sharing...
-	 */
-	32,
-	128,
-	512,
-	PAGE_SIZE / 2
-	/* bigger --> allocate pages */
+static size_t pool_max[HCD_BUFFER_POOLS] = {
+	32, 128, 512, 2048,
 };
 
+void __init usb_init_pool_max(void)
+{
+	/*
+	 * The pool_max values must never be smaller than
+	 * ARCH_KMALLOC_MINALIGN.
+	 */
+	if (ARCH_KMALLOC_MINALIGN <= 32)
+		;			/* Original value is okay */
+	else if (ARCH_KMALLOC_MINALIGN <= 64)
+		pool_max[0] = 64;
+	else if (ARCH_KMALLOC_MINALIGN <= 128)
+		pool_max[0] = 0;	/* Don't use this pool */
+	else
+		BUILD_BUG();		/* We don't allow this */
+}
 
 /* SETUP primitives */
 
diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 39901ac..6563b5e 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -501,6 +501,7 @@ static void async_completed(struct urb *urb)
 	as->status = urb->status;
 	signr = as->signr;
 	if (signr) {
+		memset(&sinfo, 0, sizeof(sinfo));
 		sinfo.si_signo = as->signr;
 		sinfo.si_errno = as->status;
 		sinfo.si_code = SI_ASYNCIO;
@@ -2232,6 +2233,7 @@ static void usbdev_remove(struct usb_device *udev)
 		wake_up_all(&ps->wait);
 		list_del_init(&ps->list);
 		if (ps->discsignr) {
+			memset(&sinfo, 0, sizeof(sinfo));
 			sinfo.si_signo = ps->discsignr;
 			sinfo.si_errno = EPIPE;
 			sinfo.si_code = SI_ASYNCIO;
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 486dfc0..2ef8561 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1602,6 +1602,7 @@ static int unlink1(struct usb_hcd *hcd, struct urb *urb, int status)
 int usb_hcd_unlink_urb (struct urb *urb, int status)
 {
 	struct usb_hcd		*hcd;
+	struct usb_device	*udev = urb->dev;
 	int			retval = -EIDRM;
 	unsigned long		flags;
 
@@ -1613,20 +1614,19 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
 	spin_lock_irqsave(&hcd_urb_unlink_lock, flags);
 	if (atomic_read(&urb->use_count) > 0) {
 		retval = 0;
-		usb_get_dev(urb->dev);
+		usb_get_dev(udev);
 	}
 	spin_unlock_irqrestore(&hcd_urb_unlink_lock, flags);
 	if (retval == 0) {
 		hcd = bus_to_hcd(urb->dev->bus);
 		retval = unlink1(hcd, urb, status);
-		usb_put_dev(urb->dev);
+		if (retval == 0)
+			retval = -EINPROGRESS;
+		else if (retval != -EIDRM && retval != -EBUSY)
+			dev_dbg(&udev->dev, "hcd_unlink_urb %p fail %d\n",
+					urb, retval);
+		usb_put_dev(udev);
 	}
-
-	if (retval == 0)
-		retval = -EINPROGRESS;
-	else if (retval != -EIDRM && retval != -EBUSY)
-		dev_dbg(&urb->dev->dev, "hcd_unlink_urb %p fail %d\n",
-				urb, retval);
 	return retval;
 }
 
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index f7e4978..bd9b6d4 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -1005,6 +1005,7 @@ static int __init usb_init(void)
 		pr_info("%s: USB support disabled\n", usbcore_name);
 		return 0;
 	}
+	usb_init_pool_max();
 
 	retval = usb_debugfs_init();
 	if (retval)
diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c
index 8f8e75e..87f8fc6 100644
--- a/drivers/usb/dwc3/gadget.c
+++ b/drivers/usb/dwc3/gadget.c
@@ -907,8 +907,7 @@ static void dwc3_prepare_trbs(struct dwc3_ep *dep, bool starting)
 
 				if (i == (request->num_mapped_sgs - 1) ||
 						sg_is_last(s)) {
-					if (list_is_last(&req->list,
-							&dep->request_list))
+					if (list_empty(&dep->request_list))
 						last_one = true;
 					chain = false;
 				}
@@ -926,6 +925,9 @@ static void dwc3_prepare_trbs(struct dwc3_ep *dep, bool starting)
 				if (last_one)
 					break;
 			}
+
+			if (last_one)
+				break;
 		} else {
 			dma = req->request.dma;
 			length = req->request.length;
diff --git a/drivers/usb/gadget/android.c b/drivers/usb/gadget/android.c
index 6afe927..87d9a4e 100644
--- a/drivers/usb/gadget/android.c
+++ b/drivers/usb/gadget/android.c
@@ -41,6 +41,7 @@
 
 #include "f_fs.c"
 #include "f_audio_source.c"
+#include "f_midi.c"
 #include "f_mass_storage.c"
 #include "f_adb.c"
 #include "f_mtp.c"
@@ -70,6 +71,21 @@ static const char longname[] = "Gadget Android";
 #define VENDOR_ID		0x0BB4
 #define PRODUCT_ID		0x0001
 
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+#include <mach/mt_boot_common.h>
+#define KPOC_USB_FUNC "mtp"
+#define KPOC_USB_VENDOR_ID 0x0E8D
+#define KPOC_USB_PRODUCT_ID 0x2008
+extern BOOTMODE g_boot_mode;
+#endif
+
+
+/* f_midi configuration */
+#define MIDI_INPUT_PORTS    1
+#define MIDI_OUTPUT_PORTS   1
+#define MIDI_BUFFER_SIZE    256
+#define MIDI_QUEUE_LENGTH   32
+
 /* Default manufacturer and product string , overridden by userspace */
 #define MANUFACTURER_STRING "MediaTek"
 #define PRODUCT_STRING "MT65xx Android Phone"
@@ -116,6 +132,9 @@ struct android_dev {
 	struct usb_composite_dev *cdev;
 	struct device *dev;
 
+	void (*setup_complete)(struct usb_ep *ep,
+				struct usb_request *req);
+
 	bool enabled;
 	int disable_depth;
 	struct mutex mutex;
@@ -1806,6 +1825,60 @@ static struct android_usb_function audio_source_function = {
 	.attributes	= audio_source_function_attributes,
 };
 
+static int midi_function_init(struct android_usb_function *f,
+					struct usb_composite_dev *cdev)
+{
+	struct midi_alsa_config *config;
+
+	config = kzalloc(sizeof(struct midi_alsa_config), GFP_KERNEL);
+	f->config = config;
+	if (!config)
+		return -ENOMEM;
+	config->card = -1;
+	config->device = -1;
+	return 0;
+}
+
+static void midi_function_cleanup(struct android_usb_function *f)
+{
+	kfree(f->config);
+}
+
+static int midi_function_bind_config(struct android_usb_function *f,
+						struct usb_configuration *c)
+{
+	struct midi_alsa_config *config = f->config;
+
+	return f_midi_bind_config(c, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,
+			MIDI_INPUT_PORTS, MIDI_OUTPUT_PORTS, MIDI_BUFFER_SIZE,
+			MIDI_QUEUE_LENGTH, config);
+}
+
+static ssize_t midi_alsa_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct midi_alsa_config *config = f->config;
+
+	/* print ALSA card and device numbers */
+	return sprintf(buf, "%d %d\n", config->card, config->device);
+}
+
+static DEVICE_ATTR(alsa, S_IRUGO, midi_alsa_show, NULL);
+
+static struct device_attribute *midi_function_attributes[] = {
+	&dev_attr_alsa,
+	NULL
+};
+
+static struct android_usb_function midi_function = {
+	.name		= "midi",
+	.init		= midi_function_init,
+	.cleanup	= midi_function_cleanup,
+	.bind_config	= midi_function_bind_config,
+	.attributes	= midi_function_attributes,
+};
+
 static struct android_usb_function *supported_functions[] = {
 	&ffs_function,
 	&adb_function,
@@ -1821,6 +1894,7 @@ static struct android_usb_function *supported_functions[] = {
 	&mass_storage_function,
 	&accessory_function,
 	&audio_source_function,
+	&midi_function,
 #ifdef CONFIG_MTK_C2K_SUPPORT
 	&rawbulk_modem_function,
 	&rawbulk_ets_function,
@@ -1834,7 +1908,6 @@ static struct android_usb_function *supported_functions[] = {
 	NULL
 };
 
-
 static int android_init_functions(struct android_usb_function **functions,
 				  struct usb_composite_dev *cdev)
 {
@@ -2012,6 +2085,19 @@ functions_store(struct device *pdev, struct device_attribute *attr,
 
 	INIT_LIST_HEAD(&dev->enabled_functions);
 
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+	if(g_boot_mode == KERNEL_POWER_OFF_CHARGING_BOOT || g_boot_mode == LOW_POWER_OFF_CHARGING_BOOT){
+		pr_notice("[USB]KPOC, func%s\n", KPOC_USB_FUNC);
+		err = android_enable_function(dev, KPOC_USB_FUNC);
+		if (err)
+			pr_err("android_usb: Cannot enable '%s' (%d)",
+					KPOC_USB_FUNC, err);
+		mutex_unlock(&dev->mutex);
+		return size;
+	}
+#endif
+
+
 	/* Added for USB Develpment debug, more log for more debuging help */
 	pr_notice("[USB]%s: \n", __func__);
 	/* Added for USB Develpment debug, more log for more debuging help */
@@ -2107,6 +2193,13 @@ static ssize_t enable_store(struct device *pdev, struct device_attribute *attr,
 		 */
 		cdev->desc.idVendor = device_desc.idVendor;
 		cdev->desc.idProduct = device_desc.idProduct;
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+		if(g_boot_mode == KERNEL_POWER_OFF_CHARGING_BOOT || g_boot_mode == LOW_POWER_OFF_CHARGING_BOOT){
+			pr_notice("[USB]KPOC, vid:%d, pid:%d\n", KPOC_USB_VENDOR_ID, KPOC_USB_PRODUCT_ID);
+			cdev->desc.idVendor = __constant_cpu_to_le16(KPOC_USB_VENDOR_ID);
+			cdev->desc.idProduct = __constant_cpu_to_le16(KPOC_USB_PRODUCT_ID);
+		}
+#endif
 		cdev->desc.bcdDevice = device_desc.bcdDevice;
 		cdev->desc.bDeviceClass = device_desc.bDeviceClass;
 		cdev->desc.bDeviceSubClass = device_desc.bDeviceSubClass;
@@ -2353,6 +2446,9 @@ static int android_bind(struct usb_composite_dev *cdev)
 	struct usb_gadget	*gadget = cdev->gadget;
 	int			id, ret;
 
+	/* Save the default handler */
+	dev->setup_complete = cdev->req->complete;
+
 	/*
 	 * Start disconnected. Userspace will connect the gadget once
 	 * it is done configuring the functions.
@@ -2427,6 +2523,7 @@ android_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *c)
 	req->zero = 0;
 	req->complete = composite_setup_complete;
 	req->length = 0;
+	req->complete = dev->setup_complete;
 	gadget->ep0->driver_data = cdev;
 
 	list_for_each_entry(f, &dev->enabled_functions, enabled_list) {
diff --git a/drivers/usb/gadget/f_accessory.c b/drivers/usb/gadget/f_accessory.c
index 7b3ebc4..742e7a1 100644
--- a/drivers/usb/gadget/f_accessory.c
+++ b/drivers/usb/gadget/f_accessory.c
@@ -956,6 +956,10 @@ kill_all_hid_devices(struct acc_dev *dev)
 	struct list_head *entry, *temp;
 	unsigned long flags;
 
+	/* do nothing if usb accessory device doesn't exist */
+	if (!dev)
+		return;
+
 	spin_lock_irqsave(&dev->lock, flags);
 	list_for_each_safe(entry, temp, &dev->hid_list) {
 		hid = list_entry(entry, struct acc_hid_dev, list);
diff --git a/drivers/usb/gadget/f_audio_source.c b/drivers/usb/gadget/f_audio_source.c
index a455b6d..4d2e1fd 100644
--- a/drivers/usb/gadget/f_audio_source.c
+++ b/drivers/usb/gadget/f_audio_source.c
@@ -35,7 +35,7 @@
 #define AUDIO_NUM_INTERFACES	2
 
 /* B.3.1  Standard AC Interface Descriptor */
-static struct usb_interface_descriptor ac_interface_desc = {
+static struct usb_interface_descriptor audio_ac_interface_desc = {
 	.bLength =		USB_DT_INTERFACE_SIZE,
 	.bDescriptorType =	USB_DT_INTERFACE,
 	.bNumEndpoints =	0,
@@ -51,7 +51,7 @@ DECLARE_UAC_AC_HEADER_DESCRIPTOR(2);
 	+ UAC_DT_INPUT_TERMINAL_SIZE + UAC_DT_OUTPUT_TERMINAL_SIZE \
 	+ UAC_DT_FEATURE_UNIT_SIZE(0))
 /* B.3.2  Class-Specific AC Interface Descriptor */
-static struct uac1_ac_header_descriptor_2 ac_header_desc = {
+static struct uac1_ac_header_descriptor_2 audio_ac_header_desc = {
 	.bLength =		UAC_DT_AC_HEADER_LENGTH,
 	.bDescriptorType =	USB_DT_CS_INTERFACE,
 	.bDescriptorSubtype =	UAC_HEADER,
@@ -65,7 +65,7 @@ static struct uac1_ac_header_descriptor_2 ac_header_desc = {
 };
 
 #define INPUT_TERMINAL_ID	1
-static struct uac_input_terminal_descriptor input_terminal_desc = {
+static struct uac_input_terminal_descriptor audio_input_terminal_desc = {
 	.bLength =		UAC_DT_INPUT_TERMINAL_SIZE,
 	.bDescriptorType =	USB_DT_CS_INTERFACE,
 	.bDescriptorSubtype =	UAC_INPUT_TERMINAL,
@@ -78,7 +78,7 @@ static struct uac_input_terminal_descriptor input_terminal_desc = {
 DECLARE_UAC_FEATURE_UNIT_DESCRIPTOR(0);
 
 #define FEATURE_UNIT_ID		2
-static struct uac_feature_unit_descriptor_0 feature_unit_desc = {
+static struct uac_feature_unit_descriptor_0 audio_feature_unit_desc = {
 	.bLength		= UAC_DT_FEATURE_UNIT_SIZE(0),
 	.bDescriptorType	= USB_DT_CS_INTERFACE,
 	.bDescriptorSubtype	= UAC_FEATURE_UNIT,
@@ -88,7 +88,7 @@ static struct uac_feature_unit_descriptor_0 feature_unit_desc = {
 };
 
 #define OUTPUT_TERMINAL_ID	3
-static struct uac1_output_terminal_descriptor output_terminal_desc = {
+static struct uac1_output_terminal_descriptor audio_output_terminal_desc = {
 	.bLength		= UAC_DT_OUTPUT_TERMINAL_SIZE,
 	.bDescriptorType	= USB_DT_CS_INTERFACE,
 	.bDescriptorSubtype	= UAC_OUTPUT_TERMINAL,
@@ -99,7 +99,7 @@ static struct uac1_output_terminal_descriptor output_terminal_desc = {
 };
 
 /* B.4.1  Standard AS Interface Descriptor */
-static struct usb_interface_descriptor as_interface_alt_0_desc = {
+static struct usb_interface_descriptor audio_as_interface_alt_0_desc = {
 	.bLength =		USB_DT_INTERFACE_SIZE,
 	.bDescriptorType =	USB_DT_INTERFACE,
 	.bAlternateSetting =	0,
@@ -108,7 +108,7 @@ static struct usb_interface_descriptor as_interface_alt_0_desc = {
 	.bInterfaceSubClass =	USB_SUBCLASS_AUDIOSTREAMING,
 };
 
-static struct usb_interface_descriptor as_interface_alt_1_desc = {
+static struct usb_interface_descriptor audio_as_interface_alt_1_desc = {
 	.bLength =		USB_DT_INTERFACE_SIZE,
 	.bDescriptorType =	USB_DT_INTERFACE,
 	.bAlternateSetting =	1,
@@ -118,7 +118,7 @@ static struct usb_interface_descriptor as_interface_alt_1_desc = {
 };
 
 /* B.4.2  Class-Specific AS Interface Descriptor */
-static struct uac1_as_header_descriptor as_header_desc = {
+static struct uac1_as_header_descriptor audio_as_header_desc = {
 	.bLength =		UAC_DT_AS_HEADER_SIZE,
 	.bDescriptorType =	USB_DT_CS_INTERFACE,
 	.bDescriptorSubtype =	UAC_AS_GENERAL,
@@ -129,7 +129,7 @@ static struct uac1_as_header_descriptor as_header_desc = {
 
 DECLARE_UAC_FORMAT_TYPE_I_DISCRETE_DESC(1);
 
-static struct uac_format_type_i_discrete_descriptor_1 as_type_i_desc = {
+static struct uac_format_type_i_discrete_descriptor_1 audio_as_type_i_desc = {
 	.bLength =		UAC_FORMAT_TYPE_I_DISCRETE_DESC_SIZE(1),
 	.bDescriptorType =	USB_DT_CS_INTERFACE,
 	.bDescriptorSubtype =	UAC_FORMAT_TYPE,
@@ -140,7 +140,7 @@ static struct uac_format_type_i_discrete_descriptor_1 as_type_i_desc = {
 };
 
 /* Standard ISO IN Endpoint Descriptor for highspeed */
-static struct usb_endpoint_descriptor hs_as_in_ep_desc  = {
+static struct usb_endpoint_descriptor audio_hs_as_in_ep_desc  = {
 	.bLength =		USB_DT_ENDPOINT_AUDIO_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 	.bEndpointAddress =	USB_DIR_IN,
@@ -151,7 +151,7 @@ static struct usb_endpoint_descriptor hs_as_in_ep_desc  = {
 };
 
 /* Standard ISO IN Endpoint Descriptor for highspeed */
-static struct usb_endpoint_descriptor fs_as_in_ep_desc  = {
+static struct usb_endpoint_descriptor audio_fs_as_in_ep_desc  = {
 	.bLength =		USB_DT_ENDPOINT_AUDIO_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 	.bEndpointAddress =	USB_DIR_IN,
@@ -162,7 +162,7 @@ static struct usb_endpoint_descriptor fs_as_in_ep_desc  = {
 };
 
 /* Class-specific AS ISO OUT Endpoint Descriptor */
-static struct uac_iso_endpoint_descriptor as_iso_in_desc = {
+static struct uac_iso_endpoint_descriptor audio_as_iso_in_desc = {
 	.bLength =		UAC_ISO_ENDPOINT_DESC_SIZE,
 	.bDescriptorType =	USB_DT_CS_ENDPOINT,
 	.bDescriptorSubtype =	UAC_EP_GENERAL,
@@ -172,40 +172,40 @@ static struct uac_iso_endpoint_descriptor as_iso_in_desc = {
 };
 
 static struct usb_descriptor_header *hs_audio_desc[] = {
-	(struct usb_descriptor_header *)&ac_interface_desc,
-	(struct usb_descriptor_header *)&ac_header_desc,
+	(struct usb_descriptor_header *)&audio_ac_interface_desc,
+	(struct usb_descriptor_header *)&audio_ac_header_desc,
 
-	(struct usb_descriptor_header *)&input_terminal_desc,
-	(struct usb_descriptor_header *)&output_terminal_desc,
-	(struct usb_descriptor_header *)&feature_unit_desc,
+	(struct usb_descriptor_header *)&audio_input_terminal_desc,
+	(struct usb_descriptor_header *)&audio_output_terminal_desc,
+	(struct usb_descriptor_header *)&audio_feature_unit_desc,
 
-	(struct usb_descriptor_header *)&as_interface_alt_0_desc,
-	(struct usb_descriptor_header *)&as_interface_alt_1_desc,
-	(struct usb_descriptor_header *)&as_header_desc,
+	(struct usb_descriptor_header *)&audio_as_interface_alt_0_desc,
+	(struct usb_descriptor_header *)&audio_as_interface_alt_1_desc,
+	(struct usb_descriptor_header *)&audio_as_header_desc,
 
-	(struct usb_descriptor_header *)&as_type_i_desc,
+	(struct usb_descriptor_header *)&audio_as_type_i_desc,
 
-	(struct usb_descriptor_header *)&hs_as_in_ep_desc,
-	(struct usb_descriptor_header *)&as_iso_in_desc,
+	(struct usb_descriptor_header *)&audio_hs_as_in_ep_desc,
+	(struct usb_descriptor_header *)&audio_as_iso_in_desc,
 	NULL,
 };
 
 static struct usb_descriptor_header *fs_audio_desc[] = {
-	(struct usb_descriptor_header *)&ac_interface_desc,
-	(struct usb_descriptor_header *)&ac_header_desc,
+	(struct usb_descriptor_header *)&audio_ac_interface_desc,
+	(struct usb_descriptor_header *)&audio_ac_header_desc,
 
-	(struct usb_descriptor_header *)&input_terminal_desc,
-	(struct usb_descriptor_header *)&output_terminal_desc,
-	(struct usb_descriptor_header *)&feature_unit_desc,
+	(struct usb_descriptor_header *)&audio_input_terminal_desc,
+	(struct usb_descriptor_header *)&audio_output_terminal_desc,
+	(struct usb_descriptor_header *)&audio_feature_unit_desc,
 
-	(struct usb_descriptor_header *)&as_interface_alt_0_desc,
-	(struct usb_descriptor_header *)&as_interface_alt_1_desc,
-	(struct usb_descriptor_header *)&as_header_desc,
+	(struct usb_descriptor_header *)&audio_as_interface_alt_0_desc,
+	(struct usb_descriptor_header *)&audio_as_interface_alt_1_desc,
+	(struct usb_descriptor_header *)&audio_as_header_desc,
 
-	(struct usb_descriptor_header *)&as_type_i_desc,
+	(struct usb_descriptor_header *)&audio_as_type_i_desc,
 
-	(struct usb_descriptor_header *)&fs_as_in_ep_desc,
-	(struct usb_descriptor_header *)&as_iso_in_desc,
+	(struct usb_descriptor_header *)&audio_fs_as_in_ep_desc,
+	(struct usb_descriptor_header *)&audio_as_iso_in_desc,
 	NULL,
 };
 
@@ -553,12 +553,12 @@ static void audio_build_desc(struct audio_dev *audio)
 	int rate;
 
 	/* Set channel numbers */
-	input_terminal_desc.bNrChannels = 2;
-	as_type_i_desc.bNrChannels = 2;
+	audio_input_terminal_desc.bNrChannels = 2;
+	audio_as_type_i_desc.bNrChannels = 2;
 
 	/* Set sample rates */
 	rate = SAMPLE_RATE;
-	sam_freq = as_type_i_desc.tSamFreq[0];
+	sam_freq = audio_as_type_i_desc.tSamFreq[0];
 	memcpy(sam_freq, &rate, 3);
 }
 
@@ -579,32 +579,32 @@ audio_bind(struct usb_configuration *c, struct usb_function *f)
 	status = usb_interface_id(c, f);
 	if (status < 0)
 		goto fail;
-	ac_interface_desc.bInterfaceNumber = status;
+	audio_ac_interface_desc.bInterfaceNumber = status;
 
 	/* AUDIO_AC_INTERFACE */
-	ac_header_desc.baInterfaceNr[0] = status;
+	audio_ac_header_desc.baInterfaceNr[0] = status;
 
 	status = usb_interface_id(c, f);
 	if (status < 0)
 		goto fail;
-	as_interface_alt_0_desc.bInterfaceNumber = status;
-	as_interface_alt_1_desc.bInterfaceNumber = status;
+	audio_as_interface_alt_0_desc.bInterfaceNumber = status;
+	audio_as_interface_alt_1_desc.bInterfaceNumber = status;
 
 	/* AUDIO_AS_INTERFACE */
-	ac_header_desc.baInterfaceNr[1] = status;
+	audio_ac_header_desc.baInterfaceNr[1] = status;
 
 	status = -ENODEV;
 
 	/* allocate our endpoint */
-	ep = usb_ep_autoconfig(cdev->gadget, &fs_as_in_ep_desc);
+	ep = usb_ep_autoconfig(cdev->gadget, &audio_fs_as_in_ep_desc);
 	if (!ep)
 		goto fail;
 	audio->in_ep = ep;
 	ep->driver_data = audio; /* claim */
 
 	if (gadget_is_dualspeed(c->cdev->gadget))
-		hs_as_in_ep_desc.bEndpointAddress =
-			fs_as_in_ep_desc.bEndpointAddress;
+		audio_hs_as_in_ep_desc.bEndpointAddress =
+			audio_fs_as_in_ep_desc.bEndpointAddress;
 
 	f->fs_descriptors = fs_audio_desc;
 	f->hs_descriptors = hs_audio_desc;
diff --git a/drivers/usb/gadget/f_midi.c b/drivers/usb/gadget/f_midi.c
index 263e721..e257a49 100644
--- a/drivers/usb/gadget/f_midi.c
+++ b/drivers/usb/gadget/f_midi.c
@@ -65,6 +65,11 @@ struct gmidi_in_port {
 	uint8_t data[2];
 };
 
+struct midi_alsa_config {
+	int	card;
+	int	device;
+};
+
 struct f_midi {
 	struct usb_function	func;
 	struct usb_gadget	*gadget;
@@ -97,7 +102,7 @@ DECLARE_USB_MIDI_OUT_JACK_DESCRIPTOR(1);
 DECLARE_USB_MS_ENDPOINT_DESCRIPTOR(16);
 
 /* B.3.1  Standard AC Interface Descriptor */
-static struct usb_interface_descriptor ac_interface_desc __initdata = {
+static struct usb_interface_descriptor ac_interface_desc /* __initdata */ = {
 	.bLength =		USB_DT_INTERFACE_SIZE,
 	.bDescriptorType =	USB_DT_INTERFACE,
 	/* .bInterfaceNumber =	DYNAMIC */
@@ -108,7 +113,7 @@ static struct usb_interface_descriptor ac_interface_desc __initdata = {
 };
 
 /* B.3.2  Class-Specific AC Interface Descriptor */
-static struct uac1_ac_header_descriptor_1 ac_header_desc __initdata = {
+static struct uac1_ac_header_descriptor_1 ac_header_desc /* __initdata */ = {
 	.bLength =		UAC_DT_AC_HEADER_SIZE(1),
 	.bDescriptorType =	USB_DT_CS_INTERFACE,
 	.bDescriptorSubtype =	USB_MS_HEADER,
@@ -119,7 +124,7 @@ static struct uac1_ac_header_descriptor_1 ac_header_desc __initdata = {
 };
 
 /* B.4.1  Standard MS Interface Descriptor */
-static struct usb_interface_descriptor ms_interface_desc __initdata = {
+static struct usb_interface_descriptor ms_interface_desc /* __initdata */ = {
 	.bLength =		USB_DT_INTERFACE_SIZE,
 	.bDescriptorType =	USB_DT_INTERFACE,
 	/* .bInterfaceNumber =	DYNAMIC */
@@ -130,7 +135,7 @@ static struct usb_interface_descriptor ms_interface_desc __initdata = {
 };
 
 /* B.4.2  Class-Specific MS Interface Descriptor */
-static struct usb_ms_header_descriptor ms_header_desc __initdata = {
+static struct usb_ms_header_descriptor ms_header_desc /* __initdata */ = {
 	.bLength =		USB_DT_MS_HEADER_SIZE,
 	.bDescriptorType =	USB_DT_CS_INTERFACE,
 	.bDescriptorSubtype =	USB_MS_HEADER,
@@ -409,7 +414,7 @@ static void f_midi_unbind(struct usb_configuration *c, struct usb_function *f)
 	card = midi->card;
 	midi->card = NULL;
 	if (card)
-		snd_card_free(card);
+		snd_card_free_when_closed(card);
 
 	kfree(midi->id);
 	midi->id = NULL;
@@ -733,7 +738,7 @@ fail:
 
 /* MIDI function driver setup/binding */
 
-static int __init
+static int /* __init */
 f_midi_bind(struct usb_configuration *c, struct usb_function *f)
 {
 	struct usb_descriptor_header **midi_function;
@@ -923,16 +928,22 @@ fail:
  *
  * Returns zero on success, else negative errno.
  */
-int __init f_midi_bind_config(struct usb_configuration *c,
+int /* __init */ f_midi_bind_config(struct usb_configuration *c,
 			      int index, char *id,
 			      unsigned int in_ports,
 			      unsigned int out_ports,
 			      unsigned int buflen,
-			      unsigned int qlen)
+			      unsigned int qlen,
+			      struct midi_alsa_config* config)
 {
 	struct f_midi *midi;
 	int status, i;
 
+	if (config) {
+		config->card = -1;
+		config->device = -1;
+	}
+
 	/* sanity check */
 	if (in_ports > MAX_PORTS || out_ports > MAX_PORTS)
 		return -EINVAL;
@@ -961,6 +972,10 @@ int __init f_midi_bind_config(struct usb_configuration *c,
 	tasklet_init(&midi->tasklet, f_midi_in_tasklet, (unsigned long) midi);
 
 	/* set up ALSA midi devices */
+	midi->id = kstrdup(id, GFP_KERNEL);
+	midi->index = index;
+	midi->buflen = buflen;
+	midi->qlen = qlen;
 	midi->in_ports = in_ports;
 	midi->out_ports = out_ports;
 	status = f_midi_register_card(midi);
@@ -974,15 +989,16 @@ int __init f_midi_bind_config(struct usb_configuration *c,
 	midi->func.set_alt     = f_midi_set_alt;
 	midi->func.disable     = f_midi_disable;
 
-	midi->id = kstrdup(id, GFP_KERNEL);
-	midi->index = index;
-	midi->buflen = buflen;
-	midi->qlen = qlen;
-
 	status = usb_add_function(c, &midi->func);
 	if (status)
 		goto setup_fail;
 
+
+	if (config) {
+		config->card = midi->rmidi->card->number;
+		config->device = midi->rmidi->device;
+	}
+
 	return 0;
 
 setup_fail:
diff --git a/drivers/usb/gadget/f_mtp.c b/drivers/usb/gadget/f_mtp.c
index f7e0bce..a90c30a 100644
--- a/drivers/usb/gadget/f_mtp.c
+++ b/drivers/usb/gadget/f_mtp.c
@@ -1005,7 +1005,7 @@ static ssize_t mtp_write(struct file *fp, const char __user *buf,
 	struct usb_request *req = 0;
 	ssize_t r = count;
 	unsigned xfer;
-	int sendZLP = 0;
+	/*int sendZLP = 0;*/
 	int ret;
 
 	DBG(cdev, "mtp_write(%zu)\n", count);
@@ -1036,14 +1036,14 @@ static ssize_t mtp_write(struct file *fp, const char __user *buf,
 	/* we need to send a zero length packet to signal the end of transfer
 	 * if the transfer size is aligned to a packet boundary.
 	 */
-	if ((count & (dev->ep_in->maxpacket - 1)) == 0)
-		sendZLP = 1;
+	/*if ((count & (dev->ep_in->maxpacket - 1)) == 0)
+		sendZLP = 1;*/
 
-	while (count > 0 || sendZLP) {
+	while (count > 0 /*|| sendZLP*/) {
 
 		/* so we exit after sending ZLP */
-		if (count == 0)
-			sendZLP = 0;
+		/*if (count == 0)
+			sendZLP = 0;*/
 
 		if (dev->state != STATE_BUSY) {
 			DBG(cdev, "mtp_write dev->error\n");
@@ -1120,7 +1120,7 @@ static void send_file_work(struct work_struct *data)
 	int64_t count;
 	int xfer, ret, hdr_size;
 	int r = 0;
-	int sendZLP = 0;
+	/*int sendZLP = 0;*/
 
 	#define IOMAXNUM	5
 	int iotimeMax[IOMAXNUM] = {0};
@@ -1145,13 +1145,13 @@ static void send_file_work(struct work_struct *data)
 	/* we need to send a zero length packet to signal the end of transfer
 	 * if the transfer size is aligned to a packet boundary.
 	 */
-	if ((count & (dev->ep_in->maxpacket - 1)) == 0)
-		sendZLP = 1;
+	/*if ((count & (dev->ep_in->maxpacket - 1)) == 0)
+		sendZLP = 1;*/
 
-	while (count > 0 || sendZLP) {
+	while (count > 0 /*|| sendZLP*/) {
 		/* so we exit after sending ZLP */
-		if (count == 0)
-			sendZLP = 0;
+		/*if (count == 0)
+			sendZLP = 0;*/
 
 		/* get an idle tx request to use */
 		req = 0;
diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c
index 9cfe3af..66c9058 100644
--- a/drivers/usb/host/pci-quirks.c
+++ b/drivers/usb/host/pci-quirks.c
@@ -470,7 +470,8 @@ static void quirk_usb_handoff_ohci(struct pci_dev *pdev)
 {
 	void __iomem *base;
 	u32 control;
-	u32 fminterval;
+	u32 fminterval = 0;
+	bool no_fminterval = false;
 	int cnt;
 
 	if (!mmio_resource_enabled(pdev, 0))
@@ -480,6 +481,13 @@ static void quirk_usb_handoff_ohci(struct pci_dev *pdev)
 	if (base == NULL)
 		return;
 
+	/*
+	 * ULi M5237 OHCI controller locks the whole system when accessing
+	 * the OHCI_FMINTERVAL offset.
+	 */
+	if (pdev->vendor == PCI_VENDOR_ID_AL && pdev->device == 0x5237)
+		no_fminterval = true;
+
 	control = readl(base + OHCI_CONTROL);
 
 /* On PA-RISC, PDC can leave IR set incorrectly; ignore it there. */
@@ -518,7 +526,9 @@ static void quirk_usb_handoff_ohci(struct pci_dev *pdev)
 	}
 
 	/* software reset of the controller, preserving HcFmInterval */
-	fminterval = readl(base + OHCI_FMINTERVAL);
+	if (!no_fminterval)
+		fminterval = readl(base + OHCI_FMINTERVAL);
+
 	writel(OHCI_HCR, base + OHCI_CMDSTATUS);
 
 	/* reset requires max 10 us delay */
@@ -527,7 +537,9 @@ static void quirk_usb_handoff_ohci(struct pci_dev *pdev)
 			break;
 		udelay(1);
 	}
-	writel(fminterval, base + OHCI_FMINTERVAL);
+
+	if (!no_fminterval)
+		writel(fminterval, base + OHCI_FMINTERVAL);
 
 	/* Now the controller is safely in SUSPEND and nothing can wake it up */
 	iounmap(base);
diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index 4f47fe7..a89edb3 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -2076,7 +2076,7 @@ static int process_ctrl_td(struct xhci_hcd *xhci, struct xhci_td *td,
 	if (event_trb != ep_ring->dequeue) {
 		/* The event was for the status stage */
 		if (event_trb == td->last_trb) {
-			if (td->urb->actual_length != 0) {
+			if (td->urb_length_set) {
 				/* Don't overwrite a previously set error code
 				 */
 				if ((*status == -EINPROGRESS || *status == 0) &&
@@ -2090,7 +2090,13 @@ static int process_ctrl_td(struct xhci_hcd *xhci, struct xhci_td *td,
 					td->urb->transfer_buffer_length;
 			}
 		} else {
-		/* Maybe the event was for the data stage? */
+			/*
+			 * Maybe the event was for the data stage? If so, update
+			 * already the actual_length of the URB and flag it as
+			 * set, so that it is not overwritten in the event for
+			 * the last TRB.
+			 */
+			td->urb_length_set = true;
 			td->urb->actual_length =
 				td->urb->transfer_buffer_length -
 				EVENT_TRB_LEN(le32_to_cpu(event->transfer_len));
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 06600bb..2864328 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1,3 +1,4 @@
+
 /*
  * xHCI host controller driver
  *
@@ -89,9 +90,10 @@ struct xhci_cap_regs {
 #define HCS_IST(p)		(((p) >> 0) & 0xf)
 /* bits 4:7, max number of Event Ring segments */
 #define HCS_ERST_MAX(p)		(((p) >> 4) & 0xf)
+/* bits 21:25 Hi 5 bits of Scratchpad buffers SW must allocate for the HW */
 /* bit 26 Scratchpad restore - for save/restore HW state - not used yet */
-/* bits 27:31 number of Scratchpad buffers SW must allocate for the HW */
-#define HCS_MAX_SCRATCHPAD(p)   (((p) >> 27) & 0x1f)
+/* bits 27:31 Lo 5 bits of Scratchpad buffers SW must allocate for the HW */
+#define HCS_MAX_SCRATCHPAD(p)   ((((p) >> 16) & 0x3e0) | (((p) >> 27) & 0x1f))
 
 /* HCSPARAMS3 - hcs_params3 - bitmasks */
 /* bits 0:7, Max U1 to U0 latency for the roothub ports */
@@ -1267,6 +1269,8 @@ struct xhci_td {
 	struct xhci_segment	*start_seg;
 	union xhci_trb		*first_trb;
 	union xhci_trb		*last_trb;
+	/* actual_length of the URB has already been set */
+	bool			urb_length_set;
 };
 
 /* xHCI command default timeout value */
diff --git a/drivers/usb/serial/bus.c b/drivers/usb/serial/bus.c
index 7229b26..5c56efe 100644
--- a/drivers/usb/serial/bus.c
+++ b/drivers/usb/serial/bus.c
@@ -76,7 +76,7 @@ static int usb_serial_device_probe(struct device *dev)
 	retval = device_create_file(dev, &dev_attr_port_number);
 	if (retval) {
 		if (driver->port_remove)
-			retval = driver->port_remove(port);
+			driver->port_remove(port);
 		goto exit_with_autopm;
 	}
 
diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c
index a24714f..79e9ea0 100644
--- a/drivers/usb/serial/cp210x.c
+++ b/drivers/usb/serial/cp210x.c
@@ -56,6 +56,7 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(0x0846, 0x1100) }, /* NetGear Managed Switch M4100 series, M5300 series, M7100 series */
 	{ USB_DEVICE(0x08e6, 0x5501) }, /* Gemalto Prox-PU/CU contactless smartcard reader */
 	{ USB_DEVICE(0x08FD, 0x000A) }, /* Digianswer A/S , ZigBee/802.15.4 MAC Device */
+	{ USB_DEVICE(0x0908, 0x01FF) }, /* Siemens RUGGEDCOM USB Serial Console */
 	{ USB_DEVICE(0x0BED, 0x1100) }, /* MEI (TM) Cashflow-SC Bill/Voucher Acceptor */
 	{ USB_DEVICE(0x0BED, 0x1101) }, /* MEI series 2000 Combo Acceptor */
 	{ USB_DEVICE(0x0FCF, 0x1003) }, /* Dynastream ANT development board */
@@ -120,10 +121,12 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(0x10C4, 0x85F8) }, /* Virtenio Preon32 */
 	{ USB_DEVICE(0x10C4, 0x8664) }, /* AC-Services CAN-IF */
 	{ USB_DEVICE(0x10C4, 0x8665) }, /* AC-Services OBD-IF */
-	{ USB_DEVICE(0x10C4, 0x8875) }, /* CEL MeshConnect USB Stick */
+	{ USB_DEVICE(0x10C4, 0x8856) },	/* CEL EM357 ZigBee USB Stick - LR */
+	{ USB_DEVICE(0x10C4, 0x8857) },	/* CEL EM357 ZigBee USB Stick */
 	{ USB_DEVICE(0x10C4, 0x88A4) }, /* MMB Networks ZigBee USB Device */
 	{ USB_DEVICE(0x10C4, 0x88A5) }, /* Planet Innovation Ingeni ZigBee USB Device */
 	{ USB_DEVICE(0x10C4, 0x8946) }, /* Ketra N1 Wireless Interface */
+	{ USB_DEVICE(0x10C4, 0x8977) },	/* CEL MeshWorks DevKit Device */
 	{ USB_DEVICE(0x10C4, 0xEA60) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA61) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA70) }, /* Silicon Labs factory default */
@@ -144,6 +147,8 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(0x166A, 0x0305) }, /* Clipsal C-5000CT2 C-Bus Spectrum Colour Touchscreen */
 	{ USB_DEVICE(0x166A, 0x0401) }, /* Clipsal L51xx C-Bus Architectural Dimmer */
 	{ USB_DEVICE(0x166A, 0x0101) }, /* Clipsal 5560884 C-Bus Multi-room Audio Matrix Switcher */
+	{ USB_DEVICE(0x16C0, 0x09B0) }, /* Lunatico Seletek */
+	{ USB_DEVICE(0x16C0, 0x09B1) }, /* Lunatico Seletek */
 	{ USB_DEVICE(0x16D6, 0x0001) }, /* Jablotron serial interface */
 	{ USB_DEVICE(0x16DC, 0x0010) }, /* W-IE-NE-R Plein & Baus GmbH PL512 Power Supply */
 	{ USB_DEVICE(0x16DC, 0x0011) }, /* W-IE-NE-R Plein & Baus GmbH RCM Remote Control for MARATON Power Supply */
diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c
index c625f55..cf127a0 100644
--- a/drivers/usb/serial/ftdi_sio.c
+++ b/drivers/usb/serial/ftdi_sio.c
@@ -815,6 +815,8 @@ static struct usb_device_id id_table_combined [] = {
 	{ USB_DEVICE(FTDI_VID, FTDI_ELSTER_UNICOM_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_PROPOX_JTAGCABLEII_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_PROPOX_ISPCABLEIII_PID) },
+	{ USB_DEVICE(FTDI_VID, CYBER_CORTEX_AV_PID),
+		.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },
 	{ USB_DEVICE(OLIMEX_VID, OLIMEX_ARM_USB_OCD_PID),
 		.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },
 	{ USB_DEVICE(OLIMEX_VID, OLIMEX_ARM_USB_OCD_H_PID),
diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h
index ac703a6..e8d3526 100644
--- a/drivers/usb/serial/ftdi_sio_ids.h
+++ b/drivers/usb/serial/ftdi_sio_ids.h
@@ -38,6 +38,9 @@
 
 #define FTDI_LUMEL_PD12_PID	0x6002
 
+/* Cyber Cortex AV by Fabulous Silicon (http://fabuloussilicon.com) */
+#define CYBER_CORTEX_AV_PID	0x8698
+
 /*
  * Marvell OpenRD Base, Client
  * http://www.open-rd.org
diff --git a/drivers/usb/serial/generic.c b/drivers/usb/serial/generic.c
index 8335b48..a10648d 100644
--- a/drivers/usb/serial/generic.c
+++ b/drivers/usb/serial/generic.c
@@ -261,7 +261,8 @@ void usb_serial_generic_wait_until_sent(struct tty_struct *tty, long timeout)
 	 * character or at least one jiffy.
 	 */
 	period = max_t(unsigned long, (10 * HZ / bps), 1);
-	period = min_t(unsigned long, period, timeout);
+	if (timeout)
+		period = min_t(unsigned long, period, timeout);
 
 	dev_dbg(&port->dev, "%s - timeout = %u ms, period = %u ms\n",
 					__func__, jiffies_to_msecs(timeout),
@@ -271,7 +272,7 @@ void usb_serial_generic_wait_until_sent(struct tty_struct *tty, long timeout)
 		schedule_timeout_interruptible(period);
 		if (signal_pending(current))
 			break;
-		if (time_after(jiffies, expire))
+		if (timeout && time_after(jiffies, expire))
 			break;
 	}
 }
diff --git a/drivers/usb/serial/keyspan.c b/drivers/usb/serial/keyspan.c
index f0e65c9..cec377b 100644
--- a/drivers/usb/serial/keyspan.c
+++ b/drivers/usb/serial/keyspan.c
@@ -418,6 +418,8 @@ static void	usa26_instat_callback(struct urb *urb)
 	}
 	port = serial->port[msg->port];
 	p_priv = usb_get_serial_port_data(port);
+	if (!p_priv)
+		goto resubmit;
 
 	/* Update handshaking pin state information */
 	old_dcd_state = p_priv->dcd_state;
@@ -428,7 +430,7 @@ static void	usa26_instat_callback(struct urb *urb)
 
 	if (old_dcd_state != p_priv->dcd_state)
 		tty_port_tty_hangup(&port->port, true);
-
+resubmit:
 	/* Resubmit urb so we continue receiving */
 	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (err != 0)
@@ -543,6 +545,8 @@ static void	usa28_instat_callback(struct urb *urb)
 	}
 	port = serial->port[msg->port];
 	p_priv = usb_get_serial_port_data(port);
+	if (!p_priv)
+		goto resubmit;
 
 	/* Update handshaking pin state information */
 	old_dcd_state = p_priv->dcd_state;
@@ -553,7 +557,7 @@ static void	usa28_instat_callback(struct urb *urb)
 
 	if (old_dcd_state != p_priv->dcd_state && old_dcd_state)
 		tty_port_tty_hangup(&port->port, true);
-
+resubmit:
 		/* Resubmit urb so we continue receiving */
 	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (err != 0)
@@ -630,6 +634,8 @@ static void	usa49_instat_callback(struct urb *urb)
 	}
 	port = serial->port[msg->portNumber];
 	p_priv = usb_get_serial_port_data(port);
+	if (!p_priv)
+		goto resubmit;
 
 	/* Update handshaking pin state information */
 	old_dcd_state = p_priv->dcd_state;
@@ -640,7 +646,7 @@ static void	usa49_instat_callback(struct urb *urb)
 
 	if (old_dcd_state != p_priv->dcd_state && old_dcd_state)
 		tty_port_tty_hangup(&port->port, true);
-
+resubmit:
 	/* Resubmit urb so we continue receiving */
 	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (err != 0)
@@ -878,6 +884,8 @@ static void	usa90_instat_callback(struct urb *urb)
 
 	port = serial->port[0];
 	p_priv = usb_get_serial_port_data(port);
+	if (!p_priv)
+		goto resubmit;
 
 	/* Update handshaking pin state information */
 	old_dcd_state = p_priv->dcd_state;
@@ -888,7 +896,7 @@ static void	usa90_instat_callback(struct urb *urb)
 
 	if (old_dcd_state != p_priv->dcd_state && old_dcd_state)
 		tty_port_tty_hangup(&port->port, true);
-
+resubmit:
 	/* Resubmit urb so we continue receiving */
 	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (err != 0)
@@ -949,6 +957,8 @@ static void	usa67_instat_callback(struct urb *urb)
 
 	port = serial->port[msg->port];
 	p_priv = usb_get_serial_port_data(port);
+	if (!p_priv)
+		goto resubmit;
 
 	/* Update handshaking pin state information */
 	old_dcd_state = p_priv->dcd_state;
@@ -957,7 +967,7 @@ static void	usa67_instat_callback(struct urb *urb)
 
 	if (old_dcd_state != p_priv->dcd_state && old_dcd_state)
 		tty_port_tty_hangup(&port->port, true);
-
+resubmit:
 	/* Resubmit urb so we continue receiving */
 	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (err != 0)
diff --git a/drivers/vfio/pci/vfio_pci.c b/drivers/vfio/pci/vfio_pci.c
index ac37254..dc55bc2 100644
--- a/drivers/vfio/pci/vfio_pci.c
+++ b/drivers/vfio/pci/vfio_pci.c
@@ -519,13 +519,11 @@ static const struct vfio_device_ops vfio_pci_ops = {
 
 static int vfio_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 {
-	u8 type;
 	struct vfio_pci_device *vdev;
 	struct iommu_group *group;
 	int ret;
 
-	pci_read_config_byte(pdev, PCI_HEADER_TYPE, &type);
-	if ((type & PCI_HEADER_TYPE) != PCI_HEADER_TYPE_NORMAL)
+	if (pdev->hdr_type != PCI_HEADER_TYPE_NORMAL)
 		return -EINVAL;
 
 	group = iommu_group_get(&pdev->dev);
diff --git a/drivers/vhost/scsi.c b/drivers/vhost/scsi.c
index 962c7e3..fb97bc0 100644
--- a/drivers/vhost/scsi.c
+++ b/drivers/vhost/scsi.c
@@ -820,6 +820,23 @@ static int vhost_scsi_map_iov_to_sgl(struct tcm_vhost_cmd *tv_cmd,
 	return 0;
 }
 
+static int vhost_scsi_to_tcm_attr(int attr)
+{
+	switch (attr) {
+	case VIRTIO_SCSI_S_SIMPLE:
+		return MSG_SIMPLE_TAG;
+	case VIRTIO_SCSI_S_ORDERED:
+		return MSG_ORDERED_TAG;
+	case VIRTIO_SCSI_S_HEAD:
+		return MSG_HEAD_TAG;
+	case VIRTIO_SCSI_S_ACA:
+		return MSG_ACA_TAG;
+	default:
+		break;
+	}
+	return MSG_SIMPLE_TAG;
+}
+
 static void tcm_vhost_submission_work(struct work_struct *work)
 {
 	struct tcm_vhost_cmd *tv_cmd =
@@ -846,9 +863,9 @@ static void tcm_vhost_submission_work(struct work_struct *work)
 	rc = target_submit_cmd_map_sgls(se_cmd, tv_nexus->tvn_se_sess,
 			tv_cmd->tvc_cdb, &tv_cmd->tvc_sense_buf[0],
 			tv_cmd->tvc_lun, tv_cmd->tvc_exp_data_len,
-			tv_cmd->tvc_task_attr, tv_cmd->tvc_data_direction,
-			0, sg_ptr, tv_cmd->tvc_sgl_count,
-			sg_bidi_ptr, sg_no_bidi);
+			vhost_scsi_to_tcm_attr(tv_cmd->tvc_task_attr),
+			tv_cmd->tvc_data_direction, 0, sg_ptr,
+			tv_cmd->tvc_sgl_count, sg_bidi_ptr, sg_no_bidi);
 	if (rc < 0) {
 		transport_send_check_condition_and_sense(se_cmd,
 				TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE, 0);
@@ -1150,6 +1167,7 @@ static int vhost_scsi_set_endpoint(
 	struct vhost_scsi *vs,
 	struct vhost_scsi_target *t)
 {
+	struct se_portal_group *se_tpg;
 	struct tcm_vhost_tport *tv_tport;
 	struct tcm_vhost_tpg *tv_tpg;
 	struct tcm_vhost_tpg **vs_tpg;
@@ -1197,6 +1215,21 @@ static int vhost_scsi_set_endpoint(
 				ret = -EEXIST;
 				goto out;
 			}
+			/*
+			 * In order to ensure individual vhost-scsi configfs
+			 * groups cannot be removed while in use by vhost ioctl,
+			 * go ahead and take an explicit se_tpg->tpg_group.cg_item
+			 * dependency now.
+			 */
+			se_tpg = &tv_tpg->se_tpg;
+			ret = configfs_depend_item(se_tpg->se_tpg_tfo->tf_subsys,
+						   &se_tpg->tpg_group.cg_item);
+			if (ret) {
+				pr_warn("configfs_depend_item() failed: %d\n", ret);
+				kfree(vs_tpg);
+				mutex_unlock(&tv_tpg->tv_tpg_mutex);
+				goto out;
+			}
 			tv_tpg->tv_tpg_vhost_count++;
 			tv_tpg->vhost_scsi = vs;
 			vs_tpg[tv_tpg->tport_tpgt] = tv_tpg;
@@ -1240,6 +1273,7 @@ static int vhost_scsi_clear_endpoint(
 	struct vhost_scsi *vs,
 	struct vhost_scsi_target *t)
 {
+	struct se_portal_group *se_tpg;
 	struct tcm_vhost_tport *tv_tport;
 	struct tcm_vhost_tpg *tv_tpg;
 	struct vhost_virtqueue *vq;
@@ -1288,6 +1322,13 @@ static int vhost_scsi_clear_endpoint(
 		vs->vs_tpg[target] = NULL;
 		match = true;
 		mutex_unlock(&tv_tpg->tv_tpg_mutex);
+		/*
+		 * Release se_tpg->tpg_group.cg_item configfs dependency now
+		 * to allow vhost-scsi WWPN se_tpg->tpg_group shutdown to occur.
+		 */
+		se_tpg = &tv_tpg->se_tpg;
+		configfs_undepend_item(se_tpg->se_tpg_tfo->tf_subsys,
+				       &se_tpg->tpg_group.cg_item);
 	}
 	if (match) {
 		for (i = 0; i < VHOST_SCSI_MAX_VQ; i++) {
diff --git a/drivers/video/logo/logo.c b/drivers/video/logo/logo.c
index 080c35b..cc5dbb5 100644
--- a/drivers/video/logo/logo.c
+++ b/drivers/video/logo/logo.c
@@ -25,6 +25,21 @@ static bool nologo;
 module_param(nologo, bool, 0);
 MODULE_PARM_DESC(nologo, "Disables startup logo");
 
+/*
+ * Logos are located in the initdata, and will be freed in kernel_init.
+ * Use late_init to mark the logos as freed to prevent any further use.
+ */
+
+static bool logos_freed;
+
+static int __init fb_logo_late_init(void)
+{
+	logos_freed = true;
+	return 0;
+}
+
+late_initcall(fb_logo_late_init);
+
 /* logo's are marked __initdata. Use __init_refok to tell
  * modpost that it is intended that this function uses data
  * marked __initdata.
@@ -33,7 +48,7 @@ const struct linux_logo * __init_refok fb_find_logo(int depth)
 {
 	const struct linux_logo *logo = NULL;
 
-	if (nologo)
+	if (nologo || logos_freed)
 		return NULL;
 
 	if (depth >= 1) {
diff --git a/drivers/xen/swiotlb-xen.c b/drivers/xen/swiotlb-xen.c
index 301b084..1d94316 100644
--- a/drivers/xen/swiotlb-xen.c
+++ b/drivers/xen/swiotlb-xen.c
@@ -390,7 +390,7 @@ static void xen_unmap_single(struct device *hwdev, dma_addr_t dev_addr,
 
 	/* NOTE: We use dev_addr here, not paddr! */
 	if (is_xen_swiotlb_buffer(dev_addr)) {
-		swiotlb_tbl_unmap_single(hwdev, dev_addr, size, dir);
+		swiotlb_tbl_unmap_single(hwdev, paddr, size, dir);
 		return;
 	}
 
diff --git a/fs/Kconfig b/fs/Kconfig
index 6228241..cd6fae0 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -92,6 +92,7 @@ if BLOCK
 menu "DOS/FAT/NT Filesystems"
 
 source "fs/fat/Kconfig"
+source "fs/exfat/Kconfig"
 source "fs/ntfs/Kconfig"
 
 endmenu
diff --git a/fs/Makefile b/fs/Makefile
index 5547e2d..8ef06f7 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -77,6 +77,7 @@ obj-$(CONFIG_HUGETLBFS)		+= hugetlbfs/
 obj-$(CONFIG_CODA_FS)		+= coda/
 obj-$(CONFIG_MINIX_FS)		+= minix/
 obj-$(CONFIG_FAT_FS)		+= fat/
+obj-$(CONFIG_EXFAT_FS)  	+= exfat/
 obj-$(CONFIG_BFS_FS)		+= bfs/
 obj-$(CONFIG_ISO9660_FS)	+= isofs/
 obj-$(CONFIG_HFSPLUS_FS)	+= hfsplus/ # Before hfs to find wrapped HFS+
diff --git a/fs/adfs/super.c b/fs/adfs/super.c
index 0ff4bae..479ef5a 100644
--- a/fs/adfs/super.c
+++ b/fs/adfs/super.c
@@ -213,6 +213,7 @@ static int parse_options(struct super_block *sb, char *options)
 
 static int adfs_remount(struct super_block *sb, int *flags, char *data)
 {
+	sync_filesystem(sb);
 	*flags |= MS_NODIRATIME;
 	return parse_options(sb, data);
 }
diff --git a/fs/affs/super.c b/fs/affs/super.c
index 45161a8..01c6e07 100644
--- a/fs/affs/super.c
+++ b/fs/affs/super.c
@@ -549,6 +549,7 @@ affs_remount(struct super_block *sb, int *flags, char *data)
 
 	pr_debug("AFFS: remount(flags=0x%x,opts=\"%s\")\n",*flags,data);
 
+	sync_filesystem(sb);
 	*flags |= MS_NODIRATIME;
 
 	memcpy(volume, sbi->s_volume, 32);
diff --git a/fs/autofs4/dev-ioctl.c b/fs/autofs4/dev-ioctl.c
index 743c7c2..6aa8312 100644
--- a/fs/autofs4/dev-ioctl.c
+++ b/fs/autofs4/dev-ioctl.c
@@ -95,7 +95,7 @@ static int check_dev_ioctl_version(int cmd, struct autofs_dev_ioctl *param)
  */
 static struct autofs_dev_ioctl *copy_dev_ioctl(struct autofs_dev_ioctl __user *in)
 {
-	struct autofs_dev_ioctl tmp;
+	struct autofs_dev_ioctl tmp, *res;
 
 	if (copy_from_user(&tmp, in, sizeof(tmp)))
 		return ERR_PTR(-EFAULT);
@@ -103,7 +103,11 @@ static struct autofs_dev_ioctl *copy_dev_ioctl(struct autofs_dev_ioctl __user *i
 	if (tmp.size < sizeof(tmp))
 		return ERR_PTR(-EINVAL);
 
-	return memdup_user(in, tmp.size);
+	res = memdup_user(in, tmp.size);
+	if (!IS_ERR(res))
+		res->size = tmp.size;
+
+	return res;
 }
 
 static inline void free_dev_ioctl(struct autofs_dev_ioctl *param)
diff --git a/fs/befs/linuxvfs.c b/fs/befs/linuxvfs.c
index f95dddc..7192a7e 100644
--- a/fs/befs/linuxvfs.c
+++ b/fs/befs/linuxvfs.c
@@ -908,6 +908,7 @@ befs_fill_super(struct super_block *sb, void *data, int silent)
 static int
 befs_remount(struct super_block *sb, int *flags, char *data)
 {
+	sync_filesystem(sb);
 	if (!(*flags & MS_RDONLY))
 		return -EINVAL;
 	return 0;
diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c
index 3feb5e7..30839a7 100644
--- a/fs/binfmt_elf.c
+++ b/fs/binfmt_elf.c
@@ -552,11 +552,12 @@ out:
 
 static unsigned long randomize_stack_top(unsigned long stack_top)
 {
-	unsigned int random_variable = 0;
+	unsigned long random_variable = 0;
 
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
-		random_variable = get_random_int() & STACK_RND_MASK;
+		random_variable = (unsigned long) get_random_int();
+		random_variable &= STACK_RND_MASK;
 		random_variable <<= PAGE_SHIFT;
 	}
 #ifdef CONFIG_STACK_GROWSUP
diff --git a/fs/btrfs/file.c b/fs/btrfs/file.c
index 4205ba7..caaf30f 100644
--- a/fs/btrfs/file.c
+++ b/fs/btrfs/file.c
@@ -1593,22 +1593,10 @@ static ssize_t btrfs_file_aio_write(struct kiocb *iocb,
 	mutex_unlock(&inode->i_mutex);
 
 	/*
-	 * we want to make sure fsync finds this change
-	 * but we haven't joined a transaction running right now.
-	 *
-	 * Later on, someone is sure to update the inode and get the
-	 * real transid recorded.
-	 *
-	 * We set last_trans now to the fs_info generation + 1,
-	 * this will either be one more than the running transaction
-	 * or the generation used for the next transaction if there isn't
-	 * one running right now.
-	 *
 	 * We also have to set last_sub_trans to the current log transid,
 	 * otherwise subsequent syncs to a file that's been synced in this
 	 * transaction will appear to have already occured.
 	 */
-	BTRFS_I(inode)->last_trans = root->fs_info->generation + 1;
 	BTRFS_I(inode)->last_sub_trans = root->log_transid;
 	if (num_written > 0 || num_written == -EIOCBQUEUED) {
 		err = generic_write_sync(file, pos, num_written);
@@ -1706,25 +1694,37 @@ int btrfs_sync_file(struct file *file, loff_t start, loff_t end, int datasync)
 	atomic_inc(&root->log_batch);
 
 	/*
-	 * check the transaction that last modified this inode
-	 * and see if its already been committed
-	 */
-	if (!BTRFS_I(inode)->last_trans) {
-		mutex_unlock(&inode->i_mutex);
-		goto out;
-	}
-
-	/*
-	 * if the last transaction that changed this file was before
-	 * the current transaction, we can bail out now without any
-	 * syncing
+	 * If the last transaction that changed this file was before the current
+	 * transaction and we have the full sync flag set in our inode, we can
+	 * bail out now without any syncing.
+	 *
+	 * Note that we can't bail out if the full sync flag isn't set. This is
+	 * because when the full sync flag is set we start all ordered extents
+	 * and wait for them to fully complete - when they complete they update
+	 * the inode's last_trans field through:
+	 *
+	 *     btrfs_finish_ordered_io() ->
+	 *         btrfs_update_inode_fallback() ->
+	 *             btrfs_update_inode() ->
+	 *                 btrfs_set_inode_last_trans()
+	 *
+	 * So we are sure that last_trans is up to date and can do this check to
+	 * bail out safely. For the fast path, when the full sync flag is not
+	 * set in our inode, we can not do it because we start only our ordered
+	 * extents and don't wait for them to complete (that is when
+	 * btrfs_finish_ordered_io runs), so here at this point their last_trans
+	 * value might be less than or equals to fs_info->last_trans_committed,
+	 * and setting a speculative last_trans for an inode when a buffered
+	 * write is made (such as fs_info->generation + 1 for example) would not
+	 * be reliable since after setting the value and before fsync is called
+	 * any number of transactions can start and commit (transaction kthread
+	 * commits the current transaction periodically), and a transaction
+	 * commit does not start nor waits for ordered extents to complete.
 	 */
 	smp_mb();
 	if (btrfs_inode_in_log(inode, root->fs_info->generation) ||
-	    BTRFS_I(inode)->last_trans <=
-	    root->fs_info->last_trans_committed) {
-		BTRFS_I(inode)->last_trans = 0;
-
+	    (full_sync && BTRFS_I(inode)->last_trans <=
+	     root->fs_info->last_trans_committed)) {
 		/*
 		 * We'v had everything committed since the last time we were
 		 * modified so clear this flag in case it was set for whatever
diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c
index 187911f..d20db64 100644
--- a/fs/btrfs/inode.c
+++ b/fs/btrfs/inode.c
@@ -6825,7 +6825,6 @@ static int btrfs_get_blocks_direct(struct inode *inode, sector_t iblock,
 	    ((BTRFS_I(inode)->flags & BTRFS_INODE_NODATACOW) &&
 	     em->block_start != EXTENT_MAP_HOLE)) {
 		int type;
-		int ret;
 		u64 block_start, orig_start, orig_block_len, ram_bytes;
 
 		if (test_bit(EXTENT_FLAG_PREALLOC, &em->flags))
diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f0857e0..461731c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1239,6 +1239,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 	unsigned int old_metadata_ratio = fs_info->metadata_ratio;
 	int ret;
 
+	sync_filesystem(sb);
 	btrfs_remount_prepare(fs_info);
 
 	ret = btrfs_parse_options(root, data);
diff --git a/fs/btrfs/tree-log.c b/fs/btrfs/tree-log.c
index bca4363..7d3331c 100644
--- a/fs/btrfs/tree-log.c
+++ b/fs/btrfs/tree-log.c
@@ -943,7 +943,7 @@ again:
 		base = btrfs_item_ptr_offset(leaf, path->slots[0]);
 
 		while (cur_offset < item_size) {
-			extref = (struct btrfs_inode_extref *)base + cur_offset;
+			extref = (struct btrfs_inode_extref *)(base + cur_offset);
 
 			victim_name_len = btrfs_inode_extref_name_len(leaf, extref);
 
diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 3752b9f..0d7daf7 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -521,6 +521,7 @@ static int cifs_show_stats(struct seq_file *s, struct dentry *root)
 
 static int cifs_remount(struct super_block *sb, int *flags, char *data)
 {
+	sync_filesystem(sb);
 	*flags |= MS_NODIRATIME;
 	return 0;
 }
diff --git a/fs/coda/dir.c b/fs/coda/dir.c
index b7d3a05..fc66861 100644
--- a/fs/coda/dir.c
+++ b/fs/coda/dir.c
@@ -391,8 +391,7 @@ static int coda_readdir(struct file *coda_file, void *buf, filldir_t filldir)
 	if (!host_file->f_op)
 		return -ENOTDIR;
 
-	if (host_file->f_op->readdir)
-	{
+	if (host_file->f_op->readdir) {
 		/* potemkin case: we were handed a directory inode.
 		 * We can't use vfs_readdir because we have to keep the file
 		 * position in sync between the coda_file and the host_file.
@@ -410,8 +409,20 @@ static int coda_readdir(struct file *coda_file, void *buf, filldir_t filldir)
 
 		coda_file->f_pos = host_file->f_pos;
 		mutex_unlock(&host_inode->i_mutex);
-	}
-	else /* Venus: we must read Venus dirents from a file */
+	} else if (host_file->f_op->iterate) {
+		struct inode *host_inode = file_inode(host_file);
+		struct dir_context *ctx = buf;
+
+		mutex_lock(&host_inode->i_mutex);
+		ret = -ENOENT;
+		if (!IS_DEADDIR(host_inode)) {
+			ret = host_file->f_op->iterate(host_file, ctx);
+			file_accessed(host_file);
+		}
+		mutex_unlock(&host_inode->i_mutex);
+
+		coda_file->f_pos = ctx->pos;
+	} else /* Venus: we must read Venus dirents from a file */
 		ret = coda_venus_readdir(coda_file, buf, filldir);
 
 	return ret;
diff --git a/fs/coda/inode.c b/fs/coda/inode.c
index 4dcc0d8..0aa4c4d 100644
--- a/fs/coda/inode.c
+++ b/fs/coda/inode.c
@@ -96,6 +96,7 @@ void coda_destroy_inodecache(void)
 
 static int coda_remount(struct super_block *sb, int *flags, char *data)
 {
+	sync_filesystem(sb);
 	*flags |= MS_NOATIME;
 	return 0;
 }
diff --git a/fs/compat.c b/fs/compat.c
index fc3b55d..6af20de 100644
--- a/fs/compat.c
+++ b/fs/compat.c
@@ -832,6 +832,7 @@ struct compat_old_linux_dirent {
 };
 
 struct compat_readdir_callback {
+	struct dir_context ctx;
 	struct compat_old_linux_dirent __user *dirent;
 	int result;
 };
@@ -873,15 +874,15 @@ asmlinkage long compat_sys_old_readdir(unsigned int fd,
 {
 	int error;
 	struct fd f = fdget(fd);
-	struct compat_readdir_callback buf;
+	struct compat_readdir_callback buf = {
+		.ctx.actor = compat_fillonedir,
+		.dirent = dirent
+	};
 
 	if (!f.file)
 		return -EBADF;
 
-	buf.result = 0;
-	buf.dirent = dirent;
-
-	error = vfs_readdir(f.file, compat_fillonedir, &buf);
+	error = iterate_dir(f.file, &buf.ctx);
 	if (buf.result)
 		error = buf.result;
 
@@ -897,6 +898,7 @@ struct compat_linux_dirent {
 };
 
 struct compat_getdents_callback {
+	struct dir_context ctx;
 	struct compat_linux_dirent __user *current_dir;
 	struct compat_linux_dirent __user *previous;
 	int count;
@@ -951,7 +953,11 @@ asmlinkage long compat_sys_getdents(unsigned int fd,
 {
 	struct fd f;
 	struct compat_linux_dirent __user * lastdirent;
-	struct compat_getdents_callback buf;
+	struct compat_getdents_callback buf = {
+		.ctx.actor = compat_filldir,
+		.current_dir = dirent,
+		.count = count
+	};
 	int error;
 
 	if (!access_ok(VERIFY_WRITE, dirent, count))
@@ -961,17 +967,12 @@ asmlinkage long compat_sys_getdents(unsigned int fd,
 	if (!f.file)
 		return -EBADF;
 
-	buf.current_dir = dirent;
-	buf.previous = NULL;
-	buf.count = count;
-	buf.error = 0;
-
-	error = vfs_readdir(f.file, compat_filldir, &buf);
+	error = iterate_dir(f.file, &buf.ctx);
 	if (error >= 0)
 		error = buf.error;
 	lastdirent = buf.previous;
 	if (lastdirent) {
-		if (put_user(f.file->f_pos, &lastdirent->d_off))
+		if (put_user(buf.ctx.pos, &lastdirent->d_off))
 			error = -EFAULT;
 		else
 			error = count - buf.count;
@@ -983,6 +984,7 @@ asmlinkage long compat_sys_getdents(unsigned int fd,
 #ifndef __ARCH_OMIT_COMPAT_SYS_GETDENTS64
 
 struct compat_getdents_callback64 {
+	struct dir_context ctx;
 	struct linux_dirent64 __user *current_dir;
 	struct linux_dirent64 __user *previous;
 	int count;
@@ -1036,7 +1038,11 @@ asmlinkage long compat_sys_getdents64(unsigned int fd,
 {
 	struct fd f;
 	struct linux_dirent64 __user * lastdirent;
-	struct compat_getdents_callback64 buf;
+	struct compat_getdents_callback64 buf = {
+		.ctx.actor = compat_filldir64,
+		.current_dir = dirent,
+		.count = count
+	};
 	int error;
 
 	if (!access_ok(VERIFY_WRITE, dirent, count))
@@ -1046,17 +1052,12 @@ asmlinkage long compat_sys_getdents64(unsigned int fd,
 	if (!f.file)
 		return -EBADF;
 
-	buf.current_dir = dirent;
-	buf.previous = NULL;
-	buf.count = count;
-	buf.error = 0;
-
-	error = vfs_readdir(f.file, compat_filldir64, &buf);
+	error = iterate_dir(f.file, &buf.ctx);
 	if (error >= 0)
 		error = buf.error;
 	lastdirent = buf.previous;
 	if (lastdirent) {
-		typeof(lastdirent->d_off) d_off = f.file->f_pos;
+		typeof(lastdirent->d_off) d_off = buf.ctx.pos;
 		if (__put_user_unaligned(d_off, &lastdirent->d_off))
 			error = -EFAULT;
 		else
diff --git a/fs/cramfs/inode.c b/fs/cramfs/inode.c
index 35b1c7b..c014858 100644
--- a/fs/cramfs/inode.c
+++ b/fs/cramfs/inode.c
@@ -227,6 +227,7 @@ static void cramfs_put_super(struct super_block *sb)
 
 static int cramfs_remount(struct super_block *sb, int *flags, char *data)
 {
+	sync_filesystem(sb);
 	*flags |= MS_RDONLY;
 	return 0;
 }
diff --git a/fs/debugfs/inode.c b/fs/debugfs/inode.c
index 1c807d3..5397ca6 100644
--- a/fs/debugfs/inode.c
+++ b/fs/debugfs/inode.c
@@ -218,6 +218,7 @@ static int debugfs_remount(struct super_block *sb, int *flags, char *data)
 	int err;
 	struct debugfs_fs_info *fsi = sb->s_fs_info;
 
+	sync_filesystem(sb);
 	err = debugfs_parse_options(data, &fsi->mount_opts);
 	if (err)
 		goto fail;
@@ -245,10 +246,19 @@ static int debugfs_show_options(struct seq_file *m, struct dentry *root)
 	return 0;
 }
 
+static void debugfs_evict_inode(struct inode *inode)
+{
+	truncate_inode_pages(&inode->i_data, 0);
+	clear_inode(inode);
+	if (S_ISLNK(inode->i_mode))
+		kfree(inode->i_private);
+}
+
 static const struct super_operations debugfs_super_operations = {
 	.statfs		= simple_statfs,
 	.remount_fs	= debugfs_remount,
 	.show_options	= debugfs_show_options,
+	.evict_inode	= debugfs_evict_inode,
 };
 
 static int debug_fill_super(struct super_block *sb, void *data, int silent)
@@ -465,23 +475,14 @@ static int __debugfs_remove(struct dentry *dentry, struct dentry *parent)
 	int ret = 0;
 
 	if (debugfs_positive(dentry)) {
-		if (dentry->d_inode) {
-			dget(dentry);
-			switch (dentry->d_inode->i_mode & S_IFMT) {
-			case S_IFDIR:
-				ret = simple_rmdir(parent->d_inode, dentry);
-				break;
-			case S_IFLNK:
-				kfree(dentry->d_inode->i_private);
-				/* fall through */
-			default:
-				simple_unlink(parent->d_inode, dentry);
-				break;
-			}
-			if (!ret)
-				d_delete(dentry);
-			dput(dentry);
-		}
+		dget(dentry);
+		if (S_ISDIR(dentry->d_inode->i_mode))
+			ret = simple_rmdir(parent->d_inode, dentry);
+		else
+			simple_unlink(parent->d_inode, dentry);
+		if (!ret)
+			d_delete(dentry);
+		dput(dentry);
 	}
 	return ret;
 }
diff --git a/fs/devpts/inode.c b/fs/devpts/inode.c
index a726b9f..c710380 100644
--- a/fs/devpts/inode.c
+++ b/fs/devpts/inode.c
@@ -313,6 +313,7 @@ static int devpts_remount(struct super_block *sb, int *flags, char *data)
 	struct pts_fs_info *fsi = DEVPTS_SB(sb);
 	struct pts_mount_opts *opts = &fsi->mount_opts;
 
+	sync_filesystem(sb);
 	err = parse_mount_options(data, PARSE_REMOUNT, opts);
 
 	/*
diff --git a/fs/ecryptfs/file.c b/fs/ecryptfs/file.c
index 9ff3664..4912bf4 100644
--- a/fs/ecryptfs/file.c
+++ b/fs/ecryptfs/file.c
@@ -68,6 +68,7 @@ static ssize_t ecryptfs_read_update_atime(struct kiocb *iocb,
 }
 
 struct ecryptfs_getdents_callback {
+	struct dir_context ctx;
 	void *dirent;
 	struct dentry *dentry;
 	filldir_t filldir;
@@ -115,18 +116,19 @@ static int ecryptfs_readdir(struct file *file, void *dirent, filldir_t filldir)
 	int rc;
 	struct file *lower_file;
 	struct inode *inode;
-	struct ecryptfs_getdents_callback buf;
+	struct ecryptfs_getdents_callback buf = {
+		.dirent = dirent,
+		.dentry = file->f_path.dentry,
+		.filldir = filldir,
+		.filldir_called = 0,
+		.entries_written = 0,
+		.ctx.actor = ecryptfs_filldir
+	};
 
 	lower_file = ecryptfs_file_to_lower(file);
 	lower_file->f_pos = file->f_pos;
 	inode = file_inode(file);
-	memset(&buf, 0, sizeof(buf));
-	buf.dirent = dirent;
-	buf.dentry = file->f_path.dentry;
-	buf.filldir = filldir;
-	buf.filldir_called = 0;
-	buf.entries_written = 0;
-	rc = vfs_readdir(lower_file, ecryptfs_filldir, (void *)&buf);
+	rc = iterate_dir(lower_file, &buf.ctx);
 	file->f_pos = lower_file->f_pos;
 	if (rc < 0)
 		goto out;
diff --git a/fs/efs/super.c b/fs/efs/super.c
index c6f57a7..4709692 100644
--- a/fs/efs/super.c
+++ b/fs/efs/super.c
@@ -113,6 +113,7 @@ static void efs_put_super(struct super_block *s)
 
 static int efs_remount(struct super_block *sb, int *flags, char *data)
 {
+	sync_filesystem(sb);
 	*flags |= MS_RDONLY;
 	return 0;
 }
diff --git a/fs/exportfs/expfs.c b/fs/exportfs/expfs.c
index 262fc99..43b448d 100644
--- a/fs/exportfs/expfs.c
+++ b/fs/exportfs/expfs.c
@@ -212,6 +212,7 @@ reconnect_path(struct vfsmount *mnt, struct dentry *target_dir, char *nbuf)
 }
 
 struct getdents_callback {
+	struct dir_context ctx;
 	char *name;		/* name that was found. It already points to a
 				   buffer NAME_MAX+1 is size */
 	unsigned long ino;	/* the inum we are looking for */
@@ -254,7 +255,11 @@ static int get_name(const struct path *path, char *name, struct dentry *child)
 	struct inode *dir = path->dentry->d_inode;
 	int error;
 	struct file *file;
-	struct getdents_callback buffer;
+	struct getdents_callback buffer = {
+		.ctx.actor = filldir_one,
+		.name = name,
+		.ino = child->d_inode->i_ino
+	};
 
 	error = -ENOTDIR;
 	if (!dir || !S_ISDIR(dir->i_mode))
@@ -271,17 +276,14 @@ static int get_name(const struct path *path, char *name, struct dentry *child)
 		goto out;
 
 	error = -EINVAL;
-	if (!file->f_op->readdir)
+	if (!file->f_op->readdir && !file->f_op->iterate)
 		goto out_close;
 
-	buffer.name = name;
-	buffer.ino = child->d_inode->i_ino;
-	buffer.found = 0;
 	buffer.sequence = 0;
 	while (1) {
 		int old_seq = buffer.sequence;
 
-		error = vfs_readdir(file, filldir_one, &buffer);
+		error = iterate_dir(file, &buffer.ctx);
 		if (buffer.found) {
 			error = 0;
 			break;
diff --git a/fs/ext2/super.c b/fs/ext2/super.c
index 20d6697..d260115 100644
--- a/fs/ext2/super.c
+++ b/fs/ext2/super.c
@@ -1254,6 +1254,7 @@ static int ext2_remount (struct super_block * sb, int * flags, char * data)
 	unsigned long old_sb_flags;
 	int err;
 
+	sync_filesystem(sb);
 	spin_lock(&sbi->s_lock);
 
 	/* Store the old options */
diff --git a/fs/ext3/super.c b/fs/ext3/super.c
index 882d4bd..b1e30be 100644
--- a/fs/ext3/super.c
+++ b/fs/ext3/super.c
@@ -2588,6 +2588,8 @@ static int ext3_remount (struct super_block * sb, int * flags, char * data)
 	int i;
 #endif
 
+	sync_filesystem(sb);
+
 	/* Store the original options */
 	old_sb_flags = sb->s_flags;
 	old_opts.s_mount_opt = sbi->s_mount_opt;
diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 6d1ffab..e5a77bb 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -589,6 +589,7 @@ enum {
 #define EXT4_FREE_BLOCKS_NO_QUOT_UPDATE	0x0008
 #define EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER	0x0010
 #define EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER	0x0020
+#define EXT4_FREE_BLOCKS_RESERVE		0x0040
 
 /*
  * Flags used by ext4_discard_partial_page_buffers
diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c
index 84d817b..7fbd1c5 100644
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@ -1722,7 +1722,8 @@ static void ext4_ext_try_to_merge_up(handle_t *handle,
 
 	brelse(path[1].p_bh);
 	ext4_free_blocks(handle, inode, NULL, blk, 1,
-			 EXT4_FREE_BLOCKS_METADATA | EXT4_FREE_BLOCKS_FORGET);
+			 EXT4_FREE_BLOCKS_METADATA | EXT4_FREE_BLOCKS_FORGET |
+			 EXT4_FREE_BLOCKS_RESERVE);
 }
 
 /*
diff --git a/fs/ext4/file.c b/fs/ext4/file.c
index 4635788..ec9770f 100644
--- a/fs/ext4/file.c
+++ b/fs/ext4/file.c
@@ -100,7 +100,7 @@ ext4_file_dio_write(struct kiocb *iocb, const struct iovec *iov,
 	struct blk_plug plug;
 	int unaligned_aio = 0;
 	ssize_t ret;
-	int overwrite = 0;
+	int *overwrite = iocb->private;
 	size_t length = iov_length(iov, nr_segs);
 
 	if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS) &&
@@ -118,8 +118,6 @@ ext4_file_dio_write(struct kiocb *iocb, const struct iovec *iov,
 	mutex_lock(&inode->i_mutex);
 	blk_start_plug(&plug);
 
-	iocb->private = &overwrite;
-
 	/* check whether we do a DIO overwrite or not */
 	if (ext4_should_dioread_nolock(inode) && !unaligned_aio &&
 	    !file->f_mapping->nrpages && pos + length <= i_size_read(inode)) {
@@ -143,7 +141,7 @@ ext4_file_dio_write(struct kiocb *iocb, const struct iovec *iov,
 		 * So we should check these two conditions.
 		 */
 		if (err == len && (map.m_flags & EXT4_MAP_MAPPED))
-			overwrite = 1;
+			*overwrite = 1;
 	}
 
 	ret = __generic_file_aio_write(iocb, iov, nr_segs, &iocb->ki_pos);
@@ -170,6 +168,7 @@ ext4_file_write(struct kiocb *iocb, const struct iovec *iov,
 {
 	struct inode *inode = file_inode(iocb->ki_filp);
 	ssize_t ret;
+	int overwrite = 0;
 
 	/*
 	 * If we have encountered a bitmap-format file, the size limit
@@ -190,6 +189,7 @@ ext4_file_write(struct kiocb *iocb, const struct iovec *iov,
 		}
 	}
 
+	iocb->private = &overwrite;
 	if (unlikely(iocb->ki_filp->f_flags & O_DIRECT))
 		ret = ext4_file_dio_write(iocb, iov, nr_segs, pos);
 	else
diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c
index 576155c..aed1a67 100644
--- a/fs/ext4/mballoc.c
+++ b/fs/ext4/mballoc.c
@@ -4611,6 +4611,7 @@ void ext4_free_blocks(handle_t *handle, struct inode *inode,
 	struct buffer_head *gd_bh;
 	ext4_group_t block_group;
 	struct ext4_sb_info *sbi;
+	struct ext4_inode_info *ei = EXT4_I(inode);
 	struct ext4_buddy e4b;
 	unsigned int count_clusters;
 	int err = 0;
@@ -4810,7 +4811,6 @@ do_more:
 	ext4_block_bitmap_csum_set(sb, block_group, gdp, bitmap_bh);
 	ext4_group_desc_csum_set(sb, block_group, gdp);
 	ext4_unlock_group(sb, block_group);
-	percpu_counter_add(&sbi->s_freeclusters_counter, count_clusters);
 
 	if (sbi->s_log_groups_per_flex) {
 		ext4_group_t flex_group = ext4_flex_group(sbi, block_group);
@@ -4818,10 +4818,23 @@ do_more:
 			     &sbi->s_flex_groups[flex_group].free_clusters);
 	}
 
-	ext4_mb_unload_buddy(&e4b);
-
-	if (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))
+	if (flags & EXT4_FREE_BLOCKS_RESERVE && ei->i_reserved_data_blocks) {
+		percpu_counter_add(&sbi->s_dirtyclusters_counter,
+				   count_clusters);
+		spin_lock(&ei->i_block_reservation_lock);
+		if (flags & EXT4_FREE_BLOCKS_METADATA)
+			ei->i_reserved_meta_blocks += count_clusters;
+		else
+			ei->i_reserved_data_blocks += count_clusters;
+		spin_unlock(&ei->i_block_reservation_lock);
+		if (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))
+			dquot_reclaim_block(inode,
+					EXT4_C2B(sbi, count_clusters));
+	} else if (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))
 		dquot_free_block(inode, EXT4_C2B(sbi, count_clusters));
+	percpu_counter_add(&sbi->s_freeclusters_counter, count_clusters);
+
+	ext4_mb_unload_buddy(&e4b);
 
 	/* We dirtied the bitmap block */
 	BUFFER_TRACE(bitmap_bh, "dirtied bitmap block");
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 0d81a73..0a29853 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -4623,6 +4623,8 @@ static int ext4_remount(struct super_block *sb, int *flags, char *data)
 #endif
 	char *orig_data = kstrdup(data, GFP_KERNEL);
 
+	sync_filesystem(sb);
+
 	/* Store the original options */
 	old_sb_flags = sb->s_flags;
 	old_opts.s_mount_opt = sbi->s_mount_opt;
diff --git a/fs/f2fs/super.c b/fs/f2fs/super.c
index 8555f7d..03ab8b8 100644
--- a/fs/f2fs/super.c
+++ b/fs/f2fs/super.c
@@ -239,7 +239,6 @@ static int f2fs_show_options(struct seq_file *seq, struct dentry *root)
 	if (test_opt(sbi, DISABLE_EXT_IDENTIFY))
 		seq_puts(seq, ",disable_ext_identify");
 
-	seq_printf(seq, ",active_logs=%u", sbi->active_logs);
 
 	return 0;
 }
diff --git a/fs/fat/inode.c b/fs/fat/inode.c
index 871ea6a..e69f87a 100644
--- a/fs/fat/inode.c
+++ b/fs/fat/inode.c
@@ -661,6 +661,8 @@ static int fat_remount(struct super_block *sb, int *flags, char *data)
 	struct msdos_sb_info *sbi = MSDOS_SB(sb);
 	*flags |= MS_NODIRATIME | (sbi->options.isvfat ? 0 : MS_NOATIME);
 
+	sync_filesystem(sb);
+
 	/* make sure we update state on remount. */
 	new_rdonly = *flags & MS_RDONLY;
 	if (new_rdonly != (sb->s_flags & MS_RDONLY)) {
diff --git a/fs/freevxfs/vxfs_super.c b/fs/freevxfs/vxfs_super.c
index e37eb27..7ca8c75 100644
--- a/fs/freevxfs/vxfs_super.c
+++ b/fs/freevxfs/vxfs_super.c
@@ -124,6 +124,7 @@ vxfs_statfs(struct dentry *dentry, struct kstatfs *bufp)
 
 static int vxfs_remount(struct super_block *sb, int *flags, char *data)
 {
+	sync_filesystem(sb);
 	*flags |= MS_RDONLY;
 	return 0;
 }
diff --git a/fs/fuse/inode.c b/fs/fuse/inode.c
index 04c0f35..fa4e8c5 100644
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@ -135,6 +135,7 @@ static void fuse_evict_inode(struct inode *inode)
 
 static int fuse_remount_fs(struct super_block *sb, int *flags, char *data)
 {
+	sync_filesystem(sb);
 	if (*flags & MS_MANDLOCK)
 		return -EINVAL;
 
diff --git a/fs/gfs2/export.c b/fs/gfs2/export.c
index 9973df4..7102c7a 100644
--- a/fs/gfs2/export.c
+++ b/fs/gfs2/export.c
@@ -88,7 +88,10 @@ static int gfs2_get_name(struct dentry *parent, char *name,
 	struct inode *dir = parent->d_inode;
 	struct inode *inode = child->d_inode;
 	struct gfs2_inode *dip, *ip;
-	struct get_name_filldir gnfd;
+	struct get_name_filldir gnfd = {
+		.ctx.actor = get_name_filldir,
+		.name = name
+	};
 	struct gfs2_holder gh;
 	u64 offset = 0;
 	int error;
@@ -106,7 +109,6 @@ static int gfs2_get_name(struct dentry *parent, char *name,
 	*name = 0;
 	gnfd.inum.no_addr = ip->i_no_addr;
 	gnfd.inum.no_formal_ino = ip->i_no_formal_ino;
-	gnfd.name = name;
 
 	error = gfs2_glock_nq_init(dip->i_gl, LM_ST_SHARED, 0, &gh);
 	if (error)
diff --git a/fs/gfs2/super.c b/fs/gfs2/super.c
index e5639de..db7fff5 100644
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@ -1142,6 +1142,8 @@ static int gfs2_remount_fs(struct super_block *sb, int *flags, char *data)
 	struct gfs2_tune *gt = &sdp->sd_tune;
 	int error;
 
+	sync_filesystem(sb);
+
 	spin_lock(&gt->gt_spin);
 	args.ar_commit = gt->gt_logd_secs;
 	args.ar_quota_quantum = gt->gt_quota_quantum;
diff --git a/fs/hfs/super.c b/fs/hfs/super.c
index 2d2039e..eee7206 100644
--- a/fs/hfs/super.c
+++ b/fs/hfs/super.c
@@ -112,6 +112,7 @@ static int hfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 
 static int hfs_remount(struct super_block *sb, int *flags, char *data)
 {
+	sync_filesystem(sb);
 	*flags |= MS_NODIRATIME;
 	if ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))
 		return 0;
diff --git a/fs/hfsplus/super.c b/fs/hfsplus/super.c
index 4c4d142..1b9414f 100644
--- a/fs/hfsplus/super.c
+++ b/fs/hfsplus/super.c
@@ -323,6 +323,7 @@ static int hfsplus_statfs(struct dentry *dentry, struct kstatfs *buf)
 
 static int hfsplus_remount(struct super_block *sb, int *flags, char *data)
 {
+	sync_filesystem(sb);
 	if ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))
 		return 0;
 	if (!(*flags & MS_RDONLY)) {
diff --git a/fs/hpfs/super.c b/fs/hpfs/super.c
index 962e90c..d37f6ff 100644
--- a/fs/hpfs/super.c
+++ b/fs/hpfs/super.c
@@ -395,6 +395,8 @@ static int hpfs_remount_fs(struct super_block *s, int *flags, char *data)
 	struct hpfs_sb_info *sbi = hpfs_sb(s);
 	char *new_opts = kstrdup(data, GFP_KERNEL);
 	
+	sync_filesystem(s);
+
 	*flags |= MS_NOATIME;
 	
 	hpfs_lock(s);
diff --git a/fs/jffs2/scan.c b/fs/jffs2/scan.c
index 7654e87..9ad5ba4 100644
--- a/fs/jffs2/scan.c
+++ b/fs/jffs2/scan.c
@@ -510,6 +510,10 @@ static int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblo
 				sumlen = c->sector_size - je32_to_cpu(sm->offset);
 				sumptr = buf + buf_size - sumlen;
 
+				/* sm->offset maybe wrong but MAGIC maybe right */
+				if (sumlen > c->sector_size)
+					goto full_scan;
+
 				/* Now, make sure the summary itself is available */
 				if (sumlen > buf_size) {
 					/* Need to kmalloc for this. */
@@ -544,6 +548,7 @@ static int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblo
 		}
 	}
 
+full_scan:
 	buf_ofs = jeb->offset;
 
 	if (!buf_size) {
diff --git a/fs/jffs2/super.c b/fs/jffs2/super.c
index 0defb1c..0918f0e 100644
--- a/fs/jffs2/super.c
+++ b/fs/jffs2/super.c
@@ -243,6 +243,7 @@ static int jffs2_remount_fs(struct super_block *sb, int *flags, char *data)
 	struct jffs2_sb_info *c = JFFS2_SB_INFO(sb);
 	int err;
 
+	sync_filesystem(sb);
 	err = jffs2_parse_options(c, data);
 	if (err)
 		return -EINVAL;
diff --git a/fs/jfs/super.c b/fs/jfs/super.c
index 788e0a9..b7486da 100644
--- a/fs/jfs/super.c
+++ b/fs/jfs/super.c
@@ -413,6 +413,7 @@ static int jfs_remount(struct super_block *sb, int *flags, char *data)
 	int flag = JFS_SBI(sb)->flag;
 	int ret;
 
+	sync_filesystem(sb);
 	if (!parse_options(data, sb, &newLVSize, &flag)) {
 		return -EINVAL;
 	}
diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 9c8a5a6..7a31848 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -137,10 +137,6 @@ lockd(void *vrqstp)
 
 	dprintk("NFS locking service started (ver " LOCKD_VERSION ").\n");
 
-	if (!nlm_timeout)
-		nlm_timeout = LOCKD_DFLT_TIMEO;
-	nlmsvc_timeout = nlm_timeout * HZ;
-
 	/*
 	 * The main request loop. We don't terminate until the last
 	 * NFS mount or NFS daemon has gone away.
@@ -346,6 +342,10 @@ static struct svc_serv *lockd_create_svc(void)
 		printk(KERN_WARNING
 			"lockd_up: no pid, %d users??\n", nlmsvc_users);
 
+	if (!nlm_timeout)
+		nlm_timeout = LOCKD_DFLT_TIMEO;
+	nlmsvc_timeout = nlm_timeout * HZ;
+
 	serv = svc_create(&nlmsvc_program, LOCKD_BUFSIZE, NULL);
 	if (!serv) {
 		printk(KERN_WARNING "lockd_up: create service failed\n");
diff --git a/fs/minix/inode.c b/fs/minix/inode.c
index df12249..a54d088 100644
--- a/fs/minix/inode.c
+++ b/fs/minix/inode.c
@@ -123,6 +123,7 @@ static int minix_remount (struct super_block * sb, int * flags, char * data)
 	struct minix_sb_info * sbi = minix_sb(sb);
 	struct minix_super_block * ms;
 
+	sync_filesystem(sb);
 	ms = sbi->s_ms;
 	if ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))
 		return 0;
diff --git a/fs/ncpfs/inode.c b/fs/ncpfs/inode.c
index 26910c8..3f54348 100644
--- a/fs/ncpfs/inode.c
+++ b/fs/ncpfs/inode.c
@@ -99,6 +99,7 @@ static void destroy_inodecache(void)
 
 static int ncp_remount(struct super_block *sb, int *flags, char* data)
 {
+	sync_filesystem(sb);
 	*flags |= MS_NODIRATIME;
 	return 0;
 }
diff --git a/fs/nfs/callback.c b/fs/nfs/callback.c
index cff089a..e05c96e 100644
--- a/fs/nfs/callback.c
+++ b/fs/nfs/callback.c
@@ -128,22 +128,24 @@ nfs41_callback_svc(void *vrqstp)
 		if (try_to_freeze())
 			continue;
 
-		prepare_to_wait(&serv->sv_cb_waitq, &wq, TASK_INTERRUPTIBLE);
+		prepare_to_wait(&serv->sv_cb_waitq, &wq, TASK_UNINTERRUPTIBLE);
 		spin_lock_bh(&serv->sv_cb_lock);
 		if (!list_empty(&serv->sv_cb_list)) {
 			req = list_first_entry(&serv->sv_cb_list,
 					struct rpc_rqst, rq_bc_list);
 			list_del(&req->rq_bc_list);
 			spin_unlock_bh(&serv->sv_cb_lock);
+			finish_wait(&serv->sv_cb_waitq, &wq);
 			dprintk("Invoking bc_svc_process()\n");
 			error = bc_svc_process(serv, req, rqstp);
 			dprintk("bc_svc_process() returned w/ error code= %d\n",
 				error);
 		} else {
 			spin_unlock_bh(&serv->sv_cb_lock);
-			schedule();
+			/* schedule_timeout to game the hung task watchdog */
+			schedule_timeout(60 * HZ);
+			finish_wait(&serv->sv_cb_waitq, &wq);
 		}
-		finish_wait(&serv->sv_cb_waitq, &wq);
 	}
 	return 0;
 }
diff --git a/fs/nfs/callback_xdr.c b/fs/nfs/callback_xdr.c
index a35582c..e98ecf8 100644
--- a/fs/nfs/callback_xdr.c
+++ b/fs/nfs/callback_xdr.c
@@ -464,8 +464,10 @@ static __be32 decode_cb_sequence_args(struct svc_rqst *rqstp,
 
 		for (i = 0; i < args->csa_nrclists; i++) {
 			status = decode_rc_list(xdr, &args->csa_rclists[i]);
-			if (status)
+			if (status) {
+				args->csa_nrclists = i;
 				goto out_free;
+			}
 		}
 	}
 	status = 0;
diff --git a/fs/nfs/direct.c b/fs/nfs/direct.c
index 725e875..615c507 100644
--- a/fs/nfs/direct.c
+++ b/fs/nfs/direct.c
@@ -123,6 +123,12 @@ static inline int put_dreq(struct nfs_direct_req *dreq)
  */
 ssize_t nfs_direct_IO(int rw, struct kiocb *iocb, const struct iovec *iov, loff_t pos, unsigned long nr_segs)
 {
+	struct inode *inode = iocb->ki_filp->f_mapping->host;
+
+	/* we only support swap file calling nfs_direct_IO */
+	if (!IS_SWAPFILE(inode))
+		return 0;
+
 #ifndef CONFIG_NFS_SWAP
 	dprintk("NFS: nfs_direct_IO (%s) off/no(%Ld/%lu) EINVAL\n",
 			iocb->ki_filp->f_path.dentry->d_name.name,
diff --git a/fs/nfs/nfs4client.c b/fs/nfs/nfs4client.c
index cc143ee..5f8d5ff 100644
--- a/fs/nfs/nfs4client.c
+++ b/fs/nfs/nfs4client.c
@@ -394,20 +394,14 @@ static bool nfs4_match_clientids(struct nfs_client *a, struct nfs_client *b)
 }
 
 /*
- * Returns true if the server owners match
+ * Returns true if the server major ids match
  */
 static bool
-nfs4_match_serverowners(struct nfs_client *a, struct nfs_client *b)
+nfs4_check_clientid_trunking(struct nfs_client *a, struct nfs_client *b)
 {
 	struct nfs41_server_owner *o1 = a->cl_serverowner;
 	struct nfs41_server_owner *o2 = b->cl_serverowner;
 
-	if (o1->minor_id != o2->minor_id) {
-		dprintk("NFS: --> %s server owner minor IDs do not match\n",
-			__func__);
-		return false;
-	}
-
 	if (o1->major_id_sz != o2->major_id_sz)
 		goto out_major_mismatch;
 	if (memcmp(o1->major_id, o2->major_id, o1->major_id_sz) != 0)
@@ -468,7 +462,7 @@ int nfs41_walk_client_list(struct nfs_client *new,
 			prev = pos;
 
 			status = nfs_wait_client_init_complete(pos);
-			if (status == 0) {
+			if (pos->cl_cons_state == NFS_CS_SESSION_INITING) {
 				nfs4_schedule_lease_recovery(pos);
 				status = nfs4_wait_clnt_recover(pos);
 			}
@@ -483,7 +477,12 @@ int nfs41_walk_client_list(struct nfs_client *new,
 		if (!nfs4_match_clientids(pos, new))
 			continue;
 
-		if (!nfs4_match_serverowners(pos, new))
+		/*
+		 * Note that session trunking is just a special subcase of
+		 * client id trunking. In either case, we want to fall back
+		 * to using the existing nfs_client.
+		 */
+		if (!nfs4_check_clientid_trunking(pos, new))
 			continue;
 
 		atomic_inc(&pos->cl_count);
diff --git a/fs/nfs/super.c b/fs/nfs/super.c
index 2d7525f..d85c1b8 100644
--- a/fs/nfs/super.c
+++ b/fs/nfs/super.c
@@ -2133,6 +2133,8 @@ nfs_remount(struct super_block *sb, int *flags, char *raw_data)
 	struct nfs4_mount_data *options4 = (struct nfs4_mount_data *)raw_data;
 	u32 nfsvers = nfss->nfs_client->rpc_ops->version;
 
+	sync_filesystem(sb);
+
 	/*
 	 * Userspace mount programs that send binary options generally send
 	 * them populated with default values. We have no way to know which
diff --git a/fs/nfsd/nfs4recover.c b/fs/nfsd/nfs4recover.c
index 4e9a21d..105a3b0 100644
--- a/fs/nfsd/nfs4recover.c
+++ b/fs/nfsd/nfs4recover.c
@@ -240,11 +240,16 @@ struct name_list {
 	struct list_head list;
 };
 
+struct nfs4_dir_ctx {
+	struct dir_context ctx;
+	struct list_head names;
+};
+
 static int
 nfsd4_build_namelist(void *arg, const char *name, int namlen,
 		loff_t offset, u64 ino, unsigned int d_type)
 {
-	struct list_head *names = arg;
+	struct nfs4_dir_ctx *ctx = arg;
 	struct name_list *entry;
 
 	if (namlen != HEXDIR_LEN - 1)
@@ -254,7 +259,7 @@ nfsd4_build_namelist(void *arg, const char *name, int namlen,
 		return -ENOMEM;
 	memcpy(entry->name, name, HEXDIR_LEN - 1);
 	entry->name[HEXDIR_LEN - 1] = '\0';
-	list_add(&entry->list, names);
+	list_add(&entry->list, &ctx->names);
 	return 0;
 }
 
@@ -263,7 +268,10 @@ nfsd4_list_rec_dir(recdir_func *f, struct nfsd_net *nn)
 {
 	const struct cred *original_cred;
 	struct dentry *dir = nn->rec_file->f_path.dentry;
-	LIST_HEAD(names);
+	struct nfs4_dir_ctx ctx = {
+		.ctx.actor = nfsd4_build_namelist,
+		.names = LIST_HEAD_INIT(ctx.names)
+	};
 	int status;
 
 	status = nfs4_save_creds(&original_cred);
@@ -276,11 +284,11 @@ nfsd4_list_rec_dir(recdir_func *f, struct nfsd_net *nn)
 		return status;
 	}
 
-	status = vfs_readdir(nn->rec_file, nfsd4_build_namelist, &names);
+	status = iterate_dir(nn->rec_file, &ctx.ctx);
 	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);
-	while (!list_empty(&names)) {
+	while (!list_empty(&ctx.names)) {
 		struct name_list *entry;
-		entry = list_entry(names.next, struct name_list, list);
+		entry = list_entry(ctx.names.next, struct name_list, list);
 		if (!status) {
 			struct dentry *dentry;
 			dentry = lookup_one_len(entry->name, dir, HEXDIR_LEN-1);
diff --git a/fs/nfsd/vfs.c b/fs/nfsd/vfs.c
index 81325ba..11224fa 100644
--- a/fs/nfsd/vfs.c
+++ b/fs/nfsd/vfs.c
@@ -1950,6 +1950,7 @@ struct buffered_dirent {
 };
 
 struct readdir_data {
+	struct dir_context ctx;
 	char		*dirent;
 	size_t		used;
 	int		full;
@@ -1981,13 +1982,15 @@ static int nfsd_buffered_filldir(void *__buf, const char *name, int namlen,
 static __be32 nfsd_buffered_readdir(struct file *file, filldir_t func,
 				    struct readdir_cd *cdp, loff_t *offsetp)
 {
-	struct readdir_data buf;
 	struct buffered_dirent *de;
 	int host_err;
 	int size;
 	loff_t offset;
+	struct readdir_data buf = {
+		.ctx.actor = nfsd_buffered_filldir,
+		.dirent = (void *)__get_free_page(GFP_KERNEL)
+	};
 
-	buf.dirent = (void *)__get_free_page(GFP_KERNEL);
 	if (!buf.dirent)
 		return nfserrno(-ENOMEM);
 
@@ -2001,7 +2004,7 @@ static __be32 nfsd_buffered_readdir(struct file *file, filldir_t func,
 		buf.used = 0;
 		buf.full = 0;
 
-		host_err = vfs_readdir(file, nfsd_buffered_filldir, &buf);
+		host_err = iterate_dir(file, &buf.ctx);
 		if (buf.full)
 			host_err = 0;
 
diff --git a/fs/nilfs2/btree.c b/fs/nilfs2/btree.c
index b2e3ff3..ecdbae1 100644
--- a/fs/nilfs2/btree.c
+++ b/fs/nilfs2/btree.c
@@ -31,6 +31,8 @@
 #include "alloc.h"
 #include "dat.h"
 
+static void __nilfs_btree_init(struct nilfs_bmap *bmap);
+
 static struct nilfs_btree_path *nilfs_btree_alloc_path(void)
 {
 	struct nilfs_btree_path *path;
@@ -368,6 +370,34 @@ static int nilfs_btree_node_broken(const struct nilfs_btree_node *node,
 	return ret;
 }
 
+/**
+ * nilfs_btree_root_broken - verify consistency of btree root node
+ * @node: btree root node to be examined
+ * @ino: inode number
+ *
+ * Return Value: If node is broken, 1 is returned. Otherwise, 0 is returned.
+ */
+static int nilfs_btree_root_broken(const struct nilfs_btree_node *node,
+				   unsigned long ino)
+{
+	int level, flags, nchildren;
+	int ret = 0;
+
+	level = nilfs_btree_node_get_level(node);
+	flags = nilfs_btree_node_get_flags(node);
+	nchildren = nilfs_btree_node_get_nchildren(node);
+
+	if (unlikely(level < NILFS_BTREE_LEVEL_NODE_MIN ||
+		     level > NILFS_BTREE_LEVEL_MAX ||
+		     nchildren < 0 ||
+		     nchildren > NILFS_BTREE_ROOT_NCHILDREN_MAX)) {
+		pr_crit("NILFS: bad btree root (inode number=%lu): level = %d, flags = 0x%x, nchildren = %d\n",
+			ino, level, flags, nchildren);
+		ret = 1;
+	}
+	return ret;
+}
+
 int nilfs_btree_broken_node_block(struct buffer_head *bh)
 {
 	int ret;
@@ -1713,7 +1743,7 @@ nilfs_btree_commit_convert_and_insert(struct nilfs_bmap *btree,
 
 	/* convert and insert */
 	dat = NILFS_BMAP_USE_VBN(btree) ? nilfs_bmap_get_dat(btree) : NULL;
-	nilfs_btree_init(btree);
+	__nilfs_btree_init(btree);
 	if (nreq != NULL) {
 		nilfs_bmap_commit_alloc_ptr(btree, dreq, dat);
 		nilfs_bmap_commit_alloc_ptr(btree, nreq, dat);
@@ -2294,12 +2324,23 @@ static const struct nilfs_bmap_operations nilfs_btree_ops_gc = {
 	.bop_gather_data	=	NULL,
 };
 
-int nilfs_btree_init(struct nilfs_bmap *bmap)
+static void __nilfs_btree_init(struct nilfs_bmap *bmap)
 {
 	bmap->b_ops = &nilfs_btree_ops;
 	bmap->b_nchildren_per_block =
 		NILFS_BTREE_NODE_NCHILDREN_MAX(nilfs_btree_node_size(bmap));
-	return 0;
+}
+
+int nilfs_btree_init(struct nilfs_bmap *bmap)
+{
+	int ret = 0;
+
+	__nilfs_btree_init(bmap);
+
+	if (nilfs_btree_root_broken(nilfs_btree_get_root(bmap),
+				    bmap->b_inode->i_ino))
+		ret = -EIO;
+	return ret;
 }
 
 void nilfs_btree_init_gc(struct nilfs_bmap *bmap)
diff --git a/fs/nilfs2/nilfs.h b/fs/nilfs2/nilfs.h
index 9bc72de..b02c202 100644
--- a/fs/nilfs2/nilfs.h
+++ b/fs/nilfs2/nilfs.h
@@ -141,7 +141,6 @@ enum {
  * @ti_save: Backup of journal_info field of task_struct
  * @ti_flags: Flags
  * @ti_count: Nest level
- * @ti_garbage:	List of inode to be put when releasing semaphore
  */
 struct nilfs_transaction_info {
 	u32			ti_magic;
@@ -150,7 +149,6 @@ struct nilfs_transaction_info {
 				   one of other filesystems has a bug. */
 	unsigned short		ti_flags;
 	unsigned short		ti_count;
-	struct list_head	ti_garbage;
 };
 
 /* ti_magic */
diff --git a/fs/nilfs2/segment.c b/fs/nilfs2/segment.c
index 9264144..c7b726c 100644
--- a/fs/nilfs2/segment.c
+++ b/fs/nilfs2/segment.c
@@ -305,7 +305,6 @@ static void nilfs_transaction_lock(struct super_block *sb,
 	ti->ti_count = 0;
 	ti->ti_save = cur_ti;
 	ti->ti_magic = NILFS_TI_MAGIC;
-	INIT_LIST_HEAD(&ti->ti_garbage);
 	current->journal_info = ti;
 
 	for (;;) {
@@ -332,8 +331,6 @@ static void nilfs_transaction_unlock(struct super_block *sb)
 
 	up_write(&nilfs->ns_segctor_sem);
 	current->journal_info = ti->ti_save;
-	if (!list_empty(&ti->ti_garbage))
-		nilfs_dispose_list(nilfs, &ti->ti_garbage, 0);
 }
 
 static void *nilfs_segctor_map_segsum_entry(struct nilfs_sc_info *sci,
@@ -746,6 +743,15 @@ static void nilfs_dispose_list(struct the_nilfs *nilfs,
 	}
 }
 
+static void nilfs_iput_work_func(struct work_struct *work)
+{
+	struct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,
+						 sc_iput_work);
+	struct the_nilfs *nilfs = sci->sc_super->s_fs_info;
+
+	nilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);
+}
+
 static int nilfs_test_metadata_dirty(struct the_nilfs *nilfs,
 				     struct nilfs_root *root)
 {
@@ -1899,8 +1905,8 @@ static int nilfs_segctor_collect_dirty_files(struct nilfs_sc_info *sci,
 static void nilfs_segctor_drop_written_files(struct nilfs_sc_info *sci,
 					     struct the_nilfs *nilfs)
 {
-	struct nilfs_transaction_info *ti = current->journal_info;
 	struct nilfs_inode_info *ii, *n;
+	int defer_iput = false;
 
 	spin_lock(&nilfs->ns_inode_lock);
 	list_for_each_entry_safe(ii, n, &sci->sc_dirty_files, i_dirty) {
@@ -1911,9 +1917,24 @@ static void nilfs_segctor_drop_written_files(struct nilfs_sc_info *sci,
 		clear_bit(NILFS_I_BUSY, &ii->i_state);
 		brelse(ii->i_bh);
 		ii->i_bh = NULL;
-		list_move_tail(&ii->i_dirty, &ti->ti_garbage);
+		list_del_init(&ii->i_dirty);
+		if (!ii->vfs_inode.i_nlink) {
+			/*
+			 * Defer calling iput() to avoid a deadlock
+			 * over I_SYNC flag for inodes with i_nlink == 0
+			 */
+			list_add_tail(&ii->i_dirty, &sci->sc_iput_queue);
+			defer_iput = true;
+		} else {
+			spin_unlock(&nilfs->ns_inode_lock);
+			iput(&ii->vfs_inode);
+			spin_lock(&nilfs->ns_inode_lock);
+		}
 	}
 	spin_unlock(&nilfs->ns_inode_lock);
+
+	if (defer_iput)
+		schedule_work(&sci->sc_iput_work);
 }
 
 /*
@@ -2582,6 +2603,8 @@ static struct nilfs_sc_info *nilfs_segctor_new(struct super_block *sb,
 	INIT_LIST_HEAD(&sci->sc_segbufs);
 	INIT_LIST_HEAD(&sci->sc_write_logs);
 	INIT_LIST_HEAD(&sci->sc_gc_inodes);
+	INIT_LIST_HEAD(&sci->sc_iput_queue);
+	INIT_WORK(&sci->sc_iput_work, nilfs_iput_work_func);
 	init_timer(&sci->sc_timer);
 
 	sci->sc_interval = HZ * NILFS_SC_DEFAULT_TIMEOUT;
@@ -2608,6 +2631,8 @@ static void nilfs_segctor_write_out(struct nilfs_sc_info *sci)
 		ret = nilfs_segctor_construct(sci, SC_LSEG_SR);
 		nilfs_transaction_unlock(sci->sc_super);
 
+		flush_work(&sci->sc_iput_work);
+
 	} while (ret && retrycount-- > 0);
 }
 
@@ -2632,6 +2657,9 @@ static void nilfs_segctor_destroy(struct nilfs_sc_info *sci)
 		|| sci->sc_seq_request != sci->sc_seq_done);
 	spin_unlock(&sci->sc_state_lock);
 
+	if (flush_work(&sci->sc_iput_work))
+		flag = true;
+
 	if (flag || !nilfs_segctor_confirm(sci))
 		nilfs_segctor_write_out(sci);
 
@@ -2641,6 +2669,12 @@ static void nilfs_segctor_destroy(struct nilfs_sc_info *sci)
 		nilfs_dispose_list(nilfs, &sci->sc_dirty_files, 1);
 	}
 
+	if (!list_empty(&sci->sc_iput_queue)) {
+		nilfs_warning(sci->sc_super, __func__,
+			      "iput queue is not empty\n");
+		nilfs_dispose_list(nilfs, &sci->sc_iput_queue, 1);
+	}
+
 	WARN_ON(!list_empty(&sci->sc_segbufs));
 	WARN_ON(!list_empty(&sci->sc_write_logs));
 
diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index 38a1d00..a48d6de 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -26,6 +26,7 @@
 #include <linux/types.h>
 #include <linux/fs.h>
 #include <linux/buffer_head.h>
+#include <linux/workqueue.h>
 #include <linux/nilfs2_fs.h>
 #include "nilfs.h"
 
@@ -92,6 +93,8 @@ struct nilfs_segsum_pointer {
  * @sc_nblk_inc: Block count of current generation
  * @sc_dirty_files: List of files to be written
  * @sc_gc_inodes: List of GC inodes having blocks to be written
+ * @sc_iput_queue: list of inodes for which iput should be done
+ * @sc_iput_work: work struct to defer iput call
  * @sc_freesegs: array of segment numbers to be freed
  * @sc_nfreesegs: number of segments on @sc_freesegs
  * @sc_dsync_inode: inode whose data pages are written for a sync operation
@@ -135,6 +138,8 @@ struct nilfs_sc_info {
 
 	struct list_head	sc_dirty_files;
 	struct list_head	sc_gc_inodes;
+	struct list_head	sc_iput_queue;
+	struct work_struct	sc_iput_work;
 
 	__u64		       *sc_freesegs;
 	size_t			sc_nfreesegs;
diff --git a/fs/nilfs2/super.c b/fs/nilfs2/super.c
index c7d1f9f..4b0a8d4 100644
--- a/fs/nilfs2/super.c
+++ b/fs/nilfs2/super.c
@@ -1114,6 +1114,7 @@ static int nilfs_remount(struct super_block *sb, int *flags, char *data)
 	unsigned long old_mount_opt;
 	int err;
 
+	sync_filesystem(sb);
 	old_sb_flags = sb->s_flags;
 	old_mount_opt = nilfs->ns_mount_opt;
 
diff --git a/fs/notify/inode_mark.c b/fs/notify/inode_mark.c
index 74825be..fbb9dfb 100644
--- a/fs/notify/inode_mark.c
+++ b/fs/notify/inode_mark.c
@@ -288,20 +288,25 @@ void fsnotify_unmount_inodes(struct list_head *list)
 		spin_unlock(&inode->i_lock);
 
 		/* In case the dropping of a reference would nuke next_i. */
-		if ((&next_i->i_sb_list != list) &&
-		    atomic_read(&next_i->i_count)) {
+		while (&next_i->i_sb_list != list) {
 			spin_lock(&next_i->i_lock);
-			if (!(next_i->i_state & (I_FREEING | I_WILL_FREE))) {
+			if (!(next_i->i_state & (I_FREEING | I_WILL_FREE)) &&
+						atomic_read(&next_i->i_count)) {
 				__iget(next_i);
 				need_iput = next_i;
+				spin_unlock(&next_i->i_lock);
+				break;
 			}
 			spin_unlock(&next_i->i_lock);
+			next_i = list_entry(next_i->i_sb_list.next,
+						struct inode, i_sb_list);
 		}
 
 		/*
-		 * We can safely drop inode_sb_list_lock here because we hold
-		 * references on both inode and next_i.  Also no new inodes
-		 * will be added since the umount has begun.
+		 * We can safely drop inode_sb_list_lock here because either
+		 * we actually hold references on both inode and next_i or
+		 * end of list.  Also no new inodes will be added since the
+		 * umount has begun.
 		 */
 		spin_unlock(&inode_sb_list_lock);
 
diff --git a/fs/ntfs/super.c b/fs/ntfs/super.c
index 82650d5..bd5610d 100644
--- a/fs/ntfs/super.c
+++ b/fs/ntfs/super.c
@@ -468,6 +468,8 @@ static int ntfs_remount(struct super_block *sb, int *flags, char *opt)
 
 	ntfs_debug("Entering with remount options string: %s", opt);
 
+	sync_filesystem(sb);
+
 #ifndef NTFS_RW
 	/* For read-only compiled driver, enforce read-only flag. */
 	*flags |= MS_RDONLY;
diff --git a/fs/ocfs2/super.c b/fs/ocfs2/super.c
index 01b8516..616bde6 100644
--- a/fs/ocfs2/super.c
+++ b/fs/ocfs2/super.c
@@ -632,6 +632,8 @@ static int ocfs2_remount(struct super_block *sb, int *flags, char *data)
 	struct ocfs2_super *osb = OCFS2_SB(sb);
 	u32 tmp;
 
+	sync_filesystem(sb);
+
 	if (!ocfs2_parse_options(sb, data, &parsed_options, 1) ||
 	    !ocfs2_check_set_options(sb, &parsed_options)) {
 		ret = -EINVAL;
diff --git a/fs/openpromfs/inode.c b/fs/openpromfs/inode.c
index 75885ff..f4026ab 100644
--- a/fs/openpromfs/inode.c
+++ b/fs/openpromfs/inode.c
@@ -375,6 +375,7 @@ static struct inode *openprom_iget(struct super_block *sb, ino_t ino)
 
 static int openprom_remount(struct super_block *sb, int *flags, char *data)
 {
+	sync_filesystem(sb);
 	*flags |= MS_NOATIME;
 	return 0;
 }
diff --git a/fs/proc/base.c b/fs/proc/base.c
index dc4c076..1151268 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -139,12 +139,6 @@ struct pid_entry {
 		NULL, &proc_single_file_operations,	\
 		{ .proc_show = show } )
 
-/* ANDROID is for special files in /proc. */
-#define ANDROID(NAME, MODE, OTYPE)			\
-	NOD(NAME, (S_IFREG|(MODE)),			\
-		&proc_##OTYPE##_inode_operations,	\
-		&proc_##OTYPE##_operations, {})
-
 /*
  * Count the number of hardlinks for the pid_entry table, excluding the .
  * and .. links.
@@ -1006,35 +1000,6 @@ out:
 	return err < 0 ? err : count;
 }
 
-static int oom_adjust_permission(struct inode *inode, int mask)
-{
-	uid_t uid;
-	struct task_struct *p;
-
-	p = get_proc_task(inode);
-	if(p) {
-		uid = task_uid(p);
-		put_task_struct(p);
-	}
-
-	/*
-	 * System Server (uid == 1000) is granted access to oom_adj of all 
-	 * android applications (uid > 10000) as and services (uid >= 1000)
-	 */
-	if (p && (current_fsuid() == 1000) && (uid >= 1000)) {
-		if (inode->i_mode >> 6 & mask) {
-			return 0;
-		}
-	}
-
-	/* Fall back to default. */
-	return generic_permission(inode, mask);
-}
-
-static const struct inode_operations proc_oom_adj_inode_operations = {
-	.permission	= oom_adjust_permission,
-};
-
 static const struct file_operations proc_oom_adj_operations = {
 	.read		= oom_adj_read,
 	.write		= oom_adj_write,
@@ -2784,8 +2749,8 @@ static const struct pid_entry tgid_base_stuff[] = {
 	REG("cgroup",  S_IRUGO, proc_cgroup_operations),
 #endif
 	INF("oom_score",  S_IRUGO, proc_oom_score),
-	ANDROID("oom_adj", S_IRUGO|S_IWUSR, oom_adj),
-	REG("oom_score_adj", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),
+	REG("oom_adj",    S_IRUSR, proc_oom_adj_operations),
+	REG("oom_score_adj", S_IRUSR, proc_oom_score_adj_operations),
 #ifdef CONFIG_AUDITSYSCALL
 	REG("loginuid",   S_IWUSR|S_IRUGO, proc_loginuid_operations),
 	REG("sessionid",  S_IRUGO, proc_sessionid_operations),
@@ -3141,8 +3106,8 @@ static const struct pid_entry tid_base_stuff[] = {
 	REG("cgroup",  S_IRUGO, proc_cgroup_operations),
 #endif
 	INF("oom_score", S_IRUGO, proc_oom_score),
-	REG("oom_adj",   S_IRUGO|S_IWUSR, proc_oom_adj_operations),
-	REG("oom_score_adj", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),
+	REG("oom_adj",   S_IRUSR, proc_oom_adj_operations),
+	REG("oom_score_adj", S_IRUSR, proc_oom_score_adj_operations),
 #ifdef CONFIG_AUDITSYSCALL
 	REG("loginuid",  S_IWUSR|S_IRUGO, proc_loginuid_operations),
 	REG("sessionid",  S_IRUGO, proc_sessionid_operations),
diff --git a/fs/proc/generic.c b/fs/proc/generic.c
index a2596af..846b1d7 100644
--- a/fs/proc/generic.c
+++ b/fs/proc/generic.c
@@ -19,7 +19,6 @@
 #include <linux/mount.h>
 #include <linux/init.h>
 #include <linux/idr.h>
-#include <linux/namei.h>
 #include <linux/bitops.h>
 #include <linux/spinlock.h>
 #include <linux/completion.h>
@@ -163,17 +162,6 @@ void proc_free_inum(unsigned int inum)
 	spin_unlock_irqrestore(&proc_inum_lock, flags);
 }
 
-static void *proc_follow_link(struct dentry *dentry, struct nameidata *nd)
-{
-	nd_set_link(nd, __PDE_DATA(dentry->d_inode));
-	return NULL;
-}
-
-static const struct inode_operations proc_link_inode_operations = {
-	.readlink	= generic_readlink,
-	.follow_link	= proc_follow_link,
-};
-
 /*
  * As some entries in /proc are volatile, we want to 
  * get rid of unused dentries.  This could be made 
diff --git a/fs/proc/inode.c b/fs/proc/inode.c
index 073aea6..843b8ef 100644
--- a/fs/proc/inode.c
+++ b/fs/proc/inode.c
@@ -23,6 +23,7 @@
 #include <linux/slab.h>
 #include <linux/mount.h>
 #include <linux/magic.h>
+#include <linux/namei.h>
 
 #include <asm/uaccess.h>
 
@@ -373,6 +374,26 @@ static const struct file_operations proc_reg_file_ops_no_compat = {
 };
 #endif
 
+static void *proc_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	struct proc_dir_entry *pde = PDE(dentry->d_inode);
+	if (unlikely(!use_pde(pde)))
+		return ERR_PTR(-EINVAL);
+	nd_set_link(nd, pde->data);
+	return pde;
+}
+
+static void proc_put_link(struct dentry *dentry, struct nameidata *nd, void *p)
+{
+	unuse_pde(p);
+}
+
+const struct inode_operations proc_link_inode_operations = {
+	.readlink	= generic_readlink,
+	.follow_link	= proc_follow_link,
+	.put_link	= proc_put_link,
+};
+
 struct inode *proc_get_inode(struct super_block *sb, struct proc_dir_entry *de)
 {
 	struct inode *inode = new_inode_pseudo(sb);
diff --git a/fs/proc/internal.h b/fs/proc/internal.h
index d600fb0..ec335ef 100644
--- a/fs/proc/internal.h
+++ b/fs/proc/internal.h
@@ -202,6 +202,7 @@ struct pde_opener {
 	int closing;
 	struct completion *c;
 };
+extern const struct inode_operations proc_link_inode_operations;
 
 extern const struct inode_operations proc_pid_link_inode_operations;
 
diff --git a/fs/proc/root.c b/fs/proc/root.c
index 04ec276..3df19e6 100644
--- a/fs/proc/root.c
+++ b/fs/proc/root.c
@@ -92,6 +92,8 @@ static int proc_parse_options(char *options, struct pid_namespace *pid)
 int proc_remount(struct super_block *sb, int *flags, char *data)
 {
 	struct pid_namespace *pid = sb->s_fs_info;
+
+	sync_filesystem(sb);
 	return !proc_parse_options(data, pid);
 }
 
diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c
index eebdc27..e75f785 100644
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@ -833,6 +833,7 @@ static int clear_refs_pte_range(pmd_t *pmd, unsigned long addr,
 #define CLEAR_REFS_ALL 1
 #define CLEAR_REFS_ANON 2
 #define CLEAR_REFS_MAPPED 3
+#define CLEAR_REFS_MM_HIWATER_RSS 5
 
 static ssize_t clear_refs_write(struct file *file, const char __user *buf,
 				size_t count, loff_t *ppos)
@@ -852,7 +853,8 @@ static ssize_t clear_refs_write(struct file *file, const char __user *buf,
 	rv = kstrtoint(strstrip(buffer), 10, &type);
 	if (rv < 0)
 		return rv;
-	if (type < CLEAR_REFS_ALL || type > CLEAR_REFS_MAPPED)
+	if ((type < CLEAR_REFS_ALL || type > CLEAR_REFS_MAPPED) &&
+	    type != CLEAR_REFS_MM_HIWATER_RSS)
 		return -EINVAL;
 	task = get_proc_task(file_inode(file));
 	if (!task)
@@ -863,6 +865,18 @@ static ssize_t clear_refs_write(struct file *file, const char __user *buf,
 			.pmd_entry = clear_refs_pte_range,
 			.mm = mm,
 		};
+
+		if (type == CLEAR_REFS_MM_HIWATER_RSS) {
+			/*
+			 * Writing 5 to /proc/pid/clear_refs resets the peak
+			 * resident set size to this mm's current rss value.
+			 */
+			down_write(&mm->mmap_sem);
+			reset_mm_hiwater_rss(mm);
+			up_write(&mm->mmap_sem);
+			goto out_mm;
+		}
+
 		down_read(&mm->mmap_sem);
 		for (vma = mm->mmap; vma; vma = vma->vm_next) {
 			clear_refs_walk.private = vma;
@@ -886,6 +900,7 @@ static ssize_t clear_refs_write(struct file *file, const char __user *buf,
 		}
 		flush_tlb_mm(mm);
 		up_read(&mm->mmap_sem);
+out_mm:
 		mmput(mm);
 	}
 	put_task_struct(task);
diff --git a/fs/pstore/inode.c b/fs/pstore/inode.c
index 45286da..a3d6a4b 100644
--- a/fs/pstore/inode.c
+++ b/fs/pstore/inode.c
@@ -178,6 +178,8 @@ static int pstore_unlink(struct inode *dir, struct dentry *dentry)
 	if (p->psi->erase)
 		p->psi->erase(p->type, p->id, p->count,
 			      dentry->d_inode->i_ctime, p->psi);
+	else
+		return -EPERM;
 
 	return simple_unlink(dir, dentry);
 }
@@ -247,6 +249,7 @@ static void parse_options(char *options)
 
 static int pstore_remount(struct super_block *sb, int *flags, char *data)
 {
+	sync_filesystem(sb);
 	parse_options(data);
 
 	return 0;
@@ -338,9 +341,8 @@ int pstore_mkfile(enum pstore_type_id type, char *psname, u64 id, int count,
 
 	mutex_lock(&root->d_inode->i_mutex);
 
-	rc = -ENOSPC;
 	dentry = d_alloc_name(root, name);
-	if (IS_ERR(dentry))
+	if (!dentry)
 		goto fail_lockedalloc;
 
 	memcpy(private->data, data, size);
diff --git a/fs/pstore/ram.c b/fs/pstore/ram.c
index d414d51..f721e47 100644
--- a/fs/pstore/ram.c
+++ b/fs/pstore/ram.c
@@ -133,13 +133,15 @@ ramoops_get_next_prz(struct persistent_ram_zone *przs[], uint *c, uint max,
 		return NULL;
 
 	prz = przs[i];
+	if (!prz)
+		return NULL;
 
-	if (update) {
-		/* Update old/shadowed buffer. */
+	/* Update old/shadowed buffer. */
+	if (update)
 		persistent_ram_save_old(prz);
-		if (!persistent_ram_old_size(prz))
-			return NULL;
-	}
+
+	if (!persistent_ram_old_size(prz))
+		return NULL;
 
 	*typep = type;
 	*id = i;
diff --git a/fs/pstore/ram_core.c b/fs/pstore/ram_core.c
index 6ff9755..bda61a7 100644
--- a/fs/pstore/ram_core.c
+++ b/fs/pstore/ram_core.c
@@ -46,7 +46,7 @@ static inline size_t buffer_start(struct persistent_ram_zone *prz)
 }
 
 /* increase and wrap the start pointer, returning the old value */
-static inline size_t buffer_start_add(struct persistent_ram_zone *prz, size_t a)
+static size_t buffer_start_add_atomic(struct persistent_ram_zone *prz, size_t a)
 {
 	int old;
 	int new;
@@ -62,7 +62,7 @@ static inline size_t buffer_start_add(struct persistent_ram_zone *prz, size_t a)
 }
 
 /* increase the size counter until it hits the max size */
-static inline void buffer_size_add(struct persistent_ram_zone *prz, size_t a)
+static void buffer_size_add_atomic(struct persistent_ram_zone *prz, size_t a)
 {
 	size_t old;
 	size_t new;
@@ -78,6 +78,53 @@ static inline void buffer_size_add(struct persistent_ram_zone *prz, size_t a)
 	} while (atomic_cmpxchg(&prz->buffer->size, old, new) != old);
 }
 
+static DEFINE_RAW_SPINLOCK(buffer_lock);
+
+/* increase and wrap the start pointer, returning the old value */
+static size_t buffer_start_add_locked(struct persistent_ram_zone *prz, size_t a)
+{
+	int old;
+	int new;
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&buffer_lock, flags);
+
+	old = atomic_read(&prz->buffer->start);
+	new = old + a;
+	while (unlikely(new > prz->buffer_size))
+		new -= prz->buffer_size;
+	atomic_set(&prz->buffer->start, new);
+
+	raw_spin_unlock_irqrestore(&buffer_lock, flags);
+
+	return old;
+}
+
+/* increase the size counter until it hits the max size */
+static void buffer_size_add_locked(struct persistent_ram_zone *prz, size_t a)
+{
+	size_t old;
+	size_t new;
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&buffer_lock, flags);
+
+	old = atomic_read(&prz->buffer->size);
+	if (old == prz->buffer_size)
+		goto exit;
+
+	new = old + a;
+	if (new > prz->buffer_size)
+		new = prz->buffer_size;
+	atomic_set(&prz->buffer->size, new);
+
+exit:
+	raw_spin_unlock_irqrestore(&buffer_lock, flags);
+}
+
+static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;
+static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;
+
 static void notrace persistent_ram_encode_rs8(struct persistent_ram_zone *prz,
 	uint8_t *data, size_t len, uint8_t *ecc)
 {
@@ -379,6 +426,9 @@ static void *persistent_ram_iomap(phys_addr_t start, size_t size,
 		return NULL;
 	}
 
+	buffer_start_add = buffer_start_add_locked;
+	buffer_size_add = buffer_size_add_locked;
+
 	if (memtype)
 		va = ioremap(start, size);
 	else
diff --git a/fs/qnx4/inode.c b/fs/qnx4/inode.c
index 2e8caa6..3410e9f 100644
--- a/fs/qnx4/inode.c
+++ b/fs/qnx4/inode.c
@@ -46,6 +46,7 @@ static int qnx4_remount(struct super_block *sb, int *flags, char *data)
 {
 	struct qnx4_sb_info *qs;
 
+	sync_filesystem(sb);
 	qs = qnx4_sb(sb);
 	qs->Version = QNX4_VERSION;
 	*flags |= MS_RDONLY;
diff --git a/fs/qnx6/inode.c b/fs/qnx6/inode.c
index 8d941ed..65cdaab 100644
--- a/fs/qnx6/inode.c
+++ b/fs/qnx6/inode.c
@@ -55,6 +55,7 @@ static int qnx6_show_options(struct seq_file *seq, struct dentry *root)
 
 static int qnx6_remount(struct super_block *sb, int *flags, char *data)
 {
+	sync_filesystem(sb);
 	*flags |= MS_RDONLY;
 	return 0;
 }
diff --git a/fs/quota/dquot.c b/fs/quota/dquot.c
index 7a10e04..4f7f451 100644
--- a/fs/quota/dquot.c
+++ b/fs/quota/dquot.c
@@ -1102,6 +1102,14 @@ static void dquot_claim_reserved_space(struct dquot *dquot, qsize_t number)
 	dquot->dq_dqb.dqb_rsvspace -= number;
 }
 
+static void dquot_reclaim_reserved_space(struct dquot *dquot, qsize_t number)
+{
+	if (WARN_ON_ONCE(dquot->dq_dqb.dqb_curspace < number))
+		number = dquot->dq_dqb.dqb_curspace;
+	dquot->dq_dqb.dqb_rsvspace += number;
+	dquot->dq_dqb.dqb_curspace -= number;
+}
+
 static inline
 void dquot_free_reserved_space(struct dquot *dquot, qsize_t number)
 {
@@ -1536,6 +1544,15 @@ void inode_claim_rsv_space(struct inode *inode, qsize_t number)
 }
 EXPORT_SYMBOL(inode_claim_rsv_space);
 
+void inode_reclaim_rsv_space(struct inode *inode, qsize_t number)
+{
+	spin_lock(&inode->i_lock);
+	*inode_reserved_space(inode) += number;
+	__inode_sub_bytes(inode, number);
+	spin_unlock(&inode->i_lock);
+}
+EXPORT_SYMBOL(inode_reclaim_rsv_space);
+
 void inode_sub_rsv_space(struct inode *inode, qsize_t number)
 {
 	spin_lock(&inode->i_lock);
@@ -1710,6 +1727,35 @@ int dquot_claim_space_nodirty(struct inode *inode, qsize_t number)
 EXPORT_SYMBOL(dquot_claim_space_nodirty);
 
 /*
+ * Convert allocated space back to in-memory reserved quotas
+ */
+void dquot_reclaim_space_nodirty(struct inode *inode, qsize_t number)
+{
+	int cnt;
+
+	if (!dquot_active(inode)) {
+		inode_reclaim_rsv_space(inode, number);
+		return;
+	}
+
+	down_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
+	spin_lock(&dq_data_lock);
+	/* Claim reserved quotas to allocated quotas */
+	for (cnt = 0; cnt < MAXQUOTAS; cnt++) {
+		if (inode->i_dquot[cnt])
+			dquot_reclaim_reserved_space(inode->i_dquot[cnt],
+						     number);
+	}
+	/* Update inode bytes */
+	inode_reclaim_rsv_space(inode, number);
+	spin_unlock(&dq_data_lock);
+	mark_all_dquot_dirty(inode->i_dquot);
+	up_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
+	return;
+}
+EXPORT_SYMBOL(dquot_reclaim_space_nodirty);
+
+/*
  * This operation can block, but only after everything is updated
  */
 void __dquot_free_space(struct inode *inode, qsize_t number, int flags)
diff --git a/fs/readdir.c b/fs/readdir.c
index fee38e0..d46eca8 100644
--- a/fs/readdir.c
+++ b/fs/readdir.c
@@ -20,11 +20,11 @@
 
 #include <asm/uaccess.h>
 
-int vfs_readdir(struct file *file, filldir_t filler, void *buf)
+int iterate_dir(struct file *file, struct dir_context *ctx)
 {
 	struct inode *inode = file_inode(file);
 	int res = -ENOTDIR;
-	if (!file->f_op || !file->f_op->readdir)
+	if (!file->f_op || (!file->f_op->readdir && !file->f_op->iterate))
 		goto out;
 
 	res = security_file_permission(file, MAY_READ);
@@ -37,15 +37,21 @@ int vfs_readdir(struct file *file, filldir_t filler, void *buf)
 
 	res = -ENOENT;
 	if (!IS_DEADDIR(inode)) {
-		res = file->f_op->readdir(file, buf, filler);
+		if (file->f_op->iterate) {
+			ctx->pos = file->f_pos;
+			res = file->f_op->iterate(file, ctx);
+			file->f_pos = ctx->pos;
+		} else {
+			res = file->f_op->readdir(file, ctx, ctx->actor);
+			ctx->pos = file->f_pos;
+		}
 		file_accessed(file);
 	}
 	mutex_unlock(&inode->i_mutex);
 out:
 	return res;
 }
-
-EXPORT_SYMBOL(vfs_readdir);
+EXPORT_SYMBOL(iterate_dir);
 
 /*
  * Traditional linux readdir() handling..
@@ -66,6 +72,7 @@ struct old_linux_dirent {
 };
 
 struct readdir_callback {
+	struct dir_context ctx;
 	struct old_linux_dirent __user * dirent;
 	int result;
 };
@@ -73,7 +80,7 @@ struct readdir_callback {
 static int fillonedir(void * __buf, const char * name, int namlen, loff_t offset,
 		      u64 ino, unsigned int d_type)
 {
-	struct readdir_callback * buf = (struct readdir_callback *) __buf;
+	struct readdir_callback *buf = (struct readdir_callback *) __buf;
 	struct old_linux_dirent __user * dirent;
 	unsigned long d_ino;
 
@@ -107,15 +114,15 @@ SYSCALL_DEFINE3(old_readdir, unsigned int, fd,
 {
 	int error;
 	struct fd f = fdget(fd);
-	struct readdir_callback buf;
+	struct readdir_callback buf = {
+		.ctx.actor = fillonedir,
+		.dirent = dirent
+	};
 
 	if (!f.file)
 		return -EBADF;
 
-	buf.result = 0;
-	buf.dirent = dirent;
-
-	error = vfs_readdir(f.file, fillonedir, &buf);
+	error = iterate_dir(f.file, &buf.ctx);
 	if (buf.result)
 		error = buf.result;
 
@@ -137,6 +144,7 @@ struct linux_dirent {
 };
 
 struct getdents_callback {
+	struct dir_context ctx;
 	struct linux_dirent __user * current_dir;
 	struct linux_dirent __user * previous;
 	int count;
@@ -191,7 +199,11 @@ SYSCALL_DEFINE3(getdents, unsigned int, fd,
 {
 	struct fd f;
 	struct linux_dirent __user * lastdirent;
-	struct getdents_callback buf;
+	struct getdents_callback buf = {
+		.ctx.actor = filldir,
+		.count = count,
+		.current_dir = dirent
+	};
 	int error;
 
 	if (!access_ok(VERIFY_WRITE, dirent, count))
@@ -201,17 +213,12 @@ SYSCALL_DEFINE3(getdents, unsigned int, fd,
 	if (!f.file)
 		return -EBADF;
 
-	buf.current_dir = dirent;
-	buf.previous = NULL;
-	buf.count = count;
-	buf.error = 0;
-
-	error = vfs_readdir(f.file, filldir, &buf);
+	error = iterate_dir(f.file, &buf.ctx);
 	if (error >= 0)
 		error = buf.error;
 	lastdirent = buf.previous;
 	if (lastdirent) {
-		if (put_user(f.file->f_pos, &lastdirent->d_off))
+		if (put_user(buf.ctx.pos, &lastdirent->d_off))
 			error = -EFAULT;
 		else
 			error = count - buf.count;
@@ -221,6 +228,7 @@ SYSCALL_DEFINE3(getdents, unsigned int, fd,
 }
 
 struct getdents_callback64 {
+	struct dir_context ctx;
 	struct linux_dirent64 __user * current_dir;
 	struct linux_dirent64 __user * previous;
 	int count;
@@ -271,7 +279,11 @@ SYSCALL_DEFINE3(getdents64, unsigned int, fd,
 {
 	struct fd f;
 	struct linux_dirent64 __user * lastdirent;
-	struct getdents_callback64 buf;
+	struct getdents_callback64 buf = {
+		.ctx.actor = filldir64,
+		.count = count,
+		.current_dir = dirent
+	};
 	int error;
 
 	if (!access_ok(VERIFY_WRITE, dirent, count))
@@ -281,17 +293,12 @@ SYSCALL_DEFINE3(getdents64, unsigned int, fd,
 	if (!f.file)
 		return -EBADF;
 
-	buf.current_dir = dirent;
-	buf.previous = NULL;
-	buf.count = count;
-	buf.error = 0;
-
-	error = vfs_readdir(f.file, filldir64, &buf);
+	error = iterate_dir(f.file, &buf.ctx);
 	if (error >= 0)
 		error = buf.error;
 	lastdirent = buf.previous;
 	if (lastdirent) {
-		typeof(lastdirent->d_off) d_off = f.file->f_pos;
+		typeof(lastdirent->d_off) d_off = buf.ctx.pos;
 		if (__put_user(d_off, &lastdirent->d_off))
 			error = -EFAULT;
 		else
diff --git a/fs/reiserfs/super.c b/fs/reiserfs/super.c
index e2e202a..460f762 100644
--- a/fs/reiserfs/super.c
+++ b/fs/reiserfs/super.c
@@ -1317,6 +1317,7 @@ static int reiserfs_remount(struct super_block *s, int *mount_flags, char *arg)
 	int i;
 #endif
 
+	sync_filesystem(s);
 	reiserfs_write_lock(s);
 
 #ifdef CONFIG_QUOTA
diff --git a/fs/romfs/super.c b/fs/romfs/super.c
index 15cbc41..ae83948 100644
--- a/fs/romfs/super.c
+++ b/fs/romfs/super.c
@@ -435,6 +435,7 @@ static int romfs_statfs(struct dentry *dentry, struct kstatfs *buf)
  */
 static int romfs_remount(struct super_block *sb, int *flags, char *data)
 {
+	sync_filesystem(sb);
 	*flags |= MS_RDONLY;
 	return 0;
 }
diff --git a/fs/squashfs/Kconfig b/fs/squashfs/Kconfig
index c70111e..ffb093e 100644
--- a/fs/squashfs/Kconfig
+++ b/fs/squashfs/Kconfig
@@ -25,6 +25,78 @@ config SQUASHFS
 
 	  If unsure, say N.
 
+choice
+	prompt "File decompression options"
+	depends on SQUASHFS
+	help
+	  Squashfs now supports two options for decompressing file
+	  data.  Traditionally Squashfs has decompressed into an
+	  intermediate buffer and then memcopied it into the page cache.
+	  Squashfs now supports the ability to decompress directly into
+	  the page cache.
+
+	  If unsure, select "Decompress file data into an intermediate buffer"
+
+config SQUASHFS_FILE_CACHE
+	bool "Decompress file data into an intermediate buffer"
+	help
+	  Decompress file data into an intermediate buffer and then
+	  memcopy it into the page cache.
+
+config SQUASHFS_FILE_DIRECT
+	bool "Decompress files directly into the page cache"
+	help
+	  Directly decompress file data into the page cache.
+	  Doing so can significantly improve performance because
+	  it eliminates a memcpy and it also removes the lock contention
+	  on the single buffer.
+
+endchoice
+
+choice
+	prompt "Decompressor parallelisation options"
+	depends on SQUASHFS
+	help
+	  Squashfs now supports three parallelisation options for
+	  decompression.  Each one exhibits various trade-offs between
+	  decompression performance and CPU and memory usage.
+
+	  If in doubt, select "Single threaded compression"
+
+config SQUASHFS_DECOMP_SINGLE
+	bool "Single threaded compression"
+	help
+	  Traditionally Squashfs has used single-threaded decompression.
+	  Only one block (data or metadata) can be decompressed at any
+	  one time.  This limits CPU and memory usage to a minimum.
+
+config SQUASHFS_DECOMP_MULTI
+	bool "Use multiple decompressors for parallel I/O"
+	help
+	  By default Squashfs uses a single decompressor but it gives
+	  poor performance on parallel I/O workloads when using multiple CPU
+	  machines due to waiting on decompressor availability.
+
+	  If you have a parallel I/O workload and your system has enough memory,
+	  using this option may improve overall I/O performance.
+
+	  This decompressor implementation uses up to two parallel
+	  decompressors per core.  It dynamically allocates decompressors
+	  on a demand basis.
+
+config SQUASHFS_DECOMP_MULTI_PERCPU
+	bool "Use percpu multiple decompressors for parallel I/O"
+	help
+	  By default Squashfs uses a single decompressor but it gives
+	  poor performance on parallel I/O workloads when using multiple CPU
+	  machines due to waiting on decompressor availability.
+
+	  This decompressor implementation uses a maximum of one
+	  decompressor per core.  It uses percpu variables to ensure
+	  decompression is load-balanced across the cores.
+
+endchoice
+
 config SQUASHFS_XATTR
 	bool "Squashfs XATTR support"
 	depends on SQUASHFS
@@ -48,6 +120,21 @@ config SQUASHFS_ZLIB
 
 	  If unsure, say Y.
 
+config SQUASHFS_LZ4
+	bool "Include support for LZ4 compressed file systems"
+	depends on SQUASHFS
+	select LZ4_DECOMPRESS
+	help
+	  Saying Y here includes support for reading Squashfs file systems
+	  compressed with LZ4 compression.  LZ4 compression is mainly
+	  aimed at embedded systems with slower CPUs where the overheads
+	  of zlib are too high.
+
+	  LZ4 is not the standard compression used in Squashfs and so most
+	  file systems will be readable without selecting this option.
+
+	  If unsure, say N.
+
 config SQUASHFS_LZO
 	bool "Include support for LZO compressed file systems"
 	depends on SQUASHFS
diff --git a/fs/squashfs/Makefile b/fs/squashfs/Makefile
index 110b047..246a6f3 100644
--- a/fs/squashfs/Makefile
+++ b/fs/squashfs/Makefile
@@ -5,7 +5,13 @@
 obj-$(CONFIG_SQUASHFS) += squashfs.o
 squashfs-y += block.o cache.o dir.o export.o file.o fragment.o id.o inode.o
 squashfs-y += namei.o super.o symlink.o decompressor.o
+squashfs-$(CONFIG_SQUASHFS_FILE_CACHE) += file_cache.o
+squashfs-$(CONFIG_SQUASHFS_FILE_DIRECT) += file_direct.o page_actor.o
+squashfs-$(CONFIG_SQUASHFS_DECOMP_SINGLE) += decompressor_single.o
+squashfs-$(CONFIG_SQUASHFS_DECOMP_MULTI) += decompressor_multi.o
+squashfs-$(CONFIG_SQUASHFS_DECOMP_MULTI_PERCPU) += decompressor_multi_percpu.o
 squashfs-$(CONFIG_SQUASHFS_XATTR) += xattr.o xattr_id.o
+squashfs-$(CONFIG_SQUASHFS_LZ4) += lz4_wrapper.o
 squashfs-$(CONFIG_SQUASHFS_LZO) += lzo_wrapper.o
 squashfs-$(CONFIG_SQUASHFS_XZ) += xz_wrapper.o
 squashfs-$(CONFIG_SQUASHFS_ZLIB) += zlib_wrapper.o
diff --git a/fs/squashfs/block.c b/fs/squashfs/block.c
index fb50652..0cea9b9 100644
--- a/fs/squashfs/block.c
+++ b/fs/squashfs/block.c
@@ -36,6 +36,7 @@
 #include "squashfs_fs_sb.h"
 #include "squashfs.h"
 #include "decompressor.h"
+#include "page_actor.h"
 
 /*
  * Read the metadata block length, this is stored in the first two
@@ -86,16 +87,16 @@ static struct buffer_head *get_block_length(struct super_block *sb,
  * generated a larger block - this does occasionally happen with compression
  * algorithms).
  */
-int squashfs_read_data(struct super_block *sb, void **buffer, u64 index,
-			int length, u64 *next_index, int srclength, int pages)
+int squashfs_read_data(struct super_block *sb, u64 index, int length,
+		u64 *next_index, struct squashfs_page_actor *output)
 {
 	struct squashfs_sb_info *msblk = sb->s_fs_info;
 	struct buffer_head **bh;
 	int offset = index & ((1 << msblk->devblksize_log2) - 1);
 	u64 cur_index = index >> msblk->devblksize_log2;
-	int bytes, compressed, b = 0, k = 0, page = 0, avail;
+	int bytes, compressed, b = 0, k = 0, avail, i;
 
-	bh = kcalloc(((srclength + msblk->devblksize - 1)
+	bh = kcalloc(((output->length + msblk->devblksize - 1)
 		>> msblk->devblksize_log2) + 1, sizeof(*bh), GFP_KERNEL);
 	if (bh == NULL)
 		return -ENOMEM;
@@ -111,9 +112,9 @@ int squashfs_read_data(struct super_block *sb, void **buffer, u64 index,
 			*next_index = index + length;
 
 		TRACE("Block @ 0x%llx, %scompressed size %d, src size %d\n",
-			index, compressed ? "" : "un", length, srclength);
+			index, compressed ? "" : "un", length, output->length);
 
-		if (length < 0 || length > srclength ||
+		if (length < 0 || length > output->length ||
 				(index + length) > msblk->bytes_used)
 			goto read_failure;
 
@@ -145,7 +146,7 @@ int squashfs_read_data(struct super_block *sb, void **buffer, u64 index,
 		TRACE("Block @ 0x%llx, %scompressed size %d\n", index,
 				compressed ? "" : "un", length);
 
-		if (length < 0 || length > srclength ||
+		if (length < 0 || length > output->length ||
 					(index + length) > msblk->bytes_used)
 			goto block_release;
 
@@ -158,35 +159,36 @@ int squashfs_read_data(struct super_block *sb, void **buffer, u64 index,
 		ll_rw_block(READ, b - 1, bh + 1);
 	}
 
+	for (i = 0; i < b; i++) {
+		wait_on_buffer(bh[i]);
+		if (!buffer_uptodate(bh[i]))
+			goto block_release;
+	}
+
 	if (compressed) {
-		length = squashfs_decompress(msblk, buffer, bh, b, offset,
-			 length, srclength, pages);
+		length = squashfs_decompress(msblk, bh, b, offset, length,
+			output);
 		if (length < 0)
 			goto read_failure;
 	} else {
 		/*
 		 * Block is uncompressed.
 		 */
-		int i, in, pg_offset = 0;
-
-		for (i = 0; i < b; i++) {
-			wait_on_buffer(bh[i]);
-			if (!buffer_uptodate(bh[i]))
-				goto block_release;
-		}
+		int in, pg_offset = 0;
+		void *data = squashfs_first_page(output);
 
 		for (bytes = length; k < b; k++) {
 			in = min(bytes, msblk->devblksize - offset);
 			bytes -= in;
 			while (in) {
 				if (pg_offset == PAGE_CACHE_SIZE) {
-					page++;
+					data = squashfs_next_page(output);
 					pg_offset = 0;
 				}
 				avail = min_t(int, in, PAGE_CACHE_SIZE -
 						pg_offset);
-				memcpy(buffer[page] + pg_offset,
-						bh[k]->b_data + offset, avail);
+				memcpy(data + pg_offset, bh[k]->b_data + offset,
+						avail);
 				in -= avail;
 				pg_offset += avail;
 				offset += avail;
@@ -194,6 +196,7 @@ int squashfs_read_data(struct super_block *sb, void **buffer, u64 index,
 			offset = 0;
 			put_bh(bh[k]);
 		}
+		squashfs_finish_page(output);
 	}
 
 	kfree(bh);
diff --git a/fs/squashfs/cache.c b/fs/squashfs/cache.c
index af0b738..1cb70a0 100644
--- a/fs/squashfs/cache.c
+++ b/fs/squashfs/cache.c
@@ -56,6 +56,7 @@
 #include "squashfs_fs.h"
 #include "squashfs_fs_sb.h"
 #include "squashfs.h"
+#include "page_actor.h"
 
 /*
  * Look-up block in cache, and increment usage count.  If not in cache, read
@@ -119,9 +120,8 @@ struct squashfs_cache_entry *squashfs_cache_get(struct super_block *sb,
 			entry->error = 0;
 			spin_unlock(&cache->lock);
 
-			entry->length = squashfs_read_data(sb, entry->data,
-				block, length, &entry->next_index,
-				cache->block_size, cache->pages);
+			entry->length = squashfs_read_data(sb, block, length,
+				&entry->next_index, entry->actor);
 
 			spin_lock(&cache->lock);
 
@@ -220,6 +220,7 @@ void squashfs_cache_delete(struct squashfs_cache *cache)
 				kfree(cache->entry[i].data[j]);
 			kfree(cache->entry[i].data);
 		}
+		kfree(cache->entry[i].actor);
 	}
 
 	kfree(cache->entry);
@@ -280,6 +281,13 @@ struct squashfs_cache *squashfs_cache_init(char *name, int entries,
 				goto cleanup;
 			}
 		}
+
+		entry->actor = squashfs_page_actor_init(entry->data,
+						cache->pages, 0);
+		if (entry->actor == NULL) {
+			ERROR("Failed to allocate %s cache entry\n", name);
+			goto cleanup;
+		}
 	}
 
 	return cache;
@@ -410,6 +418,7 @@ void *squashfs_read_table(struct super_block *sb, u64 block, int length)
 	int pages = (length + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
 	int i, res;
 	void *table, *buffer, **data;
+	struct squashfs_page_actor *actor;
 
 	table = buffer = kmalloc(length, GFP_KERNEL);
 	if (table == NULL)
@@ -421,19 +430,28 @@ void *squashfs_read_table(struct super_block *sb, u64 block, int length)
 		goto failed;
 	}
 
+	actor = squashfs_page_actor_init(data, pages, length);
+	if (actor == NULL) {
+		res = -ENOMEM;
+		goto failed2;
+	}
+
 	for (i = 0; i < pages; i++, buffer += PAGE_CACHE_SIZE)
 		data[i] = buffer;
 
-	res = squashfs_read_data(sb, data, block, length |
-		SQUASHFS_COMPRESSED_BIT_BLOCK, NULL, length, pages);
+	res = squashfs_read_data(sb, block, length |
+		SQUASHFS_COMPRESSED_BIT_BLOCK, NULL, actor);
 
 	kfree(data);
+	kfree(actor);
 
 	if (res < 0)
 		goto failed;
 
 	return table;
 
+failed2:
+	kfree(data);
 failed:
 	kfree(table);
 	return ERR_PTR(res);
diff --git a/fs/squashfs/decompressor.c b/fs/squashfs/decompressor.c
index 3f6271d..e9034bf 100644
--- a/fs/squashfs/decompressor.c
+++ b/fs/squashfs/decompressor.c
@@ -30,6 +30,7 @@
 #include "squashfs_fs_sb.h"
 #include "decompressor.h"
 #include "squashfs.h"
+#include "page_actor.h"
 
 /*
  * This file (and decompressor.h) implements a decompressor framework for
@@ -37,33 +38,40 @@
  */
 
 static const struct squashfs_decompressor squashfs_lzma_unsupported_comp_ops = {
-	NULL, NULL, NULL, LZMA_COMPRESSION, "lzma", 0
+	NULL, NULL, NULL, NULL, LZMA_COMPRESSION, "lzma", 0
 };
 
+#ifndef CONFIG_SQUASHFS_LZ4
+static const struct squashfs_decompressor squashfs_lz4_comp_ops = {
+	NULL, NULL, NULL, NULL, LZ4_COMPRESSION, "lz4", 0
+};
+#endif
+
 #ifndef CONFIG_SQUASHFS_LZO
 static const struct squashfs_decompressor squashfs_lzo_comp_ops = {
-	NULL, NULL, NULL, LZO_COMPRESSION, "lzo", 0
+	NULL, NULL, NULL, NULL, LZO_COMPRESSION, "lzo", 0
 };
 #endif
 
 #ifndef CONFIG_SQUASHFS_XZ
 static const struct squashfs_decompressor squashfs_xz_comp_ops = {
-	NULL, NULL, NULL, XZ_COMPRESSION, "xz", 0
+	NULL, NULL, NULL, NULL, XZ_COMPRESSION, "xz", 0
 };
 #endif
 
 #ifndef CONFIG_SQUASHFS_ZLIB
 static const struct squashfs_decompressor squashfs_zlib_comp_ops = {
-	NULL, NULL, NULL, ZLIB_COMPRESSION, "zlib", 0
+	NULL, NULL, NULL, NULL, ZLIB_COMPRESSION, "zlib", 0
 };
 #endif
 
 static const struct squashfs_decompressor squashfs_unknown_comp_ops = {
-	NULL, NULL, NULL, 0, "unknown", 0
+	NULL, NULL, NULL, NULL, 0, "unknown", 0
 };
 
 static const struct squashfs_decompressor *decompressor[] = {
 	&squashfs_zlib_comp_ops,
+	&squashfs_lz4_comp_ops,
 	&squashfs_lzo_comp_ops,
 	&squashfs_xz_comp_ops,
 	&squashfs_lzma_unsupported_comp_ops,
@@ -83,10 +91,11 @@ const struct squashfs_decompressor *squashfs_lookup_decompressor(int id)
 }
 
 
-void *squashfs_decompressor_init(struct super_block *sb, unsigned short flags)
+static void *get_comp_opts(struct super_block *sb, unsigned short flags)
 {
 	struct squashfs_sb_info *msblk = sb->s_fs_info;
-	void *strm, *buffer = NULL;
+	void *buffer = NULL, *comp_opts;
+	struct squashfs_page_actor *actor = NULL;
 	int length = 0;
 
 	/*
@@ -94,23 +103,46 @@ void *squashfs_decompressor_init(struct super_block *sb, unsigned short flags)
 	 */
 	if (SQUASHFS_COMP_OPTS(flags)) {
 		buffer = kmalloc(PAGE_CACHE_SIZE, GFP_KERNEL);
-		if (buffer == NULL)
-			return ERR_PTR(-ENOMEM);
+		if (buffer == NULL) {
+			comp_opts = ERR_PTR(-ENOMEM);
+			goto out;
+		}
 
-		length = squashfs_read_data(sb, &buffer,
-			sizeof(struct squashfs_super_block), 0, NULL,
-			PAGE_CACHE_SIZE, 1);
+		actor = squashfs_page_actor_init(&buffer, 1, 0);
+		if (actor == NULL) {
+			comp_opts = ERR_PTR(-ENOMEM);
+			goto out;
+		}
+
+		length = squashfs_read_data(sb,
+			sizeof(struct squashfs_super_block), 0, NULL, actor);
 
 		if (length < 0) {
-			strm = ERR_PTR(length);
-			goto finished;
+			comp_opts = ERR_PTR(length);
+			goto out;
 		}
 	}
 
-	strm = msblk->decompressor->init(msblk, buffer, length);
+	comp_opts = squashfs_comp_opts(msblk, buffer, length);
 
-finished:
+out:
+	kfree(actor);
 	kfree(buffer);
+	return comp_opts;
+}
+
+
+void *squashfs_decompressor_setup(struct super_block *sb, unsigned short flags)
+{
+	struct squashfs_sb_info *msblk = sb->s_fs_info;
+	void *stream, *comp_opts = get_comp_opts(sb, flags);
+
+	if (IS_ERR(comp_opts))
+		return comp_opts;
+
+	stream = squashfs_decompressor_create(msblk, comp_opts);
+	if (IS_ERR(stream))
+		kfree(comp_opts);
 
-	return strm;
+	return stream;
 }
diff --git a/fs/squashfs/decompressor.h b/fs/squashfs/decompressor.h
index 330073e..a25713c 100644
--- a/fs/squashfs/decompressor.h
+++ b/fs/squashfs/decompressor.h
@@ -24,34 +24,32 @@
  */
 
 struct squashfs_decompressor {
-	void	*(*init)(struct squashfs_sb_info *, void *, int);
+	void	*(*init)(struct squashfs_sb_info *, void *);
+	void	*(*comp_opts)(struct squashfs_sb_info *, void *, int);
 	void	(*free)(void *);
-	int	(*decompress)(struct squashfs_sb_info *, void **,
-		struct buffer_head **, int, int, int, int, int);
+	int	(*decompress)(struct squashfs_sb_info *, void *,
+		struct buffer_head **, int, int, int,
+		struct squashfs_page_actor *);
 	int	id;
 	char	*name;
 	int	supported;
 };
 
-static inline void squashfs_decompressor_free(struct squashfs_sb_info *msblk,
-	void *s)
+static inline void *squashfs_comp_opts(struct squashfs_sb_info *msblk,
+							void *buff, int length)
 {
-	if (msblk->decompressor)
-		msblk->decompressor->free(s);
-}
-
-static inline int squashfs_decompress(struct squashfs_sb_info *msblk,
-	void **buffer, struct buffer_head **bh, int b, int offset, int length,
-	int srclength, int pages)
-{
-	return msblk->decompressor->decompress(msblk, buffer, bh, b, offset,
-		length, srclength, pages);
+	return msblk->decompressor->comp_opts ?
+		msblk->decompressor->comp_opts(msblk, buff, length) : NULL;
 }
 
 #ifdef CONFIG_SQUASHFS_XZ
 extern const struct squashfs_decompressor squashfs_xz_comp_ops;
 #endif
 
+#ifdef CONFIG_SQUASHFS_LZ4
+extern const struct squashfs_decompressor squashfs_lz4_comp_ops;
+#endif
+
 #ifdef CONFIG_SQUASHFS_LZO
 extern const struct squashfs_decompressor squashfs_lzo_comp_ops;
 #endif
diff --git a/fs/squashfs/dir.c b/fs/squashfs/dir.c
index 57dc70e..d8c2d74 100644
--- a/fs/squashfs/dir.c
+++ b/fs/squashfs/dir.c
@@ -54,6 +54,7 @@ static int get_dir_index_using_offset(struct super_block *sb,
 {
 	struct squashfs_sb_info *msblk = sb->s_fs_info;
 	int err, i, index, length = 0;
+	unsigned int size;
 	struct squashfs_dir_index dir_index;
 
 	TRACE("Entered get_dir_index_using_offset, i_count %d, f_pos %lld\n",
@@ -81,8 +82,14 @@ static int get_dir_index_using_offset(struct super_block *sb,
 			 */
 			break;
 
+		size = le32_to_cpu(dir_index.size) + 1;
+
+		/* size should never be larger than SQUASHFS_NAME_LEN */
+		if (size > SQUASHFS_NAME_LEN)
+			break;
+
 		err = squashfs_read_metadata(sb, NULL, &index_start,
-				&index_offset, le32_to_cpu(dir_index.size) + 1);
+				&index_offset, size);
 		if (err < 0)
 			break;
 
@@ -100,14 +107,13 @@ static int get_dir_index_using_offset(struct super_block *sb,
 }
 
 
-static int squashfs_readdir(struct file *file, void *dirent, filldir_t filldir)
+static int squashfs_readdir(struct file *file, struct dir_context *ctx)
 {
 	struct inode *inode = file_inode(file);
 	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
 	u64 block = squashfs_i(inode)->start + msblk->directory_table;
-	int offset = squashfs_i(inode)->offset, length, dir_count, size,
-				type, err;
-	unsigned int inode_number;
+	int offset = squashfs_i(inode)->offset, length, err;
+	unsigned int inode_number, dir_count, size, type;
 	struct squashfs_dir_header dirh;
 	struct squashfs_dir_entry *dire;
 
@@ -127,11 +133,11 @@ static int squashfs_readdir(struct file *file, void *dirent, filldir_t filldir)
 	 * It also means that the external f_pos is offset by 3 from the
 	 * on-disk directory f_pos.
 	 */
-	while (file->f_pos < 3) {
+	while (ctx->pos < 3) {
 		char *name;
 		int i_ino;
 
-		if (file->f_pos == 0) {
+		if (ctx->pos == 0) {
 			name = ".";
 			size = 1;
 			i_ino = inode->i_ino;
@@ -141,24 +147,18 @@ static int squashfs_readdir(struct file *file, void *dirent, filldir_t filldir)
 			i_ino = squashfs_i(inode)->parent;
 		}
 
-		TRACE("Calling filldir(%p, %s, %d, %lld, %d, %d)\n",
-				dirent, name, size, file->f_pos, i_ino,
-				squashfs_filetype_table[1]);
-
-		if (filldir(dirent, name, size, file->f_pos, i_ino,
-				squashfs_filetype_table[1]) < 0) {
-				TRACE("Filldir returned less than 0\n");
+		if (!dir_emit(ctx, name, size, i_ino,
+				squashfs_filetype_table[1]))
 			goto finish;
-		}
 
-		file->f_pos += size;
+		ctx->pos += size;
 	}
 
 	length = get_dir_index_using_offset(inode->i_sb, &block, &offset,
 				squashfs_i(inode)->dir_idx_start,
 				squashfs_i(inode)->dir_idx_offset,
 				squashfs_i(inode)->dir_idx_cnt,
-				file->f_pos);
+				ctx->pos);
 
 	while (length < i_size_read(inode)) {
 		/*
@@ -198,7 +198,7 @@ static int squashfs_readdir(struct file *file, void *dirent, filldir_t filldir)
 
 			length += sizeof(*dire) + size;
 
-			if (file->f_pos >= length)
+			if (ctx->pos >= length)
 				continue;
 
 			dire->name[size] = '\0';
@@ -206,22 +206,15 @@ static int squashfs_readdir(struct file *file, void *dirent, filldir_t filldir)
 				((short) le16_to_cpu(dire->inode_number));
 			type = le16_to_cpu(dire->type);
 
-			TRACE("Calling filldir(%p, %s, %d, %lld, %x:%x, %d, %d)"
-					"\n", dirent, dire->name, size,
-					file->f_pos,
-					le32_to_cpu(dirh.start_block),
-					le16_to_cpu(dire->offset),
-					inode_number,
-					squashfs_filetype_table[type]);
+			if (type > SQUASHFS_MAX_DIR_TYPE)
+				goto failed_read;
 
-			if (filldir(dirent, dire->name, size, file->f_pos,
+			if (!dir_emit(ctx, dire->name, size,
 					inode_number,
-					squashfs_filetype_table[type]) < 0) {
-				TRACE("Filldir returned less than 0\n");
+					squashfs_filetype_table[type]))
 				goto finish;
-			}
 
-			file->f_pos = length;
+			ctx->pos = length;
 		}
 	}
 
@@ -238,6 +231,6 @@ failed_read:
 
 const struct file_operations squashfs_dir_ops = {
 	.read = generic_read_dir,
-	.readdir = squashfs_readdir,
+	.iterate = squashfs_readdir,
 	.llseek = default_llseek,
 };
diff --git a/fs/squashfs/file.c b/fs/squashfs/file.c
index 8ca62c2..e5c9689 100644
--- a/fs/squashfs/file.c
+++ b/fs/squashfs/file.c
@@ -370,77 +370,15 @@ static int read_blocklist(struct inode *inode, int index, u64 *block)
 	return le32_to_cpu(size);
 }
 
-
-static int squashfs_readpage(struct file *file, struct page *page)
+/* Copy data into page cache  */
+void squashfs_copy_cache(struct page *page, struct squashfs_cache_entry *buffer,
+	int bytes, int offset)
 {
 	struct inode *inode = page->mapping->host;
 	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
-	int bytes, i, offset = 0, sparse = 0;
-	struct squashfs_cache_entry *buffer = NULL;
 	void *pageaddr;
-
-	int mask = (1 << (msblk->block_log - PAGE_CACHE_SHIFT)) - 1;
-	int index = page->index >> (msblk->block_log - PAGE_CACHE_SHIFT);
-	int start_index = page->index & ~mask;
-	int end_index = start_index | mask;
-	int file_end = i_size_read(inode) >> msblk->block_log;
-
-	TRACE("Entered squashfs_readpage, page index %lx, start block %llx\n",
-				page->index, squashfs_i(inode)->start);
-
-	if (page->index >= ((i_size_read(inode) + PAGE_CACHE_SIZE - 1) >>
-					PAGE_CACHE_SHIFT))
-		goto out;
-
-	if (index < file_end || squashfs_i(inode)->fragment_block ==
-					SQUASHFS_INVALID_BLK) {
-		/*
-		 * Reading a datablock from disk.  Need to read block list
-		 * to get location and block size.
-		 */
-		u64 block = 0;
-		int bsize = read_blocklist(inode, index, &block);
-		if (bsize < 0)
-			goto error_out;
-
-		if (bsize == 0) { /* hole */
-			bytes = index == file_end ?
-				(i_size_read(inode) & (msblk->block_size - 1)) :
-				 msblk->block_size;
-			sparse = 1;
-		} else {
-			/*
-			 * Read and decompress datablock.
-			 */
-			buffer = squashfs_get_datablock(inode->i_sb,
-								block, bsize);
-			if (buffer->error) {
-				ERROR("Unable to read page, block %llx, size %x"
-					"\n", block, bsize);
-				squashfs_cache_put(buffer);
-				goto error_out;
-			}
-			bytes = buffer->length;
-		}
-	} else {
-		/*
-		 * Datablock is stored inside a fragment (tail-end packed
-		 * block).
-		 */
-		buffer = squashfs_get_fragment(inode->i_sb,
-				squashfs_i(inode)->fragment_block,
-				squashfs_i(inode)->fragment_size);
-
-		if (buffer->error) {
-			ERROR("Unable to read page, block %llx, size %x\n",
-				squashfs_i(inode)->fragment_block,
-				squashfs_i(inode)->fragment_size);
-			squashfs_cache_put(buffer);
-			goto error_out;
-		}
-		bytes = i_size_read(inode) & (msblk->block_size - 1);
-		offset = squashfs_i(inode)->fragment_offset;
-	}
+	int i, mask = (1 << (msblk->block_log - PAGE_CACHE_SHIFT)) - 1;
+	int start_index = page->index & ~mask, end_index = start_index | mask;
 
 	/*
 	 * Loop copying datablock into pages.  As the datablock likely covers
@@ -451,7 +389,7 @@ static int squashfs_readpage(struct file *file, struct page *page)
 	for (i = start_index; i <= end_index && bytes > 0; i++,
 			bytes -= PAGE_CACHE_SIZE, offset += PAGE_CACHE_SIZE) {
 		struct page *push_page;
-		int avail = sparse ? 0 : min_t(int, bytes, PAGE_CACHE_SIZE);
+		int avail = buffer ? min_t(int, bytes, PAGE_CACHE_SIZE) : 0;
 
 		TRACE("bytes %d, i %d, available_bytes %d\n", bytes, i, avail);
 
@@ -475,11 +413,75 @@ skip_page:
 		if (i != page->index)
 			page_cache_release(push_page);
 	}
+}
+
+/* Read datablock stored packed inside a fragment (tail-end packed block) */
+static int squashfs_readpage_fragment(struct page *page)
+{
+	struct inode *inode = page->mapping->host;
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	struct squashfs_cache_entry *buffer = squashfs_get_fragment(inode->i_sb,
+		squashfs_i(inode)->fragment_block,
+		squashfs_i(inode)->fragment_size);
+	int res = buffer->error;
+
+	if (res)
+		ERROR("Unable to read page, block %llx, size %x\n",
+			squashfs_i(inode)->fragment_block,
+			squashfs_i(inode)->fragment_size);
+	else
+		squashfs_copy_cache(page, buffer, i_size_read(inode) &
+			(msblk->block_size - 1),
+			squashfs_i(inode)->fragment_offset);
+
+	squashfs_cache_put(buffer);
+	return res;
+}
 
-	if (!sparse)
-		squashfs_cache_put(buffer);
+static int squashfs_readpage_sparse(struct page *page, int index, int file_end)
+{
+	struct inode *inode = page->mapping->host;
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	int bytes = index == file_end ?
+			(i_size_read(inode) & (msblk->block_size - 1)) :
+			 msblk->block_size;
 
+	squashfs_copy_cache(page, NULL, bytes, 0);
 	return 0;
+}
+
+static int squashfs_readpage(struct file *file, struct page *page)
+{
+	struct inode *inode = page->mapping->host;
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	int index = page->index >> (msblk->block_log - PAGE_CACHE_SHIFT);
+	int file_end = i_size_read(inode) >> msblk->block_log;
+	int res;
+	void *pageaddr;
+
+	TRACE("Entered squashfs_readpage, page index %lx, start block %llx\n",
+				page->index, squashfs_i(inode)->start);
+
+	if (page->index >= ((i_size_read(inode) + PAGE_CACHE_SIZE - 1) >>
+					PAGE_CACHE_SHIFT))
+		goto out;
+
+	if (index < file_end || squashfs_i(inode)->fragment_block ==
+					SQUASHFS_INVALID_BLK) {
+		u64 block = 0;
+		int bsize = read_blocklist(inode, index, &block);
+		if (bsize < 0)
+			goto error_out;
+
+		if (bsize == 0)
+			res = squashfs_readpage_sparse(page, index, file_end);
+		else
+			res = squashfs_readpage_block(page, block, bsize);
+	} else
+		res = squashfs_readpage_fragment(page);
+
+	if (!res)
+		return 0;
 
 error_out:
 	SetPageError(page);
diff --git a/fs/squashfs/lzo_wrapper.c b/fs/squashfs/lzo_wrapper.c
index 00f4dfc..244b9fb 100644
--- a/fs/squashfs/lzo_wrapper.c
+++ b/fs/squashfs/lzo_wrapper.c
@@ -31,13 +31,14 @@
 #include "squashfs_fs_sb.h"
 #include "squashfs.h"
 #include "decompressor.h"
+#include "page_actor.h"
 
 struct squashfs_lzo {
 	void	*input;
 	void	*output;
 };
 
-static void *lzo_init(struct squashfs_sb_info *msblk, void *buff, int len)
+static void *lzo_init(struct squashfs_sb_info *msblk, void *buff)
 {
 	int block_size = max_t(int, msblk->block_size, SQUASHFS_METADATA_SIZE);
 
@@ -74,22 +75,16 @@ static void lzo_free(void *strm)
 }
 
 
-static int lzo_uncompress(struct squashfs_sb_info *msblk, void **buffer,
-	struct buffer_head **bh, int b, int offset, int length, int srclength,
-	int pages)
+static int lzo_uncompress(struct squashfs_sb_info *msblk, void *strm,
+	struct buffer_head **bh, int b, int offset, int length,
+	struct squashfs_page_actor *output)
 {
-	struct squashfs_lzo *stream = msblk->stream;
-	void *buff = stream->input;
+	struct squashfs_lzo *stream = strm;
+	void *buff = stream->input, *data;
 	int avail, i, bytes = length, res;
-	size_t out_len = srclength;
-
-	mutex_lock(&msblk->read_data_mutex);
+	size_t out_len = output->length;
 
 	for (i = 0; i < b; i++) {
-		wait_on_buffer(bh[i]);
-		if (!buffer_uptodate(bh[i]))
-			goto block_release;
-
 		avail = min(bytes, msblk->devblksize - offset);
 		memcpy(buff, bh[i]->b_data + offset, avail);
 		buff += avail;
@@ -104,24 +99,24 @@ static int lzo_uncompress(struct squashfs_sb_info *msblk, void **buffer,
 		goto failed;
 
 	res = bytes = (int)out_len;
-	for (i = 0, buff = stream->output; bytes && i < pages; i++) {
-		avail = min_t(int, bytes, PAGE_CACHE_SIZE);
-		memcpy(buffer[i], buff, avail);
-		buff += avail;
-		bytes -= avail;
+	data = squashfs_first_page(output);
+	buff = stream->output;
+	while (data) {
+		if (bytes <= PAGE_CACHE_SIZE) {
+			memcpy(data, buff, bytes);
+			break;
+		} else {
+			memcpy(data, buff, PAGE_CACHE_SIZE);
+			buff += PAGE_CACHE_SIZE;
+			bytes -= PAGE_CACHE_SIZE;
+			data = squashfs_next_page(output);
+		}
 	}
+	squashfs_finish_page(output);
 
-	mutex_unlock(&msblk->read_data_mutex);
 	return res;
 
-block_release:
-	for (; i < b; i++)
-		put_bh(bh[i]);
-
 failed:
-	mutex_unlock(&msblk->read_data_mutex);
-
-	ERROR("lzo decompression failed, data probably corrupt\n");
 	return -EIO;
 }
 
diff --git a/fs/squashfs/namei.c b/fs/squashfs/namei.c
index 7834a51..67cad77 100644
--- a/fs/squashfs/namei.c
+++ b/fs/squashfs/namei.c
@@ -79,7 +79,8 @@ static int get_dir_index_using_name(struct super_block *sb,
 			int len)
 {
 	struct squashfs_sb_info *msblk = sb->s_fs_info;
-	int i, size, length = 0, err;
+	int i, length = 0, err;
+	unsigned int size;
 	struct squashfs_dir_index *index;
 	char *str;
 
@@ -103,6 +104,8 @@ static int get_dir_index_using_name(struct super_block *sb,
 
 
 		size = le32_to_cpu(index->size) + 1;
+		if (size > SQUASHFS_NAME_LEN)
+			break;
 
 		err = squashfs_read_metadata(sb, index->name, &index_start,
 					&index_offset, size);
@@ -144,7 +147,8 @@ static struct dentry *squashfs_lookup(struct inode *dir, struct dentry *dentry,
 	struct squashfs_dir_entry *dire;
 	u64 block = squashfs_i(dir)->start + msblk->directory_table;
 	int offset = squashfs_i(dir)->offset;
-	int err, length, dir_count, size;
+	int err, length;
+	unsigned int dir_count, size;
 
 	TRACE("Entered squashfs_lookup [%llx:%x]\n", block, offset);
 
diff --git a/fs/squashfs/squashfs.h b/fs/squashfs/squashfs.h
index d126651..887d6d2 100644
--- a/fs/squashfs/squashfs.h
+++ b/fs/squashfs/squashfs.h
@@ -25,11 +25,11 @@
 
 #define ERROR(s, args...)	pr_err("SQUASHFS error: "s, ## args)
 
-#define WARNING(s, args...)	pr_warning("SQUASHFS: "s, ## args)
+#define WARNING(s, args...)	pr_warn("SQUASHFS: "s, ## args)
 
 /* block.c */
-extern int squashfs_read_data(struct super_block *, void **, u64, int, u64 *,
-				int, int);
+extern int squashfs_read_data(struct super_block *, u64, int, u64 *,
+				struct squashfs_page_actor *);
 
 /* cache.c */
 extern struct squashfs_cache *squashfs_cache_init(char *, int, int);
@@ -48,7 +48,14 @@ extern void *squashfs_read_table(struct super_block *, u64, int);
 
 /* decompressor.c */
 extern const struct squashfs_decompressor *squashfs_lookup_decompressor(int);
-extern void *squashfs_decompressor_init(struct super_block *, unsigned short);
+extern void *squashfs_decompressor_setup(struct super_block *, unsigned short);
+
+/* decompressor_xxx.c */
+extern void *squashfs_decompressor_create(struct squashfs_sb_info *, void *);
+extern void squashfs_decompressor_destroy(struct squashfs_sb_info *);
+extern int squashfs_decompress(struct squashfs_sb_info *, struct buffer_head **,
+	int, int, int, struct squashfs_page_actor *);
+extern int squashfs_max_decompressors(void);
 
 /* export.c */
 extern __le64 *squashfs_read_inode_lookup_table(struct super_block *, u64, u64,
@@ -59,6 +66,13 @@ extern int squashfs_frag_lookup(struct super_block *, unsigned int, u64 *);
 extern __le64 *squashfs_read_fragment_index_table(struct super_block *,
 				u64, u64, unsigned int);
 
+/* file.c */
+void squashfs_copy_cache(struct page *, struct squashfs_cache_entry *, int,
+				int);
+
+/* file_xxx.c */
+extern int squashfs_readpage_block(struct page *, u64, int);
+
 /* id.c */
 extern int squashfs_get_id(struct super_block *, unsigned int, unsigned int *);
 extern __le64 *squashfs_read_id_index_table(struct super_block *, u64, u64,
diff --git a/fs/squashfs/squashfs_fs.h b/fs/squashfs/squashfs_fs.h
index 9e2349d..506f4ba 100644
--- a/fs/squashfs/squashfs_fs.h
+++ b/fs/squashfs/squashfs_fs.h
@@ -87,7 +87,7 @@
 #define SQUASHFS_COMP_OPTS(flags)		SQUASHFS_BIT(flags, \
 						SQUASHFS_COMP_OPT)
 
-/* Max number of types and file types */
+/* Inode types including extended types */
 #define SQUASHFS_DIR_TYPE		1
 #define SQUASHFS_REG_TYPE		2
 #define SQUASHFS_SYMLINK_TYPE		3
@@ -103,6 +103,9 @@
 #define SQUASHFS_LFIFO_TYPE		13
 #define SQUASHFS_LSOCKET_TYPE		14
 
+/* Max type value stored in directory entry */
+#define SQUASHFS_MAX_DIR_TYPE		7
+
 /* Xattr types */
 #define SQUASHFS_XATTR_USER             0
 #define SQUASHFS_XATTR_TRUSTED          1
@@ -237,6 +240,7 @@ struct meta_index {
 #define LZMA_COMPRESSION	2
 #define LZO_COMPRESSION		3
 #define XZ_COMPRESSION		4
+#define LZ4_COMPRESSION		5
 
 struct squashfs_super_block {
 	__le32			s_magic;
diff --git a/fs/squashfs/squashfs_fs_sb.h b/fs/squashfs/squashfs_fs_sb.h
index 52934a2..1da565c 100644
--- a/fs/squashfs/squashfs_fs_sb.h
+++ b/fs/squashfs/squashfs_fs_sb.h
@@ -50,6 +50,7 @@ struct squashfs_cache_entry {
 	wait_queue_head_t	wait_queue;
 	struct squashfs_cache	*cache;
 	void			**data;
+	struct squashfs_page_actor	*actor;
 };
 
 struct squashfs_sb_info {
@@ -63,10 +64,9 @@ struct squashfs_sb_info {
 	__le64					*id_table;
 	__le64					*fragment_index;
 	__le64					*xattr_id_table;
-	struct mutex				read_data_mutex;
 	struct mutex				meta_index_mutex;
 	struct meta_index			*meta_index;
-	void					*stream;
+	struct squashfs_stream			*stream;
 	__le64					*inode_lookup_table;
 	u64					inode_table;
 	u64					directory_table;
diff --git a/fs/squashfs/super.c b/fs/squashfs/super.c
index 60553a9..5056bab 100644
--- a/fs/squashfs/super.c
+++ b/fs/squashfs/super.c
@@ -27,6 +27,8 @@
  * the filesystem.
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/fs.h>
 #include <linux/vfs.h>
 #include <linux/slab.h>
@@ -98,7 +100,6 @@ static int squashfs_fill_super(struct super_block *sb, void *data, int silent)
 	msblk->devblksize = sb_min_blocksize(sb, SQUASHFS_DEVBLK_SIZE);
 	msblk->devblksize_log2 = ffz(~msblk->devblksize);
 
-	mutex_init(&msblk->read_data_mutex);
 	mutex_init(&msblk->meta_index_mutex);
 
 	/*
@@ -206,13 +207,14 @@ static int squashfs_fill_super(struct super_block *sb, void *data, int silent)
 		goto failed_mount;
 
 	/* Allocate read_page block */
-	msblk->read_page = squashfs_cache_init("data", 1, msblk->block_size);
+	msblk->read_page = squashfs_cache_init("data",
+		squashfs_max_decompressors(), msblk->block_size);
 	if (msblk->read_page == NULL) {
 		ERROR("Failed to allocate read_page block\n");
 		goto failed_mount;
 	}
 
-	msblk->stream = squashfs_decompressor_init(sb, flags);
+	msblk->stream = squashfs_decompressor_setup(sb, flags);
 	if (IS_ERR(msblk->stream)) {
 		err = PTR_ERR(msblk->stream);
 		msblk->stream = NULL;
@@ -336,7 +338,7 @@ failed_mount:
 	squashfs_cache_delete(msblk->block_cache);
 	squashfs_cache_delete(msblk->fragment_cache);
 	squashfs_cache_delete(msblk->read_page);
-	squashfs_decompressor_free(msblk, msblk->stream);
+	squashfs_decompressor_destroy(msblk);
 	kfree(msblk->inode_lookup_table);
 	kfree(msblk->fragment_index);
 	kfree(msblk->id_table);
@@ -371,6 +373,7 @@ static int squashfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 
 static int squashfs_remount(struct super_block *sb, int *flags, char *data)
 {
+	sync_filesystem(sb);
 	*flags |= MS_RDONLY;
 	return 0;
 }
@@ -383,7 +386,7 @@ static void squashfs_put_super(struct super_block *sb)
 		squashfs_cache_delete(sbi->block_cache);
 		squashfs_cache_delete(sbi->fragment_cache);
 		squashfs_cache_delete(sbi->read_page);
-		squashfs_decompressor_free(sbi, sbi->stream);
+		squashfs_decompressor_destroy(sbi);
 		kfree(sbi->id_table);
 		kfree(sbi->fragment_index);
 		kfree(sbi->meta_index);
@@ -447,8 +450,7 @@ static int __init init_squashfs_fs(void)
 		return err;
 	}
 
-	printk(KERN_INFO "squashfs: version 4.0 (2009/01/31) "
-		"Phillip Lougher\n");
+	pr_info("version 4.0 (2009/01/31) Phillip Lougher\n");
 
 	return 0;
 }
diff --git a/fs/squashfs/xz_wrapper.c b/fs/squashfs/xz_wrapper.c
index 1760b7d..c609624 100644
--- a/fs/squashfs/xz_wrapper.c
+++ b/fs/squashfs/xz_wrapper.c
@@ -32,44 +32,70 @@
 #include "squashfs_fs_sb.h"
 #include "squashfs.h"
 #include "decompressor.h"
+#include "page_actor.h"
 
 struct squashfs_xz {
 	struct xz_dec *state;
 	struct xz_buf buf;
 };
 
-struct comp_opts {
+struct disk_comp_opts {
 	__le32 dictionary_size;
 	__le32 flags;
 };
 
-static void *squashfs_xz_init(struct squashfs_sb_info *msblk, void *buff,
-	int len)
+struct comp_opts {
+	int dict_size;
+};
+
+static void *squashfs_xz_comp_opts(struct squashfs_sb_info *msblk,
+	void *buff, int len)
 {
-	struct comp_opts *comp_opts = buff;
-	struct squashfs_xz *stream;
-	int dict_size = msblk->block_size;
-	int err, n;
+	struct disk_comp_opts *comp_opts = buff;
+	struct comp_opts *opts;
+	int err = 0, n;
+
+	opts = kmalloc(sizeof(*opts), GFP_KERNEL);
+	if (opts == NULL) {
+		err = -ENOMEM;
+		goto out2;
+	}
 
 	if (comp_opts) {
 		/* check compressor options are the expected length */
 		if (len < sizeof(*comp_opts)) {
 			err = -EIO;
-			goto failed;
+			goto out;
 		}
 
-		dict_size = le32_to_cpu(comp_opts->dictionary_size);
+		opts->dict_size = le32_to_cpu(comp_opts->dictionary_size);
 
 		/* the dictionary size should be 2^n or 2^n+2^(n+1) */
-		n = ffs(dict_size) - 1;
-		if (dict_size != (1 << n) && dict_size != (1 << n) +
+		n = ffs(opts->dict_size) - 1;
+		if (opts->dict_size != (1 << n) && opts->dict_size != (1 << n) +
 						(1 << (n + 1))) {
 			err = -EIO;
-			goto failed;
+			goto out;
 		}
-	}
+	} else
+		/* use defaults */
+		opts->dict_size = max_t(int, msblk->block_size,
+							SQUASHFS_METADATA_SIZE);
+
+	return opts;
+
+out:
+	kfree(opts);
+out2:
+	return ERR_PTR(err);
+}
+
 
-	dict_size = max_t(int, dict_size, SQUASHFS_METADATA_SIZE);
+static void *squashfs_xz_init(struct squashfs_sb_info *msblk, void *buff)
+{
+	struct comp_opts *comp_opts = buff;
+	struct squashfs_xz *stream;
+	int err;
 
 	stream = kmalloc(sizeof(*stream), GFP_KERNEL);
 	if (stream == NULL) {
@@ -77,7 +103,7 @@ static void *squashfs_xz_init(struct squashfs_sb_info *msblk, void *buff,
 		goto failed;
 	}
 
-	stream->state = xz_dec_init(XZ_PREALLOC, dict_size);
+	stream->state = xz_dec_init(XZ_PREALLOC, comp_opts->dict_size);
 	if (stream->state == NULL) {
 		kfree(stream);
 		err = -ENOMEM;
@@ -103,42 +129,37 @@ static void squashfs_xz_free(void *strm)
 }
 
 
-static int squashfs_xz_uncompress(struct squashfs_sb_info *msblk, void **buffer,
-	struct buffer_head **bh, int b, int offset, int length, int srclength,
-	int pages)
+static int squashfs_xz_uncompress(struct squashfs_sb_info *msblk, void *strm,
+	struct buffer_head **bh, int b, int offset, int length,
+	struct squashfs_page_actor *output)
 {
 	enum xz_ret xz_err;
-	int avail, total = 0, k = 0, page = 0;
-	struct squashfs_xz *stream = msblk->stream;
-
-	mutex_lock(&msblk->read_data_mutex);
+	int avail, total = 0, k = 0;
+	struct squashfs_xz *stream = strm;
 
 	xz_dec_reset(stream->state);
 	stream->buf.in_pos = 0;
 	stream->buf.in_size = 0;
 	stream->buf.out_pos = 0;
 	stream->buf.out_size = PAGE_CACHE_SIZE;
-	stream->buf.out = buffer[page++];
+	stream->buf.out = squashfs_first_page(output);
 
 	do {
 		if (stream->buf.in_pos == stream->buf.in_size && k < b) {
 			avail = min(length, msblk->devblksize - offset);
 			length -= avail;
-			wait_on_buffer(bh[k]);
-			if (!buffer_uptodate(bh[k]))
-				goto release_mutex;
-
 			stream->buf.in = bh[k]->b_data + offset;
 			stream->buf.in_size = avail;
 			stream->buf.in_pos = 0;
 			offset = 0;
 		}
 
-		if (stream->buf.out_pos == stream->buf.out_size
-							&& page < pages) {
-			stream->buf.out = buffer[page++];
-			stream->buf.out_pos = 0;
-			total += PAGE_CACHE_SIZE;
+		if (stream->buf.out_pos == stream->buf.out_size) {
+			stream->buf.out = squashfs_next_page(output);
+			if (stream->buf.out != NULL) {
+				stream->buf.out_pos = 0;
+				total += PAGE_CACHE_SIZE;
+			}
 		}
 
 		xz_err = xz_dec_run(stream->state, &stream->buf);
@@ -147,23 +168,14 @@ static int squashfs_xz_uncompress(struct squashfs_sb_info *msblk, void **buffer,
 			put_bh(bh[k++]);
 	} while (xz_err == XZ_OK);
 
-	if (xz_err != XZ_STREAM_END) {
-		ERROR("xz_dec_run error, data probably corrupt\n");
-		goto release_mutex;
-	}
-
-	if (k < b) {
-		ERROR("xz_uncompress error, input remaining\n");
-		goto release_mutex;
-	}
+	squashfs_finish_page(output);
 
-	total += stream->buf.out_pos;
-	mutex_unlock(&msblk->read_data_mutex);
-	return total;
+	if (xz_err != XZ_STREAM_END || k < b)
+		goto out;
 
-release_mutex:
-	mutex_unlock(&msblk->read_data_mutex);
+	return total + stream->buf.out_pos;
 
+out:
 	for (; k < b; k++)
 		put_bh(bh[k]);
 
@@ -172,6 +184,7 @@ release_mutex:
 
 const struct squashfs_decompressor squashfs_xz_comp_ops = {
 	.init = squashfs_xz_init,
+	.comp_opts = squashfs_xz_comp_opts,
 	.free = squashfs_xz_free,
 	.decompress = squashfs_xz_uncompress,
 	.id = XZ_COMPRESSION,
diff --git a/fs/squashfs/zlib_wrapper.c b/fs/squashfs/zlib_wrapper.c
index 55d918f..8727cab 100644
--- a/fs/squashfs/zlib_wrapper.c
+++ b/fs/squashfs/zlib_wrapper.c
@@ -32,8 +32,9 @@
 #include "squashfs_fs_sb.h"
 #include "squashfs.h"
 #include "decompressor.h"
+#include "page_actor.h"
 
-static void *zlib_init(struct squashfs_sb_info *dummy, void *buff, int len)
+static void *zlib_init(struct squashfs_sb_info *dummy, void *buff)
 {
 	z_stream *stream = kmalloc(sizeof(z_stream), GFP_KERNEL);
 	if (stream == NULL)
@@ -61,44 +62,37 @@ static void zlib_free(void *strm)
 }
 
 
-static int zlib_uncompress(struct squashfs_sb_info *msblk, void **buffer,
-	struct buffer_head **bh, int b, int offset, int length, int srclength,
-	int pages)
+static int zlib_uncompress(struct squashfs_sb_info *msblk, void *strm,
+	struct buffer_head **bh, int b, int offset, int length,
+	struct squashfs_page_actor *output)
 {
-	int zlib_err, zlib_init = 0;
-	int k = 0, page = 0;
-	z_stream *stream = msblk->stream;
-
-	mutex_lock(&msblk->read_data_mutex);
+	int zlib_err, zlib_init = 0, k = 0;
+	z_stream *stream = strm;
 
-	stream->avail_out = 0;
+	stream->avail_out = PAGE_CACHE_SIZE;
+	stream->next_out = squashfs_first_page(output);
 	stream->avail_in = 0;
 
 	do {
 		if (stream->avail_in == 0 && k < b) {
 			int avail = min(length, msblk->devblksize - offset);
 			length -= avail;
-			wait_on_buffer(bh[k]);
-			if (!buffer_uptodate(bh[k]))
-				goto release_mutex;
-
 			stream->next_in = bh[k]->b_data + offset;
 			stream->avail_in = avail;
 			offset = 0;
 		}
 
-		if (stream->avail_out == 0 && page < pages) {
-			stream->next_out = buffer[page++];
-			stream->avail_out = PAGE_CACHE_SIZE;
+		if (stream->avail_out == 0) {
+			stream->next_out = squashfs_next_page(output);
+			if (stream->next_out != NULL)
+				stream->avail_out = PAGE_CACHE_SIZE;
 		}
 
 		if (!zlib_init) {
 			zlib_err = zlib_inflateInit(stream);
 			if (zlib_err != Z_OK) {
-				ERROR("zlib_inflateInit returned unexpected "
-					"result 0x%x, srclength %d\n",
-					zlib_err, srclength);
-				goto release_mutex;
+				squashfs_finish_page(output);
+				goto out;
 			}
 			zlib_init = 1;
 		}
@@ -109,29 +103,21 @@ static int zlib_uncompress(struct squashfs_sb_info *msblk, void **buffer,
 			put_bh(bh[k++]);
 	} while (zlib_err == Z_OK);
 
-	if (zlib_err != Z_STREAM_END) {
-		ERROR("zlib_inflate error, data probably corrupt\n");
-		goto release_mutex;
-	}
+	squashfs_finish_page(output);
 
-	zlib_err = zlib_inflateEnd(stream);
-	if (zlib_err != Z_OK) {
-		ERROR("zlib_inflate error, data probably corrupt\n");
-		goto release_mutex;
-	}
+	if (zlib_err != Z_STREAM_END)
+		goto out;
 
-	if (k < b) {
-		ERROR("zlib_uncompress error, data remaining\n");
-		goto release_mutex;
-	}
+	zlib_err = zlib_inflateEnd(stream);
+	if (zlib_err != Z_OK)
+		goto out;
 
-	length = stream->total_out;
-	mutex_unlock(&msblk->read_data_mutex);
-	return length;
+	if (k < b)
+		goto out;
 
-release_mutex:
-	mutex_unlock(&msblk->read_data_mutex);
+	return stream->total_out;
 
+out:
 	for (; k < b; k++)
 		put_bh(bh[k]);
 
diff --git a/fs/stat.c b/fs/stat.c
index 04ce1ac..d0ea7ef 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -447,9 +447,8 @@ void inode_add_bytes(struct inode *inode, loff_t bytes)
 
 EXPORT_SYMBOL(inode_add_bytes);
 
-void inode_sub_bytes(struct inode *inode, loff_t bytes)
+void __inode_sub_bytes(struct inode *inode, loff_t bytes)
 {
-	spin_lock(&inode->i_lock);
 	inode->i_blocks -= bytes >> 9;
 	bytes &= 511;
 	if (inode->i_bytes < bytes) {
@@ -457,6 +456,14 @@ void inode_sub_bytes(struct inode *inode, loff_t bytes)
 		inode->i_bytes += 512;
 	}
 	inode->i_bytes -= bytes;
+}
+
+EXPORT_SYMBOL(__inode_sub_bytes);
+
+void inode_sub_bytes(struct inode *inode, loff_t bytes)
+{
+	spin_lock(&inode->i_lock);
+	__inode_sub_bytes(inode, bytes);
 	spin_unlock(&inode->i_lock);
 }
 
diff --git a/fs/sysv/inode.c b/fs/sysv/inode.c
index c327d4e..4742e58 100644
--- a/fs/sysv/inode.c
+++ b/fs/sysv/inode.c
@@ -60,6 +60,7 @@ static int sysv_remount(struct super_block *sb, int *flags, char *data)
 {
 	struct sysv_sb_info *sbi = SYSV_SB(sb);
 
+	sync_filesystem(sb);
 	if (sbi->s_forced_ro)
 		*flags |= MS_RDONLY;
 	return 0;
diff --git a/fs/ubifs/super.c b/fs/ubifs/super.c
index 6ea200d..20c777e 100644
--- a/fs/ubifs/super.c
+++ b/fs/ubifs/super.c
@@ -1862,6 +1862,7 @@ static int ubifs_remount_fs(struct super_block *sb, int *flags, char *data)
 	int err;
 	struct ubifs_info *c = sb->s_fs_info;
 
+	sync_filesystem(sb);
 	dbg_gen("old flags %#lx, new flags %#x", sb->s_flags, *flags);
 
 	err = ubifs_parse_options(c, data, 1);
diff --git a/fs/udf/super.c b/fs/udf/super.c
index 839a2ba..32f5297 100644
--- a/fs/udf/super.c
+++ b/fs/udf/super.c
@@ -629,6 +629,7 @@ static int udf_remount_fs(struct super_block *sb, int *flags, char *options)
 	struct udf_options uopt;
 	struct udf_sb_info *sbi = UDF_SB(sb);
 	int error = 0;
+	sync_filesystem(sb);
 
 	if (sbi->s_lvid_bh) {
 		int write_rev = le16_to_cpu(udf_sb_lvidiu(sbi)->minUDFWriteRev);
diff --git a/fs/ufs/super.c b/fs/ufs/super.c
index 329f2f5..b8c6791 100644
--- a/fs/ufs/super.c
+++ b/fs/ufs/super.c
@@ -1280,6 +1280,7 @@ static int ufs_remount (struct super_block *sb, int *mount_flags, char *data)
 	unsigned new_mount_opt, ufstype;
 	unsigned flags;
 
+	sync_filesystem(sb);
 	lock_ufs(sb);
 	mutex_lock(&UFS_SB(sb)->s_lock);
 	uspi = UFS_SB(sb)->s_uspi;
diff --git a/fs/xfs/xfs_buf_item.c b/fs/xfs/xfs_buf_item.c
index 4ec4317..e0451f4 100644
--- a/fs/xfs/xfs_buf_item.c
+++ b/fs/xfs/xfs_buf_item.c
@@ -296,6 +296,10 @@ xfs_buf_item_format(
 	ASSERT(atomic_read(&bip->bli_refcount) > 0);
 	ASSERT((bip->bli_flags & XFS_BLI_LOGGED) ||
 	       (bip->bli_flags & XFS_BLI_STALE));
+	ASSERT((bip->bli_flags & XFS_BLI_STALE) ||
+	       (xfs_blft_from_flags(&bip->__bli_format) > XFS_BLFT_UNKNOWN_BUF
+	        && xfs_blft_from_flags(&bip->__bli_format) < XFS_BLFT_MAX_BUF));
+
 
 	/*
 	 * If it is an inode buffer, transfer the in-memory state to the
diff --git a/fs/xfs/xfs_inode.c b/fs/xfs/xfs_inode.c
index 7f7be5f..f010ab4 100644
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@ -1655,6 +1655,7 @@ xfs_iunlink(
 	agi->agi_unlinked[bucket_index] = cpu_to_be32(agino);
 	offset = offsetof(xfs_agi_t, agi_unlinked) +
 		(sizeof(xfs_agino_t) * bucket_index);
+	xfs_trans_buf_set_type(tp, agibp, XFS_BLFT_AGI_BUF);
 	xfs_trans_log_buf(tp, agibp, offset,
 			  (offset + sizeof(xfs_agino_t) - 1));
 	return 0;
@@ -1746,6 +1747,7 @@ xfs_iunlink_remove(
 		agi->agi_unlinked[bucket_index] = cpu_to_be32(next_agino);
 		offset = offsetof(xfs_agi_t, agi_unlinked) +
 			(sizeof(xfs_agino_t) * bucket_index);
+		xfs_trans_buf_set_type(tp, agibp, XFS_BLFT_AGI_BUF);
 		xfs_trans_log_buf(tp, agibp, offset,
 				  (offset + sizeof(xfs_agino_t) - 1));
 	} else {
diff --git a/fs/xfs/xfs_super.c b/fs/xfs/xfs_super.c
index 3033ba5..478c0ad 100644
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@ -1218,6 +1218,7 @@ xfs_fs_remount(
 	char			*p;
 	int			error;
 
+	sync_filesystem(sb);
 	while ((p = strsep(&options, ",")) != NULL) {
 		int token;
 
diff --git a/fs/xfs/xfs_trans.c b/fs/xfs/xfs_trans.c
index 2fd7c1f..b5d5beb 100644
--- a/fs/xfs/xfs_trans.c
+++ b/fs/xfs/xfs_trans.c
@@ -1100,6 +1100,7 @@ xfs_trans_apply_sb_deltas(
 		whole = 1;
 	}
 
+	xfs_trans_buf_set_type(tp, bp, XFS_BLFT_SB_BUF);
 	if (whole)
 		/*
 		 * Log the whole thing, the fields are noncontiguous.
diff --git a/include/linux/batch.h b/include/linux/batch.h
index cb7b03c..9fb9ccf 100644
--- a/include/linux/batch.h
+++ b/include/linux/batch.h
@@ -89,8 +89,8 @@ struct batch_data_path
 
 struct batch_dev_list
 {
-	struct batch_control_path 	ctl_dev[MAX_ANDROID_SENSOR_NUM+1];//ctl_dev[max] is used for sensor HUB driver to control sensor HUB , ctl_dev[1]... are for single sensor batch mode control
-	struct batch_data_path 		data_dev[MAX_ANDROID_SENSOR_NUM+1];//data_dev[max] is used for sensor HUB driver to access single fifo sensor data, data_dev[1]... are for single sensor fifo sensor data
+	struct batch_control_path 	ctl_dev[ID_SENSOR_MAX_HANDLE+1];//ctl_dev[max] is used for sensor HUB driver to control sensor HUB , ctl_dev[1]... are for single sensor batch mode control
+	struct batch_data_path 		data_dev[ID_SENSOR_MAX_HANDLE+1];//data_dev[max] is used for sensor HUB driver to access single fifo sensor data, data_dev[1]... are for single sensor fifo sensor data
 };
 
 
@@ -120,7 +120,7 @@ struct batch_context {
 	int				numOfDataLeft;
 	int                 force_wake_upon_fifo_full;
 
-    struct batch_timestamp_info timestamp_info[MAX_ANDROID_SENSOR_NUM+1];
+    struct batch_timestamp_info timestamp_info[ID_SENSOR_MAX_HANDLE+1];
 };
 
 typedef enum {
@@ -138,7 +138,7 @@ extern int  batch_notify(BATCH_NOTIFY_TYPE type);
 extern int  batch_driver_add(struct batch_init_info* obj);
 extern void report_batch_data(struct input_dev *dev, hwm_sensor_data *data);
 extern void report_batch_finish(struct input_dev *dev, int handle);
-extern int batch_register_control_path(int handle, struct batch_control_path *ctl);//when you register control path of sensor hub driver, use handle = [MAX_ANDROID_SENSOR_NUM+1]
-extern int batch_register_data_path(int handle, struct batch_data_path *data);//when you register control path of sensor hub driver, use handle = [MAX_ANDROID_SENSOR_NUM+1]
+extern int batch_register_control_path(int handle, struct batch_control_path *ctl);//when you register control path of sensor hub driver, use handle = [ID_SENSOR_MAX_HANDLE+1]
+extern int batch_register_data_path(int handle, struct batch_data_path *data);//when you register control path of sensor hub driver, use handle = [ID_SENSOR_MAX_HANDLE+1]
 extern int batch_register_support_info(int handle, int support, int div, int timestamp_supported);
 #endif
diff --git a/include/linux/cgroup_subsys.h b/include/linux/cgroup_subsys.h
index 6e7ec64..60216b1 100644
--- a/include/linux/cgroup_subsys.h
+++ b/include/linux/cgroup_subsys.h
@@ -83,4 +83,8 @@ SUBSYS(hugetlb)
 SUBSYS(bcache)
 #endif
 
+#if IS_SUBSYS_ENABLED(CONFIG_CGROUP_BFQIO)
+SUBSYS(bfqio)
+#endif
+
 /* */
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
index b92eadf..2b00d92 100644
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -26,6 +26,19 @@
 #include <linux/uaccess.h>
 
 /*
+ * Autoloaded crypto modules should only use a prefixed name to avoid allowing
+ * arbitrary modules to be loaded. Loading from userspace may still need the
+ * unprefixed names, so retains those aliases as well.
+ * This uses __MODULE_INFO directly instead of MODULE_ALIAS because pre-4.3
+ * gcc (e.g. avr32 toolchain) uses __LINE__ for uniqueness, and this macro
+ * expands twice on the same line. Instead, use a separate base name for the
+ * alias.
+ */
+#define MODULE_ALIAS_CRYPTO(name)	\
+		__MODULE_INFO(alias, alias_userspace, name);	\
+		__MODULE_INFO(alias, alias_crypto, "crypto-" name)
+
+/*
  * Algorithm masks and types.
  */
 #define CRYPTO_ALG_TYPE_MASK		0x0000000f
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3c46de2..edecfa2 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1507,6 +1507,17 @@ int fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags);
  * to have different dirent layouts depending on the binary type.
  */
 typedef int (*filldir_t)(void *, const char *, int, loff_t, u64, unsigned);
+struct dir_context {
+	const filldir_t actor;
+	loff_t pos;
+};
+
+static inline bool dir_emit(struct dir_context *ctx,
+			    const char *name, int namelen,
+			    u64 ino, unsigned type)
+{
+	return ctx->actor(ctx, name, namelen, ctx->pos, ino, type) == 0;
+}
 struct block_device_operations;
 
 /* These macros are for out of kernel modules to test that
@@ -1523,6 +1534,7 @@ struct file_operations {
 	ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
 	ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
 	int (*readdir) (struct file *, void *, filldir_t);
+	int (*iterate) (struct file *, struct dir_context *);
 	unsigned int (*poll) (struct file *, struct poll_table_struct *);
 	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
 	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
@@ -2499,11 +2511,13 @@ extern void generic_fillattr(struct inode *, struct kstat *);
 extern int vfs_getattr(struct path *, struct kstat *);
 void __inode_add_bytes(struct inode *inode, loff_t bytes);
 void inode_add_bytes(struct inode *inode, loff_t bytes);
+void __inode_sub_bytes(struct inode *inode, loff_t bytes);
 void inode_sub_bytes(struct inode *inode, loff_t bytes);
 loff_t inode_get_bytes(struct inode *inode);
 void inode_set_bytes(struct inode *inode, loff_t bytes);
 
 extern int vfs_readdir(struct file *, filldir_t, void *);
+extern int iterate_dir(struct file *, struct dir_context *);
 
 extern int vfs_stat(const char __user *, struct kstat *);
 extern int vfs_lstat(const char __user *, struct kstat *);
diff --git a/include/linux/fsnotify.h b/include/linux/fsnotify.h
index a78680a..661c0ae 100644
--- a/include/linux/fsnotify.h
+++ b/include/linux/fsnotify.h
@@ -101,8 +101,10 @@ static inline void fsnotify_move(struct inode *old_dir, struct inode *new_dir,
 		new_dir_mask |= FS_ISDIR;
 	}
 
-	fsnotify(old_dir, old_dir_mask, old_dir, FSNOTIFY_EVENT_INODE, old_name, fs_cookie);
-	fsnotify(new_dir, new_dir_mask, new_dir, FSNOTIFY_EVENT_INODE, new_name, fs_cookie);
+	fsnotify(old_dir, old_dir_mask, source, FSNOTIFY_EVENT_INODE, old_name,
+		 fs_cookie);
+	fsnotify(new_dir, new_dir_mask, source, FSNOTIFY_EVENT_INODE, new_name,
+		 fs_cookie);
 
 	if (target)
 		fsnotify_link_count(target);
diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 98300e2..6de0f2c 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -115,12 +115,6 @@ struct irqaction {
 	unsigned long		thread_flags;
 	unsigned long		thread_mask;
 	const char		*name;
-#ifdef CONFIG_MTPROF_IRQ_DURATION
-	unsigned long long duration;
-	unsigned long count;
-	unsigned long long dur_max;
-	unsigned long long dur_min;
-#endif
 	struct proc_dir_entry	*dir;
 } ____cacheline_internodealigned_in_smp;
 
diff --git a/include/linux/mm.h b/include/linux/mm.h
index cf90902..5d8f988 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -1182,6 +1182,11 @@ static inline void update_hiwater_vm(struct mm_struct *mm)
 		mm->hiwater_vm = mm->total_vm;
 }
 
+static inline void reset_mm_hiwater_rss(struct mm_struct *mm)
+{
+	mm->hiwater_rss = get_mm_rss(mm);
+}
+
 static inline void setmax_mm_hiwater_rss(unsigned long *maxrss,
 					 struct mm_struct *mm)
 {
diff --git a/include/linux/mmprofile_internal.h b/include/linux/mmprofile_internal.h
index 9f184e2..9cc6f0f 100644
--- a/include/linux/mmprofile_internal.h
+++ b/include/linux/mmprofile_internal.h
@@ -7,7 +7,7 @@
 extern "C" {
 #endif
 
-#define MMProfileMaxEventCount 4096
+#define MMProfileMaxEventCount 1000
 
 #define MMP_EVENT_STATE_ENABLED (1 << 0)
 #define MMP_EVENT_STATE_FTRACE  (1 << 1)
diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h
index 9a9ebd0..bfe1126 100644
--- a/include/linux/mmzone.h
+++ b/include/linux/mmzone.h
@@ -84,9 +84,13 @@ enum {
 
 extern int page_group_by_mobility_disabled;
 
+#define NR_MIGRATETYPE_BITS (PB_migrate_end - PB_migrate + 1)
+#define MIGRATETYPE_MASK ((1UL << NR_MIGRATETYPE_BITS) - 1)
+
 static inline int get_pageblock_migratetype(struct page *page)
 {
-	return get_pageblock_flags_group(page, PB_migrate, PB_migrate_end);
+	BUILD_BUG_ON(PB_migrate_end - PB_migrate != 2);
+	return get_pageblock_flags_mask(page, PB_migrate_end, MIGRATETYPE_MASK);
 }
 
 struct free_area {
diff --git a/include/linux/mu3phy/mtk-phy-asic.h b/include/linux/mu3phy/mtk-phy-asic.h
index 9000abd..8cdafe1 100644
--- a/include/linux/mu3phy/mtk-phy-asic.h
+++ b/include/linux/mu3phy/mtk-phy-asic.h
@@ -12,6 +12,7 @@
 #define U3D_U2PHYACR3       (SSUSB_SIFSLV_U2PHY_COM_SIV_B_BASE+0x001c) /*0:31 SIV_B*/
 #define U3D_U2PHYACR4_0     (SSUSB_SIFSLV_U2PHY_COM_SIV_B_BASE+0x0020) /*0:5 SIV_B*/
 
+#define U3D_USBPHYACR2_0	(SSUSB_SIFSLV_U2PHY_COM_BASE+0x0008) /* 16:18 */
 #define U3D_U2PHYACR4       (SSUSB_SIFSLV_U2PHY_COM_BASE+0x0020) /*8:18*/
 #define U3D_U2PHYAMON0      (SSUSB_SIFSLV_U2PHY_COM_BASE+0x0024) /*0:1*/
 #define U3D_U2PHYDCR0       (SSUSB_SIFSLV_U2PHY_COM_BASE+0x0060) /*0:31*/
@@ -111,6 +112,9 @@ struct u2phy_reg_e {
 #define E60802_RG_SIFSLV_MAC_CHOPPER_EN           (0x1<<16) //16:16
 #define E60802_RG_USB20_CLKREF_REV                (0xffff<<0) //15:0
 
+//U3D_USBPHYACR2_0
+#define E60802_RG_SIFSLV_USB20_PLL_FORCE_MODE		(0x1<<18) //18:18
+
 //U3D_USBPHYACR4
 #define E60802_RG_USB20_DP_ABIST_SOURCE_EN        (0x1<<31) //31:31
 #define E60802_RG_USB20_DP_ABIST_SELE             (0xf<<24) //27:24
@@ -362,6 +366,9 @@ struct u2phy_reg_e {
 #define E60802_RG_SIFSLV_MAC_CHOPPER_EN_OFST      (16)
 #define E60802_RG_USB20_CLKREF_REV_OFST           (0)
 
+//U3D_USBPHYACR2_0
+#define E60802_RG_SIFSLV_USB20_PLL_FORCE_MODE_OFST	(18)
+
 //U3D_USBPHYACR4
 #define E60802_RG_USB20_DP_ABIST_SOURCE_EN_OFST   (31)
 #define E60802_RG_USB20_DP_ABIST_SELE_OFST        (24)
diff --git a/include/linux/mu3phy/mtk-phy.h b/include/linux/mu3phy/mtk-phy.h
index deff657..fc335ee 100644
--- a/include/linux/mu3phy/mtk-phy.h
+++ b/include/linux/mu3phy/mtk-phy.h
@@ -201,8 +201,9 @@ EXTERN PHY_UINT8                      _bYcurr;
 EXTERN enumScanDir               _eScanDir;
 EXTERN PHY_INT8                      _fgXChged;
 EXTERN unsigned int                      _bPIResult;
-EXTERN PHY_UINT32 pwErrCnt0[CYCLE_COUNT_MAX][ERRCNT_MAX][ERRCNT_MAX];
-EXTERN PHY_UINT32 pwErrCnt1[CYCLE_COUNT_MAX][ERRCNT_MAX][ERRCNT_MAX];
+/* Comment for saving the kernel size. This's only used at external PHY*/
+/*EXTERN PHY_UINT32 pwErrCnt0[CYCLE_COUNT_MAX][ERRCNT_MAX][ERRCNT_MAX];*/
+/*EXTERN PHY_UINT32 pwErrCnt1[CYCLE_COUNT_MAX][ERRCNT_MAX][ERRCNT_MAX];*/
 
 /***********************************/
 #endif
diff --git a/include/linux/pageblock-flags.h b/include/linux/pageblock-flags.h
index be655e4..1ccd74e 100644
--- a/include/linux/pageblock-flags.h
+++ b/include/linux/pageblock-flags.h
@@ -30,9 +30,11 @@ enum pageblock_bits {
 	PB_migrate,
 	PB_migrate_end = PB_migrate + 3 - 1,
 			/* 3 bits required for migrate types */
-#ifdef CONFIG_COMPACTION
 	PB_migrate_skip,/* If set the block is skipped by compaction */
-#endif /* CONFIG_COMPACTION */
+	/*
+	 * Assume the bits will always align on a word. If this assumption
+	 * changes then get/set pageblock needs updating.
+	 */
 	NR_PAGEBLOCK_BITS
 };
 
@@ -62,11 +64,32 @@ extern int pageblock_order;
 /* Forward declaration */
 struct page;
 
+unsigned long get_pageblock_flags_mask(struct page *page,
+				unsigned long end_bitidx,
+				unsigned long mask);
+void set_pageblock_flags_mask(struct page *page,
+				unsigned long flags,
+				unsigned long end_bitidx,
+				unsigned long mask);
 /* Declarations for getting and setting flags. See mm/page_alloc.c */
-unsigned long get_pageblock_flags_group(struct page *page,
-					int start_bitidx, int end_bitidx);
-void set_pageblock_flags_group(struct page *page, unsigned long flags,
-					int start_bitidx, int end_bitidx);
+static inline unsigned long get_pageblock_flags_group(struct page *page,
+					int start_bitidx, int end_bitidx)
+{
+	unsigned long nr_flag_bits = end_bitidx - start_bitidx + 1;
+	unsigned long mask = (1 << nr_flag_bits) - 1;
+
+	return get_pageblock_flags_mask(page, end_bitidx, mask);
+}
+
+static inline void set_pageblock_flags_group(struct page *page,
+					unsigned long flags,
+					int start_bitidx, int end_bitidx)
+{
+	unsigned long nr_flag_bits = end_bitidx - start_bitidx + 1;
+	unsigned long mask = (1 << nr_flag_bits) - 1;
+
+	set_pageblock_flags_mask(page, flags, end_bitidx, mask);
+}
 
 #ifdef CONFIG_COMPACTION
 #define get_pageblock_skip(page) \
diff --git a/include/linux/quotaops.h b/include/linux/quotaops.h
index 1c50093..6965fe3 100644
--- a/include/linux/quotaops.h
+++ b/include/linux/quotaops.h
@@ -41,6 +41,7 @@ void __quota_error(struct super_block *sb, const char *func,
 void inode_add_rsv_space(struct inode *inode, qsize_t number);
 void inode_claim_rsv_space(struct inode *inode, qsize_t number);
 void inode_sub_rsv_space(struct inode *inode, qsize_t number);
+void inode_reclaim_rsv_space(struct inode *inode, qsize_t number);
 
 void dquot_initialize(struct inode *inode);
 void dquot_drop(struct inode *inode);
@@ -59,6 +60,7 @@ int dquot_alloc_inode(const struct inode *inode);
 
 int dquot_claim_space_nodirty(struct inode *inode, qsize_t number);
 void dquot_free_inode(const struct inode *inode);
+void dquot_reclaim_space_nodirty(struct inode *inode, qsize_t number);
 
 int dquot_disable(struct super_block *sb, int type, unsigned int flags);
 /* Suspend quotas on remount RO */
@@ -238,6 +240,13 @@ static inline int dquot_claim_space_nodirty(struct inode *inode, qsize_t number)
 	return 0;
 }
 
+static inline int dquot_reclaim_space_nodirty(struct inode *inode,
+					      qsize_t number)
+{
+	inode_sub_bytes(inode, number);
+	return 0;
+}
+
 static inline int dquot_disable(struct super_block *sb, int type,
 		unsigned int flags)
 {
@@ -336,6 +345,12 @@ static inline int dquot_claim_block(struct inode *inode, qsize_t nr)
 	return ret;
 }
 
+static inline void dquot_reclaim_block(struct inode *inode, qsize_t nr)
+{
+	dquot_reclaim_space_nodirty(inode, nr << inode->i_blkbits);
+	mark_inode_dirty_sync(inode);
+}
+
 static inline void dquot_free_space_nodirty(struct inode *inode, qsize_t nr)
 {
 	__dquot_free_space(inode, nr, 0);
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index a0d1c0d..478120a 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -1942,10 +1942,7 @@ static inline void __skb_queue_purge(struct sk_buff_head *list)
 		kfree_skb(skb);
 }
 
-#if 1  // memory fragement issue
 #define NETDEV_FRAG_PAGE_MAX_ORDER get_order(32768)
-#endif
-//#define NETDEV_FRAG_PAGE_MAX_ORDER get_order(8192)
 #define NETDEV_FRAG_PAGE_MAX_SIZE  (PAGE_SIZE << NETDEV_FRAG_PAGE_MAX_ORDER)
 #define NETDEV_PAGECNT_MAX_BIAS	   NETDEV_FRAG_PAGE_MAX_SIZE
 
diff --git a/include/linux/time.h b/include/linux/time.h
index d5d229b..7d532a3 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -173,6 +173,19 @@ extern void getboottime(struct timespec *ts);
 extern void monotonic_to_bootbased(struct timespec *ts);
 extern void get_monotonic_boottime(struct timespec *ts);
 
+static inline bool timeval_valid(const struct timeval *tv)
+{
+	/* Dates before 1970 are bogus */
+	if (tv->tv_sec < 0)
+		return false;
+
+	/* Can't have more microseconds then a second */
+	if (tv->tv_usec < 0 || tv->tv_usec >= USEC_PER_SEC)
+		return false;
+
+	return true;
+}
+
 extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 extern int timekeeping_valid_for_hres(void);
 extern u64 timekeeping_max_deferment(void);
diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index ba6ce1e..00ecc77 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -426,6 +426,7 @@ extern const struct dev_pm_ops usb_hcd_pci_pm_ops;
 #endif /* CONFIG_PCI */
 
 /* pci-ish (pdev null is ok) buffer alloc/mapping support */
+void usb_init_pool_max(void);
 int hcd_buffer_create(struct usb_hcd *hcd);
 void hcd_buffer_destroy(struct usb_hcd *hcd);
 
diff --git a/include/mach/battery_common.h b/include/mach/battery_common.h
index 40a35ab..d9b3ec9 100644
--- a/include/mach/battery_common.h
+++ b/include/mach/battery_common.h
@@ -10,12 +10,14 @@
  *  BATTERY VOLTAGE
  ****************************************************************************/
 #define PRE_CHARGE_VOLTAGE                  3200
-#define SYSTEM_OFF_VOLTAGE                  3400
 #define CONSTANT_CURRENT_CHARGE_VOLTAGE     4100
 #define CONSTANT_VOLTAGE_CHARGE_VOLTAGE     4200
 #define CV_DROPDOWN_VOLTAGE                 4000
 #define CHARGER_THRESH_HOLD                 4300
 #define BATTERY_UVLO_VOLTAGE                2700
+#ifndef SHUTDOWN_SYSTEM_VOLTAGE
+#define SHUTDOWN_SYSTEM_VOLTAGE		3400
+#endif
 
 /*****************************************************************************
  *  BATTERY TIMER
@@ -87,6 +89,13 @@ typedef enum {
 	BATTERY_AVG_MAX
 } BATTERY_AVG_ENUM;
 
+typedef enum {
+	BATTERY_THREAD_TIME = 0,
+	CAR_TIME,
+	SUSPEND_TIME,
+	DURATION_NUM
+} BATTERY_TIME_ENUM;
+
 /*****************************************************************************
 *   JEITA battery temperature standard
     charging info ,like temperatue, charging current, re-charging voltage, CV threshold would be reconfigurated.
@@ -168,6 +177,7 @@ typedef struct {
 	UINT32 charger_type;
 	INT32 SOC;
 	INT32 UI_SOC;
+	INT32 UI_SOC2;
 	UINT32 nPercent_ZCV;
 	UINT32 nPrecent_UI_SOC_check_point;
 	UINT32 ZCV;
@@ -206,6 +216,13 @@ extern void set_usb_current_unlimited(bool enable);
 extern bool get_usb_current_unlimited(void);
 extern CHARGER_TYPE mt_get_charger_type(void);
 
+extern kal_uint32 mt_battery_get_duration_time(BATTERY_TIME_ENUM duration_type);
+extern void mt_battery_update_time(struct timespec * pre_time, BATTERY_TIME_ENUM duration_type);
+
+extern kal_uint32 mt_battery_shutdown_check(void);
+
+extern kal_uint8 bat_is_kpoc(void);
+
 #ifdef CONFIG_MTK_SMART_BATTERY
 extern void wake_up_bat(void);
 extern void wake_up_bat2(void);
diff --git a/include/mach/battery_meter.h b/include/mach/battery_meter.h
index 12d84e9..f88eb8a 100644
--- a/include/mach/battery_meter.h
+++ b/include/mach/battery_meter.h
@@ -16,6 +16,30 @@
 /* structure */
 /* ============================================================ */
 
+#define FGD_NL_MSG_T_HDR_LEN 12
+#define FGD_NL_MSG_MAX_LEN 9200
+
+struct fgd_nl_msg_t{
+    unsigned int fgd_cmd;
+    unsigned int fgd_data_len;
+    unsigned int fgd_ret_data_len;
+	char fgd_data[FGD_NL_MSG_MAX_LEN];
+};
+
+enum {
+	FG_MAIN = 1,
+	FG_SUSPEND = 2,
+	FG_RESUME = 4,
+	FG_CHARGER = 8
+};
+
+enum {
+	HW_FG,
+	SW_FG,
+	AUXADC
+};
+
+
 /* ============================================================ */
 /* typedef */
 /* ============================================================ */
@@ -24,6 +48,71 @@ typedef struct {
 	INT32 TemperatureR;
 } BATT_TEMPERATURE;
 
+typedef enum {
+	FG_DAEMON_CMD_GET_INIT_FLAG,
+	FG_DAEMON_CMD_GET_SOC,
+	FG_DAEMON_CMD_GET_DOD0,
+	FG_DAEMON_CMD_GET_DOD1,
+	FG_DAEMON_CMD_GET_HW_OCV,
+	FG_DAEMON_CMD_GET_HW_FG_INIT_CURRENT,
+	FG_DAEMON_CMD_GET_HW_FG_CURRENT,
+	FG_DAEMON_CMD_GET_HW_FG_INIT_CURRENT_SIGN,
+	FG_DAEMON_CMD_GET_HW_FG_CURRENT_SIGN,
+	FG_DAEMON_CMD_GET_HW_FG_CAR_ACT,
+	FG_DAEMON_CMD_GET_TEMPERTURE,
+	FG_DAEMON_CMD_DUMP_REGISTER,
+	FG_DAEMON_CMD_CHARGING_ENABLE,
+	FG_DAEMON_CMD_GET_BATTERY_INIT_VOLTAGE,
+	FG_DAEMON_CMD_GET_BATTERY_VOLTAGE,
+	FG_DAEMON_CMD_FGADC_RESET,
+	FG_DAEMON_CMD_GET_BATTERY_PLUG_STATUS,
+	FG_DAEMON_CMD_GET_RTC_SPARE_FG_VALUE,
+	FG_DAEMON_CMD_IS_CHARGER_EXIST,
+	FG_DAEMON_CMD_IS_BATTERY_FULL,           //bat_is_battery_full,
+	FG_DAEMON_CMD_SET_BATTERY_FULL,			 //bat_set_battery_full,
+	FG_DAEMON_CMD_SET_RTC,					 //set RTC,
+	FG_DAEMON_CMD_SET_POWEROFF,				 //set Poweroff,
+	FG_DAEMON_CMD_IS_KPOC,           		 //is KPOC,
+	FG_DAEMON_CMD_GET_BOOT_REASON,           //g_boot_reason,
+	FG_DAEMON_CMD_GET_CHARGING_CURRENT,
+	FG_DAEMON_CMD_GET_CHARGER_VOLTAGE,
+	FG_DAEMON_CMD_GET_SHUTDOWN_COND,
+	FG_DAEMON_CMD_GET_CUSTOM_SETTING,
+	FG_DAEMON_CMD_GET_UI_SOC,
+	FG_DAEMON_CMD_GET_CV_VALUE,
+	FG_DAEMON_CMD_GET_DURATION_TIME,
+	FG_DAEMON_CMD_GET_TRACKING_TIME,
+	FG_DAEMON_CMD_GET_CURRENT_TH,
+	FG_DAEMON_CMD_GET_CHECK_TIME,
+	FG_DAEMON_CMD_GET_DIFFERENCE_VOLTAGE_UPDATE,
+	FG_DAEMON_CMD_GET_AGING1_LOAD_SOC,
+	FG_DAEMON_CMD_GET_AGING1_UPDATE_SOC,
+	FG_DAEMON_CMD_GET_SHUTDOWN_SYSTEM_VOLTAGE,
+	FG_DAEMON_CMD_GET_CHARGE_TRACKING_TIME,
+	FG_DAEMON_CMD_GET_DISCHARGE_TRACKING_TIME,
+	FG_DAEMON_CMD_GET_SHUTDOWN_GAUGE0,
+	FG_DAEMON_CMD_GET_SHUTDOWN_GAUGE1_XMINS,
+	FG_DAEMON_CMD_GET_SHUTDOWN_GAUGE1_MINS,
+	FG_DAEMON_CMD_SET_SUSPEND_TIME,
+	FG_DAEMON_CMD_SET_WAKEUP_SMOOTH_TIME,
+	FG_DAEMON_CMD_SET_IS_CHARGING,
+	FG_DAEMON_CMD_SET_RBAT,
+	FG_DAEMON_CMD_SET_SWOCV,
+	FG_DAEMON_CMD_SET_DOD0,
+	FG_DAEMON_CMD_SET_DOD1,
+	FG_DAEMON_CMD_SET_QMAX,
+	FG_DAEMON_CMD_SET_SOC,
+	FG_DAEMON_CMD_SET_UI_SOC,
+	FG_DAEMON_CMD_SET_UI_SOC2,
+	FG_DAEMON_CMD_SET_INIT_FLAG,
+	FG_DAEMON_CMD_SET_DAEMON_PID,
+	FG_DAEMON_CMD_CHECK_FG_DAEMON_VERSION,
+	FG_DAEMON_CMD_NOTIFY_DAEMON,
+
+	FG_DAEMON_CMD_FROM_USER_NUMBER
+} FG_DAEMON_CTRL_CMD_FROM_USER;
+
+
 /* ============================================================ */
 /* External Variables */
 /* ============================================================ */
@@ -51,6 +140,5 @@ extern kal_int32 battery_meter_get_battery_nPercent_UI_SOC(void);	/* tracking po
 extern kal_int32 battery_meter_get_tempR(kal_int32 dwVolt);
 extern kal_int32 battery_meter_get_tempV(void);
 extern kal_int32 battery_meter_get_VSense(void);	/* isense voltage */
-
-
+extern int wakeup_fg_algo(int flow_state);
 #endif				/* #ifndef _BATTERY_METER_H */
diff --git a/include/mach/battery_meter_hal.h b/include/mach/battery_meter_hal.h
index 58bce84..d3d5934 100644
--- a/include/mach/battery_meter_hal.h
+++ b/include/mach/battery_meter_hal.h
@@ -9,6 +9,8 @@
 #define BM_LOG_CRTI 1
 #define BM_LOG_FULL 2
 
+#define BM_DAEMON_DEFAULT_LOG_LEVEL 6
+
 #define bm_print(num, fmt, args...)   \
 do {									\
 	if (Enable_FGADC_LOG >= (int)num) {				\
@@ -26,6 +28,7 @@ typedef enum {
 	BATTERY_METER_CMD_GET_HW_FG_CURRENT,	/* fgauge_read_current */
 	BATTERY_METER_CMD_GET_HW_FG_CURRENT_SIGN,	/*  */
 	BATTERY_METER_CMD_GET_HW_FG_CAR,	/* fgauge_read_columb */
+	BATTERY_METER_CMD_GET_HW_FG_CAR_ACT,	/* fgauge_read_columb */
 
 	BATTERY_METER_CMD_HW_RESET,	/* FGADC_Reset_SW_Parameter */
 
@@ -35,7 +38,7 @@ typedef enum {
 	BATTERY_METER_CMD_GET_ADC_V_CHARGER,
 
 	BATTERY_METER_CMD_GET_HW_OCV,
-
+	BATTERY_METER_CMD_GET_BATTERY_PLUG_STATUS,
 	BATTERY_METER_CMD_DUMP_REGISTER,
 	BATTERY_METER_CMD_SET_COLUMB_INTERRUPT,
 	BATTERY_METER_CMD_NUMBER
diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index cfa6b2e..2cbf0ba 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -203,6 +203,7 @@ extern int ipv6_dev_ac_inc(struct net_device *dev, const struct in6_addr *addr);
 extern int __ipv6_dev_ac_dec(struct inet6_dev *idev, const struct in6_addr *addr);
 extern bool ipv6_chk_acast_addr(struct net *net, struct net_device *dev,
 				const struct in6_addr *addr);
+extern void ipv6_ac_destroy_dev(struct inet6_dev *idev);
 
 
 /* Device notifier */
diff --git a/include/net/flow.h b/include/net/flow.h
index c91e2aa..1426681 100644
--- a/include/net/flow.h
+++ b/include/net/flow.h
@@ -12,6 +12,14 @@
 #include <linux/atomic.h>
 #include <linux/uidgid.h>
 
+/*
+ * ifindex generation is per-net namespace, and loopback is
+ * always the 1st device in ns (see net_dev_init), thus any
+ * loopback device should get ifindex 1
+ */
+
+#define LOOPBACK_IFINDEX	1
+
 struct flowi_common {
 	int	flowic_oif;
 	int	flowic_iif;
@@ -85,7 +93,7 @@ static inline void flowi4_init_output(struct flowi4 *fl4, int oif,
 				      kuid_t uid)
 {
 	fl4->flowi4_oif = oif;
-	fl4->flowi4_iif = 0;
+	fl4->flowi4_iif = LOOPBACK_IFINDEX;
 	fl4->flowi4_mark = mark;
 	fl4->flowi4_tos = tos;
 	fl4->flowi4_scope = scope;
diff --git a/include/net/ip.h b/include/net/ip.h
index 1f6794b..fc62ae0 100644
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@ -37,11 +37,12 @@ struct inet_skb_parm {
 	struct ip_options	opt;		/* Compiled IP options		*/
 	unsigned char		flags;
 
-#define IPSKB_FORWARDED		1
-#define IPSKB_XFRM_TUNNEL_SIZE	2
-#define IPSKB_XFRM_TRANSFORMED	4
-#define IPSKB_FRAG_COMPLETE	8
-#define IPSKB_REROUTED		16
+#define IPSKB_FORWARDED		BIT(0)
+#define IPSKB_XFRM_TUNNEL_SIZE	BIT(1)
+#define IPSKB_XFRM_TRANSFORMED	BIT(2)
+#define IPSKB_FRAG_COMPLETE	BIT(3)
+#define IPSKB_REROUTED		BIT(4)
+#define IPSKB_DOREDIRECT	BIT(5)
 
 	u16			frag_max_size;
 };
@@ -163,7 +164,7 @@ static inline __u8 ip_reply_arg_flowi_flags(const struct ip_reply_arg *arg)
 	return (arg->flags & IP_REPLY_ARG_NOSRCCHECK) ? FLOWI_FLAG_ANYSRC : 0;
 }
 
-void ip_send_unicast_reply(struct net *net, struct sk_buff *skb, __be32 daddr,
+void ip_send_unicast_reply(struct sock *sk, struct sk_buff *skb, __be32 daddr,
 			   __be32 saddr, const struct ip_reply_arg *arg,
 			   unsigned int len);
 
diff --git a/include/net/net_namespace.h b/include/net/net_namespace.h
index b176978..b064d6d 100644
--- a/include/net/net_namespace.h
+++ b/include/net/net_namespace.h
@@ -9,6 +9,7 @@
 #include <linux/list.h>
 #include <linux/sysctl.h>
 
+#include <net/flow.h>
 #include <net/netns/core.h>
 #include <net/netns/mib.h>
 #include <net/netns/unix.h>
@@ -120,14 +121,6 @@ struct net {
 	atomic_t		rt_genid;
 };
 
-/*
- * ifindex generation is per-net namespace, and loopback is
- * always the 1st device in ns (see net_dev_init), thus any
- * loopback device should get ifindex 1
- */
-
-#define LOOPBACK_IFINDEX	1
-
 #include <linux/seq_file_net.h>
 
 /* Init's network namespace */
diff --git a/include/net/netns/ipv4.h b/include/net/netns/ipv4.h
index 0dd6f0b..4f6c720 100644
--- a/include/net/netns/ipv4.h
+++ b/include/net/netns/ipv4.h
@@ -43,6 +43,7 @@ struct netns_ipv4 {
 	struct inet_peer_base	*peers;
 	struct tcpm_hash_bucket	*tcp_metrics_hash;
 	unsigned int		tcp_metrics_hash_log;
+	struct sock  * __percpu	*tcp_sk;
 	struct netns_frags	frags;
 #ifdef CONFIG_NETFILTER
 	struct xt_table		*iptable_filter;
diff --git a/include/sound/ak4113.h b/include/sound/ak4113.h
index 2609048..3a34f6e 100644
--- a/include/sound/ak4113.h
+++ b/include/sound/ak4113.h
@@ -286,7 +286,7 @@ struct ak4113 {
 	ak4113_write_t *write;
 	ak4113_read_t *read;
 	void *private_data;
-	unsigned int init:1;
+	atomic_t wq_processing;
 	spinlock_t lock;
 	unsigned char regmap[AK4113_WRITABLE_REGS];
 	struct snd_kcontrol *kctls[AK4113_CONTROLS];
diff --git a/include/sound/ak4114.h b/include/sound/ak4114.h
index 3ce69fd..6944116 100644
--- a/include/sound/ak4114.h
+++ b/include/sound/ak4114.h
@@ -168,7 +168,7 @@ struct ak4114 {
 	ak4114_write_t * write;
 	ak4114_read_t * read;
 	void * private_data;
-	unsigned int init: 1;
+	atomic_t wq_processing;
 	spinlock_t lock;
 	unsigned char regmap[7];
 	unsigned char txcsb[5];
diff --git a/include/uapi/linux/input.h b/include/uapi/linux/input.h
index 4585011..ce58921 100644
--- a/include/uapi/linux/input.h
+++ b/include/uapi/linux/input.h
@@ -725,8 +725,8 @@ struct input_keymap_entry {
 #define BTN_DPAD_RIGHT		0x223
 
 // zormax
-#define KEY_GESTURE_U  		0x224  /*by wangyang 2014.08.12*/
-#define KEY_GESTURE_H   		0x225
+//#define KEY_GESTURE_U  		0x224  /*by wangyang 2014.08.12*/
+//#define KEY_GESTURE_H   		0x225
 
 #define KEY_ALS_TOGGLE		0x230	/* Ambient light sensor */
 
diff --git a/kernel/debug/kdb/kdb_main.c b/kernel/debug/kdb/kdb_main.c
index fd31267..51bcfb5 100644
--- a/kernel/debug/kdb/kdb_main.c
+++ b/kernel/debug/kdb/kdb_main.c
@@ -2546,7 +2546,7 @@ static int kdb_summary(int argc, const char **argv)
 #define K(x) ((x) << (PAGE_SHIFT - 10))
 	kdb_printf("\nMemTotal:       %8lu kB\nMemFree:        %8lu kB\n"
 		   "Buffers:        %8lu kB\n",
-		   val.totalram, val.freeram, val.bufferram);
+		   K(val.totalram), K(val.freeram), K(val.bufferram));
 	return 0;
 }
 
diff --git a/kernel/irq/handle.c b/kernel/irq/handle.c
index 00bfde7..935411b 100644
--- a/kernel/irq/handle.c
+++ b/kernel/irq/handle.c
@@ -142,89 +142,89 @@ static void irq_wake_thread(struct irq_desc *desc, struct irqaction *action)
 	wake_up_process(action->thread);
 }
 
+#ifdef CONFIG_MTPROF_CPUTIME
+static void save_isr_info(unsigned int irq, struct irqaction *action,
+        unsigned long long start, unsigned long long end)
+{
+    int isr_find = 0;
+	struct mtk_isr_info *mtk_isr_point = current->se.mtk_isr;
+	struct mtk_isr_info *mtk_isr_current = mtk_isr_point;
+	char *isr_name = NULL;
+    unsigned long long dur = end - start;
+			
+	current->se.mtk_isr_time += dur;
+	while((current->se.mtk_isr!= NULL) && (mtk_isr_point != NULL))
+	{
+		if(mtk_isr_point->isr_num == irq)
+		{
+			mtk_isr_point->isr_time += dur;
+			mtk_isr_point->isr_count++;
+			isr_find = 1;
+			break;
+		}
+		mtk_isr_current = mtk_isr_point;
+		mtk_isr_point = mtk_isr_point -> next;
+	}
+
+	if((isr_find == 0) && (proc_count < MAX_THREAD_COUNT))
+	{
+		mtk_isr_point =  kmalloc(sizeof(struct mtk_isr_info), GFP_ATOMIC);
+		if(mtk_isr_point == NULL)
+		{
+			printk(KERN_ERR"cant' alloc mtk_isr_info mem!\n");					
+		}
+		else
+		{
+			mtk_isr_point->isr_num = irq;
+			mtk_isr_point->isr_time = dur;
+			mtk_isr_point->isr_count = 1;
+			mtk_isr_point->next = NULL;
+			if(mtk_isr_current == NULL)
+			{
+				current->se.mtk_isr = mtk_isr_point;
+			}
+			else
+			{
+				mtk_isr_current->next  = mtk_isr_point;
+			}
+
+			isr_name = kmalloc(sizeof(action->name),GFP_ATOMIC);
+			if(isr_name != NULL)
+			{
+				strcpy(isr_name, action->name);
+				mtk_isr_point->isr_name = isr_name;
+			}
+			else
+			{
+				printk(KERN_ERR"cant' alloc isr_name mem!\n");
+			}
+			current->se.mtk_isr_count++;
+		}	
+	}
+}
+#endif
+
 irqreturn_t
 handle_irq_event_percpu(struct irq_desc *desc, struct irqaction *action)
 {
 	irqreturn_t retval = IRQ_NONE;
 	unsigned int flags = 0, irq = desc->irq_data.irq;
 
-#ifdef CONFIG_MTPROF_IRQ_DURATION
-	unsigned long long t1, t2, dur;
+#ifdef CONFIG_MTPROF_CPUTIME
+	unsigned long long t1, t2;
 #endif
 	do {
 		irqreturn_t res;
 
 		trace_irq_handler_entry(irq, action);
-#ifdef CONFIG_MTPROF_IRQ_DURATION
+#ifdef CONFIG_MTPROF_CPUTIME
 		t1 = sched_clock();
+#endif
 		res = action->handler(irq, action->dev_id);
-		t2 = sched_clock();
-		dur = t2 - t1;
-		action->duration += dur;
-		action->count++;
-		action->dur_max = max(dur,action->dur_max);
-		action->dur_min = min(dur,action->dur_min);
 #ifdef CONFIG_MTPROF_CPUTIME
-		if(mtsched_enabled == 1)
-		{
-			int isr_find = 0;
-			struct mtk_isr_info *mtk_isr_point = current->se.mtk_isr;
-			struct mtk_isr_info *mtk_isr_current = mtk_isr_point;
-			char *isr_name = NULL;
-			
-			current->se.mtk_isr_time += dur;
-			while((current->se.mtk_isr!= NULL) && (mtk_isr_point != NULL))
-			{
-				if(mtk_isr_point->isr_num == irq)
-				{
-					mtk_isr_point->isr_time += dur;
-					mtk_isr_point->isr_count++;
-					isr_find = 1;
-					break;
-				}
-				mtk_isr_current = mtk_isr_point;
-				mtk_isr_point = mtk_isr_point -> next;
-			}
-
-			if((isr_find == 0) && (proc_count < MAX_THREAD_COUNT))
-			{
-				mtk_isr_point =  kmalloc(sizeof(struct mtk_isr_info), GFP_ATOMIC);
-				if(mtk_isr_point == NULL)
-				{
-					printk(KERN_ERR"cant' alloc mtk_isr_info mem!\n");					
-				}
-				else
-				{
-					mtk_isr_point->isr_num = irq;
-					mtk_isr_point->isr_time = dur;
-					mtk_isr_point->isr_count = 1;
-					mtk_isr_point->next = NULL;
-					if(mtk_isr_current == NULL)
-					{
-						current->se.mtk_isr = mtk_isr_point;
-					}
-					else
-					{
-						mtk_isr_current->next  = mtk_isr_point;
-					}
-
-					isr_name = kmalloc(sizeof(action->name),GFP_ATOMIC);
-					if(isr_name != NULL)
-					{
-						strcpy(isr_name, action->name);
-						mtk_isr_point->isr_name = isr_name;
-					}
-					else
-					{
-						printk(KERN_ERR"cant' alloc isr_name mem!\n");
-					}
-					current->se.mtk_isr_count++;
-				}	
-			}
-		}
-#endif		
-#else
-		res = action->handler(irq, action->dev_id);
+		t2 = sched_clock();
+		if (unlikely(mtsched_enabled == 1))
+            save_isr_info(irq, action, t1, t2);
 #endif
 		trace_irq_handler_exit(irq, action, res);
 
diff --git a/kernel/power/qos.c b/kernel/power/qos.c
index 25cf89b..8703fc7 100644
--- a/kernel/power/qos.c
+++ b/kernel/power/qos.c
@@ -369,12 +369,6 @@ void pm_qos_update_request(struct pm_qos_request *req,
 	}
 
 	cancel_delayed_work_sync(&req->work);
-
-	if (new_value != req->node.prio)
-		pm_qos_update_target(
-			pm_qos_array[req->pm_qos_class]->constraints,
-			&req->node, PM_QOS_UPDATE_REQ, new_value);
-
 	__pm_qos_update_request(req, new_value);
 }
 EXPORT_SYMBOL_GPL(pm_qos_update_request);
diff --git a/kernel/power/tuxonice_bio_core.c b/kernel/power/tuxonice_bio_core.c
index dad1dd8..1b581db 100644
--- a/kernel/power/tuxonice_bio_core.c
+++ b/kernel/power/tuxonice_bio_core.c
@@ -712,10 +712,8 @@ static int toi_start_one_readahead(int dedicated_thread)
 	int oom = 0, result;
 
 	result = throttle_if_needed(dedicated_thread ? THROTTLE_WAIT : 0);
-	if (result) {
-		printk("%s: throttle_if_needed returned %d.\n", __func__, result);
+	if (result)
 		return result;
-	}
 
 	mutex_lock(&toi_bio_readahead_mutex);
 
@@ -728,7 +726,6 @@ static int toi_start_one_readahead(int dedicated_thread)
 		if (!buffer) {
 			if (oom && !dedicated_thread) {
 				mutex_unlock(&toi_bio_readahead_mutex);
-				printk("%s: oom and !dedicated thread %d.\n", __func__, result);
 				return -ENOMEM;
 			}
 
@@ -742,9 +739,6 @@ static int toi_start_one_readahead(int dedicated_thread)
 	}
 
 	result = toi_bio_rw_page(READ, virt_to_page(buffer), 1, 0);
-	if (result) {
-		printk("%s: toi_bio_rw_page returned %d.\n", __func__, result);
-	}
 	if (result == -ENOSPC)
 		toi__free_page(12, virt_to_page(buffer));
 	mutex_unlock(&toi_bio_readahead_mutex);
@@ -1364,7 +1358,11 @@ static void toi_bio_cleanup(int finishing_cycle)
 
 	header_block_device = NULL;
 
+#ifdef CONFIG_TOI_FIXUP
+	close_resume_dev_t(1);
+#else
 	close_resume_dev_t(0);
+#endif
 }
 
 static int toi_bio_write_header_init(void)
@@ -1415,6 +1413,10 @@ static int toi_bio_write_header_cleanup(void)
 	if (!result)
 		result = toi_bio_mark_have_image();
 
+#ifdef CONFIG_MTK_MTD_NAND
+	/* FIXME: mtdblock doesn't sync without this */
+	blkdev_ioctl(resume_block_device, 0, BLKFLSBUF, 0);
+#endif
 	return result;
 }
 
diff --git a/kernel/smpboot.c b/kernel/smpboot.c
index 02fc5c9..7020eec 100644
--- a/kernel/smpboot.c
+++ b/kernel/smpboot.c
@@ -279,6 +279,7 @@ int smpboot_register_percpu_thread(struct smp_hotplug_thread *plug_thread)
 	unsigned int cpu;
 	int ret = 0;
 
+	get_online_cpus();
 	mutex_lock(&smpboot_threads_lock);
 	for_each_online_cpu(cpu) {
 		ret = __smpboot_create_thread(plug_thread, cpu);
@@ -291,6 +292,7 @@ int smpboot_register_percpu_thread(struct smp_hotplug_thread *plug_thread)
 	list_add(&plug_thread->list, &hotplug_threads);
 out:
 	mutex_unlock(&smpboot_threads_lock);
+	put_online_cpus();
 	return ret;
 }
 EXPORT_SYMBOL_GPL(smpboot_register_percpu_thread);
diff --git a/kernel/time.c b/kernel/time.c
index b0f7b1d..5d4d9a0 100644
--- a/kernel/time.c
+++ b/kernel/time.c
@@ -198,6 +198,10 @@ SYSCALL_DEFINE2(settimeofday, struct timeval __user *, tv,
 	if (tv) {
 		if (copy_from_user(&user_tv, tv, sizeof(*tv)))
 			return -EFAULT;
+
+		if (!timeval_valid(&user_tv))
+			return -EINVAL;
+
 		new_ts.tv_sec = user_tv.tv_sec;
 		new_ts.tv_nsec = user_tv.tv_usec * NSEC_PER_USEC;
 	}
diff --git a/kernel/time/ntp.c b/kernel/time/ntp.c
index af8d1d4..6211d5d 100644
--- a/kernel/time/ntp.c
+++ b/kernel/time/ntp.c
@@ -631,6 +631,17 @@ int ntp_validate_timex(struct timex *txc)
 	if ((txc->modes & ADJ_SETOFFSET) && (!capable(CAP_SYS_TIME)))
 		return -EPERM;
 
+	/*
+	 * Check for potential multiplication overflows that can
+	 * only happen on 64-bit systems:
+	 */
+	if ((txc->modes & ADJ_FREQUENCY) && (BITS_PER_LONG == 64)) {
+		if (LLONG_MIN / PPM_SCALE > txc->freq)
+			return -EINVAL;
+		if (LLONG_MAX / PPM_SCALE < txc->freq)
+			return -EINVAL;
+	}
+
 	return 0;
 }
 
diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index 017992c..929f4ec 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -4786,7 +4786,7 @@ tracing_mark_write(struct file *filp, const char __user *ubuf,
 	*fpos += written;
 
  out_unlock:
-	for (i = 0; i < nr_pages; i++){
+	for (i = nr_pages - 1; i >= 0; i--) {
 		kunmap_atomic(map_page[i]);
 		put_page(pages[i]);
 	}
diff --git a/kernel/workqueue.c b/kernel/workqueue.c
index 650b563..9e5453b 100644
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -1950,17 +1950,13 @@ static void pool_mayday_timeout(unsigned long __pool)
  * spin_lock_irq(pool->lock) which may be released and regrabbed
  * multiple times.  Does GFP_KERNEL allocations.  Called only from
  * manager.
- *
- * RETURNS:
- * %false if no action was taken and pool->lock stayed locked, %true
- * otherwise.
  */
-static bool maybe_create_worker(struct worker_pool *pool)
+static void maybe_create_worker(struct worker_pool *pool)
 __releases(&pool->lock)
 __acquires(&pool->lock)
 {
 	if (!need_to_create_worker(pool))
-		return false;
+		return;
 restart:
 	spin_unlock_irq(&pool->lock);
 
@@ -1977,7 +1973,7 @@ restart:
 			start_worker(worker);
 			if (WARN_ON_ONCE(need_to_create_worker(pool)))
 				goto restart;
-			return true;
+			return;
 		}
 
 		if (!need_to_create_worker(pool))
@@ -1994,7 +1990,7 @@ restart:
 	spin_lock_irq(&pool->lock);
 	if (need_to_create_worker(pool))
 		goto restart;
-	return true;
+	return;
 }
 
 /**
@@ -2007,15 +2003,9 @@ restart:
  * LOCKING:
  * spin_lock_irq(pool->lock) which may be released and regrabbed
  * multiple times.  Called only from manager.
- *
- * RETURNS:
- * %false if no action was taken and pool->lock stayed locked, %true
- * otherwise.
  */
-static bool maybe_destroy_workers(struct worker_pool *pool)
+static void maybe_destroy_workers(struct worker_pool *pool)
 {
-	bool ret = false;
-
 	while (too_many_workers(pool)) {
 		struct worker *worker;
 		unsigned long expires;
@@ -2029,10 +2019,7 @@ static bool maybe_destroy_workers(struct worker_pool *pool)
 		}
 
 		destroy_worker(worker);
-		ret = true;
 	}
-
-	return ret;
 }
 
 /**
@@ -2052,13 +2039,14 @@ static bool maybe_destroy_workers(struct worker_pool *pool)
  * multiple times.  Does GFP_KERNEL allocations.
  *
  * RETURNS:
- * spin_lock_irq(pool->lock) which may be released and regrabbed
- * multiple times.  Does GFP_KERNEL allocations.
+ * %false if the pool doesn't need management and the caller can safely
+ * start processing works, %true if management function was performed and
+ * the conditions that the caller verified before calling the function may
+ * no longer be true.
  */
 static bool manage_workers(struct worker *worker)
 {
 	struct worker_pool *pool = worker->pool;
-	bool ret = false;
 
 	/*
 	 * Managership is governed by two mutexes - manager_arb and
@@ -2082,7 +2070,7 @@ static bool manage_workers(struct worker *worker)
 	 * manager_mutex.
 	 */
 	if (!mutex_trylock(&pool->manager_arb))
-		return ret;
+		return false;
 
 	/*
 	 * With manager arbitration won, manager_mutex would be free in
@@ -2092,7 +2080,6 @@ static bool manage_workers(struct worker *worker)
 		spin_unlock_irq(&pool->lock);
 		mutex_lock(&pool->manager_mutex);
 		spin_lock_irq(&pool->lock);
-		ret = true;
 	}
 
 	pool->flags &= ~POOL_MANAGE_WORKERS;
@@ -2101,12 +2088,12 @@ static bool manage_workers(struct worker *worker)
 	 * Destroy and then create so that may_start_working() is true
 	 * on return.
 	 */
-	ret |= maybe_destroy_workers(pool);
-	ret |= maybe_create_worker(pool);
+	maybe_destroy_workers(pool);
+	maybe_create_worker(pool);
 
 	mutex_unlock(&pool->manager_mutex);
 	mutex_unlock(&pool->manager_arb);
-	return ret;
+	return true;
 }
 
 /**
diff --git a/lib/Kconfig b/lib/Kconfig
index 0712f53..59f306d 100644
--- a/lib/Kconfig
+++ b/lib/Kconfig
@@ -189,6 +189,15 @@ config LZO_COMPRESS
 config LZO_DECOMPRESS
 	tristate
 
+config LZ4_COMPRESS
+	tristate
+
+config LZ4HC_COMPRESS
+	tristate
+
+config LZ4_DECOMPRESS
+	tristate
+
 config LZ4K
 	bool "LZ4K compression"
 	default n
diff --git a/lib/Makefile b/lib/Makefile
index 99c98b5..0912ad8 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -76,6 +76,9 @@ obj-$(CONFIG_REED_SOLOMON) += reed_solomon/
 obj-$(CONFIG_BCH) += bch.o
 obj-$(CONFIG_LZO_COMPRESS) += lzo/
 obj-$(CONFIG_LZO_DECOMPRESS) += lzo/
+obj-$(CONFIG_LZ4_COMPRESS) += lz4/
+obj-$(CONFIG_LZ4HC_COMPRESS) += lz4/
+obj-$(CONFIG_LZ4_DECOMPRESS) += lz4/
 obj-$(CONFIG_XZ_DEC) += xz/
 obj-$(CONFIG_RAID6_PQ) += raid6/
 
diff --git a/lib/checksum.c b/lib/checksum.c
index 129775e..8b39e86 100644
--- a/lib/checksum.c
+++ b/lib/checksum.c
@@ -181,6 +181,15 @@ csum_partial_copy(const void *src, void *dst, int len, __wsum sum)
 EXPORT_SYMBOL(csum_partial_copy);
 
 #ifndef csum_tcpudp_nofold
+static inline u32 from64to32(u64 x)
+{
+	/* add up 32-bit and 32-bit for 32+c bit */
+	x = (x & 0xffffffff) + (x >> 32);
+	/* add up carry.. */
+	x = (x & 0xffffffff) + (x >> 32);
+	return (u32)x;
+}
+
 __wsum csum_tcpudp_nofold(__be32 saddr, __be32 daddr,
 			unsigned short len,
 			unsigned short proto,
@@ -195,8 +204,7 @@ __wsum csum_tcpudp_nofold(__be32 saddr, __be32 daddr,
 #else
 	s += (proto + len) << 8;
 #endif
-	s += (s >> 32);
-	return (__force __wsum)s;
+	return (__force __wsum)from64to32(s);
 }
 EXPORT_SYMBOL(csum_tcpudp_nofold);
 #endif
diff --git a/lib/decompress_bunzip2.c b/lib/decompress_bunzip2.c
index 31c5f76..f504027 100644
--- a/lib/decompress_bunzip2.c
+++ b/lib/decompress_bunzip2.c
@@ -184,7 +184,7 @@ static int INIT get_next_block(struct bunzip_data *bd)
 	if (get_bits(bd, 1))
 		return RETVAL_OBSOLETE_INPUT;
 	origPtr = get_bits(bd, 24);
-	if (origPtr > dbufSize)
+	if (origPtr >= dbufSize)
 		return RETVAL_DATA_ERROR;
 	/* mapping table: if some byte values are never used (encoding things
 	   like ascii text), the compression code removes the gaps to have fewer
diff --git a/mm/compaction.c b/mm/compaction.c
index 06b8c52..b9372c3 100644
--- a/mm/compaction.c
+++ b/mm/compaction.c
@@ -890,7 +890,7 @@ static int compact_finished(struct zone *zone,
 			return COMPACT_PARTIAL;
 
 		/* Job done if allocation would set block type */
-		if (cc->order >= pageblock_order && area->nr_free)
+		if (order >= pageblock_order && area->nr_free)
 			return COMPACT_PARTIAL;
 	}
 
diff --git a/mm/hugetlb.c b/mm/hugetlb.c
index 7de4f67..d9bc87c 100644
--- a/mm/hugetlb.c
+++ b/mm/hugetlb.c
@@ -2451,9 +2451,10 @@ again:
 			continue;
 
 		/*
-		 * HWPoisoned hugepage is already unmapped and dropped reference
+		 * Migrating hugepage or HWPoisoned hugepage is already
+		 * unmapped and its refcount is dropped, so just clear pte here.
 		 */
-		if (unlikely(is_hugetlb_entry_hwpoisoned(pte))) {
+		if (unlikely(!pte_present(pte))) {
 			huge_pte_clear(mm, address, ptep);
 			continue;
 		}
diff --git a/mm/memory.c b/mm/memory.c
index 9129471..5686bce 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -4113,7 +4113,7 @@ int generic_access_phys(struct vm_area_struct *vma, unsigned long addr,
 	if (follow_phys(vma, addr, write, &prot, &phys_addr))
 		return -EINVAL;
 
-	maddr = ioremap_prot(phys_addr, PAGE_SIZE, prot);
+	maddr = ioremap_prot(phys_addr, PAGE_ALIGN(len + offset), prot);
 	if (write)
 		memcpy_toio(maddr + offset, buf, len);
 	else
diff --git a/mm/mlock.c b/mm/mlock.c
index 3dcea72..b680dfd 100644
--- a/mm/mlock.c
+++ b/mm/mlock.c
@@ -23,10 +23,10 @@
 
 int can_do_mlock(void)
 {
-	if (capable(CAP_IPC_LOCK))
-		return 1;
 	if (rlimit(RLIMIT_MEMLOCK) != 0)
 		return 1;
+	if (capable(CAP_IPC_LOCK))
+		return 1;
 	return 0;
 }
 EXPORT_SYMBOL(can_do_mlock);
diff --git a/mm/mmap.c b/mm/mmap.c
index b683751..25760e2 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -127,7 +127,7 @@ EXPORT_SYMBOL_GPL(vm_memory_committed);
  */
 int __vm_enough_memory(struct mm_struct *mm, long pages, int cap_sys_admin)
 {
-	unsigned long free, allowed, reserve;
+	long free, allowed, reserve;
 
 	vm_acct_memory(pages);
 
@@ -193,7 +193,7 @@ int __vm_enough_memory(struct mm_struct *mm, long pages, int cap_sys_admin)
 	 */
 	if (mm) {
 		reserve = sysctl_user_reserve_kbytes >> (PAGE_SHIFT - 10);
-		allowed -= min(mm->total_vm / 32, reserve);
+		allowed -= min_t(long, mm->total_vm / 32, reserve);
 	}
 
 	if (percpu_counter_read_positive(&vm_committed_as) < allowed)
diff --git a/mm/nommu.c b/mm/nommu.c
index 298884d..d9d07a5 100644
--- a/mm/nommu.c
+++ b/mm/nommu.c
@@ -1898,7 +1898,7 @@ EXPORT_SYMBOL(unmap_mapping_range);
  */
 int __vm_enough_memory(struct mm_struct *mm, long pages, int cap_sys_admin)
 {
-	unsigned long free, allowed, reserve;
+	long free, allowed, reserve;
 
 	vm_acct_memory(pages);
 
@@ -1963,7 +1963,7 @@ int __vm_enough_memory(struct mm_struct *mm, long pages, int cap_sys_admin)
 	 */
 	if (mm) {
 		reserve = sysctl_user_reserve_kbytes >> (PAGE_SHIFT - 10);
-		allowed -= min(mm->total_vm / 32, reserve);
+		allowed -= min_t(long, mm->total_vm / 32, reserve);
 	}
 
 	if (percpu_counter_read_positive(&vm_committed_as) < allowed)
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index 2aa09af..159073f 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -745,11 +745,21 @@ static bool free_pages_prepare(struct page *page, unsigned int order)
 	return true;
 }
 
+#ifdef CONFIG_MT_ENG_BUILD
+#define EXTFRAG_PAGE_ORDER	3
+#define EXTFRAG_MAX_PAGE_ORDER	6
+#endif
+
 static void __free_pages_ok(struct page *page, unsigned int order)
 {
 	unsigned long flags;
 	int migratetype;
 
+#ifdef CONFIG_MT_ENG_BUILD 	
+ 	if (order >= EXTFRAG_PAGE_ORDER && order < EXTFRAG_MAX_PAGE_ORDER)
+ 		printk("F[EXTFRAG](%lx)\n", (unsigned long)page);
+#endif
+
 	if (!free_pages_prepare(page, order))
 		return;
 
@@ -980,8 +990,11 @@ int move_freepages(struct zone *zone,
 	 * anyway as we check zone boundaries in move_freepages_block().
 	 * Remove at a later date when no bug reports exist related to
 	 * grouping pages by mobility
+	 * BUG_ON(page_zone(start_page) != page_zone(end_page)); 
 	 */
-	BUG_ON(page_zone(start_page) != page_zone(end_page));
+	if (page_zone(start_page) != page_zone(end_page))
+		pr_warn("%s: page_zone check fail(%lu, %lu): mt:0x%x\n", 
+			current->comm, page_to_pfn(start_page), page_to_pfn(end_page), migratetype);
 #endif
 
 	for (page = start_page; page <= end_page;) {
@@ -2821,6 +2834,7 @@ retry_cpuset:
                                 goto out;
                 }
 
+#ifdef CONFIG_MTKPASR
 		/* Check whether we should release PASR reserved page */
 		if (gfp_mask & __GFP_NOMTKPASR) {
 			/* Do nothing, just go ahead */
@@ -2834,6 +2848,7 @@ retry_cpuset:
 			}
 #endif
 		}
+#endif
 
 		page = __alloc_pages_slowpath(gfp_mask, order,
 				zonelist, high_zoneidx, nodemask,
@@ -2867,6 +2882,11 @@ retry_cpuset:
 #endif // __LOG_PAGE_ALLOC_ORDER__
 	trace_mm_page_alloc(page, order, gfp_mask, migratetype);
 
+#ifdef CONFIG_MT_ENG_BUILD
+	if (order >= EXTFRAG_PAGE_ORDER)
+ 		printk("A[EXTFRAG](%lx)gfp=0x%x\n", (unsigned long)page, gfp_mask);
+#endif
+
 out:
 	/*
 	 * When updating a task's mems_allowed, it is possible to race with
@@ -6051,53 +6071,65 @@ static inline int pfn_to_bitidx(struct zone *zone, unsigned long pfn)
  * @end_bitidx: The last bit of interest
  * returns pageblock_bits flags
  */
-unsigned long get_pageblock_flags_group(struct page *page,
-					int start_bitidx, int end_bitidx)
+unsigned long get_pageblock_flags_mask(struct page *page,
+					unsigned long end_bitidx,
+					unsigned long mask)
 {
 	struct zone *zone;
 	unsigned long *bitmap;
-	unsigned long pfn, bitidx;
-	unsigned long flags = 0;
-	unsigned long value = 1;
+	unsigned long pfn, bitidx, word_bitidx;
+	unsigned long word;
 
 	zone = page_zone(page);
 	pfn = page_to_pfn(page);
 	bitmap = get_pageblock_bitmap(zone, pfn);
 	bitidx = pfn_to_bitidx(zone, pfn);
+	word_bitidx = bitidx / BITS_PER_LONG;
+	bitidx &= (BITS_PER_LONG-1);
 
-	for (; start_bitidx <= end_bitidx; start_bitidx++, value <<= 1)
-		if (test_bit(bitidx + start_bitidx, bitmap))
-			flags |= value;
-
-	return flags;
+	word = bitmap[word_bitidx];
+	bitidx += end_bitidx;
+	return (word >> (BITS_PER_LONG - bitidx - 1)) & mask;
 }
 
 /**
- * set_pageblock_flags_group - Set the requested group of flags for a pageblock_nr_pages block of pages
+ * set_pageblock_flags_mask - Set the requested group of flags for a pageblock_nr_pages block of pages
  * @page: The page within the block of interest
  * @start_bitidx: The first bit of interest
  * @end_bitidx: The last bit of interest
  * @flags: The flags to set
  */
-void set_pageblock_flags_group(struct page *page, unsigned long flags,
-					int start_bitidx, int end_bitidx)
+void set_pageblock_flags_mask(struct page *page, unsigned long flags,
+					unsigned long end_bitidx,
+					unsigned long mask)
 {
 	struct zone *zone;
 	unsigned long *bitmap;
-	unsigned long pfn, bitidx;
-	unsigned long value = 1;
+	unsigned long pfn, bitidx, word_bitidx;
+	unsigned long old_word, word;
+
+	BUILD_BUG_ON(NR_PAGEBLOCK_BITS != 4);
 
 	zone = page_zone(page);
 	pfn = page_to_pfn(page);
 	bitmap = get_pageblock_bitmap(zone, pfn);
 	bitidx = pfn_to_bitidx(zone, pfn);
+	word_bitidx = bitidx / BITS_PER_LONG;
+	bitidx &= (BITS_PER_LONG-1);
+
 	VM_BUG_ON(!zone_spans_pfn(zone, pfn));
 
-	for (; start_bitidx <= end_bitidx; start_bitidx++, value <<= 1)
-		if (flags & value)
-			__set_bit(bitidx + start_bitidx, bitmap);
-		else
-			__clear_bit(bitidx + start_bitidx, bitmap);
+	bitidx += end_bitidx;
+	mask <<= (BITS_PER_LONG - bitidx - 1);
+	flags <<= (BITS_PER_LONG - bitidx - 1);
+
+	word = ACCESS_ONCE(bitmap[word_bitidx]);
+	for (;;) {
+		old_word = cmpxchg(&bitmap[word_bitidx], word, (word & ~mask) | flags);
+		if (word == old_word)
+			break;
+		word = old_word;
+	}
 }
 
 /*
@@ -6656,7 +6688,7 @@ EXPORT_SYMBOL(pasr_acquire_inuse_page);
 /* Compute maximum safe order for page allocation */
 int pasr_compute_safe_order(void)
 {
-	struct zone *z = &NODE_DATA(0)->node_zones[ZONE_NORMAL];
+	struct zone *z = MTKPASR_ZONE;
 	int order;
 	unsigned long watermark = low_wmark_pages(z);
 	long free_pages = zone_page_state(z, NR_FREE_PAGES);
diff --git a/mm/pagewalk.c b/mm/pagewalk.c
index 2beeabf..9056d22 100644
--- a/mm/pagewalk.c
+++ b/mm/pagewalk.c
@@ -199,7 +199,10 @@ int walk_page_range(unsigned long addr, unsigned long end,
 			 */
 			if ((vma->vm_start <= addr) &&
 			    (vma->vm_flags & VM_PFNMAP)) {
-				next = vma->vm_end;
+				if (walk->pte_hole)
+					err = walk->pte_hole(addr, next, walk);
+				if (err)
+					break;
 				pgd = pgd_offset(walk->mm, next);
 				continue;
 			}
diff --git a/mm/slub.c b/mm/slub.c
index 8e6104a..3657e2a 100644
--- a/mm/slub.c
+++ b/mm/slub.c
@@ -204,9 +204,6 @@ static struct notifier_block slab_notifier;
  * Tracking user of a slab.
  */
 
-#ifdef MTK_COMPACT_SLUB_TRACK
-#define LOW_BYTE_MASK 0xffffffff00000000
-#endif
 
 #define TRACK_ADDRS_COUNT 8
 
@@ -214,7 +211,7 @@ static struct notifier_block slab_notifier;
 struct track {
 	unsigned long addr;	/* Called from address */
 #ifdef CONFIG_STACKTRACE
-	u32 addrs[TRACK_ADDRS_COUNT];	/* only lower 32bit for 64bit pointer Called from address */
+	u32 addrs[TRACK_ADDRS_COUNT];	/* we store the offset after MODULES_VADDR for kernel module and kernel text address  */
 #endif
 	int cpu;		/* Was running on cpu */
 	int pid;		/* Pid context */
@@ -550,8 +547,13 @@ static void set_track(struct kmem_cache *s, void *object,
 		for (i = trace.nr_entries; i < TRACK_ADDRS_COUNT; i++)
 			addrs[i] = 0;
 
-		for (i = 0; i < TRACK_ADDRS_COUNT; i++)
-		    p->addrs[i] = (u32)addrs[i];
+		for (i = 0; i < TRACK_ADDRS_COUNT; i++){
+            if(addrs[i])
+		        p->addrs[i] = addrs[i] - MODULES_VADDR;
+            else
+                p->addrs[i] = 0;
+        }
+        
 
 #endif
 		p->addr = addr;
@@ -617,14 +619,14 @@ static void print_track(const char *s, struct track *t)
 	    unsigned long addrs[TRACK_ADDRS_COUNT];	/* Called from address */
 		for (i = 0; i < TRACK_ADDRS_COUNT; i++) {
 
-            if(((unsigned int*)t->addrs)[i])
-                /*Assume high 32 bit will never change , text section should never cross _etext*/
-               addrs[i] = ((unsigned long)_etext & LOW_BYTE_MASK) | (t->addrs[i]);
+            if(t->addrs[i])
+                /* we store the offset after MODULES_VADDR for kernel module and kernel text address  */
+               addrs[i] =  MODULES_VADDR + t->addrs[i];
             else
                addrs[i] = 0;
         }
 		for (i = 0; i < TRACK_ADDRS_COUNT; i++) {
-			if (addrs[i])
+			if (addrs[i]) 
 				printk(KERN_ERR "\t%pS\n", (void *)addrs[i]);
 			else
 				break;
@@ -5490,13 +5492,12 @@ static int mtk_memcfg_add_location(struct loc_track *t, struct kmem_cache *s,
 
 	start = -1;
 	end = t->count;
-
 	/* find the index of track->addr */
 	for (i = 0; i < TRACK_ADDRS_COUNT; i++) {
 #ifdef MTK_COMPACT_SLUB_TRACK
-        /*Assume high 32 bit will never change , text section should never cross _etext */
-		if ((track->addr == (((unsigned long)_etext & LOW_BYTE_MASK) | (track->addrs[i]))) ||
-			(track->addr - 4 == (((unsigned long)_etext & LOW_BYTE_MASK) | track->addrs[i])))
+        /* we store the offset after MODULES_VADDR for kernel module and kernel text address  */
+		if (track->addr == ((MODULES_VADDR + track->addrs[i])) ||
+			((track->addr - 4) == (MODULES_VADDR + track->addrs[i])))
 #else
 		if ((track->addr == track->addrs[i]) ||
 			(track->addr - 4 == track->addrs[i]))
@@ -5510,8 +5511,11 @@ static int mtk_memcfg_add_location(struct loc_track *t, struct kmem_cache *s,
         unsigned long addrs[TRACK_ADDRS_COUNT];
 
         for(j =0;j < TRACK_ADDRS_COUNT;j++) {
-            /*Assume high 32 bit will never change , text section should never cross _etext */
-            addrs[j] = ((unsigned long)_etext & LOW_BYTE_MASK) | (track->addrs[j]);
+            /* we store the offset after MODULES_VADDR for kernel module and kernel text address  */
+            if(track->addrs[j])
+                addrs[j] = MODULES_VADDR + track->addrs[j];
+            else    
+                addrs[j] = 0;
         }
         memcpy(taddrs, addrs + i, (cnt * sizeof (unsigned long)));
     }
diff --git a/mm/vmscan.c b/mm/vmscan.c
index 58eb006..26e2810 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -3949,6 +3949,9 @@ void scan_unevictable_unregister_node(struct node *node)
 #endif
 
 #ifdef CONFIG_MTKPASR
+#ifdef CONFIG_64BIT
+#define SHRINKER_IGNORE_TAG 0xffffffc008000000UL
+#endif
 void try_to_shrink_slab(void)
 {
 	struct shrinker *shrinker;
@@ -3969,6 +3972,11 @@ void try_to_shrink_slab(void)
 		if (num_objs <= 0)
 			continue;
 
+#ifdef CONFIG_64BIT
+		if ((unsigned long)shrinker < SHRINKER_IGNORE_TAG)
+			continue;
+#endif
+
 		do {
 			/* To shrink */
 			shrink_ret = do_shrinker_shrink(shrinker, &shrink, num_objs);
@@ -4084,6 +4092,7 @@ int mtkpasr_drop_page(struct page *page)
 	 * Try to allocate it some swap space here.
 	 */
 	if (PageAnon(page) && !PageSwapCache(page)) {
+#ifndef CONFIG_64BIT
 		/* Check whether we have enough free memory */
 		if (vm_swap_full()) {
 			goto unlock;
@@ -4093,6 +4102,9 @@ int mtkpasr_drop_page(struct page *page)
 		if (!add_to_swap(page, NULL)){
 			goto unlock;
 		}
+#else
+		goto unlock;
+#endif
 	}
 	
 	/* We don't handle dirty file cache here (Related devices may be suspended) */
@@ -4104,7 +4116,7 @@ int mtkpasr_drop_page(struct page *page)
 		/* We don't handle dirty file pages! */
 		if (PageDirty(page)) {
 #ifdef CONFIG_MTKPASR_DEBUG 
-			printk(KERN_ALERT "\n\n\n\n\n\n [%s][%d]\n\n\n\n\n\n",__FUNCTION__,__LINE__);
+			/*printk(KERN_ALERT "\n\n\n\n\n\n [%s][%d]\n\n\n\n\n\n",__FUNCTION__,__LINE__);*/
 #endif
 			goto unlock;
 		}
diff --git a/net/ceph/osd_client.c b/net/ceph/osd_client.c
index 3663a30..1b51d92 100644
--- a/net/ceph/osd_client.c
+++ b/net/ceph/osd_client.c
@@ -967,12 +967,24 @@ static void put_osd(struct ceph_osd *osd)
  */
 static void __remove_osd(struct ceph_osd_client *osdc, struct ceph_osd *osd)
 {
-	dout("__remove_osd %p\n", osd);
-	BUG_ON(!list_empty(&osd->o_requests));
-	rb_erase(&osd->o_node, &osdc->osds);
+	dout("%s %p osd%d\n", __func__, osd, osd->o_osd);
+	WARN_ON(!list_empty(&osd->o_requests));
+	WARN_ON(!list_empty(&osd->o_linger_requests));
+
 	list_del_init(&osd->o_osd_lru);
-	ceph_con_close(&osd->o_con);
-	put_osd(osd);
+	rb_erase(&osd->o_node, &osdc->osds);
+	RB_CLEAR_NODE(&osd->o_node);
+}
+
+static void remove_osd(struct ceph_osd_client *osdc, struct ceph_osd *osd)
+{
+	dout("%s %p osd%d\n", __func__, osd, osd->o_osd);
+
+	if (!RB_EMPTY_NODE(&osd->o_node)) {
+		ceph_con_close(&osd->o_con);
+		__remove_osd(osdc, osd);
+		put_osd(osd);
+	}
 }
 
 static void remove_all_osds(struct ceph_osd_client *osdc)
@@ -982,7 +994,7 @@ static void remove_all_osds(struct ceph_osd_client *osdc)
 	while (!RB_EMPTY_ROOT(&osdc->osds)) {
 		struct ceph_osd *osd = rb_entry(rb_first(&osdc->osds),
 						struct ceph_osd, o_node);
-		__remove_osd(osdc, osd);
+		remove_osd(osdc, osd);
 	}
 	mutex_unlock(&osdc->request_mutex);
 }
@@ -1012,7 +1024,7 @@ static void remove_old_osds(struct ceph_osd_client *osdc)
 	list_for_each_entry_safe(osd, nosd, &osdc->osd_lru, o_osd_lru) {
 		if (time_before(jiffies, osd->lru_ttl))
 			break;
-		__remove_osd(osdc, osd);
+		remove_osd(osdc, osd);
 	}
 	mutex_unlock(&osdc->request_mutex);
 }
@@ -1027,8 +1039,7 @@ static int __reset_osd(struct ceph_osd_client *osdc, struct ceph_osd *osd)
 	dout("__reset_osd %p osd%d\n", osd, osd->o_osd);
 	if (list_empty(&osd->o_requests) &&
 	    list_empty(&osd->o_linger_requests)) {
-		__remove_osd(osdc, osd);
-
+		remove_osd(osdc, osd);
 		return -ENODEV;
 	}
 
@@ -1610,6 +1621,7 @@ static void reset_changed_osds(struct ceph_osd_client *osdc)
 {
 	struct rb_node *p, *n;
 
+	dout("%s %p\n", __func__, osdc);
 	for (p = rb_first(&osdc->osds); p; p = n) {
 		struct ceph_osd *osd = rb_entry(p, struct ceph_osd, o_node);
 
diff --git a/net/compat.c b/net/compat.c
index cbc1a2a..275af79 100644
--- a/net/compat.c
+++ b/net/compat.c
@@ -738,24 +738,18 @@ static unsigned char nas[21] = {
 
 asmlinkage long compat_sys_sendmsg(int fd, struct compat_msghdr __user *msg, unsigned int flags)
 {
-	if (flags & MSG_CMSG_COMPAT)
-		return -EINVAL;
 	return __sys_sendmsg(fd, (struct msghdr __user *)msg, flags | MSG_CMSG_COMPAT);
 }
 
 asmlinkage long compat_sys_sendmmsg(int fd, struct compat_mmsghdr __user *mmsg,
 				    unsigned int vlen, unsigned int flags)
 {
-	if (flags & MSG_CMSG_COMPAT)
-		return -EINVAL;
 	return __sys_sendmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,
 			      flags | MSG_CMSG_COMPAT);
 }
 
 asmlinkage long compat_sys_recvmsg(int fd, struct compat_msghdr __user *msg, unsigned int flags)
 {
-	if (flags & MSG_CMSG_COMPAT)
-		return -EINVAL;
 	return __sys_recvmsg(fd, (struct msghdr __user *)msg, flags | MSG_CMSG_COMPAT);
 }
 
@@ -778,9 +772,6 @@ asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,
 	int datagrams;
 	struct timespec ktspec;
 
-	if (flags & MSG_CMSG_COMPAT)
-		return -EINVAL;
-
 	if (timeout == NULL)
 		return __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,
 				      flags | MSG_CMSG_COMPAT, NULL);
diff --git a/net/core/dev.c b/net/core/dev.c
index 5f5a78a..348e3c0 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -931,7 +931,7 @@ bool dev_valid_name(const char *name)
 		return false;
 
 	while (*name) {
-		if (*name == '/' || isspace(*name))
+		if (*name == '/' || *name == ':' || isspace(*name))
 			return false;
 		name++;
 	}
@@ -6036,10 +6036,20 @@ static int dev_cpu_callback(struct notifier_block *nfb,
 		oldsd->output_queue = NULL;
 		oldsd->output_queue_tailp = &oldsd->output_queue;
 	}
-	/* Append NAPI poll list from offline CPU. */
-	if (!list_empty(&oldsd->poll_list)) {
-		list_splice_init(&oldsd->poll_list, &sd->poll_list);
-		raise_softirq_irqoff(NET_RX_SOFTIRQ);
+	/* Append NAPI poll list from offline CPU, with one exception :
+	 * process_backlog() must be called by cpu owning percpu backlog.
+	 * We properly handle process_queue & input_pkt_queue later.
+	 */
+	while (!list_empty(&oldsd->poll_list)) {
+		struct napi_struct *napi = list_first_entry(&oldsd->poll_list,
+							    struct napi_struct,
+							    poll_list);
+
+		list_del_init(&napi->poll_list);
+		if (napi->poll == process_backlog)
+			napi->state = 0;
+		else
+			____napi_schedule(sd, napi);
 	}
 
 	raise_softirq_irqoff(NET_TX_SOFTIRQ);
@@ -6050,7 +6060,7 @@ static int dev_cpu_callback(struct notifier_block *nfb,
 		netif_rx(skb);
 		input_queue_head_incr(oldsd);
 	}
-	while ((skb = __skb_dequeue(&oldsd->input_pkt_queue))) {
+	while ((skb = skb_dequeue(&oldsd->input_pkt_queue))) {
 		netif_rx(skb);
 		input_queue_head_incr(oldsd);
 	}
diff --git a/net/core/gen_stats.c b/net/core/gen_stats.c
index ddedf21..b96437b 100644
--- a/net/core/gen_stats.c
+++ b/net/core/gen_stats.c
@@ -32,6 +32,9 @@ gnet_stats_copy(struct gnet_dump *d, int type, void *buf, int size)
 	return 0;
 
 nla_put_failure:
+	kfree(d->xstats);
+	d->xstats = NULL;
+	d->xstats_len = 0;
 	spin_unlock_bh(d->lock);
 	return -1;
 }
@@ -205,7 +208,9 @@ int
 gnet_stats_copy_app(struct gnet_dump *d, void *st, int len)
 {
 	if (d->compat_xstats) {
-		d->xstats = st;
+		d->xstats = kmemdup(st, len, GFP_ATOMIC);
+		if (!d->xstats)
+			goto err_out;
 		d->xstats_len = len;
 	}
 
@@ -213,6 +218,11 @@ gnet_stats_copy_app(struct gnet_dump *d, void *st, int len)
 		return gnet_stats_copy(d, TCA_STATS_APP, st, len);
 
 	return 0;
+
+err_out:
+	d->xstats_len = 0;
+	spin_unlock_bh(d->lock);
+	return -1;
 }
 EXPORT_SYMBOL(gnet_stats_copy_app);
 
@@ -245,6 +255,9 @@ gnet_stats_finish_copy(struct gnet_dump *d)
 			return -1;
 	}
 
+	kfree(d->xstats);
+	d->xstats = NULL;
+	d->xstats_len = 0;
 	spin_unlock_bh(d->lock);
 	return 0;
 }
diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
index 9fd4f8c..7e051ee 100644
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -1149,14 +1149,10 @@ static const struct nla_policy ifla_vfinfo_policy[IFLA_VF_INFO_MAX+1] = {
 };
 
 static const struct nla_policy ifla_vf_policy[IFLA_VF_MAX+1] = {
-	[IFLA_VF_MAC]		= { .type = NLA_BINARY,
-				    .len = sizeof(struct ifla_vf_mac) },
-	[IFLA_VF_VLAN]		= { .type = NLA_BINARY,
-				    .len = sizeof(struct ifla_vf_vlan) },
-	[IFLA_VF_TX_RATE]	= { .type = NLA_BINARY,
-				    .len = sizeof(struct ifla_vf_tx_rate) },
-	[IFLA_VF_SPOOFCHK]	= { .type = NLA_BINARY,
-				    .len = sizeof(struct ifla_vf_spoofchk) },
+	[IFLA_VF_MAC]		= { .len = sizeof(struct ifla_vf_mac) },
+	[IFLA_VF_VLAN]		= { .len = sizeof(struct ifla_vf_vlan) },
+	[IFLA_VF_TX_RATE]	= { .len = sizeof(struct ifla_vf_tx_rate) },
+	[IFLA_VF_SPOOFCHK]	= { .len = sizeof(struct ifla_vf_spoofchk) },
 };
 
 static const struct nla_policy ifla_port_policy[IFLA_PORT_MAX+1] = {
@@ -1866,8 +1862,16 @@ replay:
 			goto out;
 
 		err = rtnl_configure_link(dev, ifm);
-		if (err < 0)
-			unregister_netdevice(dev);
+		if (err < 0) {
+			if (ops->newlink) {
+				LIST_HEAD(list_kill);
+
+				ops->dellink(dev, &list_kill);
+				unregister_netdevice_many(&list_kill);
+			} else {
+				unregister_netdevice(dev);
+			}
+		}
 out:
 		put_net(dest_net);
 		return err;
@@ -2491,12 +2495,16 @@ static int rtnl_bridge_notify(struct net_device *dev, u16 flags)
 			goto errout;
 	}
 
+	if (!skb->len)
+		goto errout;
+
 	rtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL, GFP_ATOMIC);
 	return 0;
 errout:
 	WARN_ON(err == -EMSGSIZE);
 	kfree_skb(skb);
-	rtnl_set_sk_err(net, RTNLGRP_LINK, err);
+	if (err)
+		rtnl_set_sk_err(net, RTNLGRP_LINK, err);
 	return err;
 }
 
diff --git a/net/ipv4/fib_frontend.c b/net/ipv4/fib_frontend.c
index 4fc63bd..f5d321f 100644
--- a/net/ipv4/fib_frontend.c
+++ b/net/ipv4/fib_frontend.c
@@ -250,7 +250,7 @@ static int __fib_validate_source(struct sk_buff *skb, __be32 src, __be32 dst,
 	bool dev_match;
 
 	fl4.flowi4_oif = 0;
-	fl4.flowi4_iif = oif;
+	fl4.flowi4_iif = oif ? : LOOPBACK_IFINDEX;
 	fl4.daddr = src;
 	fl4.saddr = dst;
 	fl4.flowi4_tos = tos;
diff --git a/net/ipv4/fib_semantics.c b/net/ipv4/fib_semantics.c
index bc773a1..d00d8f9 100644
--- a/net/ipv4/fib_semantics.c
+++ b/net/ipv4/fib_semantics.c
@@ -629,6 +629,7 @@ static int fib_check_nh(struct fib_config *cfg, struct fib_info *fi,
 				.daddr = nh->nh_gw,
 				.flowi4_scope = cfg->fc_scope + 1,
 				.flowi4_oif = nh->nh_oif,
+				.flowi4_iif = LOOPBACK_IFINDEX,
 			};
 
 			/* It is not necessary, but requires a bit of thinking */
diff --git a/net/ipv4/ip_forward.c b/net/ipv4/ip_forward.c
index bd1c5ba..31ee5c6 100644
--- a/net/ipv4/ip_forward.c
+++ b/net/ipv4/ip_forward.c
@@ -175,7 +175,8 @@ int ip_forward(struct sk_buff *skb)
 	 *	We now generate an ICMP HOST REDIRECT giving the route
 	 *	we calculated.
 	 */
-	if (rt->rt_flags&RTCF_DOREDIRECT && !opt->srr && !skb_sec_path(skb))
+	if (IPCB(skb)->flags & IPSKB_DOREDIRECT && !opt->srr &&
+	    !skb_sec_path(skb))
 		ip_rt_send_redirect(skb);
 
 	skb->priority = rt_tos2priority(iph->tos);
diff --git a/net/ipv4/ip_fragment.c b/net/ipv4/ip_fragment.c
index b66910a..4c1884f 100644
--- a/net/ipv4/ip_fragment.c
+++ b/net/ipv4/ip_fragment.c
@@ -678,27 +678,30 @@ EXPORT_SYMBOL(ip_defrag);
 struct sk_buff *ip_check_defrag(struct sk_buff *skb, u32 user)
 {
 	struct iphdr iph;
+	int netoff;
 	u32 len;
 
 	if (skb->protocol != htons(ETH_P_IP))
 		return skb;
 
-	if (!skb_copy_bits(skb, 0, &iph, sizeof(iph)))
+	netoff = skb_network_offset(skb);
+
+	if (skb_copy_bits(skb, netoff, &iph, sizeof(iph)) < 0)
 		return skb;
 
 	if (iph.ihl < 5 || iph.version != 4)
 		return skb;
 
 	len = ntohs(iph.tot_len);
-	if (skb->len < len || len < (iph.ihl * 4))
+	if (skb->len < netoff + len || len < (iph.ihl * 4))
 		return skb;
 
 	if (ip_is_fragment(&iph)) {
 		skb = skb_share_check(skb, GFP_ATOMIC);
 		if (skb) {
-			if (!pskb_may_pull(skb, iph.ihl*4))
+			if (!pskb_may_pull(skb, netoff + iph.ihl * 4))
 				return skb;
-			if (pskb_trim_rcsum(skb, len))
+			if (pskb_trim_rcsum(skb, netoff + len))
 				return skb;
 			memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));
 			if (ip_defrag(skb, user))
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index 1bb1171..47d2361 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -845,7 +845,8 @@ static int __ip_append_data(struct sock *sk,
 	cork->length += length;
 	if (((length > mtu) || (skb && skb_has_frags(skb))) &&
 	    (sk->sk_protocol == IPPROTO_UDP) &&
-	    (rt->dst.dev->features & NETIF_F_UFO) && !rt->dst.header_len) {
+	    (rt->dst.dev->features & NETIF_F_UFO) && !rt->dst.header_len &&
+	    (sk->sk_type == SOCK_DGRAM)) {
 		err = ip_ufo_append_data(sk, queue, getfrag, from, length,
 					 hh_len, fragheaderlen, transhdrlen,
 					 maxfraglen, flags);
@@ -1454,23 +1455,8 @@ static int ip_reply_glue_bits(void *dptr, char *to, int offset,
 /*
  *	Generic function to send a packet as reply to another packet.
  *	Used to send some TCP resets/acks so far.
- *
- *	Use a fake percpu inet socket to avoid false sharing and contention.
  */
-static DEFINE_PER_CPU(struct inet_sock, unicast_sock) = {
-	.sk = {
-		.__sk_common = {
-			.skc_refcnt = ATOMIC_INIT(1),
-		},
-		.sk_wmem_alloc	= ATOMIC_INIT(1),
-		.sk_allocation	= GFP_ATOMIC,
-		.sk_flags	= (1UL << SOCK_USE_WRITE_QUEUE),
-	},
-	.pmtudisc	= IP_PMTUDISC_WANT,
-	.uc_ttl		= -1,
-};
-
-void ip_send_unicast_reply(struct net *net, struct sk_buff *skb, __be32 daddr,
+void ip_send_unicast_reply(struct sock *sk, struct sk_buff *skb, __be32 daddr,
 			   __be32 saddr, const struct ip_reply_arg *arg,
 			   unsigned int len)
 {
@@ -1478,9 +1464,8 @@ void ip_send_unicast_reply(struct net *net, struct sk_buff *skb, __be32 daddr,
 	struct ipcm_cookie ipc;
 	struct flowi4 fl4;
 	struct rtable *rt = skb_rtable(skb);
+	struct net *net = sock_net(sk);
 	struct sk_buff *nskb;
-	struct sock *sk;
-	struct inet_sock *inet;
 	int err;
 
 	if (ip_options_echo(&replyopts.opt.opt, skb))
@@ -1510,15 +1495,11 @@ void ip_send_unicast_reply(struct net *net, struct sk_buff *skb, __be32 daddr,
 	if (IS_ERR(rt))
 		return;
 
-	inet = &get_cpu_var(unicast_sock);
+	inet_sk(sk)->tos = arg->tos;
 
-	inet->tos = arg->tos;
-	sk = &inet->sk;
 	sk->sk_priority = skb->priority;
 	sk->sk_protocol = ip_hdr(skb)->protocol;
 	sk->sk_bound_dev_if = arg->bound_dev_if;
-	sock_net_set(sk, net);
-	__skb_queue_head_init(&sk->sk_write_queue);
 	sk->sk_sndbuf = sysctl_wmem_default;
 	err = ip_append_data(sk, &fl4, ip_reply_glue_bits, arg->iov->iov_base,
 			     len, 0, &ipc, &rt, MSG_DONTWAIT);
@@ -1534,13 +1515,10 @@ void ip_send_unicast_reply(struct net *net, struct sk_buff *skb, __be32 daddr,
 			  arg->csumoffset) = csum_fold(csum_add(nskb->csum,
 								arg->csum));
 		nskb->ip_summed = CHECKSUM_NONE;
-		skb_orphan(nskb);
 		skb_set_queue_mapping(nskb, skb_get_queue_mapping(skb));
 		ip_push_pending_frames(sk, &fl4);
 	}
 out:
-	put_cpu_var(unicast_sock);
-
 	ip_rt_put(rt);
 }
 
diff --git a/net/ipv4/ip_sockglue.c b/net/ipv4/ip_sockglue.c
index 23e6ab0..f660314 100644
--- a/net/ipv4/ip_sockglue.c
+++ b/net/ipv4/ip_sockglue.c
@@ -410,15 +410,11 @@ int ip_recv_error(struct sock *sk, struct msghdr *msg, int len, int *addr_len)
 
 	memcpy(&errhdr.ee, &serr->ee, sizeof(struct sock_extended_err));
 	sin = &errhdr.offender;
-	sin->sin_family = AF_UNSPEC;
+	memset(sin, 0, sizeof(*sin));
 	if (serr->ee.ee_origin == SO_EE_ORIGIN_ICMP) {
-		struct inet_sock *inet = inet_sk(sk);
-
 		sin->sin_family = AF_INET;
 		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
-		sin->sin_port = 0;
-		memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
-		if (inet->cmsg_flags)
+		if (inet_sk(sk)->cmsg_flags)
 			ip_cmsg_recv(msg, skb);
 	}
 
diff --git a/net/ipv4/ipmr.c b/net/ipv4/ipmr.c
index 56d079b..9fc74ec 100644
--- a/net/ipv4/ipmr.c
+++ b/net/ipv4/ipmr.c
@@ -454,7 +454,7 @@ static netdev_tx_t reg_vif_xmit(struct sk_buff *skb, struct net_device *dev)
 	struct mr_table *mrt;
 	struct flowi4 fl4 = {
 		.flowi4_oif	= dev->ifindex,
-		.flowi4_iif	= skb->skb_iif,
+		.flowi4_iif	= skb->skb_iif ? : LOOPBACK_IFINDEX,
 		.flowi4_mark	= skb->mark,
 	};
 	int err;
diff --git a/net/ipv4/netfilter/ipt_rpfilter.c b/net/ipv4/netfilter/ipt_rpfilter.c
index c49dcd0..4bfaedf 100644
--- a/net/ipv4/netfilter/ipt_rpfilter.c
+++ b/net/ipv4/netfilter/ipt_rpfilter.c
@@ -89,11 +89,8 @@ static bool rpfilter_mt(const struct sk_buff *skb, struct xt_action_param *par)
 	if (ipv4_is_multicast(iph->daddr)) {
 		if (ipv4_is_zeronet(iph->saddr))
 			return ipv4_is_local_multicast(iph->daddr) ^ invert;
-		flow.flowi4_iif = 0;
-	} else {
-		flow.flowi4_iif = LOOPBACK_IFINDEX;
 	}
-
+	flow.flowi4_iif = LOOPBACK_IFINDEX;
 	flow.daddr = iph->saddr;
 	flow.saddr = rpfilter_get_saddr(iph->daddr);
 	flow.flowi4_oif = 0;
diff --git a/net/ipv4/ping.c b/net/ipv4/ping.c
index d99c80b..015e030 100644
--- a/net/ipv4/ping.c
+++ b/net/ipv4/ping.c
@@ -154,7 +154,6 @@ void ping_unhash(struct sock *sk)
 	if (sk_hashed(sk)) {
 		write_lock_bh(&ping_table.lock);
 		hlist_nulls_del(&sk->sk_nulls_node);
-		sk_nulls_node_init(&sk->sk_nulls_node);
 		sock_put(sk);
 		isk->inet_num = 0;
 		isk->inet_sport = 0;
@@ -257,7 +256,10 @@ int ping_init_sock(struct sock *sk)
 	int i, j, count;
 	kgid_t low, high;
 	int ret = 0;
-	
+
+	if (sk->sk_family == AF_INET6)
+		inet6_sk(sk)->ipv6only = 1;
+
 	inet_get_ping_group_range_net(net, &low, &high);
 	if (gid_lte(low, group) && gid_lte(group, high))
 		return 0;
@@ -305,6 +307,11 @@ int ping_check_bind_addr(struct sock *sk, struct inet_sock *isk,
 		if (addr_len < sizeof(*addr))
 			return -EINVAL;
 
+		if (addr->sin_family != AF_INET &&
+		    !(addr->sin_family == AF_UNSPEC &&
+		      addr->sin_addr.s_addr == htonl(INADDR_ANY)))
+			return -EAFNOSUPPORT;
+
 		pr_debug("ping_check_bind_addr(sk=%p,addr=%pI4,port=%d)\n",
 			 sk, &addr->sin_addr.s_addr, ntohs(addr->sin_port));
 
@@ -329,6 +336,9 @@ int ping_check_bind_addr(struct sock *sk, struct inet_sock *isk,
 		if (addr_len < sizeof(*addr))
 			return -EINVAL;
 
+		if (addr->sin6_family != AF_INET6)
+			return -EAFNOSUPPORT;
+
 		pr_debug("ping_check_bind_addr(sk=%p,addr=%pI6c,port=%d)\n",
 			 sk, addr->sin6_addr.s6_addr, ntohs(addr->sin6_port));
 
@@ -711,7 +721,7 @@ int ping_v4_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 		if (msg->msg_namelen < sizeof(*usin))
 			return -EINVAL;
 		if (usin->sin_family != AF_INET)
-			return -EINVAL;
+			return -EAFNOSUPPORT;
 		daddr = usin->sin_addr.s_addr;
 		/* no remote port */
 	} else {
diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index 2717323..5778011 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -1523,11 +1523,10 @@ static int __mkroute_input(struct sk_buff *skb,
 
 	do_cache = res->fi && !itag;
 	if (out_dev == in_dev && err && IN_DEV_TX_REDIRECTS(out_dev) &&
+	    skb->protocol == htons(ETH_P_IP) &&
 	    (IN_DEV_SHARED_MEDIA(out_dev) ||
-	     inet_addr_onlink(out_dev, saddr, FIB_RES_GW(*res)))) {
-		flags |= RTCF_DOREDIRECT;
-		do_cache = false;
-	}
+	     inet_addr_onlink(out_dev, saddr, FIB_RES_GW(*res))))
+		IPCB(skb)->flags |= IPSKB_DOREDIRECT;
 
 	if (skb->protocol != htons(ETH_P_IP)) {
 		/* Not IP (i.e. ARP). Do not create route, if it is
@@ -2264,6 +2263,8 @@ static int rt_fill_info(struct net *net,  __be32 dst, __be32 src,
 	r->rtm_flags	= (rt->rt_flags & ~0xFFFF) | RTM_F_CLONED;
 	if (rt->rt_flags & RTCF_NOTIFY)
 		r->rtm_flags |= RTM_F_NOTIFY;
+	if (IPCB(skb)->flags & IPSKB_DOREDIRECT)
+		r->rtm_flags |= RTCF_DOREDIRECT;
 
 	if (nla_put_be32(skb, RTA_DST, dst))
 		goto nla_put_failure;
diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c
index 35c0158..7edf30c 100644
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@ -707,7 +707,8 @@ static void tcp_v4_send_reset(struct sock *sk, struct sk_buff *skb)
 
 	net = dev_net(skb_dst(skb)->dev);
 	arg.tos = ip_hdr(skb)->tos;
-	ip_send_unicast_reply(net, skb, ip_hdr(skb)->saddr,
+	ip_send_unicast_reply(*this_cpu_ptr(net->ipv4.tcp_sk),
+			      skb, ip_hdr(skb)->saddr,
 			      ip_hdr(skb)->daddr, &arg, arg.iov[0].iov_len);
 
 	TCP_INC_STATS_BH(net, TCP_MIB_OUTSEGS);
@@ -790,7 +791,8 @@ static void tcp_v4_send_ack(struct sk_buff *skb, u32 seq, u32 ack,
 	if (oif)
 		arg.bound_dev_if = oif;
 	arg.tos = tos;
-	ip_send_unicast_reply(net, skb, ip_hdr(skb)->saddr,
+	ip_send_unicast_reply(*this_cpu_ptr(net->ipv4.tcp_sk),
+			      skb, ip_hdr(skb)->saddr,
 			      ip_hdr(skb)->daddr, &arg, arg.iov[0].iov_len);
 
 	TCP_INC_STATS_BH(net, TCP_MIB_OUTSEGS);
@@ -3009,14 +3011,39 @@ struct proto tcp_prot = {
 };
 EXPORT_SYMBOL(tcp_prot);
 
+static void __net_exit tcp_sk_exit(struct net *net)
+{
+	int cpu;
+
+	for_each_possible_cpu(cpu)
+		inet_ctl_sock_destroy(*per_cpu_ptr(net->ipv4.tcp_sk, cpu));
+	free_percpu(net->ipv4.tcp_sk);
+}
+
 static int __net_init tcp_sk_init(struct net *net)
 {
+	int res, cpu;
+
+	net->ipv4.tcp_sk = alloc_percpu(struct sock *);
+	if (!net->ipv4.tcp_sk)
+		return -ENOMEM;
+
+	for_each_possible_cpu(cpu) {
+		struct sock *sk;
+
+		res = inet_ctl_sock_create(&sk, PF_INET, SOCK_RAW,
+					   IPPROTO_TCP, net);
+		if (res)
+			goto fail;
+		*per_cpu_ptr(net->ipv4.tcp_sk, cpu) = sk;
+	}
 	net->ipv4.sysctl_tcp_ecn = 2;
 	return 0;
-}
 
-static void __net_exit tcp_sk_exit(struct net *net)
-{
+fail:
+	tcp_sk_exit(net);
+
+	return res;
 }
 
 static void __net_exit tcp_sk_exit_batch(struct list_head *net_exit_list)
diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c
index eef147c..25f2aec 100644
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@ -1861,7 +1861,7 @@ static bool tcp_write_xmit(struct sock *sk, unsigned int mss_now, int nonagle,
 		if (unlikely(!tcp_snd_wnd_test(tp, skb, mss_now)))
 			break;
 
-		if (tso_segs == 1) {
+		if (tso_segs == 1 || !sk->sk_gso_max_segs) {
 			if (unlikely(!tcp_nagle_test(tp, skb, mss_now,
 						     (tcp_skb_is_last(sk, skb) ?
 						      nonagle : TCP_NAGLE_PUSH))))
@@ -1898,7 +1898,7 @@ static bool tcp_write_xmit(struct sock *sk, unsigned int mss_now, int nonagle,
 		}
 
 		limit = mss_now;
-		if (tso_segs > 1 && !tcp_urg_mode(tp))
+		if (tso_segs > 1 && sk->sk_gso_max_segs && !tcp_urg_mode(tp))
 			limit = tcp_mss_split_point(sk, skb, mss_now,
 						    min_t(unsigned int,
 							  cwnd_quota,
diff --git a/net/ipv4/udp_diag.c b/net/ipv4/udp_diag.c
index 7927db0..4a000f1 100644
--- a/net/ipv4/udp_diag.c
+++ b/net/ipv4/udp_diag.c
@@ -99,11 +99,13 @@ static void udp_dump(struct udp_table *table, struct sk_buff *skb, struct netlin
 	s_slot = cb->args[0];
 	num = s_num = cb->args[1];
 
-	for (slot = s_slot; slot <= table->mask; num = s_num = 0, slot++) {
+	for (slot = s_slot; slot <= table->mask; s_num = 0, slot++) {
 		struct sock *sk;
 		struct hlist_nulls_node *node;
 		struct udp_hslot *hslot = &table->hash[slot];
 
+		num = 0;
+
 		if (hlist_nulls_empty(&hslot->head))
 			continue;
 
diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c
index ccddbe6..862e2c2 100644
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@ -3215,11 +3215,13 @@ static int addrconf_ifdown(struct net_device *dev, int how)
 
 	write_unlock_bh(&idev->lock);
 
-	/* Step 5: Discard multicast list */
-	if (how)
+	/* Step 5: Discard anycast and multicast list */
+	if (how) {
+		ipv6_ac_destroy_dev(idev);
 		ipv6_mc_destroy_dev(idev);
-	else
+	} else {
 		ipv6_mc_down(idev);
+	}
 
 	idev->tstamp = jiffies;
 
diff --git a/net/ipv6/anycast.c b/net/ipv6/anycast.c
index 5a80f15..1e97d08 100644
--- a/net/ipv6/anycast.c
+++ b/net/ipv6/anycast.c
@@ -341,6 +341,27 @@ static int ipv6_dev_ac_dec(struct net_device *dev, const struct in6_addr *addr)
 	return __ipv6_dev_ac_dec(idev, addr);
 }
 
+void ipv6_ac_destroy_dev(struct inet6_dev *idev)
+{
+	struct ifacaddr6 *aca;
+
+	write_lock_bh(&idev->lock);
+	while ((aca = idev->ac_list) != NULL) {
+		idev->ac_list = aca->aca_next;
+		write_unlock_bh(&idev->lock);
+
+		addrconf_leave_solict(idev, &aca->aca_addr);
+
+		dst_hold(&aca->aca_rt->dst);
+		ip6_del_rt(aca->aca_rt);
+
+		aca_put(aca);
+
+		write_lock_bh(&idev->lock);
+	}
+	write_unlock_bh(&idev->lock);
+}
+
 /*
  *	check if the interface has this anycast address
  *	called with rcu_read_lock()
diff --git a/net/ipv6/datagram.c b/net/ipv6/datagram.c
index 41a353b..5a2c0de 100644
--- a/net/ipv6/datagram.c
+++ b/net/ipv6/datagram.c
@@ -375,11 +375,10 @@ int ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len, int *addr_len)
 
 	memcpy(&errhdr.ee, &serr->ee, sizeof(struct sock_extended_err));
 	sin = &errhdr.offender;
-	sin->sin6_family = AF_UNSPEC;
+	memset(sin, 0, sizeof(*sin));
+
 	if (serr->ee.ee_origin != SO_EE_ORIGIN_LOCAL) {
 		sin->sin6_family = AF_INET6;
-		sin->sin6_flowinfo = 0;
-		sin->sin6_port = 0;
 		if (skb->protocol == htons(ETH_P_IPV6)) {
 			sin->sin6_addr = ipv6_hdr(skb)->saddr;
 			if (np->rxopt.all)
@@ -388,12 +387,9 @@ int ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len, int *addr_len)
 				ipv6_iface_scope_id(&sin->sin6_addr,
 						    IP6CB(skb)->iif);
 		} else {
-			struct inet_sock *inet = inet_sk(sk);
-
 			ipv6_addr_set_v4mapped(ip_hdr(skb)->saddr,
 					       &sin->sin6_addr);
-			sin->sin6_scope_id = 0;
-			if (inet->cmsg_flags)
+			if (inet_sk(sk)->cmsg_flags)
 				ip_cmsg_recv(msg, skb);
 		}
 	}
diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c
index 009c962..ceeb945 100644
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@ -638,6 +638,29 @@ static inline bool rt6_qualify_for_ecmp(struct rt6_info *rt)
 	       RTF_GATEWAY;
 }
 
+static void fib6_purge_rt(struct rt6_info *rt, struct fib6_node *fn,
+			  struct net *net)
+{
+	if (atomic_read(&rt->rt6i_ref) != 1) {
+		/* This route is used as dummy address holder in some split
+		 * nodes. It is not leaked, but it still holds other resources,
+		 * which must be released in time. So, scan ascendant nodes
+		 * and replace dummy references to this route with references
+		 * to still alive ones.
+		 */
+		while (fn) {
+			if (!(fn->fn_flags & RTN_RTINFO) && fn->leaf == rt) {
+				fn->leaf = fib6_find_prefix(net, fn);
+				atomic_inc(&fn->leaf->rt6i_ref);
+				rt6_release(rt);
+			}
+			fn = fn->parent;
+		}
+		/* No more references are possible at this point. */
+		BUG_ON(atomic_read(&rt->rt6i_ref) != 1);
+	}
+}
+
 /*
  *	Insert routing information in a node.
  */
@@ -775,11 +798,12 @@ add:
 		rt->dst.rt6_next = iter->dst.rt6_next;
 		atomic_inc(&rt->rt6i_ref);
 		inet6_rt_notify(RTM_NEWROUTE, rt, info);
-		rt6_release(iter);
 		if (!(fn->fn_flags & RTN_RTINFO)) {
 			info->nl_net->ipv6.rt6_stats->fib_route_nodes++;
 			fn->fn_flags |= RTN_RTINFO;
 		}
+		fib6_purge_rt(iter, fn, info->nl_net);
+		rt6_release(iter);
 	}
 
 	return 0;
@@ -1284,24 +1308,7 @@ static void fib6_del_route(struct fib6_node *fn, struct rt6_info **rtp,
 		fn = fib6_repair_tree(net, fn);
 	}
 
-	if (atomic_read(&rt->rt6i_ref) != 1) {
-		/* This route is used as dummy address holder in some split
-		 * nodes. It is not leaked, but it still holds other resources,
-		 * which must be released in time. So, scan ascendant nodes
-		 * and replace dummy references to this route with references
-		 * to still alive ones.
-		 */
-		while (fn) {
-			if (!(fn->fn_flags & RTN_RTINFO) && fn->leaf == rt) {
-				fn->leaf = fib6_find_prefix(net, fn);
-				atomic_inc(&fn->leaf->rt6i_ref);
-				rt6_release(rt);
-			}
-			fn = fn->parent;
-		}
-		/* No more references are possible at this point. */
-		BUG_ON(atomic_read(&rt->rt6i_ref) != 1);
-	}
+	fib6_purge_rt(rt, fn, net);
 
 	inet6_rt_notify(RTM_DELROUTE, rt, info);
 	rt6_release(rt);
diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c
index 071edcb..1ce7ea1 100644
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@ -1286,7 +1286,8 @@ int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,
 	if (((length > mtu) ||
 	     (skb && skb_has_frags(skb))) &&
 	    (sk->sk_protocol == IPPROTO_UDP) &&
-	    (rt->dst.dev->features & NETIF_F_UFO)) {
+	    (rt->dst.dev->features & NETIF_F_UFO) &&
+	    (sk->sk_type == SOCK_DGRAM)) {
 		err = ip6_ufo_append_data(sk, getfrag, from, length,
 					  hh_len, fragheaderlen,
 					  transhdrlen, mtu, flags, rt);
diff --git a/net/ipv6/ip6mr.c b/net/ipv6/ip6mr.c
index 2c84072..63cf7cd 100644
--- a/net/ipv6/ip6mr.c
+++ b/net/ipv6/ip6mr.c
@@ -701,7 +701,7 @@ static netdev_tx_t reg_vif_xmit(struct sk_buff *skb,
 	struct mr6_table *mrt;
 	struct flowi6 fl6 = {
 		.flowi6_oif	= dev->ifindex,
-		.flowi6_iif	= skb->skb_iif,
+		.flowi6_iif	= skb->skb_iif ? : LOOPBACK_IFINDEX,
 		.flowi6_mark	= skb->mark,
 	};
 	int err;
diff --git a/net/ipv6/ping.c b/net/ipv6/ping.c
index 6bd4246..9cd08db 100644
--- a/net/ipv6/ping.c
+++ b/net/ipv6/ping.c
@@ -103,9 +103,10 @@ int ping_v6_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 
 	if (msg->msg_name) {
 		struct sockaddr_in6 *u = (struct sockaddr_in6 *) msg->msg_name;
-		if (msg->msg_namelen < sizeof(struct sockaddr_in6) ||
-		    u->sin6_family != AF_INET6) {
+		if (msg->msg_namelen < sizeof(*u))
 			return -EINVAL;
+		if (u->sin6_family != AF_INET6) {
+			return -EAFNOSUPPORT;
 		}
 		if (sk->sk_bound_dev_if &&
 		    sk->sk_bound_dev_if != u->sin6_scope_id) {
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index 03b1e6f..2f127bd 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -108,7 +108,7 @@ static u32 *ipv6_cow_metrics(struct dst_entry *dst, unsigned long old)
 	u32 *p = NULL;
 
 	if (!(rt->dst.flags & DST_HOST))
-		return NULL;
+		return dst_cow_metrics_generic(dst, old);
 
 	peer = rt6_get_peer_create(rt);
 	if (peer) {
@@ -1137,12 +1137,9 @@ static void ip6_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,
 		struct net *net = dev_net(dst->dev);
 
 		rt6->rt6i_flags |= RTF_MODIFIED;
-		if (mtu < IPV6_MIN_MTU) {
-			u32 features = dst_metric(dst, RTAX_FEATURES);
+		if (mtu < IPV6_MIN_MTU)
 			mtu = IPV6_MIN_MTU;
-			features |= RTAX_FEATURE_ALLFRAG;
-			dst_metric_set(dst, RTAX_FEATURES, features);
-		}
+
 		dst_metric_set(dst, RTAX_MTU, mtu);
 		rt6_update_expires(rt6, net->ipv6.sysctl.ip6_rt_mtu_expires);
 	}
@@ -2638,6 +2635,9 @@ static int inet6_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr* nlh)
 	if (tb[RTA_OIF])
 		oif = nla_get_u32(tb[RTA_OIF]);
 
+	if (tb[RTA_MARK])
+		fl6.flowi6_mark = nla_get_u32(tb[RTA_MARK]);
+
 	if (tb[RTA_UID])
 		fl6.flowi6_uid = make_kuid(current_user_ns(),
 					   nla_get_u32(tb[RTA_UID]));
diff --git a/net/irda/ircomm/ircomm_tty.c b/net/irda/ircomm/ircomm_tty.c
index 41ac793..2ee29ed 100644
--- a/net/irda/ircomm/ircomm_tty.c
+++ b/net/irda/ircomm/ircomm_tty.c
@@ -820,7 +820,9 @@ static void ircomm_tty_wait_until_sent(struct tty_struct *tty, int timeout)
 	orig_jiffies = jiffies;
 
 	/* Set poll time to 200 ms */
-	poll_time = IRDA_MIN(timeout, msecs_to_jiffies(200));
+	poll_time = msecs_to_jiffies(200);
+	if (timeout)
+		poll_time = min_t(unsigned long, timeout, poll_time);
 
 	spin_lock_irqsave(&self->spinlock, flags);
 	while (self->tx_skb && self->tx_skb->len) {
diff --git a/net/netfilter/ipset/ip_set_core.c b/net/netfilter/ipset/ip_set_core.c
index f771390..3b04dfd 100644
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@ -1754,6 +1754,12 @@ ip_set_sockfn_get(struct sock *sk, int optval, void __user *user, int *len)
 	if (*op < IP_SET_OP_VERSION) {
 		/* Check the version at the beginning of operations */
 		struct ip_set_req_version *req_version = data;
+
+		if (*len < sizeof(struct ip_set_req_version)) {
+			ret = -EINVAL;
+			goto done;
+		}
+
 		if (req_version->version != IPSET_PROTOCOL) {
 			ret = -EPROTO;
 			goto done;
diff --git a/net/netfilter/ipvs/ip_vs_ftp.c b/net/netfilter/ipvs/ip_vs_ftp.c
index 77c1732..4a662f1 100644
--- a/net/netfilter/ipvs/ip_vs_ftp.c
+++ b/net/netfilter/ipvs/ip_vs_ftp.c
@@ -183,6 +183,8 @@ static int ip_vs_ftp_out(struct ip_vs_app *app, struct ip_vs_conn *cp,
 	struct nf_conn *ct;
 	struct net *net;
 
+	*diff = 0;
+
 #ifdef CONFIG_IP_VS_IPV6
 	/* This application helper doesn't work with IPv6 yet,
 	 * so turn this into a no-op for IPv6 packets
@@ -191,8 +193,6 @@ static int ip_vs_ftp_out(struct ip_vs_app *app, struct ip_vs_conn *cp,
 		return 1;
 #endif
 
-	*diff = 0;
-
 	/* Only useful for established sessions */
 	if (cp->state != IP_VS_TCP_S_ESTABLISHED)
 		return 1;
@@ -321,6 +321,9 @@ static int ip_vs_ftp_in(struct ip_vs_app *app, struct ip_vs_conn *cp,
 	struct ip_vs_conn *n_cp;
 	struct net *net;
 
+	/* no diff required for incoming packets */
+	*diff = 0;
+
 #ifdef CONFIG_IP_VS_IPV6
 	/* This application helper doesn't work with IPv6 yet,
 	 * so turn this into a no-op for IPv6 packets
@@ -329,9 +332,6 @@ static int ip_vs_ftp_in(struct ip_vs_app *app, struct ip_vs_conn *cp,
 		return 1;
 #endif
 
-	/* no diff required for incoming packets */
-	*diff = 0;
-
 	/* Only useful for established sessions */
 	if (cp->state != IP_VS_TCP_S_ESTABLISHED)
 		return 1;
diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c
index a1fd507..8a3d3a4 100644
--- a/net/netlink/af_netlink.c
+++ b/net/netlink/af_netlink.c
@@ -374,14 +374,14 @@ out:
 	return err;
 }
 
-static void netlink_frame_flush_dcache(const struct nl_mmap_hdr *hdr)
+static void netlink_frame_flush_dcache(const struct nl_mmap_hdr *hdr, unsigned int nm_len)
 {
 #if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1
 	struct page *p_start, *p_end;
 
 	/* First page is flushed through netlink_{get,set}_status */
 	p_start = pgvec_to_page(hdr + PAGE_SIZE);
-	p_end   = pgvec_to_page((void *)hdr + NL_MMAP_HDRLEN + hdr->nm_len - 1);
+	p_end   = pgvec_to_page((void *)hdr + NL_MMAP_HDRLEN + nm_len - 1);
 	while (p_start <= p_end) {
 		flush_dcache_page(p_start);
 		p_start++;
@@ -399,9 +399,9 @@ static enum nl_mmap_status netlink_get_status(const struct nl_mmap_hdr *hdr)
 static void netlink_set_status(struct nl_mmap_hdr *hdr,
 			       enum nl_mmap_status status)
 {
+	smp_mb();
 	hdr->nm_status = status;
 	flush_dcache_page(pgvec_to_page(hdr));
-	smp_wmb();
 }
 
 static struct nl_mmap_hdr *
@@ -563,24 +563,16 @@ static int netlink_mmap_sendmsg(struct sock *sk, struct msghdr *msg,
 	struct nl_mmap_hdr *hdr;
 	struct sk_buff *skb;
 	unsigned int maxlen;
-	bool excl = true;
 	int err = 0, len = 0;
 
-	/* Netlink messages are validated by the receiver before processing.
-	 * In order to avoid userspace changing the contents of the message
-	 * after validation, the socket and the ring may only be used by a
-	 * single process, otherwise we fall back to copying.
-	 */
-	if (atomic_long_read(&sk->sk_socket->file->f_count) > 1 ||
-	    atomic_read(&nlk->mapped) > 1)
-		excl = false;
-
 	mutex_lock(&nlk->pg_vec_lock);
 
 	ring   = &nlk->tx_ring;
 	maxlen = ring->frame_size - NL_MMAP_HDRLEN;
 
 	do {
+		unsigned int nm_len;
+
 		hdr = netlink_current_frame(ring, NL_MMAP_STATUS_VALID);
 		if (hdr == NULL) {
 			if (!(msg->msg_flags & MSG_DONTWAIT) &&
@@ -588,35 +580,23 @@ static int netlink_mmap_sendmsg(struct sock *sk, struct msghdr *msg,
 				schedule();
 			continue;
 		}
-		if (hdr->nm_len > maxlen) {
+
+		nm_len = ACCESS_ONCE(hdr->nm_len);
+		if (nm_len > maxlen) {
 			err = -EINVAL;
 			goto out;
 		}
 
-		netlink_frame_flush_dcache(hdr);
+		netlink_frame_flush_dcache(hdr, nm_len);
 
-		if (likely(dst_portid == 0 && dst_group == 0 && excl)) {
-			skb = alloc_skb_head(GFP_KERNEL);
-			if (skb == NULL) {
-				err = -ENOBUFS;
-				goto out;
-			}
-			sock_hold(sk);
-			netlink_ring_setup_skb(skb, sk, ring, hdr);
-			NETLINK_CB(skb).flags |= NETLINK_SKB_TX;
-			__skb_put(skb, hdr->nm_len);
-			netlink_set_status(hdr, NL_MMAP_STATUS_RESERVED);
-			atomic_inc(&ring->pending);
-		} else {
-			skb = alloc_skb(hdr->nm_len, GFP_KERNEL);
-			if (skb == NULL) {
-				err = -ENOBUFS;
-				goto out;
-			}
-			__skb_put(skb, hdr->nm_len);
-			memcpy(skb->data, (void *)hdr + NL_MMAP_HDRLEN, hdr->nm_len);
-			netlink_set_status(hdr, NL_MMAP_STATUS_UNUSED);
+		skb = alloc_skb(nm_len, GFP_KERNEL);
+		if (skb == NULL) {
+			err = -ENOBUFS;
+			goto out;
 		}
+		__skb_put(skb, nm_len);
+		memcpy(skb->data, (void *)hdr + NL_MMAP_HDRLEN, nm_len);
+		netlink_set_status(hdr, NL_MMAP_STATUS_UNUSED);
 
 		netlink_increment_head(ring);
 
@@ -662,7 +642,7 @@ static void netlink_queue_mmaped_skb(struct sock *sk, struct sk_buff *skb)
 	hdr->nm_pid	= NETLINK_CB(skb).creds.pid;
 	hdr->nm_uid	= from_kuid(sk_user_ns(sk), NETLINK_CB(skb).creds.uid);
 	hdr->nm_gid	= from_kgid(sk_user_ns(sk), NETLINK_CB(skb).creds.gid);
-	netlink_frame_flush_dcache(hdr);
+	netlink_frame_flush_dcache(hdr, hdr->nm_len);
 	netlink_set_status(hdr, NL_MMAP_STATUS_VALID);
 
 	NETLINK_CB(skb).flags |= NETLINK_SKB_DELIVERED;
diff --git a/net/sched/ematch.c b/net/sched/ematch.c
index 3a633de..a2abc44 100644
--- a/net/sched/ematch.c
+++ b/net/sched/ematch.c
@@ -227,6 +227,7 @@ static int tcf_em_validate(struct tcf_proto *tp,
 				 * to replay the request.
 				 */
 				module_put(em->ops->owner);
+				em->ops = NULL;
 				err = -EAGAIN;
 			}
 #endif
diff --git a/net/sctp/associola.c b/net/sctp/associola.c
index ca4a1a1..6360a14 100644
--- a/net/sctp/associola.c
+++ b/net/sctp/associola.c
@@ -1297,7 +1297,6 @@ void sctp_assoc_update(struct sctp_association *asoc,
 	asoc->peer.peer_hmacs = new->peer.peer_hmacs;
 	new->peer.peer_hmacs = NULL;
 
-	sctp_auth_key_put(asoc->asoc_shared_key);
 	sctp_auth_asoc_init_active_key(asoc, GFP_ATOMIC);
 }
 
diff --git a/net/sctp/sm_make_chunk.c b/net/sctp/sm_make_chunk.c
index 29fc16f..beedadf 100644
--- a/net/sctp/sm_make_chunk.c
+++ b/net/sctp/sm_make_chunk.c
@@ -2595,7 +2595,7 @@ do_addr_param:
 
 		addr_param = param.v + sizeof(sctp_addip_param_t);
 
-		af = sctp_get_af_specific(param_type2af(param.p->type));
+		af = sctp_get_af_specific(param_type2af(addr_param->p.type));
 		if (af == NULL)
 			break;
 
diff --git a/net/sunrpc/cache.c b/net/sunrpc/cache.c
index 80fe5c8..231b719 100644
--- a/net/sunrpc/cache.c
+++ b/net/sunrpc/cache.c
@@ -930,7 +930,7 @@ static unsigned int cache_poll(struct file *filp, poll_table *wait,
 	poll_wait(filp, &queue_wait, wait);
 
 	/* alway allow write */
-	mask = POLL_OUT | POLLWRNORM;
+	mask = POLLOUT | POLLWRNORM;
 
 	if (!rp)
 		return mask;
diff --git a/net/wireless/chan.c b/net/wireless/chan.c
index fd556ac..e69a17d 100644
--- a/net/wireless/chan.c
+++ b/net/wireless/chan.c
@@ -338,7 +338,7 @@ bool cfg80211_chandef_usable(struct wiphy *wiphy,
 {
 	struct ieee80211_sta_ht_cap *ht_cap;
 	struct ieee80211_sta_vht_cap *vht_cap;
-	u32 width, control_freq;
+	u32 width, control_freq, cap;
 
 	if (WARN_ON(!cfg80211_chandef_valid(chandef)))
 		return false;
@@ -370,7 +370,8 @@ bool cfg80211_chandef_usable(struct wiphy *wiphy,
 			return false;
 		break;
 	case NL80211_CHAN_WIDTH_80P80:
-		if (!(vht_cap->cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ))
+		cap = vht_cap->cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;
+		if (cap != IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ)
 			return false;
 	case NL80211_CHAN_WIDTH_80:
 		if (!vht_cap->vht_supported)
@@ -381,7 +382,9 @@ bool cfg80211_chandef_usable(struct wiphy *wiphy,
 	case NL80211_CHAN_WIDTH_160:
 		if (!vht_cap->vht_supported)
 			return false;
-		if (!(vht_cap->cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ))
+		cap = vht_cap->cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;
+		if (cap != IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ &&
+		    cap != IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ)
 			return false;
 		prohibited_flags |= IEEE80211_CHAN_NO_160MHZ;
 		width = 160;
diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index 9abf196..162fd28 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -2668,6 +2668,9 @@ static int nl80211_get_key(struct sk_buff *skb, struct genl_info *info)
 	if (!rdev->ops->get_key)
 		return -EOPNOTSUPP;
 
+	if (!pairwise && mac_addr && !(rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN))
+		return -ENOENT;
+
 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
 	if (!msg)
 		return -ENOMEM;
@@ -2687,10 +2690,6 @@ static int nl80211_get_key(struct sk_buff *skb, struct genl_info *info)
 	    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr))
 		goto nla_put_failure;
 
-	if (pairwise && mac_addr &&
-	    !(rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN))
-		return -ENOENT;
-
 	err = rdev_get_key(rdev, dev, key_idx, pairwise, mac_addr, &cookie,
 			   get_key_callback);
 
@@ -2861,7 +2860,7 @@ static int nl80211_del_key(struct sk_buff *skb, struct genl_info *info)
 	wdev_lock(dev->ieee80211_ptr);
 	err = nl80211_key_allowed(dev->ieee80211_ptr);
 
-	if (key.type == NL80211_KEYTYPE_PAIRWISE && mac_addr &&
+	if (key.type == NL80211_KEYTYPE_GROUP && mac_addr &&
 	    !(rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN))
 		err = -ENOENT;
 
diff --git a/scripts/Makefile.modinst b/scripts/Makefile.modinst
index ecbb447..8900c5c 100644
--- a/scripts/Makefile.modinst
+++ b/scripts/Makefile.modinst
@@ -24,7 +24,7 @@ quiet_cmd_modules_install = INSTALL $@
 INSTALL_MOD_DIR ?= extra
 ext-mod-dir = $(INSTALL_MOD_DIR)$(subst $(patsubst %/,%,$(KBUILD_EXTMOD)),,$(@D))
 
-modinst_dir = $(if $(KBUILD_EXTMOD),$(ext-mod-dir),kernel/$(@D))
+modinst_dir ?= $(if $(KBUILD_EXTMOD),$(ext-mod-dir),kernel/$(@D))
 
 $(modules):
 	$(call cmd,modules_install,$(MODLIB)/$(modinst_dir))
diff --git a/scripts/recordmcount.pl b/scripts/recordmcount.pl
index 151739b..aead5de 100755
--- a/scripts/recordmcount.pl
+++ b/scripts/recordmcount.pl
@@ -262,7 +262,6 @@ if ($arch eq "x86_64") {
     # force flags for this arch
     $ld .= " -m shlelf_linux";
     $objcopy .= " -O elf32-sh-linux";
-    $cc .= " -m32";
 
 } elsif ($arch eq "powerpc") {
     $local_regex = "^[0-9a-fA-F]+\\s+t\\s+(\\.?\\S+)";
diff --git a/security/keys/gc.c b/security/keys/gc.c
index d67c97b..7978186 100644
--- a/security/keys/gc.c
+++ b/security/keys/gc.c
@@ -201,12 +201,12 @@ static noinline void key_gc_unused_keys(struct list_head *keys)
 		if (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))
 			atomic_dec(&key->user->nikeys);
 
-		key_user_put(key->user);
-
 		/* now throw away the key memory */
 		if (key->type->destroy)
 			key->type->destroy(key);
 
+		key_user_put(key->user);
+
 		kfree(key->description);
 
 #ifdef KEY_DEBUGGING
diff --git a/sound/core/pcm_native.c b/sound/core/pcm_native.c
index 175dca4..707405c 100644
--- a/sound/core/pcm_native.c
+++ b/sound/core/pcm_native.c
@@ -1404,6 +1404,8 @@ static int snd_pcm_do_drain_init(struct snd_pcm_substream *substream, int state)
 			if (! snd_pcm_playback_empty(substream)) {
 				snd_pcm_do_start(substream, SNDRV_PCM_STATE_DRAINING);
 				snd_pcm_post_start(substream, SNDRV_PCM_STATE_DRAINING);
+			} else {
+				runtime->status->state = SNDRV_PCM_STATE_SETUP;
 			}
 			break;
 		case SNDRV_PCM_STATE_RUNNING:
diff --git a/sound/core/seq/seq_dummy.c b/sound/core/seq/seq_dummy.c
index dbc5507..f60d814 100644
--- a/sound/core/seq/seq_dummy.c
+++ b/sound/core/seq/seq_dummy.c
@@ -82,36 +82,6 @@ struct snd_seq_dummy_port {
 static int my_client = -1;
 
 /*
- * unuse callback - send ALL_SOUNDS_OFF and RESET_CONTROLLERS events
- * to subscribers.
- * Note: this callback is called only after all subscribers are removed.
- */
-static int
-dummy_unuse(void *private_data, struct snd_seq_port_subscribe *info)
-{
-	struct snd_seq_dummy_port *p;
-	int i;
-	struct snd_seq_event ev;
-
-	p = private_data;
-	memset(&ev, 0, sizeof(ev));
-	if (p->duplex)
-		ev.source.port = p->connect;
-	else
-		ev.source.port = p->port;
-	ev.dest.client = SNDRV_SEQ_ADDRESS_SUBSCRIBERS;
-	ev.type = SNDRV_SEQ_EVENT_CONTROLLER;
-	for (i = 0; i < 16; i++) {
-		ev.data.control.channel = i;
-		ev.data.control.param = MIDI_CTL_ALL_SOUNDS_OFF;
-		snd_seq_kernel_client_dispatch(p->client, &ev, 0, 0);
-		ev.data.control.param = MIDI_CTL_RESET_CONTROLLERS;
-		snd_seq_kernel_client_dispatch(p->client, &ev, 0, 0);
-	}
-	return 0;
-}
-
-/*
  * event input callback - just redirect events to subscribers
  */
 static int
@@ -175,7 +145,6 @@ create_port(int idx, int type)
 		| SNDRV_SEQ_PORT_TYPE_PORT;
 	memset(&pcb, 0, sizeof(pcb));
 	pcb.owner = THIS_MODULE;
-	pcb.unuse = dummy_unuse;
 	pcb.event_input = dummy_input;
 	pcb.private_free = dummy_free;
 	pcb.private_data = rec;
diff --git a/sound/i2c/other/ak4113.c b/sound/i2c/other/ak4113.c
index e04e750..7a9149b 100644
--- a/sound/i2c/other/ak4113.c
+++ b/sound/i2c/other/ak4113.c
@@ -56,8 +56,7 @@ static inline unsigned char reg_read(struct ak4113 *ak4113, unsigned char reg)
 
 static void snd_ak4113_free(struct ak4113 *chip)
 {
-	chip->init = 1;	/* don't schedule new work */
-	mb();
+	atomic_inc(&chip->wq_processing);	/* don't schedule new work */
 	cancel_delayed_work_sync(&chip->work);
 	kfree(chip);
 }
@@ -89,6 +88,7 @@ int snd_ak4113_create(struct snd_card *card, ak4113_read_t *read,
 	chip->write = write;
 	chip->private_data = private_data;
 	INIT_DELAYED_WORK(&chip->work, ak4113_stats);
+	atomic_set(&chip->wq_processing, 0);
 
 	for (reg = 0; reg < AK4113_WRITABLE_REGS ; reg++)
 		chip->regmap[reg] = pgm[reg];
@@ -139,13 +139,11 @@ static void ak4113_init_regs(struct ak4113 *chip)
 
 void snd_ak4113_reinit(struct ak4113 *chip)
 {
-	chip->init = 1;
-	mb();
-	flush_delayed_work(&chip->work);
+	if (atomic_inc_return(&chip->wq_processing) == 1)
+		cancel_delayed_work_sync(&chip->work);
 	ak4113_init_regs(chip);
 	/* bring up statistics / event queing */
-	chip->init = 0;
-	if (chip->kctls[0])
+	if (atomic_dec_and_test(&chip->wq_processing))
 		schedule_delayed_work(&chip->work, HZ / 10);
 }
 EXPORT_SYMBOL_GPL(snd_ak4113_reinit);
@@ -632,8 +630,9 @@ static void ak4113_stats(struct work_struct *work)
 {
 	struct ak4113 *chip = container_of(work, struct ak4113, work.work);
 
-	if (!chip->init)
+	if (atomic_inc_return(&chip->wq_processing) == 1)
 		snd_ak4113_check_rate_and_errors(chip, chip->check_flags);
 
-	schedule_delayed_work(&chip->work, HZ / 10);
+	if (atomic_dec_and_test(&chip->wq_processing))
+		schedule_delayed_work(&chip->work, HZ / 10);
 }
diff --git a/sound/i2c/other/ak4114.c b/sound/i2c/other/ak4114.c
index 5bf4fca..84a1ee7 100644
--- a/sound/i2c/other/ak4114.c
+++ b/sound/i2c/other/ak4114.c
@@ -66,8 +66,7 @@ static void reg_dump(struct ak4114 *ak4114)
 
 static void snd_ak4114_free(struct ak4114 *chip)
 {
-	chip->init = 1;	/* don't schedule new work */
-	mb();
+	atomic_inc(&chip->wq_processing);	/* don't schedule new work */
 	cancel_delayed_work_sync(&chip->work);
 	kfree(chip);
 }
@@ -100,6 +99,7 @@ int snd_ak4114_create(struct snd_card *card,
 	chip->write = write;
 	chip->private_data = private_data;
 	INIT_DELAYED_WORK(&chip->work, ak4114_stats);
+	atomic_set(&chip->wq_processing, 0);
 
 	for (reg = 0; reg < 7; reg++)
 		chip->regmap[reg] = pgm[reg];
@@ -152,13 +152,11 @@ static void ak4114_init_regs(struct ak4114 *chip)
 
 void snd_ak4114_reinit(struct ak4114 *chip)
 {
-	chip->init = 1;
-	mb();
-	flush_delayed_work(&chip->work);
+	if (atomic_inc_return(&chip->wq_processing) == 1)
+		cancel_delayed_work_sync(&chip->work);
 	ak4114_init_regs(chip);
 	/* bring up statistics / event queing */
-	chip->init = 0;
-	if (chip->kctls[0])
+	if (atomic_dec_and_test(&chip->wq_processing))
 		schedule_delayed_work(&chip->work, HZ / 10);
 }
 
@@ -612,10 +610,10 @@ static void ak4114_stats(struct work_struct *work)
 {
 	struct ak4114 *chip = container_of(work, struct ak4114, work.work);
 
-	if (!chip->init)
+	if (atomic_inc_return(&chip->wq_processing) == 1)
 		snd_ak4114_check_rate_and_errors(chip, chip->check_flags);
-
-	schedule_delayed_work(&chip->work, HZ / 10);
+	if (atomic_dec_and_test(&chip->wq_processing))
+		schedule_delayed_work(&chip->work, HZ / 10);
 }
 
 EXPORT_SYMBOL(snd_ak4114_create);
diff --git a/sound/pci/hda/patch_sigmatel.c b/sound/pci/hda/patch_sigmatel.c
index 4ae5767..44d3fb9 100644
--- a/sound/pci/hda/patch_sigmatel.c
+++ b/sound/pci/hda/patch_sigmatel.c
@@ -85,6 +85,7 @@ enum {
 	STAC_ALIENWARE_M17X,
 	STAC_92HD89XX_HP_FRONT_JACK,
 	STAC_92HD89XX_HP_Z1_G2_RIGHT_MIC_JACK,
+	STAC_92HD73XX_ASUS_MOBO,
 	STAC_92HD73XX_MODELS
 };
 
@@ -1915,7 +1916,18 @@ static const struct hda_fixup stac92hd73xx_fixups[] = {
 	[STAC_92HD89XX_HP_Z1_G2_RIGHT_MIC_JACK] = {
 		.type = HDA_FIXUP_PINS,
 		.v.pins = stac92hd89xx_hp_z1_g2_right_mic_jack_pin_configs,
-	}
+	},
+	[STAC_92HD73XX_ASUS_MOBO] = {
+		.type = HDA_FIXUP_PINS,
+		.v.pins = (const struct hda_pintbl[]) {
+			/* enable 5.1 and SPDIF out */
+			{ 0x0c, 0x01014411 },
+			{ 0x0d, 0x01014410 },
+			{ 0x0e, 0x01014412 },
+			{ 0x22, 0x014b1180 },
+			{ }
+		}
+	},
 };
 
 static const struct hda_model_fixup stac92hd73xx_models[] = {
@@ -1927,6 +1939,7 @@ static const struct hda_model_fixup stac92hd73xx_models[] = {
 	{ .id = STAC_DELL_M6_BOTH, .name = "dell-m6" },
 	{ .id = STAC_DELL_EQ, .name = "dell-eq" },
 	{ .id = STAC_ALIENWARE_M17X, .name = "alienware" },
+	{ .id = STAC_92HD73XX_ASUS_MOBO, .name = "asus-mobo" },
 	{}
 };
 
@@ -1979,6 +1992,8 @@ static const struct snd_pci_quirk stac92hd73xx_fixup_tbl[] = {
 				"HP Z1 G2", STAC_92HD89XX_HP_Z1_G2_RIGHT_MIC_JACK),
 	SND_PCI_QUIRK(PCI_VENDOR_ID_HP, 0x2b17,
 				"unknown HP", STAC_92HD89XX_HP_FRONT_JACK),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_ASUSTEK, 0x83f8, "ASUS AT4NM10",
+		      STAC_92HD73XX_ASUS_MOBO),
 	{} /* terminator */
 };
 
diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 63c1c80..fa66ba3 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -2032,32 +2032,43 @@ snd_riptide_joystick_probe(struct pci_dev *pci, const struct pci_device_id *id)
 {
 	static int dev;
 	struct gameport *gameport;
+	int ret;
 
 	if (dev >= SNDRV_CARDS)
 		return -ENODEV;
+
 	if (!enable[dev]) {
-		dev++;
-		return -ENOENT;
+		ret = -ENOENT;
+		goto inc_dev;
 	}
 
-	if (!joystick_port[dev++])
-		return 0;
+	if (!joystick_port[dev]) {
+		ret = 0;
+		goto inc_dev;
+	}
 
 	gameport = gameport_allocate_port();
-	if (!gameport)
-		return -ENOMEM;
+	if (!gameport) {
+		ret = -ENOMEM;
+		goto inc_dev;
+	}
 	if (!request_region(joystick_port[dev], 8, "Riptide gameport")) {
 		snd_printk(KERN_WARNING
 			   "Riptide: cannot grab gameport 0x%x\n",
 			   joystick_port[dev]);
 		gameport_free_port(gameport);
-		return -EBUSY;
+		ret = -EBUSY;
+		goto inc_dev;
 	}
 
 	gameport->io = joystick_port[dev];
 	gameport_register_port(gameport);
 	pci_set_drvdata(pci, gameport);
-	return 0;
+
+	ret = 0;
+inc_dev:
+	dev++;
+	return ret;
 }
 
 static void snd_riptide_joystick_remove(struct pci_dev *pci)
diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 9ea05e9..dd910d2 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -5789,6 +5789,9 @@ static int snd_hdspm_playback_open(struct snd_pcm_substream *substream)
 		snd_pcm_hw_constraint_minmax(runtime,
 					     SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
 					     64, 8192);
+		snd_pcm_hw_constraint_minmax(runtime,
+					     SNDRV_PCM_HW_PARAM_PERIODS,
+					     2, 2);
 		break;
 	}
 
@@ -5863,6 +5866,9 @@ static int snd_hdspm_capture_open(struct snd_pcm_substream *substream)
 		snd_pcm_hw_constraint_minmax(runtime,
 					     SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
 					     64, 8192);
+		snd_pcm_hw_constraint_minmax(runtime,
+					     SNDRV_PCM_HW_PARAM_PERIODS,
+					     2, 2);
 		break;
 	}
 
diff --git a/sound/soc/atmel/atmel_ssc_dai.c b/sound/soc/atmel/atmel_ssc_dai.c
index f3fdfa0..c5f7959 100644
--- a/sound/soc/atmel/atmel_ssc_dai.c
+++ b/sound/soc/atmel/atmel_ssc_dai.c
@@ -331,7 +331,6 @@ static int atmel_ssc_hw_params(struct snd_pcm_substream *substream,
 	struct atmel_pcm_dma_params *dma_params;
 	int dir, channels, bits;
 	u32 tfmr, rfmr, tcmr, rcmr;
-	int start_event;
 	int ret;
 
 	/*
@@ -450,19 +449,10 @@ static int atmel_ssc_hw_params(struct snd_pcm_substream *substream,
 		 * The SSC transmit clock is obtained from the BCLK signal on
 		 * on the TK line, and the SSC receive clock is
 		 * generated from the transmit clock.
-		 *
-		 *  For single channel data, one sample is transferred
-		 * on the falling edge of the LRC clock.
-		 * For two channel data, one sample is
-		 * transferred on both edges of the LRC clock.
 		 */
-		start_event = ((channels == 1)
-				? SSC_START_FALLING_RF
-				: SSC_START_EDGE_RF);
-
 		rcmr =	  SSC_BF(RCMR_PERIOD, 0)
 			| SSC_BF(RCMR_STTDLY, START_DELAY)
-			| SSC_BF(RCMR_START, start_event)
+			| SSC_BF(RCMR_START, SSC_START_FALLING_RF)
 			| SSC_BF(RCMR_CKI, SSC_CKI_RISING)
 			| SSC_BF(RCMR_CKO, SSC_CKO_NONE)
 			| SSC_BF(RCMR_CKS, SSC_CKS_CLOCK);
@@ -470,14 +460,14 @@ static int atmel_ssc_hw_params(struct snd_pcm_substream *substream,
 		rfmr =	  SSC_BF(RFMR_FSEDGE, SSC_FSEDGE_POSITIVE)
 			| SSC_BF(RFMR_FSOS, SSC_FSOS_NONE)
 			| SSC_BF(RFMR_FSLEN, 0)
-			| SSC_BF(RFMR_DATNB, 0)
+			| SSC_BF(RFMR_DATNB, (channels - 1))
 			| SSC_BIT(RFMR_MSBF)
 			| SSC_BF(RFMR_LOOP, 0)
 			| SSC_BF(RFMR_DATLEN, (bits - 1));
 
 		tcmr =	  SSC_BF(TCMR_PERIOD, 0)
 			| SSC_BF(TCMR_STTDLY, START_DELAY)
-			| SSC_BF(TCMR_START, start_event)
+			| SSC_BF(TCMR_START, SSC_START_FALLING_RF)
 			| SSC_BF(TCMR_CKI, SSC_CKI_FALLING)
 			| SSC_BF(TCMR_CKO, SSC_CKO_NONE)
 			| SSC_BF(TCMR_CKS, SSC_CKS_PIN);
@@ -486,7 +476,7 @@ static int atmel_ssc_hw_params(struct snd_pcm_substream *substream,
 			| SSC_BF(TFMR_FSDEN, 0)
 			| SSC_BF(TFMR_FSOS, SSC_FSOS_NONE)
 			| SSC_BF(TFMR_FSLEN, 0)
-			| SSC_BF(TFMR_DATNB, 0)
+			| SSC_BF(TFMR_DATNB, (channels - 1))
 			| SSC_BIT(TFMR_MSBF)
 			| SSC_BF(TFMR_DATDEF, 0)
 			| SSC_BF(TFMR_DATLEN, (bits - 1));
diff --git a/sound/soc/codecs/sgtl5000.c b/sound/soc/codecs/sgtl5000.c
index 2367073..3b5f565 100644
--- a/sound/soc/codecs/sgtl5000.c
+++ b/sound/soc/codecs/sgtl5000.c
@@ -1242,6 +1242,9 @@ static int sgtl5000_enable_regulators(struct snd_soc_codec *codec)
 	/* wait for all power rails bring up */
 	udelay(10);
 
+	/* Need 8 clocks before I2C accesses */
+	udelay(1);
+
 	/* read chip information */
 	reg = snd_soc_read(codec, SGTL5000_CHIP_ID);
 	if (((reg & SGTL5000_PARTID_MASK) >> SGTL5000_PARTID_SHIFT) !=
diff --git a/sound/soc/codecs/wm8960.c b/sound/soc/codecs/wm8960.c
index 5e5af89..412d90f 100644
--- a/sound/soc/codecs/wm8960.c
+++ b/sound/soc/codecs/wm8960.c
@@ -555,7 +555,7 @@ static struct {
 	{ 22050, 2 },
 	{ 24000, 2 },
 	{ 16000, 3 },
-	{ 11250, 4 },
+	{ 11025, 4 },
 	{ 12000, 4 },
 	{  8000, 5 },
 };
diff --git a/sound/soc/mediatek/common/auddrv_underflow_mach.c b/sound/soc/mediatek/common/auddrv_underflow_mach.c
index 7b0ab96..3937c02 100644
--- a/sound/soc/mediatek/common/auddrv_underflow_mach.c
+++ b/sound/soc/mediatek/common/auddrv_underflow_mach.c
@@ -83,7 +83,7 @@ void Auddrv_Aee_Dump(void)
     printk("+%s\n", __func__);
     if(bEnableDump == true)
     {
-        aee_kernel_exception_api(__FILE__, __LINE__, DB_OPT_FTRACE, "Audio is blocked", "audio blocked dump ftrace");
+        //aee_kernel_exception_api(__FILE__, __LINE__, DB_OPT_FTRACE, "Audio is blocked", "audio blocked dump ftrace");
     }
     Auddrv_Reset_Dump_State();
     printk("-%s\n", __func__);
diff --git a/sound/soc/mediatek/mt_soc_audio_8163/AudDrv_Afe.h b/sound/soc/mediatek/mt_soc_audio_8163/AudDrv_Afe.h
index da4689d..b5d60b4 100644
--- a/sound/soc/mediatek/mt_soc_audio_8163/AudDrv_Afe.h
+++ b/sound/soc/mediatek/mt_soc_audio_8163/AudDrv_Afe.h
@@ -451,7 +451,7 @@ typedef struct
 #define AUDIO_CG_CLR (0x8c)
 #define AUDIO_CG_STATUS (0x94)
 
-//  add
+// 6752 add
 //#define AUDIO_CLK_AUDDIV_0 (0x00120)
 //#define AUDIO_CLK_AUDDIV_1 (0x00124)
 
@@ -791,7 +791,7 @@ typedef struct
 #define AFE_ASRC3_CON13         (AFE_BASE+0x0774)
 #define AFE_ASRC3_CON14         (AFE_BASE+0x0778)
 
-//  add
+// 6752 add
 #define AFE_ADDA4_TOP_CON0          (AFE_BASE+0x0780)
 #define AFE_ADDA4_UL_SRC_CON0       (AFE_BASE+0x0784)
 #define AFE_ADDA4_UL_SRC_CON1       (AFE_BASE+0x0788)
diff --git a/sound/soc/mediatek/mt_soc_audio_8163/AudDrv_Clk.c b/sound/soc/mediatek/mt_soc_audio_8163/AudDrv_Clk.c
index a45a607..2d6867a 100644
--- a/sound/soc/mediatek/mt_soc_audio_8163/AudDrv_Clk.c
+++ b/sound/soc/mediatek/mt_soc_audio_8163/AudDrv_Clk.c
@@ -356,7 +356,7 @@ void AudDrv_ADC2_Clk_On(void)
     if (Aud_ADC2_Clk_cntr == 0)
     {
         PRINTK_AUDDRV("+%s  enable_clock ADC clk(%x)\n", __func__, Aud_ADC2_Clk_cntr);
-#if 0 // removed
+#if 0 //6752 removed
 #ifdef PM_MANAGER_API
         if (enable_clock(MT_CG_AUDIO_ADDA2, "AUDIO"))
         {
@@ -379,7 +379,7 @@ void AudDrv_ADC2_Clk_Off(void)
     if (Aud_ADC2_Clk_cntr == 0)
     {
         PRINTK_AUDDRV("+%s disable_clock ADC clk(%x)\n", __func__, Aud_ADC2_Clk_cntr);
-#if 0 // removed
+#if 0 //6752 removed
 #ifdef PM_MANAGER_API
         if (disable_clock(MT_CG_AUDIO_ADDA2, "AUDIO"))
         {
@@ -417,7 +417,7 @@ void AudDrv_ADC3_Clk_On(void)
     if (Aud_ADC3_Clk_cntr == 0)
     {
         PRINTK_AUDDRV("+%s  enable_clock ADC clk(%x)\n", __func__, Aud_ADC3_Clk_cntr);
-#if 0 // removed
+#if 0 //6752 removed
 #ifdef PM_MANAGER_API
         if (enable_clock(MT_CG_AUDIO_ADDA3, "AUDIO"))
         {
@@ -438,7 +438,7 @@ void AudDrv_ADC3_Clk_Off(void)
     if (Aud_ADC3_Clk_cntr == 0)
     {
         PRINTK_AUDDRV("+%s disable_clock ADC clk(%x)\n", __func__, Aud_ADC3_Clk_cntr);
-#if 0 // removed
+#if 0 //6752 removed
 #ifdef PM_MANAGER_API
         if (disable_clock(MT_CG_AUDIO_ADDA3, "AUDIO"))
         {
@@ -871,7 +871,7 @@ void AudDrv_Suspend_Clk_Off(void)
         }
         if (Aud_ADC2_Clk_cntr > 0)
         {
-        	#if 0 // removed
+        	#if 0 //6752 removed
             if (disable_clock(MT_CG_AUDIO_ADDA2, "AUDIO"))
             {
                 PRINTK_AUD_CLK("%s fail", __func__);
@@ -880,7 +880,7 @@ void AudDrv_Suspend_Clk_Off(void)
         }
         if (Aud_ADC3_Clk_cntr > 0)
         {
-            #if 0 // removed
+            #if 0 //6752 removed
             if (disable_clock(MT_CG_AUDIO_ADDA3, "AUDIO"))
             {
                 PRINTK_AUD_CLK("%s fail", __func__);
@@ -953,7 +953,7 @@ void AudDrv_Suspend_Clk_On(void)
         }
         if (Aud_ADC2_Clk_cntr > 0)
         {
-        	#if 0 // removed
+        	#if 0 //6752 removed
             if (enable_clock(MT_CG_AUDIO_ADDA2, "AUDIO"))
             {
                 PRINTK_AUD_CLK("%s fail", __func__);
@@ -962,7 +962,7 @@ void AudDrv_Suspend_Clk_On(void)
         }
         if (Aud_ADC3_Clk_cntr > 0)
         {
-        	#if 0 // removed
+        	#if 0 //6752 removed
             if (enable_clock(MT_CG_AUDIO_ADDA3, "AUDIO"))
             {
                 PRINTK_AUD_CLK("%s fail", __func__);
diff --git a/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_afe_control.c b/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_afe_control.c
index 4a90a43..48d727a 100644
--- a/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_afe_control.c
+++ b/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_afe_control.c
@@ -1463,7 +1463,7 @@ bool SetMrgI2SEnable(bool bEnable, unsigned int sampleRate)
 }
 bool Set2ndI2SAdcIn(AudioDigtalI2S *DigtalI2S)
 {
-    // todo
+    // todo?
     return true;
 }
 
@@ -2000,10 +2000,7 @@ bool SetModemPcmEnable(int modem_index, bool modem_pcm_on)
             mPcm1AsyncFifo  = (Afe_Get_Reg(PCM_INTF_CON) & 0x0040) >> 6;
             if (mPcm1AsyncFifo == 0)
             {
-                //Afe_Set_Reg(AFE_ASRC_CON6, 0x005f188f, MASK_ALL); 
                 Afe_Set_Reg(AFE_ASRC_CON0,  0x86083031, MASK_ALL);
-
-                //Afe_Set_Reg(AFE_ASRC4_CON6, 0x005f188f, MASK_ALL); 
                 Afe_Set_Reg(AFE_ASRC4_CON0, 0x06003031, MASK_ALL);
             }
             Afe_Set_Reg(PCM_INTF_CON, 0x1, 0x1);
@@ -2255,7 +2252,6 @@ void SetHdmiPcmInterConnection(unsigned int connection_state, unsigned int chann
 
 bool SetHDMIConnection(uint32 ConnectionState, uint32 Input , uint32 Output)
 {
-    //  removed
     return true;
 }
 
@@ -3101,7 +3097,7 @@ void Auddrv_UL1_Spinlock_unlock(void)
 
 void Auddrv_HDMI_Interrupt_Handler(void)  // irq5 ISR handler
 {
-    //  removed
+    // removed
 }
 
 
@@ -3798,7 +3794,7 @@ bool BackUp_Audio_Register(void)
     mAudioRegCache.REG_AFE_IRQ_MCU_EN = Afe_Get_Reg(AFE_IRQ_MCU_EN);
     mAudioRegCache.REG_AFE_MEMIF_MAXLEN = Afe_Get_Reg(AFE_MEMIF_MAXLEN);
     mAudioRegCache.REG_AFE_MEMIF_PBUF_SIZE = Afe_Get_Reg(AFE_MEMIF_PBUF_SIZE);
-    mAudioRegCache.REG_AFE_IRQ_MCU_CNT7 = Afe_Get_Reg(AFE_IRQ_MCU_CNT7); //  add
+    mAudioRegCache.REG_AFE_IRQ_MCU_CNT7 = Afe_Get_Reg(AFE_IRQ_MCU_CNT7); 
 
     mAudioRegCache.REG_AFE_APLL1_TUNER_CFG = Afe_Get_Reg(AFE_APLL1_TUNER_CFG);
     mAudioRegCache.REG_AFE_APLL2_TUNER_CFG = Afe_Get_Reg(AFE_APLL2_TUNER_CFG);
@@ -3821,7 +3817,7 @@ bool BackUp_Audio_Register(void)
     mAudioRegCache.REG_AFE_CONN7 = Afe_Get_Reg(AFE_CONN7);
     mAudioRegCache.REG_AFE_CONN8 = Afe_Get_Reg(AFE_CONN8);
     mAudioRegCache.REG_AFE_CONN9 = Afe_Get_Reg(AFE_CONN9);
-    mAudioRegCache.REG_AFE_CONN10 = Afe_Get_Reg(AFE_CONN10); //  add
+    mAudioRegCache.REG_AFE_CONN10 = Afe_Get_Reg(AFE_CONN10);
 
     mAudioRegCache.REG_FPGA_CFG2 = Afe_Get_Reg(FPGA_CFG2);
     mAudioRegCache.REG_FPGA_CFG3 = Afe_Get_Reg(FPGA_CFG3);
@@ -3843,7 +3839,7 @@ bool BackUp_Audio_Register(void)
     mAudioRegCache.REG_PCM_INTF_CON = Afe_Get_Reg(PCM_INTF_CON);
     mAudioRegCache.REG_PCM_INTF_CON2 = Afe_Get_Reg(PCM_INTF_CON2);
     mAudioRegCache.REG_PCM2_INTF_CON = Afe_Get_Reg(PCM2_INTF_CON);
-    //6752 add
+   
     mAudioRegCache.REG_AUDIO_CLK_AUDDIV_0 = Afe_Get_Reg(AUDIO_CLK_AUDDIV_0);
     mAudioRegCache.REG_AUDIO_CLK_AUDDIV_1 = Afe_Get_Reg(AUDIO_CLK_AUDDIV_1);
     mAudioRegCache.REG_AFE_ASRC4_CON0 = Afe_Get_Reg(AFE_ASRC4_CON0);
@@ -3901,7 +3897,7 @@ bool BackUp_Audio_Register(void)
     mAudioRegCache.REG_AFE_ASRC3_CON12 = Afe_Get_Reg(AFE_ASRC3_CON12);
     mAudioRegCache.REG_AFE_ASRC3_CON13 = Afe_Get_Reg(AFE_ASRC3_CON13);
     mAudioRegCache.REG_AFE_ASRC3_CON14 = Afe_Get_Reg(AFE_ASRC3_CON14);
-    //6752 add
+    
     mAudioRegCache.REG_AFE_ADDA4_TOP_CON0 = Afe_Get_Reg(AFE_ADDA4_TOP_CON0);
     mAudioRegCache.REG_AFE_ADDA4_UL_SRC_CON0 = Afe_Get_Reg(AFE_ADDA4_UL_SRC_CON0);
     mAudioRegCache.REG_AFE_ADDA4_UL_SRC_CON1 = Afe_Get_Reg(AFE_ADDA4_UL_SRC_CON1);
@@ -3929,7 +3925,7 @@ bool BackUp_Audio_Register(void)
 
 bool Restore_Audio_Register(void)
 {
-    // 6752 TODO?
+    // TODO?
     return true;
 }
 
diff --git a/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_codec_63xx.c b/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_codec_63xx.c
index f2747bd..17ab4d3 100644
--- a/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_codec_63xx.c
+++ b/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_codec_63xx.c
@@ -3030,26 +3030,22 @@ static int Audio_ADC2_Set(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_val
 static int Audio_ADC3_Get(struct snd_kcontrol *kcontrol,
                           struct snd_ctl_elem_value *ucontrol)
 {
-    // removed
     return 0;
 }
 
 static int Audio_ADC3_Set(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-    // removed
     return 0;
 }
 
 static int Audio_ADC4_Get(struct snd_kcontrol *kcontrol,
                           struct snd_ctl_elem_value *ucontrol)
 {
-    // removed
     return 0;
 }
 
 static int Audio_ADC4_Set(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-    // removed
     return 0;
 }
 
@@ -3136,26 +3132,22 @@ static int Audio_ADC2_Sel_Set(struct snd_kcontrol *kcontrol, struct snd_ctl_elem
 static int Audio_ADC3_Sel_Get(struct snd_kcontrol *kcontrol,
                               struct snd_ctl_elem_value *ucontrol)
 {
-    // removed
     return 0;
 }
 
 static int Audio_ADC3_Sel_Set(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-    // removed
     return 0;
 }
 
 static int Audio_ADC4_Sel_Get(struct snd_kcontrol *kcontrol,
                               struct snd_ctl_elem_value *ucontrol)
 {
-    // removed
     return 0;
 }
 
 static int Audio_ADC4_Sel_Set(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-    // removed
     return 0;
 }
 
@@ -3339,26 +3331,22 @@ static int Audio_PGA2_Set(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_val
 static int Audio_PGA3_Get(struct snd_kcontrol *kcontrol,
                           struct snd_ctl_elem_value *ucontrol)
 {
-    // removed
     return 0;
 }
 
 static int Audio_PGA3_Set(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-    // removed
     return 0;
 }
 
 static int Audio_PGA4_Get(struct snd_kcontrol *kcontrol,
                           struct snd_ctl_elem_value *ucontrol)
 {
-    // removed
     return 0;
 }
 
 static int Audio_PGA4_Set(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-    // removed
     return 0;
 }
 
@@ -3414,13 +3402,11 @@ static int Audio_MicSource2_Set(struct snd_kcontrol *kcontrol, struct snd_ctl_el
 static int Audio_MicSource3_Get(struct snd_kcontrol *kcontrol,
                                 struct snd_ctl_elem_value *ucontrol)
 {
-    // removed
     return 0;
 }
 
 static int Audio_MicSource3_Set(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-    // removed
     return 0;
 }
 
@@ -3428,13 +3414,11 @@ static int Audio_MicSource3_Set(struct snd_kcontrol *kcontrol, struct snd_ctl_el
 static int Audio_MicSource4_Get(struct snd_kcontrol *kcontrol,
                                 struct snd_ctl_elem_value *ucontrol)
 {
-    // removed
     return 0;
 }
 
 static int Audio_MicSource4_Set(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-    // removed
     return 0;
 }
 
@@ -3797,7 +3781,6 @@ static int SineTable_DAC_HP_Get(struct snd_kcontrol *kcontrol,
 
 static int SineTable_DAC_HP_Set(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-    // TODO?
     printk("%s()\n", __func__);
     return 0;
 }
diff --git a/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_digital_type.h b/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_digital_type.h
index 1cd0d00..ec9e385 100644
--- a/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_digital_type.h
+++ b/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_digital_type.h
@@ -981,7 +981,7 @@ typedef struct
     uint32 REG_AFE_ASRC3_CON12;
     uint32 REG_AFE_ASRC3_CON13;
     uint32 REG_AFE_ASRC3_CON14;
-#if 1 
+#if 1
     uint32 REG_AFE_ADDA4_TOP_CON0;
     uint32 REG_AFE_ADDA4_UL_SRC_CON0;
     uint32 REG_AFE_ADDA4_UL_SRC_CON1;
diff --git a/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_machine.c b/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_machine.c
index 76076e5..d16d785 100644
--- a/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_machine.c
+++ b/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_machine.c
@@ -372,7 +372,7 @@ static ssize_t mt_soc_debug_read(struct file *file, char __user *buf,
     n += scnprintf(buffer + n, size - n, "AFE_IRQ1_EN_CNT_MON  = 0x%x\n", Afe_Get_Reg(AFE_IRQ1_MCU_EN_CNT_MON));
     n += scnprintf(buffer + n, size - n, "AFE_MEMIF_MAXLEN  = 0x%x\n", Afe_Get_Reg(AFE_MEMIF_MAXLEN));
     n += scnprintf(buffer + n, size - n, "AFE_MEMIF_PBUF_SIZE  = 0x%x\n", Afe_Get_Reg(AFE_MEMIF_PBUF_SIZE));
-    n += scnprintf(buffer + n, size - n, "AFE_IRQ_MCU_CNT7  = 0x%x\n", Afe_Get_Reg(AFE_IRQ_MCU_CNT7)); //  add
+    n += scnprintf(buffer + n, size - n, "AFE_IRQ_MCU_CNT7  = 0x%x\n", Afe_Get_Reg(AFE_IRQ_MCU_CNT7)); // 6752 add
 
     n += scnprintf(buffer + n, size - n, "AFE_APLL1_TUNER_CFG  = 0x%x\n", Afe_Get_Reg(AFE_APLL1_TUNER_CFG));
     n += scnprintf(buffer + n, size - n, "AFE_APLL2_TUNER_CFG  = 0x%x\n", Afe_Get_Reg(AFE_APLL2_TUNER_CFG));
@@ -440,7 +440,7 @@ static ssize_t mt_soc_debug_read(struct file *file, char __user *buf,
     n += scnprintf(buffer + n, size - n, "AFE_ASRC3_CON5  = 0x%x\n", Afe_Get_Reg(AFE_ASRC3_CON5));
     n += scnprintf(buffer + n, size - n, "AFE_ASRC3_CON6  = 0x%x\n", Afe_Get_Reg(AFE_ASRC3_CON6));
 
-    //  add
+    // 6752 add
     n += scnprintf(buffer + n, size - n, "AFE_ADDA4_TOP_CON0  = 0x%x\n", Afe_Get_Reg(AFE_ADDA4_TOP_CON0));
     n += scnprintf(buffer + n, size - n, "AFE_ADDA4_UL_SRC_CON0  = 0x%x\n", Afe_Get_Reg(AFE_ADDA4_UL_SRC_CON0));
     n += scnprintf(buffer + n, size - n, "AFE_ADDA4_UL_SRC_CON1  = 0x%x\n", Afe_Get_Reg(AFE_ADDA4_UL_SRC_CON1));
@@ -515,7 +515,7 @@ static ssize_t mt_soc_debug_write(struct file *f, const char __user *buf,
         ret = strict_strtoul(token3, 16, &regaddr);
         ret =  strict_strtoul(token5, 16, &regvalue);
         printk("%s regaddr = 0x%lu regvalue = 0x%lu\n", ParSetkeyAna, regaddr, regvalue);
-        //clk_buf_ctrl(CLK_BUF_AUDIO, true); // need?
+        //clk_buf_ctrl(CLK_BUF_AUDIO, true); //6752 need?
         AudDrv_Clk_On();
         audckbufEnable(true);
         Ana_Set_Reg(regaddr,  regvalue, 0xffffffff);
diff --git a/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_pcm_dl1_i2s0Dl1.c b/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_pcm_dl1_i2s0Dl1.c
index de1b6be..ef74f3b 100644
--- a/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_pcm_dl1_i2s0Dl1.c
+++ b/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_pcm_dl1_i2s0Dl1.c
@@ -372,7 +372,7 @@ static int mtk_pcm_I2S0dl1_close(struct snd_pcm_substream *substream)
         if (GetMemoryPathEnable(Soc_Aud_Digital_Block_I2S_OUT_2) == false)
         {
             Afe_Set_Reg(AFE_I2S_CON3, 0x0, 0x1);
-            //Afe_Set_Reg(AFE_I2S_CON, 0x0, 0x1);// TODO: fix fm playback then mp3, i2s_con is misconfigured...
+            //Afe_Set_Reg(AFE_I2S_CON, 0x0, 0x1);//6752 TODO: fix fm playback then mp3, i2s_con is misconfigured...
         }
 
         RemoveMemifSubStream(Soc_Aud_Digital_Block_MEM_DL1, substream);
@@ -471,7 +471,7 @@ static int mtk_pcm_I2S0dl1_prepare(struct snd_pcm_substream *substream)
         if (GetMemoryPathEnable(Soc_Aud_Digital_Block_I2S_OUT_2) == false)
         {
             SetMemoryPathEnable(Soc_Aud_Digital_Block_I2S_OUT_2, true);
-            //Afe_Set_Reg(AFE_I2S_CON, Audio_I2S_Dac | 0x1, MASK_ALL); // TODO: fix fm playback then mp3, i2s_con is misconfigured...
+            //Afe_Set_Reg(AFE_I2S_CON, Audio_I2S_Dac | 0x1, MASK_ALL); //6752 TODO: fix fm playback then mp3, i2s_con is misconfigured...
             Afe_Set_Reg(AFE_I2S_CON3, u32AudioI2S | 1, AFE_MASK_ALL);
         }
         else
diff --git a/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_pcm_hdmi.c b/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_pcm_hdmi.c
index e6035e2..833d495 100644
--- a/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_pcm_hdmi.c
+++ b/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_pcm_hdmi.c
@@ -570,7 +570,7 @@ static snd_pcm_uframes_t mtk_pcm_hdmi_pointer(struct snd_pcm_substream *substrea
 
     if (pMemControl->interruptTrigger == 1)
     {
-    	#if 0 //  removed
+    	#if 0 // 6752 removed
         HW_Cur_ReadIdx = Afe_Get_Reg(AFE_HDMI_CUR);
 		#endif
         if (HW_Cur_ReadIdx == 0)
diff --git a/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_pcm_hp_impedance.c b/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_pcm_hp_impedance.c
index b805b97..1013d73 100644
--- a/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_pcm_hp_impedance.c
+++ b/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_pcm_hp_impedance.c
@@ -336,6 +336,7 @@ static unsigned short mAuxAdc_Offset = 0;
 static int Audio_HP_ImpeDance_Set(struct snd_kcontrol *kcontrol,
                                   struct snd_ctl_elem_value *ucontrol)
 {
+#ifndef DENALI_FPGA_EARLYPORTING
 
     const int off_counter = 20;
     printk("%s \n", __func__);
@@ -423,7 +424,7 @@ static int Audio_HP_ImpeDance_Set(struct snd_kcontrol *kcontrol,
     }
 
     AudDrv_Clk_Off();
-
+#endif
     return 0;
 }
 
@@ -506,6 +507,8 @@ static void CheckDcinitValue(void)
 
 static void ApplyDctoDl(void)
 {
+#ifndef DENALI_FPGA_EARLYPORTING
+
     unsigned short  value = 0 , average = 0;
     unsigned short dcoffset , dcoffset2, dcoffset3;
     printk("%s\n", __func__);
@@ -584,6 +587,7 @@ static void ApplyDctoDl(void)
             break;
         }
     }
+#endif
 }
 
 static int Audio_HP_ImpeDance_Get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
diff --git a/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_pcm_mrgrx.c b/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_pcm_mrgrx.c
index 6898ac6..1770e25 100644
--- a/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_pcm_mrgrx.c
+++ b/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_pcm_mrgrx.c
@@ -61,9 +61,9 @@
 #include "mt_soc_pcm_common.h"
 
 #include <mach/mtk_wcn_cmb_stub.h>
-          
+#ifndef DENALI_FPGA_EARLYPORTING            
 extern  int mtk_wcn_cmb_stub_audio_ctrl(CMB_STUB_AIF_X state);
-
+#endif
 
 //static DEFINE_SPINLOCK(auddrv_mrgrx_lock);
 
@@ -120,9 +120,9 @@ static int Audio_Wcn_Cmb_Set(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_
 {
     mAudio_Wcn_Cmb = ucontrol->value.integer.value[0];
     printk("%s mAudio_Wcn_Cmb = 0x%x \n", __func__, mAudio_Wcn_Cmb);
-              
+#ifndef DENALI_FPGA_EARLYPORTING                   
     mtk_wcn_cmb_stub_audio_ctrl((CMB_STUB_AIF_X)mAudio_Wcn_Cmb);
-
+#endif
     return 0;
 }
 
@@ -231,9 +231,9 @@ static int mtk_pcm_mrgrx_close(struct snd_pcm_substream *substream)
     struct snd_pcm_runtime *runtime = substream->runtime;
     printk("%s \n", __func__);
 
-        
+#ifndef DENALI_FPGA_EARLYPORTING            
     mtk_wcn_cmb_stub_audio_ctrl((CMB_STUB_AIF_X)CMB_STUB_AIF_0);
-
+#endif
     SetMemoryPathEnable(Soc_Aud_Digital_Block_MRG_I2S_OUT, false);
     if (GetMemoryPathEnable(Soc_Aud_Digital_Block_MRG_I2S_OUT) == false)
     {
@@ -270,9 +270,9 @@ static int mtk_pcm_mrgrx_prepare(struct snd_pcm_substream *substream)
 
     if (mPrepareDone == false)
     {
-             
+#ifndef DENALI_FPGA_EARLYPORTING               
         mtk_wcn_cmb_stub_audio_ctrl((CMB_STUB_AIF_X)CMB_STUB_AIF_3);
-
+#endif
         // interconnection setting
         SetConnection(Soc_Aud_InterCon_Connection, Soc_Aud_InterConnectionInput_I15, Soc_Aud_InterConnectionOutput_O13);
         SetConnection(Soc_Aud_InterCon_Connection, Soc_Aud_InterConnectionInput_I16, Soc_Aud_InterConnectionOutput_O14);
diff --git a/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_pcm_routing.c b/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_pcm_routing.c
index 1a1c37a..ffe32e1 100644
--- a/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_pcm_routing.c
+++ b/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_pcm_routing.c
@@ -790,7 +790,7 @@ static const struct snd_kcontrol_new Audio_snd_routing_controls[] =
 void EnAble_Anc_Path(int state)
 {
     // todo?
-    printk("%s not supported!!!\n ", __func__);
+    printk("%s not supported now!!!\n ", __func__);
 
 }
 
diff --git a/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_pcm_voice_md2.c b/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_pcm_voice_md2.c
index d3afe2f..d9a3ecd 100644
--- a/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_pcm_voice_md2.c
+++ b/sound/soc/mediatek/mt_soc_audio_8163/mt_soc_pcm_voice_md2.c
@@ -93,7 +93,7 @@ bool get_voice_md2_status(void)
     return voice_md2_Status;
 }
 EXPORT_SYMBOL(get_voice_md2_status);
-
+//for 6752 internal md 2 bring up
 static AudioDigitalPCM  Voice2IntPcm =
 {
     .mBclkOutInv = false,
diff --git a/sound/soc/mediatek/mt_soc_audio_v1/mt_soc_codec_63xx.c b/sound/soc/mediatek/mt_soc_audio_v1/mt_soc_codec_63xx.c
index 995f91b..ce21c85 100644
--- a/sound/soc/mediatek/mt_soc_audio_v1/mt_soc_codec_63xx.c
+++ b/sound/soc/mediatek/mt_soc_audio_v1/mt_soc_codec_63xx.c
@@ -1446,6 +1446,16 @@ static void TurnOnDacPower(void)
 static void TurnOffDacPower(void)
 {
     printk("TurnOffDacPower\n");
+
+    Ana_Set_Reg(AFE_DL_SRC2_CON0_L , 0x0000 , 0xffff); //bit0, Turn off down-link
+    if (GetAdcStatus() == false)
+    {
+        Ana_Set_Reg(AFE_UL_DL_CON0, 0x0000, 0xffff);   //turn off afe
+    }
+    udelay(250);
+
+    Ana_Set_Reg(AFE_AUDIO_TOP_CON0, 0x0040, 0x0040); //down-link power down
+
     Ana_Set_Reg(AFE_CLASSH_CFG1, 0x24, 0xffff);
     Ana_Set_Reg(AFE_CLASSH_CFG0, 0xd518, 0xffff); // ClassH off
     Ana_Set_Reg(AUDLDO_NVREG_CFG0, 0x0, 0xffff); // NCP off
diff --git a/sound/soc/mediatek/mt_soc_audio_v1/mt_soc_pcm_capture.c b/sound/soc/mediatek/mt_soc_audio_v1/mt_soc_pcm_capture.c
index 97e11ff..3caa981 100644
--- a/sound/soc/mediatek/mt_soc_audio_v1/mt_soc_pcm_capture.c
+++ b/sound/soc/mediatek/mt_soc_audio_v1/mt_soc_pcm_capture.c
@@ -101,9 +101,6 @@ static void StopAudioCaptureHardware(struct snd_pcm_substream *substream)
 {
     printk("StopAudioCaptureHardware \n");
 
-    // here to set interrupt
-    SetIrqEnable(Soc_Aud_IRQ_MCU_MODE_IRQ2_MCU_MODE, false);
-
     SetMemoryPathEnable(Soc_Aud_Digital_Block_I2S_IN_ADC, false);
     if (GetMemoryPathEnable(Soc_Aud_Digital_Block_I2S_IN_ADC) == false)
     {
@@ -112,6 +109,9 @@ static void StopAudioCaptureHardware(struct snd_pcm_substream *substream)
 
     SetMemoryPathEnable(Soc_Aud_Digital_Block_MEM_VUL, false);
 
+    // here to set interrupt
+    SetIrqEnable(Soc_Aud_IRQ_MCU_MODE_IRQ2_MCU_MODE, false);
+
     // here to turn off digital part
     SetConnection(Soc_Aud_InterCon_DisConnect, Soc_Aud_InterConnectionInput_I03, Soc_Aud_InterConnectionOutput_O09);
     SetConnection(Soc_Aud_InterCon_DisConnect, Soc_Aud_InterConnectionInput_I04, Soc_Aud_InterConnectionOutput_O10);
@@ -190,16 +190,20 @@ static snd_pcm_uframes_t mtk_capture_pcm_pointer(struct snd_pcm_substream *subst
     kal_int32 HW_Cur_ReadIdx = 0;
     //kal_uint32 Frameidx = 0;
     kal_int32 Hw_Get_bytes = 0;
+    bool bIsOverflow = false;
+    unsigned long flags;
     AFE_BLOCK_T *UL1_Block = &(VUL_Control_context->rBlock);
-    PRINTK_AUD_UL1("mtk_capture_pcm_pointer Awb_Block->u4WriteIdx;= 0x%x \n", UL1_Block->u4WriteIdx);
     Auddrv_UL1_Spinlock_lock();
+	spin_lock_irqsave(&VUL_Control_context->substream_lock, flags);
+    PRINTK_AUD_UL1("mtk_capture_pcm_pointer UL1_Block->u4WriteIdx= 0x%x, u4DataRemained=0x%x \n", UL1_Block->u4WriteIdx,UL1_Block->u4DataRemained);
+    
     if (GetMemoryPathEnable(Soc_Aud_Digital_Block_MEM_VUL) == true)
     {
 
         HW_Cur_ReadIdx = Align64ByteSize(Afe_Get_Reg(AFE_VUL_CUR));
         if (HW_Cur_ReadIdx == 0)
         {
-            PRINTK_AUD_UL1("[Auddrv] mtk_awb_pcm_pointer  HW_Cur_ReadIdx ==0 \n");
+            PRINTK_AUD_UL1("[Auddrv] mtk_capture_pcm_pointer  HW_Cur_ReadIdx ==0 \n");
             HW_Cur_ReadIdx = UL1_Block->pucPhysBufAddr;
         }
         HW_memory_index = (HW_Cur_ReadIdx - UL1_Block->pucPhysBufAddr);
@@ -213,11 +217,30 @@ static snd_pcm_uframes_t mtk_capture_pcm_pointer(struct snd_pcm_substream *subst
         UL1_Block->u4WriteIdx	+= Hw_Get_bytes;
         UL1_Block->u4WriteIdx	%= UL1_Block->u4BufferSize;
         UL1_Block->u4DataRemained += Hw_Get_bytes;
+
+        printk("mtk_capture_pcm_pointer u4DMAReadIdx=0x%x u4WriteIdx = 0x%x u4DataRemained = 0x%x u4BufferSize= 0x%x,Hw_Get_bytes= 0x%x\n", UL1_Block->u4DMAReadIdx, UL1_Block->u4WriteIdx,UL1_Block->u4DataRemained,UL1_Block->u4BufferSize,Hw_Get_bytes);
+        if (UL1_Block->u4DataRemained > UL1_Block->u4BufferSize)
+        {
+            bIsOverflow = true;
+            printk("[Auddrv] overflow!? mtk_capture_pcm_pointer u4DMAReadIdx=0x%x u4WriteIdx = 0x%x u4DataRemained = 0x%x u4BufferSize= 0x%x,Hw_Get_bytes= 0x%x\n", UL1_Block->u4DMAReadIdx, UL1_Block->u4WriteIdx,UL1_Block->u4DataRemained,UL1_Block->u4BufferSize,Hw_Get_bytes);
+
+            // reset pointer info
+            UL1_Block->u4DataRemained = 0;
+            UL1_Block->u4DMAReadIdx   = UL1_Block->u4WriteIdx;
+        }
+        
         PRINTK_AUD_UL1("[Auddrv] mtk_capture_pcm_pointer =0x%x HW_memory_index = 0x%x\n", HW_Cur_ReadIdx, HW_memory_index);
+        
+        spin_unlock_irqrestore(&VUL_Control_context->substream_lock, flags);
         Auddrv_UL1_Spinlock_unlock();
 
+        if (bIsOverflow == true)
+        {
+            return -1;
+        }
         return audio_bytes_to_frame(substream, HW_memory_index);
     }
+    spin_unlock_irqrestore(&VUL_Control_context->substream_lock, flags);
     Auddrv_UL1_Spinlock_unlock();
     return 0;
 
diff --git a/sound/soc/mediatek/mt_soc_audio_v1/mt_soc_pcm_common.h b/sound/soc/mediatek/mt_soc_audio_v1/mt_soc_pcm_common.h
index 4864e5c..d6fc3ea 100644
--- a/sound/soc/mediatek/mt_soc_audio_v1/mt_soc_pcm_common.h
+++ b/sound/soc/mediatek/mt_soc_audio_v1/mt_soc_pcm_common.h
@@ -130,9 +130,9 @@ define for PCM settings
 #define AWB_MAX_PERIOD_SIZE     AWB_MAX_BUFFER_SIZE
 
 
-#define HDMI_MAX_BUFFER_SIZE     (192*1024*2)
+#define HDMI_MAX_BUFFER_SIZE     (192*1024*4)
 
-#define HDMI_MULTI_MAX_BUFFER_SIZE     (192*1024*2)
+#define HDMI_MULTI_MAX_BUFFER_SIZE     (192*1024*4)
 #define HDMI_STEREO_MAX_BUFFER_SIZE     (24*1024)
 
 
diff --git a/sound/soc/mediatek/mt_soc_audio_v1/mt_soc_pcm_dl1_awb.c b/sound/soc/mediatek/mt_soc_audio_v1/mt_soc_pcm_dl1_awb.c
index a33007a..f0bae01 100644
--- a/sound/soc/mediatek/mt_soc_audio_v1/mt_soc_pcm_dl1_awb.c
+++ b/sound/soc/mediatek/mt_soc_audio_v1/mt_soc_pcm_dl1_awb.c
@@ -304,6 +304,7 @@ static int mtk_dl1_awb_pcm_open(struct snd_pcm_substream *substream)
 static int mtk_dl1_awb_pcm_close(struct snd_pcm_substream *substream)
 {
     AudDrv_Emi_Clk_Off();
+    AudDrv_Clk_Off();
     return 0;
 }
 
diff --git a/sound/soc/mediatek/mt_soc_audio_v1/mt_soc_pcm_dl1_i2s0.c b/sound/soc/mediatek/mt_soc_audio_v1/mt_soc_pcm_dl1_i2s0.c
index b62a103..4df9f66 100644
--- a/sound/soc/mediatek/mt_soc_audio_v1/mt_soc_pcm_dl1_i2s0.c
+++ b/sound/soc/mediatek/mt_soc_audio_v1/mt_soc_pcm_dl1_i2s0.c
@@ -149,9 +149,10 @@ static int Audio_i2s0_SideGen_Set(struct snd_kcontrol *kcontrol, struct snd_ctl_
         REG44C = Afe_Get_Reg(AFE_GAIN1_CONN3);
         printk("%s() AFE_GAIN1_CONN3 (0X44C) =0x%x\n",  __func__, REG44C);
         // Set HW_GAIN1
-        SetHwDigitalGainMode(Soc_Aud_Hw_Digital_Gain_HW_DIGITAL_GAIN1, samplerate, 0x80);
-        SetHwDigitalGainEnable(Soc_Aud_Hw_Digital_Gain_HW_DIGITAL_GAIN1, true);
+        SetHwDigitalGainMode(Soc_Aud_Hw_Digital_Gain_HW_DIGITAL_GAIN1, samplerate, 0x1F);
         SetHwDigitalGain(0x80000, Soc_Aud_Hw_Digital_Gain_HW_DIGITAL_GAIN1);
+        Afe_Set_Reg(AFE_GAIN1_CUR, 0x80000, 0xfffff);
+        SetHwDigitalGainEnable(Soc_Aud_Hw_Digital_Gain_HW_DIGITAL_GAIN1, true);
 
         Afe_Set_Reg(AFE_DAC_CON1, 0x400, 0xF00);
 
diff --git a/sound/soc/mediatek/mt_soc_audio_v1/mt_soc_pcm_i2s0_awb.c b/sound/soc/mediatek/mt_soc_audio_v1/mt_soc_pcm_i2s0_awb.c
index 7bfcc8f..d814751 100644
--- a/sound/soc/mediatek/mt_soc_audio_v1/mt_soc_pcm_i2s0_awb.c
+++ b/sound/soc/mediatek/mt_soc_audio_v1/mt_soc_pcm_i2s0_awb.c
@@ -143,7 +143,7 @@ static void StartAudioI2S0AWBHardware(struct snd_pcm_substream *substream)
     Afe_Set_Reg(AFE_I2S_CON, Audio_I2S_Dac | 0x1, MASK_ALL);
 
     // here to set interrupt
-    SetIrqMcuCounter(Soc_Aud_IRQ_MCU_MODE_IRQ2_MCU_MODE, substream->runtime->period_size);
+    SetIrqMcuCounter(Soc_Aud_IRQ_MCU_MODE_IRQ2_MCU_MODE, substream->runtime->period_size >> 1);
     SetIrqMcuSampleRate(Soc_Aud_IRQ_MCU_MODE_IRQ2_MCU_MODE, substream->runtime->rate);
     SetIrqEnable(Soc_Aud_IRQ_MCU_MODE_IRQ2_MCU_MODE, true);
 
@@ -200,7 +200,7 @@ static snd_pcm_uframes_t mtk_i2s0_awb_pcm_pointer(struct snd_pcm_substream *subs
         // get total bytes to copysinewavetohdmi
         Frameidx =audio_bytes_to_frame(substream , Awb_Block->u4WriteIdx);
         return Frameidx;
-
+#if 0
         HW_Cur_ReadIdx = Align64ByteSize(Afe_Get_Reg(AFE_AWB_CUR));
         if (HW_Cur_ReadIdx == 0)
         {
@@ -211,6 +211,7 @@ static snd_pcm_uframes_t mtk_i2s0_awb_pcm_pointer(struct snd_pcm_substream *subs
         Previous_Hw_cur = HW_memory_index;
         PRINTK_AUD_AWB("[Auddrv] mtk_i2s0_awb_pcm_pointer =0x%x HW_memory_index = 0x%x\n", HW_Cur_ReadIdx, HW_memory_index);
         return audio_bytes_to_frame(substream,Previous_Hw_cur);
+#endif
     }
     return 0;
 }
@@ -344,6 +345,7 @@ static int mtk_i2s0_awb_pcm_open(struct snd_pcm_substream *substream)
 static int mtk_i2s0_awb_pcm_close(struct snd_pcm_substream *substream)
 {
     AudDrv_Emi_Clk_Off();
+    AudDrv_Clk_Off();
     return 0;
 }
 
diff --git a/sound/soc/mediatek/mt_soc_audio_v2/AudDrv_Afe.h b/sound/soc/mediatek/mt_soc_audio_v2/AudDrv_Afe.h
index d8e62a7..9621838 100644
--- a/sound/soc/mediatek/mt_soc_audio_v2/AudDrv_Afe.h
+++ b/sound/soc/mediatek/mt_soc_audio_v2/AudDrv_Afe.h
@@ -21,7 +21,7 @@
  *
  * Project:
  * --------
- *   Audio Driver Afe Register setting
+ *   MT6583  Audio Driver Afe Register setting
  *
  * Description:
  * ------------
@@ -514,6 +514,7 @@ typedef struct
 #define AFE_MEMIF_MON4 (AFE_BASE + 0x00E0)
 
 
+//6582 Add
 #define AFE_ADDA_DL_SRC2_CON0   (AFE_BASE+0x00108)
 #define AFE_ADDA_DL_SRC2_CON1   (AFE_BASE+0x0010C)
 #define AFE_ADDA_UL_SRC_CON0    (AFE_BASE+0x00114)
@@ -707,6 +708,7 @@ typedef struct
 #define PCM_INTF_CON2   (AFE_BASE + 0x538)
 #define PCM2_INTF_CON   (AFE_BASE + 0x53C)
 
+//6582 Add
 #define AFE_ASRC_CON13  (AFE_BASE+0x00550)
 #define AFE_ASRC_CON14  (AFE_BASE+0x00554)
 #define AFE_ASRC_CON15  (AFE_BASE+0x00558)
diff --git a/sound/soc/mediatek/mt_soc_audio_v2/mt_soc_codec_63xx.c b/sound/soc/mediatek/mt_soc_audio_v2/mt_soc_codec_63xx.c
index 941e4a5..750d3f9 100644
--- a/sound/soc/mediatek/mt_soc_audio_v2/mt_soc_codec_63xx.c
+++ b/sound/soc/mediatek/mt_soc_audio_v2/mt_soc_codec_63xx.c
@@ -4189,7 +4189,7 @@ static int Audio_MicSource1_Get(struct snd_kcontrol *kcontrol,
 
 static int Audio_MicSource1_Set(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-    //used for ADC1 Mic source selection, "ADC1" is main_mic, "ADC2" is headset_mic
+    //ADC1 Mic source selection, "ADC1" is main_mic, "ADC2" is headset_mic
     int index = 0;
     printk("%s()\n", __func__);
     if (ucontrol->value.enumerated.item[0] > ARRAY_SIZE(Pmic_Digital_Mux))
diff --git a/sound/soc/mediatek/mt_soc_audio_v2/mt_soc_digital_type.h b/sound/soc/mediatek/mt_soc_audio_v2/mt_soc_digital_type.h
index bfd27fc..2c125ea 100644
--- a/sound/soc/mediatek/mt_soc_audio_v2/mt_soc_digital_type.h
+++ b/sound/soc/mediatek/mt_soc_audio_v2/mt_soc_digital_type.h
@@ -836,7 +836,6 @@ typedef struct
     uint32 REG_PCM_INTF_CON;
     uint32 REG_PCM_INTF_CON2;
     uint32 REG_PCM2_INTF_CON;
-
     uint32 REG_AUDIO_CLK_AUDDIV_0;
     uint32 REG_AUDIO_CLK_AUDDIV_1;
     uint32 REG_AUDIO_CLK_AUDDIV_2;
@@ -856,7 +855,6 @@ typedef struct
     uint32 REG_AFE_ASRC4_CON12;
     uint32 REG_AFE_ASRC4_CON13;
     uint32 REG_AFE_ASRC4_CON14;
-
     uint32 REG_AFE_TDM_CON1;
     uint32 REG_AFE_TDM_CON2;
     uint32 REG_AFE_ASRC_CON13;
@@ -940,7 +938,6 @@ typedef struct
     uint32 REG_AFE_ASRC3_CON12;
     uint32 REG_AFE_ASRC3_CON13;
     uint32 REG_AFE_ASRC3_CON14;
-
     uint32 REG_AFE_ADDA4_TOP_CON0;
     uint32 REG_AFE_ADDA4_UL_SRC_CON0;
     uint32 REG_AFE_ADDA4_UL_SRC_CON1;
@@ -961,7 +958,6 @@ typedef struct
     uint32 REG_AFE_ADDA4_ULCF_CFG_26_25;
     uint32 REG_AFE_ADDA4_ULCF_CFG_28_27;
     uint32 REG_AFE_ADDA4_ULCF_CFG_30_29;
-
 } AudioAfeRegCache;
 
 #endif
diff --git a/sound/soc/mediatek/mt_soc_audio_v2/mt_soc_pcm_dl1_awb.c b/sound/soc/mediatek/mt_soc_audio_v2/mt_soc_pcm_dl1_awb.c
index acc0301..349c9e2 100644
--- a/sound/soc/mediatek/mt_soc_audio_v2/mt_soc_pcm_dl1_awb.c
+++ b/sound/soc/mediatek/mt_soc_audio_v2/mt_soc_pcm_dl1_awb.c
@@ -302,6 +302,7 @@ static int mtk_dl1_awb_pcm_open(struct snd_pcm_substream *substream)
 static int mtk_dl1_awb_pcm_close(struct snd_pcm_substream *substream)
 {
     AudDrv_Emi_Clk_Off();
+    AudDrv_Clk_Off();
     return 0;
 }
 
diff --git a/sound/soc/mediatek/mt_soc_audio_v2/mt_soc_pcm_dl1_i2s0.c b/sound/soc/mediatek/mt_soc_audio_v2/mt_soc_pcm_dl1_i2s0.c
index 3dc2099..1ce42a2 100644
--- a/sound/soc/mediatek/mt_soc_audio_v2/mt_soc_pcm_dl1_i2s0.c
+++ b/sound/soc/mediatek/mt_soc_audio_v2/mt_soc_pcm_dl1_i2s0.c
@@ -60,6 +60,9 @@
 #include "mt_soc_digital_type.h"
 #include "mt_soc_pcm_common.h"
 
+
+#define  ECHO_I2S1_O24
+
 static DEFINE_SPINLOCK(auddrv_I2S0_lock);
 static AFE_MEM_CONTROL_T *pI2s0MemControl = NULL;
 
@@ -144,7 +147,14 @@ static int Audio_i2s0_SideGen_Set(struct snd_kcontrol *kcontrol, struct snd_ctl_
         Afe_Set_Reg(AUDIO_TOP_CON1, 0x1 << 4,  0x1 << 4); // I2S_SOFT_Reset
         if (mi2s0_extcodec_echoref_control == true)
         {
+#ifdef  ECHO_I2S1_O24
+            //phone call echo reference connection enable: I1 ->O24
+
+            printk("%s() InterCon  AFE_CONN9 I01 ->  O24\n",  __func__);
+            Afe_Set_Reg(AFE_CONN9, 0x8000, 0x8000);
+#else
             //phone call echo reference connection enable: I1->O14(HW Gain1)->I11 ->O24
+            printk("%s() InterCon  I1->O14(HW Gain1)->I11 ->O24 No Ramping\n",  __func__);
             printk("%s() Soc_Aud_InterCon_Connection  I01  O14\n",  __func__);
             SetConnection(Soc_Aud_InterCon_Connection, Soc_Aud_InterConnectionInput_I01, Soc_Aud_InterConnectionOutput_O14);//0x448, 0x10000
             REG448 = Afe_Get_Reg(AFE_GAIN1_CONN2);
@@ -156,10 +166,12 @@ static int Audio_i2s0_SideGen_Set(struct snd_kcontrol *kcontrol, struct snd_ctl_
             REG44C = Afe_Get_Reg(AFE_GAIN1_CONN3);
             printk("%s() AFE_GAIN1_CONN3 (0X44C) =0x%x\n",  __func__, REG44C);
             // Set HW_GAIN1
-            SetHwDigitalGainMode(Soc_Aud_Hw_Digital_Gain_HW_DIGITAL_GAIN1, samplerate, 0x80);
-            SetHwDigitalGainEnable(Soc_Aud_Hw_Digital_Gain_HW_DIGITAL_GAIN1, true);
+            SetHwDigitalGainMode(Soc_Aud_Hw_Digital_Gain_HW_DIGITAL_GAIN1, samplerate, 0x1F);
             SetHwDigitalGain(0x80000, Soc_Aud_Hw_Digital_Gain_HW_DIGITAL_GAIN1);
+            Afe_Set_Reg(AFE_GAIN1_CUR, 0x80000, 0xfffff);
+            SetHwDigitalGainEnable(Soc_Aud_Hw_Digital_Gain_HW_DIGITAL_GAIN1, true);
 
+#endif
             Afe_Set_Reg(AFE_DAC_CON1, 0x400, 0xF00);
 
             //I2S0 Input Control
@@ -227,6 +239,10 @@ static int Audio_i2s0_SideGen_Set(struct snd_kcontrol *kcontrol, struct snd_ctl_
     {
         if (mi2s0_extcodec_echoref_control == true)
         {
+#ifdef  ECHO_I2S1_O24
+            //phone call echo reference connection disable: I1 ->O24
+            Afe_Set_Reg(AFE_CONN9, 0, 0x8000);
+#else
             //phone call echo reference connection disable: I1->O14(HW Gain1)->I11 ->O24
             printk("%s() Soc_Aud_InterCon_Connection  I01  O14\n",  __func__);
             //phone call echo reference connection: I1->O14(HW Gain1)->I11 ->O24
@@ -241,7 +257,7 @@ static int Audio_i2s0_SideGen_Set(struct snd_kcontrol *kcontrol, struct snd_ctl_
             printk("%s() AFE_GAIN1_CONN3 (0X44C) =0x%x\n",  __func__, REG44C);
             // Set HW_GAIN1
             SetHwDigitalGainEnable(Soc_Aud_Hw_Digital_Gain_HW_DIGITAL_GAIN1, false);
-
+#endif
         }
         SetMemoryPathEnable(Soc_Aud_Digital_Block_I2S_OUT_2, false);
         if (GetMemoryPathEnable(Soc_Aud_Digital_Block_I2S_OUT_2) == false)
diff --git a/sound/soc/mediatek/mt_soc_audio_v2/mt_soc_pcm_i2s0_awb.c b/sound/soc/mediatek/mt_soc_audio_v2/mt_soc_pcm_i2s0_awb.c
index 00f8c61..871c247 100644
--- a/sound/soc/mediatek/mt_soc_audio_v2/mt_soc_pcm_i2s0_awb.c
+++ b/sound/soc/mediatek/mt_soc_audio_v2/mt_soc_pcm_i2s0_awb.c
@@ -325,6 +325,7 @@ static int mtk_i2s0_awb_pcm_open(struct snd_pcm_substream *substream)
 
 static int mtk_i2s0_awb_pcm_close(struct snd_pcm_substream *substream)
 {
+    AudDrv_Clk_Off();
     return 0;
 }
 
diff --git a/sound/soc/mediatek/mt_soc_audio_v3/mt_soc_pcm_dl1_awb.c b/sound/soc/mediatek/mt_soc_audio_v3/mt_soc_pcm_dl1_awb.c
index 18cecd1..67c291c 100644
--- a/sound/soc/mediatek/mt_soc_audio_v3/mt_soc_pcm_dl1_awb.c
+++ b/sound/soc/mediatek/mt_soc_audio_v3/mt_soc_pcm_dl1_awb.c
@@ -302,6 +302,7 @@ static int mtk_dl1_awb_pcm_open(struct snd_pcm_substream *substream)
 static int mtk_dl1_awb_pcm_close(struct snd_pcm_substream *substream)
 {
     AudDrv_Emi_Clk_Off();
+	AudDrv_Clk_Off();
     return 0;
 }
 
diff --git a/sound/soc/mediatek/mt_soc_audio_v3/mt_soc_pcm_i2s0_awb.c b/sound/soc/mediatek/mt_soc_audio_v3/mt_soc_pcm_i2s0_awb.c
index 11257d3..7437c1d 100644
--- a/sound/soc/mediatek/mt_soc_audio_v3/mt_soc_pcm_i2s0_awb.c
+++ b/sound/soc/mediatek/mt_soc_audio_v3/mt_soc_pcm_i2s0_awb.c
@@ -323,6 +323,7 @@ static int mtk_i2s0_awb_pcm_open(struct snd_pcm_substream *substream)
 
 static int mtk_i2s0_awb_pcm_close(struct snd_pcm_substream *substream)
 {
+	AudDrv_Clk_Off();
     return 0;
 }
 
diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c
index be4db47..061be0e 100644
--- a/sound/usb/mixer.c
+++ b/sound/usb/mixer.c
@@ -886,6 +886,7 @@ static void volume_control_quirks(struct usb_mixer_elem_info *cval,
 	case USB_ID(0x046d, 0x0807): /* Logitech Webcam C500 */
 	case USB_ID(0x046d, 0x0808):
 	case USB_ID(0x046d, 0x0809):
+	case USB_ID(0x046d, 0x0819): /* Logitech Webcam C210 */
 	case USB_ID(0x046d, 0x081b): /* HD Webcam c310 */
 	case USB_ID(0x046d, 0x081d): /* HD Webcam c510 */
 	case USB_ID(0x046d, 0x0825): /* HD Webcam c270 */
diff --git a/tools/dct/DCT.log b/tools/dct/DCT.log
index 17150b4..7a3fc38 100644
--- a/tools/dct/DCT.log
+++ b/tools/dct/DCT.log
@@ -1,9 +1,5 @@
 /* Log generated by MTK SP DrvGen Version 03.13.6;
- Log Time is Thu Dec 10 16:44:15 2015
+ Log Time is Fri Feb 19 20:19:41 2016
  */
 open operater parse MT6752.fig OK!
 Edit operater parse .cmp file OK!
-Gencode operater parse .cmp file OK!
-Gencode cust_eint_md1.h OK!
-Gencode cust_eint_md2.h OK!
-Gencode cust_power.h OK!
